
zig-out/bin/hello:	file format elf64-littleriscv

Disassembly of section .text:

0000000000012e50 <_start>:
;                 argc_argv_ptr = asm volatile (
   12e50: 01 44        	li	s0, 0
   12e52: 81 40        	li	ra, 0
   12e54: 37 55 02 00  	lui	a0, 37
   12e58: 23 3c 25 42  	sd	sp, 1080(a0)
;     @call(.never_inline, posixCallMainAndExit, .{});
   12e5c: 97 00 00 00  	auipc	ra, 0
   12e60: e7 80 80 00  	jalr	8(ra)

0000000000012e64 <start.posixCallMainAndExit>:
; fn posixCallMainAndExit() callconv(.C) noreturn {
   12e64: 49 71        	addi	sp, sp, -368
   12e66: 86 f6        	sd	ra, 360(sp)
   12e68: a2 f2        	sd	s0, 352(sp)
   12e6a: a6 ee        	sd	s1, 344(sp)
   12e6c: ca ea        	sd	s2, 336(sp)
   12e6e: ce e6        	sd	s3, 328(sp)
   12e70: d2 e2        	sd	s4, 320(sp)
   12e72: 56 fe        	sd	s5, 312(sp)
   12e74: 5a fa        	sd	s6, 304(sp)
   12e76: 80 1a        	addi	s0, sp, 368
   12e78: 13 71 01 ff  	andi	sp, sp, -16
   12e7c: 28 00        	addi	a0, sp, 8
   12e7e: 2a ea        	sd	a0, 272(sp)
;     const argc = argc_argv_ptr[0];
   12e80: 37 55 02 00  	lui	a0, 37
   12e84: 03 35 85 43  	ld	a0, 1080(a0)
   12e88: 93 05 00 02  	li	a1, 32
   12e8c: 2e ee        	sd	a1, 280(sp)
   12e8e: 02 e6        	sd	zero, 264(sp)
   12e90: 83 39 05 00  	ld	s3, 0(a0)
;     const argv = @ptrCast([*][*:0]u8, argc_argv_ptr + 1);
   12e94: 93 0a 85 00  	addi	s5, a0, 8
;     const envp_optional = @ptrCast([*:null]?[*:0]u8, @alignCast(@alignOf(usize), argv + argc + 1));
   12e98: 13 95 39 00  	slli	a0, s3, 3
   12e9c: 56 95        	add	a0, a0, s5
   12e9e: 13 0b 85 00  	addi	s6, a0, 8
   12ea2: 13 75 7b 00  	andi	a0, s6, 7
   12ea6: 6d ed        	bnez	a0, 0x12fa0 <start.posixCallMainAndExit+0x13c>
;     while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
   12ea8: 03 35 0b 00  	ld	a0, 0(s6)
   12eac: 81 44        	li	s1, 0
   12eae: da 85        	mv	a1, s6
   12eb0: 11 c9        	beqz	a0, 0x12ec4 <start.posixCallMainAndExit+0x60>
   12eb2: 81 44        	li	s1, 0
;     while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
   12eb4: 85 04        	addi	s1, s1, 1
   12eb6: b1 cc        	beqz	s1, 0x12f12 <start.posixCallMainAndExit+0xae>
   12eb8: 13 95 34 00  	slli	a0, s1, 3
   12ebc: b3 05 ab 00  	add	a1, s6, a0
   12ec0: 88 61        	ld	a0, 0(a1)
   12ec2: 6d f9        	bnez	a0, 0x12eb4 <start.posixCallMainAndExit+0x50>
;         const auxv = @ptrCast([*]elf.Auxv, @alignCast(@alignOf(usize), envp.ptr + envp_count + 1));
   12ec4: 13 86 85 00  	addi	a2, a1, 8
   12ec8: 13 75 76 00  	andi	a0, a2, 7
   12ecc: 71 e9        	bnez	a0, 0x12fa0 <start.posixCallMainAndExit+0x13c>
   12ece: 01 4a        	li	s4, 0
   12ed0: 01 49        	li	s2, 0
;         std.os.linux.elf_aux_maybe = auxv;
   12ed2: b7 56 02 00  	lui	a3, 37
   12ed6: 23 b0 c6 44  	sd	a2, 1088(a3)
;             var at_phnum: usize = 0;
   12eda: c1 05        	addi	a1, a1, 16
   12edc: 0d 46        	li	a2, 3
   12ede: fd 56        	li	a3, -1
   12ee0: 15 47        	li	a4, 5
;             while (auxv[i].a_type != elf.AT_NULL) : (i += 1) {
   12ee2: 83 b7 85 ff  	ld	a5, -8(a1)
   12ee6: 63 86 c7 00  	beq	a5, a2, 0x12ef2 <start.posixCallMainAndExit+0x8e>
   12eea: 63 89 e7 00  	beq	a5, a4, 0x12efc <start.posixCallMainAndExit+0x98>
   12eee: 81 e7        	bnez	a5, 0x12ef6 <start.posixCallMainAndExit+0x92>
   12ef0: 1d a8        	j	0x12f26 <start.posixCallMainAndExit+0xc2>
;                     elf.AT_PHDR => at_phdr = auxv[i].a_un.a_val,
   12ef2: 03 ba 05 00  	ld	s4, 0(a1)
   12ef6: 63 17 d5 00  	bne	a0, a3, 0x12f04 <start.posixCallMainAndExit+0xa0>
   12efa: 21 a8        	j	0x12f12 <start.posixCallMainAndExit+0xae>
;                     elf.AT_PHNUM => at_phnum = auxv[i].a_un.a_val,
   12efc: 03 b9 05 00  	ld	s2, 0(a1)
;             while (auxv[i].a_type != elf.AT_NULL) : (i += 1) {
   12f00: 63 09 d5 00  	beq	a0, a3, 0x12f12 <start.posixCallMainAndExit+0xae>
   12f04: 05 05        	addi	a0, a0, 1
   12f06: c1 05        	addi	a1, a1, 16
   12f08: 83 b7 85 ff  	ld	a5, -8(a1)
   12f0c: e3 9f c7 fc  	bne	a5, a2, 0x12eea <start.posixCallMainAndExit+0x86>
   12f10: cd b7        	j	0x12ef2 <start.posixCallMainAndExit+0x8e>
   12f12: 37 15 01 00  	lui	a0, 17
   12f16: 13 05 95 5d  	addi	a0, a0, 1497
   12f1a: c1 45        	li	a1, 16
   12f1c: 81 46        	li	a3, 0
   12f1e: 97 00 01 00  	auipc	ra, 16
   12f22: e7 80 c0 45  	jalr	1116(ra)
   12f26: 63 1c 0a 00  	bnez	s4, 0x12f3e <start.posixCallMainAndExit+0xda>
;             break :init @intToPtr([*]elf.Phdr, at_phdr)[0..at_phnum];
   12f2a: 37 25 01 00  	lui	a0, 18
   12f2e: 13 05 a5 86  	addi	a0, a0, -1942
   12f32: f9 45        	li	a1, 30
   12f34: 81 46        	li	a3, 0
   12f36: 97 00 01 00  	auipc	ra, 16
   12f3a: e7 80 40 44  	jalr	1092(ra)
   12f3e: 13 75 7a 00  	andi	a0, s4, 7
   12f42: 39 ed        	bnez	a0, 0x12fa0 <start.posixCallMainAndExit+0x13c>
;             std.os.linux.tls.initStaticTLS(phdrs);
   12f44: 52 85        	mv	a0, s4
   12f46: ca 85        	mv	a1, s2
   12f48: 97 00 00 00  	auipc	ra, 0
   12f4c: e7 80 c0 45  	jalr	1116(ra)
;         expandStackSize(phdrs);
   12f50: 52 85        	mv	a0, s4
   12f52: ca 85        	mv	a1, s2
   12f54: 97 00 00 00  	auipc	ra, 0
   12f58: e7 80 00 70  	jalr	1792(ra)
;     std.os.argv = argv[0..argc];
   12f5c: 37 65 02 00  	lui	a0, 38
   12f60: 23 30 55 01  	sd	s5, 0(a0)
   12f64: 13 05 05 00  	mv	a0, a0
   12f68: 23 34 35 01  	sd	s3, 8(a0)
;     std.os.environ = envp;
   12f6c: 37 55 02 00  	lui	a0, 37
   12f70: 23 34 65 45  	sd	s6, 1096(a0)
   12f74: 37 55 02 00  	lui	a0, 37
   12f78: 23 38 95 44  	sd	s1, 1104(a0)
;     std.debug.maybeEnableSegfaultHandler();
   12f7c: 97 00 00 00  	auipc	ra, 0
   12f80: e7 80 00 78  	jalr	1920(ra)
;             const result = root.main() catch |err| {
   12f84: 28 02        	addi	a0, sp, 264
   12f86: 97 00 00 00  	auipc	ra, 0
   12f8a: e7 80 40 10  	jalr	260(ra)
   12f8e: 42 15        	slli	a0, a0, 48
   12f90: 93 55 05 03  	srli	a1, a0, 48
   12f94: 85 e1        	bnez	a1, 0x12fb4 <start.posixCallMainAndExit+0x150>
;     return initEventLoopAndCallMain();
   12f96: 01 45        	li	a0, 0
   12f98: 97 10 00 00  	auipc	ra, 1
   12f9c: e7 80 e0 d5  	jalr	-674(ra)
   12fa0: 37 15 01 00  	lui	a0, 17
   12fa4: 13 05 75 63  	addi	a0, a0, 1591
   12fa8: cd 45        	li	a1, 19
   12faa: 81 46        	li	a3, 0
   12fac: 97 00 01 00  	auipc	ra, 16
   12fb0: e7 80 e0 3c  	jalr	974(ra)
;                 std.log.err("{s}", .{@errorName(err)});
   12fb4: 41 95        	srai	a0, a0, 48
   12fb6: b7 15 01 00  	lui	a1, 17
   12fba: 93 85 05 14  	addi	a1, a1, 320
   12fbe: 12 05        	slli	a0, a0, 4
   12fc0: 2e 95        	add	a0, a0, a1
   12fc2: 0c 61        	ld	a1, 0(a0)
   12fc4: 08 65        	ld	a0, 8(a0)
   12fc6: 2e f2        	sd	a1, 288(sp)
   12fc8: 2a f6        	sd	a0, 296(sp)
   12fca: 08 12        	addi	a0, sp, 288
   12fcc: 97 10 01 00  	auipc	ra, 17
   12fd0: e7 80 c0 c5  	jalr	-932(ra)
;                     std.debug.dumpStackTrace(trace.*);
   12fd4: 28 02        	addi	a0, sp, 264
   12fd6: 97 00 00 00  	auipc	ra, 0
   12fda: e7 80 a0 77  	jalr	1914(ra)
;     return initEventLoopAndCallMain();
   12fde: 05 45        	li	a0, 1
   12fe0: 97 10 00 00  	auipc	ra, 1
   12fe4: e7 80 60 d1  	jalr	-746(ra)

0000000000012fe8 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll>:
;         pub fn writeAll(self: Self, bytes: []const u8) Error!void {
   12fe8: 5d 71        	addi	sp, sp, -80
   12fea: 86 e4        	sd	ra, 72(sp)
   12fec: a2 e0        	sd	s0, 64(sp)
   12fee: 26 fc        	sd	s1, 56(sp)
   12ff0: 4a f8        	sd	s2, 48(sp)
   12ff2: 4e f4        	sd	s3, 40(sp)
   12ff4: 52 f0        	sd	s4, 32(sp)
   12ff6: 56 ec        	sd	s5, 24(sp)
;             while (index != bytes.len) {
   12ff8: 95 ce        	beqz	a3, 0x13034 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x4c>
   12ffa: b6 8a        	mv	s5, a3
   12ffc: b2 89        	mv	s3, a2
   12ffe: 2e 8a        	mv	s4, a1
   13000: 2a 89        	mv	s2, a0
   13002: 81 44        	li	s1, 0
;                 index += try self.write(bytes[index..]);
   13004: 63 ee 9a 04  	bltu	s5, s1, 0x13060 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x78>
;             return writeFn(self.context, bytes);
   13008: 03 26 0a 00  	lw	a2, 0(s4)
;                 index += try self.write(bytes[index..]);
   1300c: b3 86 99 00  	add	a3, s3, s1
   13010: 33 87 9a 40  	sub	a4, s5, s1
;             return writeFn(self.context, bytes);
   13014: 28 00        	addi	a0, sp, 8
   13016: ca 85        	mv	a1, s2
   13018: 97 10 00 00  	auipc	ra, 1
   1301c: e7 80 40 e4  	jalr	-444(ra)
   13020: 03 54 01 01  	lhu	s0, 16(sp)
   13024: 1d e0        	bnez	s0, 0x1304a <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x62>
   13026: 22 65        	ld	a0, 8(sp)
;                 index += try self.write(bytes[index..]);
   13028: 26 95        	add	a0, a0, s1
   1302a: 63 66 95 04  	bltu	a0, s1, 0x13076 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x8e>
   1302e: aa 84        	mv	s1, a0
;             while (index != bytes.len) {
   13030: e3 1a 55 fd  	bne	a0, s5, 0x13004 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x1c>
   13034: 01 44        	li	s0, 0
   13036: 22 85        	mv	a0, s0
   13038: a6 60        	ld	ra, 72(sp)
   1303a: 06 64        	ld	s0, 64(sp)
   1303c: e2 74        	ld	s1, 56(sp)
   1303e: 42 79        	ld	s2, 48(sp)
   13040: a2 79        	ld	s3, 40(sp)
   13042: 02 7a        	ld	s4, 32(sp)
   13044: e2 6a        	ld	s5, 24(sp)
   13046: 61 61        	addi	sp, sp, 80
   13048: 82 80        	ret
;             return writeFn(self.context, bytes);
   1304a: 4a 85        	mv	a0, s2
   1304c: 97 10 01 00  	auipc	ra, 17
   13050: e7 80 c0 ba  	jalr	-1108(ra)
;                 index += try self.write(bytes[index..]);
   13054: 4a 85        	mv	a0, s2
   13056: 97 10 01 00  	auipc	ra, 17
   1305a: e7 80 20 ba  	jalr	-1118(ra)
   1305e: e1 bf        	j	0x13036 <io.writer.Writer(fs.file.File,error{AccessDenied,BrokenPipe,ConnectionResetByPeer,DiskQuota,FileTooBig,InputOutput,LockViolation,NoSpaceLeft,NotOpenForWriting,OperationAborted,SystemResources,Unexpected,WouldBlock},(function 'write')).writeAll+0x4e>
   13060: 37 15 01 00  	lui	a0, 17
   13064: 13 05 45 5b  	addi	a0, a0, 1460
   13068: 93 05 40 02  	li	a1, 36
   1306c: 81 46        	li	a3, 0
   1306e: 97 00 01 00  	auipc	ra, 16
   13072: e7 80 c0 30  	jalr	780(ra)
   13076: 37 15 01 00  	lui	a0, 17
   1307a: 13 05 95 5d  	addi	a0, a0, 1497
   1307e: c1 45        	li	a1, 16
   13080: 81 46        	li	a3, 0
   13082: 97 00 01 00  	auipc	ra, 16
   13086: e7 80 80 2f  	jalr	760(ra)

000000000001308a <main.main>:
; pub fn main() !void {
   1308a: 13 01 01 81  	addi	sp, sp, -2032
   1308e: 23 34 11 7e  	sd	ra, 2024(sp)
   13092: 23 30 81 7e  	sd	s0, 2016(sp)
   13096: 23 3c 91 7c  	sd	s1, 2008(sp)
   1309a: 23 38 21 7d  	sd	s2, 2000(sp)
   1309e: 23 34 31 7d  	sd	s3, 1992(sp)
   130a2: 23 30 41 7d  	sd	s4, 1984(sp)
   130a6: 13 01 01 80  	addi	sp, sp, -2048
   130aa: 65 71        	addi	sp, sp, -400
   130ac: 85 65        	lui	a1, 1
   130ae: 9b 85 05 02  	addiw	a1, a1, 32
   130b2: 8a 95        	add	a1, a1, sp
   130b4: 05 66        	lui	a2, 1
   130b6: 1b 06 86 12  	addiw	a2, a2, 296
   130ba: 0a 96        	add	a2, a2, sp
   130bc: 0c e2        	sd	a1, 0(a2)
   130be: 93 05 00 02  	li	a1, 32
   130c2: 05 66        	lui	a2, 1
   130c4: 1b 06 06 13  	addiw	a2, a2, 304
   130c8: 0a 96        	add	a2, a2, sp
   130ca: 0c e2        	sd	a1, 0(a2)
   130cc: 85 65        	lui	a1, 1
   130ce: 9b 85 05 12  	addiw	a1, a1, 288
   130d2: 8a 95        	add	a1, a1, sp
   130d4: 23 b0 05 00  	sd	zero, 0(a1)
;                 false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),
   130d8: b7 55 02 00  	lui	a1, 37
   130dc: 93 85 05 49  	addi	a1, a1, 1168
   130e0: 05 46        	li	a2, 1
;                 false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),
   130e2: af a6 05 14  	lr.w.aq	a3, (a1)
   130e6: 81 e6        	bnez	a3, 0x130ee <main.main+0x64>
   130e8: 2f a7 c5 18  	sc.w	a4, a2, (a1)
   130ec: 7d fb        	bnez	a4, 0x130e2 <main.main+0x58>
   130ee: 2a 89        	mv	s2, a0
;         return @field(self.state, casFn)(unlocked, locked, .Acquire, .Monotonic) == null;
   130f0: 63 94 06 26  	bnez	a3, 0x13358 <main.main+0x2ce>
   130f4: 01 44        	li	s0, 0
   130f6: 09 45        	li	a0, 2
;     const stderr = io.getStdErr().writer();
   130f8: 85 65        	lui	a1, 1
   130fa: 9b 85 85 13  	addiw	a1, a1, 312
   130fe: 8a 95        	add	a1, a1, sp
   13100: 88 c1        	sw	a0, 0(a1)
   13102: a9 49        	li	s3, 10
   13104: 37 25 01 00  	lui	a0, 18
   13108: 93 04 75 db  	addi	s1, a0, -585
   1310c: 25 4a        	li	s4, 9
;                 index += try self.write(bytes[index..]);
   1310e: 63 76 34 27  	bgeu	s0, s3, 0x1337a <main.main+0x2f0>
   13112: b3 86 84 00  	add	a3, s1, s0
   13116: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   1311a: 05 65        	lui	a0, 1
   1311c: 1b 05 05 14  	addiw	a0, a0, 320
   13120: 0a 95        	add	a0, a0, sp
   13122: 85 65        	lui	a1, 1
   13124: 9b 85 05 12  	addiw	a1, a1, 288
   13128: 8a 95        	add	a1, a1, sp
   1312a: 09 46        	li	a2, 2
   1312c: 97 10 00 00  	auipc	ra, 1
   13130: e7 80 00 d3  	jalr	-720(ra)
   13134: 05 65        	lui	a0, 1
   13136: 1b 05 85 14  	addiw	a0, a0, 328
   1313a: 0a 95        	add	a0, a0, sp
   1313c: 03 55 05 00  	lhu	a0, 0(a0)
   13140: 65 ed        	bnez	a0, 0x13238 <main.main+0x1ae>
   13142: 05 65        	lui	a0, 1
   13144: 1b 05 05 14  	addiw	a0, a0, 320
   13148: 0a 95        	add	a0, a0, sp
   1314a: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   1314c: 22 95        	add	a0, a0, s0
   1314e: 63 61 85 24  	bltu	a0, s0, 0x13390 <main.main+0x306>
   13152: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   13154: e3 1d 45 fb  	bne	a0, s4, 0x1310e <main.main+0x84>
;                                 return formatBuf(value, options, writer);
   13158: 37 25 01 00  	lui	a0, 18
   1315c: 93 05 15 9e  	addi	a1, a0, -1567
   13160: 37 15 01 00  	lui	a0, 17
   13164: 93 06 85 11  	addi	a3, a0, 280
   13168: 05 65        	lui	a0, 1
   1316a: 1b 05 05 12  	addiw	a0, a0, 288
   1316e: 0a 95        	add	a0, a0, sp
   13170: 21 46        	li	a2, 8
   13172: 05 67        	lui	a4, 1
   13174: 1b 07 87 13  	addiw	a4, a4, 312
   13178: 0a 97        	add	a4, a4, sp
   1317a: 97 f0 00 00  	auipc	ra, 15
   1317e: e7 80 60 bb  	jalr	-1098(ra)
   13182: 42 15        	slli	a0, a0, 48
   13184: 41 91        	srli	a0, a0, 48
   13186: 69 e1        	bnez	a0, 0x13248 <main.main+0x1be>
   13188: 81 44        	li	s1, 0
   1318a: d1 49        	li	s3, 20
   1318c: 37 25 01 00  	lui	a0, 18
   13190: 13 04 75 db  	addi	s0, a0, -585
   13194: 4d 4a        	li	s4, 19
;                 index += try self.write(bytes[index..]);
   13196: 63 f2 34 1f  	bgeu	s1, s3, 0x1337a <main.main+0x2f0>
   1319a: 33 05 94 00  	add	a0, s0, s1
   1319e: 93 06 c5 00  	addi	a3, a0, 12
   131a2: 33 07 9a 40  	sub	a4, s4, s1
;             return writeFn(self.context, bytes);
   131a6: 05 65        	lui	a0, 1
   131a8: 1b 05 05 14  	addiw	a0, a0, 320
   131ac: 0a 95        	add	a0, a0, sp
   131ae: 85 65        	lui	a1, 1
   131b0: 9b 85 05 12  	addiw	a1, a1, 288
   131b4: 8a 95        	add	a1, a1, sp
   131b6: 09 46        	li	a2, 2
   131b8: 97 10 00 00  	auipc	ra, 1
   131bc: e7 80 40 ca  	jalr	-860(ra)
   131c0: 05 65        	lui	a0, 1
   131c2: 1b 05 85 14  	addiw	a0, a0, 328
   131c6: 0a 95        	add	a0, a0, sp
   131c8: 03 55 05 00  	lhu	a0, 0(a0)
   131cc: 35 e5        	bnez	a0, 0x13238 <main.main+0x1ae>
   131ce: 05 65        	lui	a0, 1
   131d0: 1b 05 05 14  	addiw	a0, a0, 320
   131d4: 0a 95        	add	a0, a0, sp
   131d6: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   131d8: 26 95        	add	a0, a0, s1
   131da: 63 6b 95 1a  	bltu	a0, s1, 0x13390 <main.main+0x306>
   131de: aa 84        	mv	s1, a0
;             while (index != bytes.len) {
   131e0: e3 1b 45 fb  	bne	a0, s4, 0x13196 <main.main+0x10c>
;             return @atomicRmw(T, &self.value, op, value, ordering);
   131e4: 37 55 02 00  	lui	a0, 37
   131e8: 13 05 05 49  	addi	a0, a0, 1168
   131ec: af 25 05 0a  	amoswap.w.rl	a1, zero, (a0)
   131f0: 0d 46        	li	a2, 3
   131f2: 63 8d c5 00  	beq	a1, a2, 0x1320c <main.main+0x182>
   131f6: cd e5        	bnez	a1, 0x132a0 <main.main+0x216>
   131f8: 37 25 01 00  	lui	a0, 18
   131fc: 13 05 b5 a7  	addi	a0, a0, -1413
   13200: e1 45        	li	a1, 24
   13202: 81 46        	li	a3, 0
   13204: 97 00 01 00  	auipc	ra, 16
   13208: e7 80 60 17  	jalr	374(ra)
;     return asm volatile ("ecall"
   1320c: 93 08 20 06  	li	a7, 98
   13210: 93 05 10 08  	li	a1, 129
   13214: 05 46        	li	a2, 1
   13216: fd 76        	lui	a3, 1048575
   13218: 85 26        	addiw	a3, a3, 1
   1321a: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1321e: 63 61 d5 08  	bltu	a0, a3, 0x132a0 <main.main+0x216>
   13222: 3b 05 a0 40  	negw	a0, a0
   13226: 42 15        	slli	a0, a0, 48
   13228: 41 91        	srli	a0, a0, 48
   1322a: b9 45        	li	a1, 14
   1322c: 63 0a b5 06  	beq	a0, a1, 0x132a0 <main.main+0x216>
   13230: d9 45        	li	a1, 22
   13232: 63 07 b5 06  	beq	a0, a1, 0x132a0 <main.main+0x216>
   13236: c9 b7        	j	0x131f8 <main.main+0x16e>
   13238: 05 65        	lui	a0, 1
   1323a: 1b 05 05 12  	addiw	a0, a0, 288
   1323e: 0a 95        	add	a0, a0, sp
   13240: 97 10 01 00  	auipc	ra, 17
   13244: e7 80 80 9b  	jalr	-1608(ra)
   13248: 05 65        	lui	a0, 1
   1324a: 1b 05 05 12  	addiw	a0, a0, 288
   1324e: 0a 95        	add	a0, a0, sp
   13250: 97 10 01 00  	auipc	ra, 17
   13254: e7 80 80 9a  	jalr	-1624(ra)
   13258: 05 65        	lui	a0, 1
   1325a: 1b 05 05 12  	addiw	a0, a0, 288
   1325e: 0a 95        	add	a0, a0, sp
   13260: 97 10 01 00  	auipc	ra, 17
   13264: e7 80 80 99  	jalr	-1640(ra)
;             return std.fmt.format(self, format, args);
   13268: 05 65        	lui	a0, 1
   1326a: 1b 05 05 12  	addiw	a0, a0, 288
   1326e: 0a 95        	add	a0, a0, sp
   13270: 97 10 01 00  	auipc	ra, 17
   13274: e7 80 80 98  	jalr	-1656(ra)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   13278: 37 55 02 00  	lui	a0, 37
   1327c: 13 05 05 49  	addi	a0, a0, 1168
   13280: af 25 05 0a  	amoswap.w.rl	a1, zero, (a0)
   13284: 0d 46        	li	a2, 3
;     if (!ok) unreachable; // assertion failure
   13286: e3 98 c5 f6  	bne	a1, a2, 0x131f6 <main.main+0x16c>
;     return asm volatile ("ecall"
   1328a: 93 08 20 06  	li	a7, 98
   1328e: 93 05 10 08  	li	a1, 129
   13292: 05 46        	li	a2, 1
   13294: fd 76        	lui	a3, 1048575
   13296: 85 26        	addiw	a3, a3, 1
   13298: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1329c: e3 73 d5 f8  	bgeu	a0, a3, 0x13222 <main.main+0x198>
;     var bw = std.io.bufferedWriter(stdout_file);
   132a0: 64 08        	addi	s1, sp, 28
;     return .{ .unbuffered_writer = underlying_stream };
   132a2: 88 00        	addi	a0, sp, 64
   132a4: 85 65        	lui	a1, 1
   132a6: 1b 86 c5 fd  	addiw	a2, a1, -36
   132aa: 93 05 a0 0a  	li	a1, 170
   132ae: 97 10 01 00  	auipc	ra, 17
   132b2: e7 80 c0 fe  	jalr	-20(ra)
   132b6: 37 45 37 10  	lui	a0, 66420
   132ba: 1b 05 95 aa  	addiw	a0, a0, -1367
   132be: 06 15        	slli	a0, a0, 33
   132c0: 05 05        	addi	a0, a0, 1
;     var bw = std.io.bufferedWriter(stdout_file);
   132c2: 2a ec        	sd	a0, 24(sp)
   132c4: 37 55 02 00  	lui	a0, 37
   132c8: 03 35 05 2f  	ld	a0, 752(a0)
   132cc: b7 55 02 00  	lui	a1, 37
   132d0: 83 b5 85 2f  	ld	a1, 760(a1)
   132d4: 37 56 02 00  	lui	a2, 37
   132d8: 03 36 06 30  	ld	a2, 768(a2)
   132dc: b7 56 02 00  	lui	a3, 37
   132e0: 83 b6 86 30  	ld	a3, 776(a3)
;         dest[i] = s;
   132e4: 2a f0        	sd	a0, 32(sp)
   132e6: 2e f4        	sd	a1, 40(sp)
   132e8: 32 f8        	sd	a2, 48(sp)
   132ea: 36 fc        	sd	a3, 56(sp)
   132ec: 0d 65        	lui	a0, 3
   132ee: 1b 05 35 e7  	addiw	a0, a0, -397
   132f2: 23 10 a1 04  	sh	a0, 64(sp)
   132f6: 29 45        	li	a0, 10
   132f8: 23 01 a1 04  	sb	a0, 66(sp)
   132fc: 13 05 70 02  	li	a0, 39
;             self.end += bytes.len;
   13300: 2a e8        	sd	a0, 16(sp)
   13302: 05 45        	li	a0, 1
;             try self.unbuffered_writer.writeAll(self.buf[0..self.end]);
   13304: 85 65        	lui	a1, 1
   13306: 9b 85 05 02  	addiw	a1, a1, 32
   1330a: 8a 95        	add	a1, a1, sp
   1330c: 88 c1        	sw	a0, 0(a1)
   1330e: 05 65        	lui	a0, 1
   13310: 1b 05 05 02  	addiw	a0, a0, 32
   13314: b3 05 a1 00  	add	a1, sp, a0
   13318: 93 06 70 02  	li	a3, 39
   1331c: 4a 85        	mv	a0, s2
   1331e: 26 86        	mv	a2, s1
   13320: 97 00 00 00  	auipc	ra, 0
   13324: e7 80 80 cc  	jalr	-824(ra)
   13328: aa 84        	mv	s1, a0
   1332a: 42 15        	slli	a0, a0, 48
   1332c: 41 91        	srli	a0, a0, 48
   1332e: 1d e9        	bnez	a0, 0x13364 <main.main+0x2da>
;             self.end = 0;
   13330: 02 e8        	sd	zero, 16(sp)
   13332: 26 85        	mv	a0, s1
   13334: 13 01 01 7f  	addi	sp, sp, 2032
   13338: 1d 61        	addi	sp, sp, 416
   1333a: 83 30 81 7e  	ld	ra, 2024(sp)
   1333e: 03 34 01 7e  	ld	s0, 2016(sp)
   13342: 83 34 81 7d  	ld	s1, 2008(sp)
   13346: 03 39 01 7d  	ld	s2, 2000(sp)
   1334a: 83 39 81 7c  	ld	s3, 1992(sp)
   1334e: 03 3a 01 7c  	ld	s4, 1984(sp)
   13352: 13 01 01 7f  	addi	sp, sp, 2032
   13356: 82 80        	ret
;             self.lockSlow();
   13358: 2e 85        	mv	a0, a1
   1335a: 97 10 01 00  	auipc	ra, 17
   1335e: e7 80 e0 c4  	jalr	-946(ra)
   13362: 49 bb        	j	0x130f4 <main.main+0x6a>
;             try self.unbuffered_writer.writeAll(self.buf[0..self.end]);
   13364: 4a 85        	mv	a0, s2
   13366: 97 10 01 00  	auipc	ra, 17
   1336a: e7 80 20 89  	jalr	-1902(ra)
;     try bw.flush(); // don't forget to flush!
   1336e: 4a 85        	mv	a0, s2
   13370: 97 10 01 00  	auipc	ra, 17
   13374: e7 80 80 88  	jalr	-1912(ra)
   13378: 6d bf        	j	0x13332 <main.main+0x2a8>
   1337a: 37 15 01 00  	lui	a0, 17
   1337e: 13 05 45 5b  	addi	a0, a0, 1460
   13382: 93 05 40 02  	li	a1, 36
   13386: 81 46        	li	a3, 0
   13388: 97 00 01 00  	auipc	ra, 16
   1338c: e7 80 20 ff  	jalr	-14(ra)
   13390: 37 15 01 00  	lui	a0, 17
   13394: 13 05 95 5d  	addi	a0, a0, 1497
   13398: c1 45        	li	a1, 16
   1339a: 81 46        	li	a3, 0
   1339c: 97 00 01 00  	auipc	ra, 16
   133a0: e7 80 e0 fd  	jalr	-34(ra)

00000000000133a4 <os.linux.tls.initStaticTLS>:
; pub fn initStaticTLS(phdrs: []elf.Phdr) void {
   133a4: 4d 71        	addi	sp, sp, -336
   133a6: 86 e6        	sd	ra, 328(sp)
   133a8: a2 e2        	sd	s0, 320(sp)
   133aa: 26 fe        	sd	s1, 312(sp)
   133ac: 30 00        	addi	a2, sp, 8
   133ae: 32 ea        	sd	a2, 272(sp)
   133b0: 13 06 00 02  	li	a2, 32
   133b4: 32 ee        	sd	a2, 280(sp)
   133b6: 02 e6        	sd	zero, 264(sp)
   133b8: 21 48        	li	a6, 8
;     for (phdrs) |*phdr| {
   133ba: a5 c1        	beqz	a1, 0x1341a <os.linux.tls.initStaticTLS+0x76>
   133bc: 01 44        	li	s0, 0
   133be: 01 47        	li	a4, 0
   133c0: 9d 47        	li	a5, 7
   133c2: 99 44        	li	s1, 6
   133c4: aa 86        	mv	a3, a0
   133c6: 31 a0        	j	0x133d2 <os.linux.tls.initStaticTLS+0x2e>
   133c8: 36 84        	mv	s0, a3
;     for (phdrs) |*phdr| {
   133ca: fd 15        	addi	a1, a1, -1
   133cc: 93 86 86 03  	addi	a3, a3, 56
   133d0: 8d c5        	beqz	a1, 0x133fa <os.linux.tls.initStaticTLS+0x56>
;         switch (phdr.p_type) {
   133d2: 90 42        	lw	a2, 0(a3)
   133d4: e3 0a f6 fe  	beq	a2, a5, 0x133c8 <os.linux.tls.initStaticTLS+0x24>
   133d8: e3 19 96 fe  	bne	a2, s1, 0x133ca <os.linux.tls.initStaticTLS+0x26>
;             elf.PT_PHDR => img_base = @ptrToInt(phdrs.ptr) - phdr.p_vaddr,
   133dc: 90 6a        	ld	a2, 16(a3)
   133de: 33 07 c5 40  	sub	a4, a0, a2
   133e2: e3 74 e5 fe  	bgeu	a0, a4, 0x133ca <os.linux.tls.initStaticTLS+0x26>
   133e6: 37 15 01 00  	lui	a0, 17
   133ea: 13 05 95 5d  	addi	a0, a0, 1497
   133ee: c1 45        	li	a1, 16
   133f0: 81 46        	li	a3, 0
   133f2: 97 00 01 00  	auipc	ra, 16
   133f6: e7 80 80 f8  	jalr	-120(ra)
;     if (tls_phdr) |phdr| {
   133fa: 15 c8        	beqz	s0, 0x1342e <os.linux.tls.initStaticTLS+0x8a>
;         tls_data = @intToPtr([*]u8, img_base + phdr.p_vaddr)[0..phdr.p_filesz];
   133fc: 08 68        	ld	a0, 16(s0)
   133fe: 3a 95        	add	a0, a0, a4
   13400: e3 63 e5 fe  	bltu	a0, a4, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
   13404: 63 0e 05 22  	beqz	a0, 0x13640 <os.linux.tls.initStaticTLS+0x29c>
   13408: 03 38 04 03  	ld	a6, 48(s0)
;         tls_data = @intToPtr([*]u8, img_base + phdr.p_vaddr)[0..phdr.p_filesz];
   1340c: 0c 70        	ld	a1, 32(s0)
;         tls_data_alloc_size = phdr.p_memsz;
   1340e: 14 74        	ld	a3, 40(s0)
;             const delta = (l + @sizeOf(CustomData)) & (tls_align_factor - 1);
   13410: 13 07 f8 ff  	addi	a4, a6, -1
   13414: 63 77 e8 02  	bgeu	a6, a4, 0x13442 <os.linux.tls.initStaticTLS+0x9e>
   13418: f9 b7        	j	0x133e6 <os.linux.tls.initStaticTLS+0x42>
   1341a: 37 55 02 00  	lui	a0, 37
   1341e: 03 35 05 31  	ld	a0, 784(a0)
   13422: 81 46        	li	a3, 0
;             const delta = (l + @sizeOf(CustomData)) & (tls_align_factor - 1);
   13424: 13 07 f8 ff  	addi	a4, a6, -1
   13428: 63 7d e8 00  	bgeu	a6, a4, 0x13442 <os.linux.tls.initStaticTLS+0x9e>
   1342c: 6d bf        	j	0x133e6 <os.linux.tls.initStaticTLS+0x42>
   1342e: 37 55 02 00  	lui	a0, 37
   13432: 03 35 05 31  	ld	a0, 784(a0)
   13436: 81 45        	li	a1, 0
   13438: 81 46        	li	a3, 0
;             const delta = (l + @sizeOf(CustomData)) & (tls_align_factor - 1);
   1343a: 13 07 f8 ff  	addi	a4, a6, -1
   1343e: e3 64 e8 fa  	bltu	a6, a4, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
   13442: 93 77 87 01  	andi	a5, a4, 24
;             if (delta > 0)
   13446: 91 cf        	beqz	a5, 0x13462 <os.linux.tls.initStaticTLS+0xbe>
;                 l += tls_align_factor - delta;
   13448: b3 07 f8 40  	sub	a5, a6, a5
   1344c: e3 6d f8 f8  	bltu	a6, a5, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
   13450: 93 84 07 01  	addi	s1, a5, 16
   13454: e3 e9 f4 f8  	bltu	s1, a5, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;             l += @sizeOf(CustomData);
   13458: 93 87 84 00  	addi	a5, s1, 8
   1345c: 63 f8 97 00  	bgeu	a5, s1, 0x1346c <os.linux.tls.initStaticTLS+0xc8>
   13460: 59 b7        	j	0x133e6 <os.linux.tls.initStaticTLS+0x42>
   13462: c1 44        	li	s1, 16
;             l += @sizeOf(CustomData);
   13464: 93 87 84 00  	addi	a5, s1, 8
   13468: e3 ef 97 f6  	bltu	a5, s1, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;     return alignment > 0 and std.math.isPowerOfTwo(alignment);
   1346c: 33 76 e8 00  	and	a2, a6, a4
   13470: 13 36 16 00  	seqz	a2, a2
   13474: b3 34 00 01  	snez	s1, a6
   13478: 65 8e        	and	a2, a2, s1
   1347a: 63 06 06 16  	beqz	a2, 0x135e6 <os.linux.tls.initStaticTLS+0x242>
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   1347e: 93 04 78 00  	addi	s1, a6, 7
   13482: e3 e2 e4 f6  	bltu	s1, a4, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;     return addr & ~(alignment - 1);
   13486: 33 06 00 41  	neg	a2, a6
   1348a: 65 8e        	and	a2, a2, s1
;             l += mem.alignForward(tls_tcb_size, tls_align_factor);
   1348c: 33 87 c7 00  	add	a4, a5, a2
   13490: e3 6b f7 f4  	bltu	a4, a5, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;             l += tls_data_alloc_size;
   13494: 33 04 d7 00  	add	s0, a4, a3
   13498: e3 67 e4 f4  	bltu	s0, a4, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;     tls_image = TLSImage{
   1349c: 37 56 02 00  	lui	a2, 37
   134a0: 23 30 a6 46  	sd	a0, 1120(a2)
   134a4: 37 55 02 00  	lui	a0, 37
   134a8: 23 34 b5 46  	sd	a1, 1128(a0)
   134ac: 37 55 02 00  	lui	a0, 37
   134b0: 23 38 85 46  	sd	s0, 1136(a0)
   134b4: 37 55 02 00  	lui	a0, 37
   134b8: 23 3c 05 47  	sd	a6, 1144(a0)
   134bc: 37 55 02 00  	lui	a0, 37
   134c0: 23 30 f5 48  	sd	a5, 1152(a0)
   134c4: 37 55 02 00  	lui	a0, 37
   134c8: 85 65        	lui	a1, 1
   134ca: 85 25        	addiw	a1, a1, 1
;         if (tls_image.alloc_align <= mem.page_size and
   134cc: b3 35 b8 00  	sltu	a1, a6, a1
   134d0: 09 66        	lui	a2, 2
   134d2: 1b 06 16 10  	addiw	a2, a2, 257
   134d6: 33 36 c4 00  	sltu	a2, s0, a2
   134da: f1 8d        	and	a1, a1, a2
;     tls_image = TLSImage{
   134dc: 23 34 e5 48  	sd	a4, 1160(a0)
;             tls_image.alloc_size <= main_thread_tls_buffer.len)
   134e0: d9 c1        	beqz	a1, 0x13566 <os.linux.tls.initStaticTLS+0x1c2>
;             break :blk main_thread_tls_buffer[0..tls_image.alloc_size];
   134e2: 37 75 02 00  	lui	a0, 39
   134e6: 93 04 05 00  	mv	s1, a0
;     for (dest) |*d|
   134ea: 01 c8        	beqz	s0, 0x134fa <os.linux.tls.initStaticTLS+0x156>
;         d.* = value;
   134ec: 26 85        	mv	a0, s1
   134ee: 81 45        	li	a1, 0
   134f0: 22 86        	mv	a2, s0
   134f2: 97 10 01 00  	auipc	ra, 17
   134f6: e7 80 80 da  	jalr	-600(ra)
;     return @ptrCast(*T, @alignCast(@alignOf(T), ptr));
   134fa: 13 f5 74 00  	andi	a0, s1, 7
   134fe: 75 ed        	bnez	a0, 0x135fa <os.linux.tls.initStaticTLS+0x256>
   13500: 05 45        	li	a0, 1
;     dtv.entries = 1;
   13502: 88 e0        	sd	a0, 0(s1)
;     dtv.tls_block[0] = area.ptr + tls_dtv_offset + tls_image.data_offset;
   13504: 37 55 02 00  	lui	a0, 37
   13508: 03 35 85 48  	ld	a0, 1160(a0)
   1350c: b3 85 a4 00  	add	a1, s1, a0
   13510: 13 86 f5 7f  	addi	a2, a1, 2047
   13514: 05 06        	addi	a2, a2, 1
   13516: 90 e4        	sd	a2, 8(s1)
;     const tcb_ptr = alignPtrCast([*]u8, area.ptr + tls_image.tcb_offset);
   13518: 37 56 02 00  	lui	a2, 37
   1351c: 03 36 06 48  	ld	a2, 1152(a2)
   13520: 26 96        	add	a2, a2, s1
;     return @ptrCast(*T, @alignCast(@alignOf(T), ptr));
   13522: 93 76 76 00  	andi	a3, a2, 7
   13526: f1 ea        	bnez	a3, 0x135fa <os.linux.tls.initStaticTLS+0x256>
;         .VariantI => area.ptr + tls_image.dtv_offset,
   13528: 04 e2        	sd	s1, 0(a2)
;     mem.copy(u8, area[tls_image.data_offset..], tls_image.init_data);
   1352a: 63 62 a4 0e  	bltu	s0, a0, 0x1360e <os.linux.tls.initStaticTLS+0x26a>
   1352e: 37 56 02 00  	lui	a2, 37
   13532: 03 36 86 46  	ld	a2, 1128(a2)
   13536: b3 06 a4 40  	sub	a3, s0, a0
;     if (!ok) unreachable; // assertion failure
   1353a: 63 e6 c6 0a  	bltu	a3, a2, 0x135e6 <os.linux.tls.initStaticTLS+0x242>
;     for (source) |s, i|
   1353e: 09 ce        	beqz	a2, 0x13558 <os.linux.tls.initStaticTLS+0x1b4>
   13540: b7 56 02 00  	lui	a3, 37
   13544: 83 b6 06 46  	ld	a3, 1120(a3)
;     for (source) |s, i|
   13548: 03 87 06 00  	lb	a4, 0(a3)
;         dest[i] = s;
   1354c: 23 80 e5 00  	sb	a4, 0(a1)
;     for (source) |s, i|
   13550: 7d 16        	addi	a2, a2, -1
   13552: 85 05        	addi	a1, a1, 1
   13554: 85 06        	addi	a3, a3, 1
   13556: 6d fa        	bnez	a2, 0x13548 <os.linux.tls.initStaticTLS+0x1a4>
;         if (tls_tp_points_past_tcb) tls_image.data_offset else tls_image.tcb_offset;
   13558: 26 95        	add	a0, a0, s1
;             asm volatile (
   1355a: 2a 82        	mv	tp, a0
;     setThreadPointer(tp_value);
   1355c: b6 60        	ld	ra, 328(sp)
   1355e: 16 64        	ld	s0, 320(sp)
   13560: f2 74        	ld	s1, 312(sp)
   13562: 71 61        	addi	sp, sp, 336
   13564: 82 80        	ret
;             tls_image.alloc_size + tls_image.alloc_align - 1,
   13566: 33 05 04 01  	add	a0, s0, a6
   1356a: e3 6e 85 e6  	bltu	a0, s0, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
   1356e: 93 06 f5 ff  	addi	a3, a0, -1
   13572: e3 6a d5 e6  	bltu	a0, a3, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;             os.MAP.PRIVATE | os.MAP.ANONYMOUS,
   13576: 08 12        	addi	a0, sp, 288
   13578: 2c 02        	addi	a1, sp, 264
   1357a: 0d 47        	li	a4, 3
   1357c: 93 07 20 02  	li	a5, 34
   13580: 7d 58        	li	a6, -1
   13582: 01 46        	li	a2, 0
   13584: 97 00 00 00  	auipc	ra, 0
   13588: e7 80 e0 77  	jalr	1918(ra)
   1358c: 03 55 01 13  	lhu	a0, 304(sp)
   13590: 51 e9        	bnez	a0, 0x13624 <os.linux.tls.initStaticTLS+0x280>
;         const begin_aligned_addr = mem.alignForward(begin_addr, tls_image.alloc_align);
   13592: 37 55 02 00  	lui	a0, 37
   13596: 83 35 85 47  	ld	a1, 1144(a0)
;     return alignment > 0 and std.math.isPowerOfTwo(alignment);
   1359a: 13 85 f5 ff  	addi	a0, a1, -1
   1359e: 6d 8d        	and	a0, a0, a1
   135a0: 13 35 15 00  	seqz	a0, a0
   135a4: 33 36 b0 00  	snez	a2, a1
   135a8: 71 8d        	and	a0, a0, a2
   135aa: 15 cd        	beqz	a0, 0x135e6 <os.linux.tls.initStaticTLS+0x242>
   135ac: 12 75        	ld	a0, 288(sp)
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   135ae: 33 86 a5 00  	add	a2, a1, a0
   135b2: 7d 16        	addi	a2, a2, -1
   135b4: e3 69 a6 e2  	bltu	a2, a0, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;     return addr & ~(alignment - 1);
   135b8: b3 05 b0 40  	neg	a1, a1
   135bc: 6d 8e        	and	a2, a2, a1
;         const start = begin_aligned_addr - begin_addr;
   135be: b3 05 a6 40  	sub	a1, a2, a0
   135c2: e3 62 b6 e2  	bltu	a2, a1, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
;         break :blk alloc_tls_area[start .. start + tls_image.alloc_size];
   135c6: 37 56 02 00  	lui	a2, 37
   135ca: 03 36 06 47  	ld	a2, 1136(a2)
   135ce: 2e 96        	add	a2, a2, a1
   135d0: e3 6b b6 e0  	bltu	a2, a1, 0x133e6 <os.linux.tls.initStaticTLS+0x42>
   135d4: b2 76        	ld	a3, 296(sp)
;         break :blk alloc_tls_area[start .. start + tls_image.alloc_size];
   135d6: 63 eb c6 04  	bltu	a3, a2, 0x1362c <os.linux.tls.initStaticTLS+0x288>
   135da: 33 04 b6 40  	sub	s0, a2, a1
   135de: b3 04 b5 00  	add	s1, a0, a1
;     for (dest) |*d|
   135e2: 09 f4        	bnez	s0, 0x134ec <os.linux.tls.initStaticTLS+0x148>
   135e4: 19 bf        	j	0x134fa <os.linux.tls.initStaticTLS+0x156>
   135e6: 37 25 01 00  	lui	a0, 18
   135ea: 13 05 b5 a7  	addi	a0, a0, -1413
   135ee: e1 45        	li	a1, 24
   135f0: 81 46        	li	a3, 0
   135f2: 97 00 01 00  	auipc	ra, 16
   135f6: e7 80 80 d8  	jalr	-632(ra)
   135fa: 37 15 01 00  	lui	a0, 17
   135fe: 13 05 75 63  	addi	a0, a0, 1591
   13602: cd 45        	li	a1, 19
   13604: 81 46        	li	a3, 0
   13606: 97 00 01 00  	auipc	ra, 16
   1360a: e7 80 40 d7  	jalr	-652(ra)
;     mem.copy(u8, area[tls_image.data_offset..], tls_image.init_data);
   1360e: 37 15 01 00  	lui	a0, 17
   13612: 13 05 45 5b  	addi	a0, a0, 1460
   13616: 93 05 40 02  	li	a1, 36
   1361a: 81 46        	li	a3, 0
   1361c: 97 00 01 00  	auipc	ra, 16
   13620: e7 80 e0 d5  	jalr	-674(ra)
;         ) catch os.abort();
   13624: 97 00 01 00  	auipc	ra, 16
   13628: e7 80 a0 7c  	jalr	1994(ra)
;         break :blk alloc_tls_area[start .. start + tls_image.alloc_size];
   1362c: 37 15 01 00  	lui	a0, 17
   13630: 13 05 35 6e  	addi	a0, a0, 1763
   13634: cd 45        	li	a1, 19
   13636: 81 46        	li	a3, 0
   13638: 97 00 01 00  	auipc	ra, 16
   1363c: e7 80 20 d4  	jalr	-702(ra)
;         tls_data = @intToPtr([*]u8, img_base + phdr.p_vaddr)[0..phdr.p_filesz];
   13640: 37 25 01 00  	lui	a0, 18
   13644: 13 05 a5 86  	addi	a0, a0, -1942
   13648: f9 45        	li	a1, 30
   1364a: 81 46        	li	a3, 0
   1364c: 97 00 01 00  	auipc	ra, 16
   13650: e7 80 e0 d2  	jalr	-722(ra)

0000000000013654 <start.expandStackSize>:
; fn expandStackSize(phdrs: []elf.Phdr) void {
   13654: 69 71        	addi	sp, sp, -304
   13656: 06 f6        	sd	ra, 296(sp)
   13658: 0a 86        	mv	a2, sp
   1365a: 32 e6        	sd	a2, 264(sp)
   1365c: 13 06 00 02  	li	a2, 32
   13660: 32 ea        	sd	a2, 272(sp)
   13662: 02 e2        	sd	zero, 256(sp)
;     for (phdrs) |*phdr| {
   13664: 81 cd        	beqz	a1, 0x1367c <start.expandStackSize+0x28>
   13666: 37 e6 74 64  	lui	a2, 411470
   1366a: 1b 06 16 55  	addiw	a2, a2, 1361
;         switch (phdr.p_type) {
   1366e: 14 41        	lw	a3, 0(a0)
   13670: 63 89 c6 00  	beq	a3, a2, 0x13682 <start.expandStackSize+0x2e>
;     for (phdrs) |*phdr| {
   13674: fd 15        	addi	a1, a1, -1
   13676: 13 05 85 03  	addi	a0, a0, 56
   1367a: f5 f9        	bnez	a1, 0x1366e <start.expandStackSize+0x1a>
;                 break;
   1367c: b2 70        	ld	ra, 296(sp)
   1367e: 55 61        	addi	sp, sp, 304
   13680: 82 80        	ret
;                 const wanted_stack_size = phdr.p_memsz;
   13682: 08 75        	ld	a0, 40(a0)
;                 assert(wanted_stack_size % std.mem.page_size == 0);
   13684: 93 15 45 03  	slli	a1, a0, 52
   13688: d1 91        	srli	a1, a1, 52
;     if (!ok) unreachable; // assertion failure
   1368a: b9 ed        	bnez	a1, 0x136e8 <start.expandStackSize+0x94>
;     switch (errno(setrlimit_sym(resource, &limits))) {
   1368c: 2a ee        	sd	a0, 280(sp)
   1368e: 2a f2        	sd	a0, 288(sp)
;     return asm volatile ("ecall"
   13690: 93 08 50 10  	li	a7, 261
   13694: 8d 45        	li	a1, 3
   13696: 30 0a        	addi	a2, sp, 280
   13698: 7d 77        	lui	a4, 1048575
   1369a: 01 45        	li	a0, 0
   1369c: 81 46        	li	a3, 0
   1369e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   136a2: 63 67 a7 00  	bltu	a4, a0, 0x136b0 <start.expandStackSize+0x5c>
   136a6: 01 45        	li	a0, 0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   136a8: 42 15        	slli	a0, a0, 48
   136aa: 41 91        	srli	a0, a0, 48
;     switch (errno(setrlimit_sym(resource, &limits))) {
   136ac: 61 d9        	beqz	a0, 0x1367c <start.expandStackSize+0x28>
   136ae: 31 a0        	j	0x136ba <start.expandStackSize+0x66>
   136b0: 33 05 a0 40  	neg	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   136b4: 42 15        	slli	a0, a0, 48
   136b6: 41 91        	srli	a0, a0, 48
;     switch (errno(setrlimit_sym(resource, &limits))) {
   136b8: 71 d1        	beqz	a0, 0x1367c <start.expandStackSize+0x28>
   136ba: 85 45        	li	a1, 1
;     switch (errno(setrlimit_sym(resource, &limits))) {
   136bc: 63 0d b5 00  	beq	a0, a1, 0x136d6 <start.expandStackSize+0x82>
   136c0: d9 45        	li	a1, 22
;     switch (errno(setrlimit_sym(resource, &limits))) {
   136c2: 63 0a b5 00  	beq	a0, a1, 0x136d6 <start.expandStackSize+0x82>
   136c6: b9 45        	li	a1, 14
;     switch (errno(setrlimit_sym(resource, &limits))) {
   136c8: 63 00 b5 02  	beq	a0, a1, 0x136e8 <start.expandStackSize+0x94>
;     return error.Unexpected;
   136cc: 08 02        	addi	a0, sp, 256
   136ce: 97 00 01 00  	auipc	ra, 16
   136d2: e7 80 a0 52  	jalr	1322(ra)
   136d6: 08 02        	addi	a0, sp, 256
   136d8: 97 00 01 00  	auipc	ra, 16
   136dc: e7 80 00 52  	jalr	1312(ra)
;                 std.os.setrlimit(.STACK, .{
   136e0: 02 e2        	sd	zero, 256(sp)
;                 break;
   136e2: b2 70        	ld	ra, 296(sp)
   136e4: 55 61        	addi	sp, sp, 304
   136e6: 82 80        	ret
   136e8: 37 25 01 00  	lui	a0, 18
   136ec: 13 05 b5 a7  	addi	a0, a0, -1413
   136f0: e1 45        	li	a1, 24
   136f2: 81 46        	li	a3, 0
   136f4: 97 00 01 00  	auipc	ra, 16
   136f8: e7 80 60 c8  	jalr	-890(ra)

00000000000136fc <debug.maybeEnableSegfaultHandler>:
; pub fn maybeEnableSegfaultHandler() void {
   136fc: 21 71        	addi	sp, sp, -448
   136fe: 06 ff        	sd	ra, 440(sp)
   13700: 28 00        	addi	a0, sp, 8
   13702: 2a ea        	sd	a0, 272(sp)
   13704: 13 05 00 02  	li	a0, 32
   13708: 2a ee        	sd	a0, 280(sp)
   1370a: 02 e6        	sd	zero, 264(sp)
;     var act = os.Sigaction{
   1370c: 37 15 01 00  	lui	a0, 17
   13710: 93 05 85 f5  	addi	a1, a0, -168
   13714: 08 12        	addi	a0, sp, 288
   13716: 13 06 80 09  	li	a2, 152
   1371a: 97 10 01 00  	auipc	ra, 17
   1371e: e7 80 a0 b5  	jalr	-1190(ra)
;     updateSegfaultHandler(&act) catch {
   13722: 28 02        	addi	a0, sp, 264
   13724: 0c 12        	addi	a1, sp, 288
   13726: 97 d0 00 00  	auipc	ra, 13
   1372a: e7 80 00 5f  	jalr	1520(ra)
   1372e: 42 15        	slli	a0, a0, 48
   13730: 41 91        	srli	a0, a0, 48
   13732: 01 e5        	bnez	a0, 0x1373a <debug.maybeEnableSegfaultHandler+0x3e>
;         std.debug.attachSegfaultHandler();
   13734: fa 70        	ld	ra, 440(sp)
   13736: 39 61        	addi	sp, sp, 448
   13738: 82 80        	ret
;         @panic("unable to install segfault handler, maybe adjust have_segfault_handling_support in std/debug.zig");
   1373a: 37 25 01 00  	lui	a0, 18
   1373e: 13 05 f5 8e  	addi	a0, a0, -1809
   13742: 93 05 00 06  	li	a1, 96
   13746: 81 46        	li	a3, 0
   13748: 97 00 01 00  	auipc	ra, 16
   1374c: e7 80 20 c3  	jalr	-974(ra)

0000000000013750 <debug.dumpStackTrace>:
; pub fn dumpStackTrace(stack_trace: std.builtin.StackTrace) void {
   13750: 13 01 01 df  	addi	sp, sp, -528
   13754: 23 34 11 20  	sd	ra, 520(sp)
   13758: 23 30 81 20  	sd	s0, 512(sp)
   1375c: a6 ff        	sd	s1, 504(sp)
   1375e: ca fb        	sd	s2, 496(sp)
   13760: ce f7        	sd	s3, 488(sp)
   13762: d2 f3        	sd	s4, 480(sp)
   13764: d6 ef        	sd	s5, 472(sp)
   13766: da eb        	sd	s6, 464(sp)
   13768: de e7        	sd	s7, 456(sp)
   1376a: 2a 89        	mv	s2, a0
   1376c: 0a 85        	mv	a0, sp
   1376e: 2a e6        	sd	a0, 264(sp)
   13770: 13 05 00 02  	li	a0, 32
   13774: 2a ea        	sd	a0, 272(sp)
   13776: 89 45        	li	a1, 2
;     if (self_debug_info) |*info| {
   13778: 37 95 02 00  	lui	a0, 41
   1377c: 03 46 05 13  	lbu	a2, 304(a0)
   13780: 37 95 02 00  	lui	a0, 41
   13784: 03 45 85 14  	lbu	a0, 328(a0)
;         return .{ .context = file };
   13788: 23 2c b1 10  	sw	a1, 280(sp)
;         const stderr = io.getStdErr().writer();
   1378c: 23 20 b1 12  	sw	a1, 288(sp)
   13790: 02 e2        	sd	zero, 256(sp)
;     if (self_debug_info) |*info| {
   13792: 29 c2        	beqz	a2, 0x137d4 <debug.dumpStackTrace+0x84>
;     if (debug_info_allocator) |a| return a;
   13794: 5d e9        	bnez	a0, 0x1384a <debug.dumpStackTrace+0xfa>
;             return .{
   13796: 37 15 01 00  	lui	a0, 17
   1379a: 83 35 85 00  	ld	a1, 8(a0)
   1379e: 13 05 85 00  	addi	a0, a0, 8
   137a2: 08 65        	ld	a0, 8(a0)
;         return (State{}).promote(child_allocator);
   137a4: 37 96 02 00  	lui	a2, 41
   137a8: 23 38 b6 14  	sd	a1, 336(a2)
   137ac: 93 05 06 15  	addi	a1, a2, 336
   137b0: 23 b8 05 00  	sd	zero, 16(a1)
   137b4: 23 bc 05 00  	sd	zero, 24(a1)
   137b8: 88 e5        	sd	a0, 8(a1)
;     debug_info_allocator = allocator;
   137ba: 37 95 02 00  	lui	a0, 41
   137be: 23 3c b5 12  	sd	a1, 312(a0)
   137c2: 13 05 85 13  	addi	a0, a0, 312
   137c6: b7 15 01 00  	lui	a1, 17
   137ca: 93 85 05 02  	addi	a1, a1, 32
   137ce: 0c e5        	sd	a1, 8(a0)
   137d0: 41 05        	addi	a0, a0, 16
   137d2: 8d a8        	j	0x13844 <debug.dumpStackTrace+0xf4>
;     if (debug_info_allocator) |a| return a;
   137d4: 09 c9        	beqz	a0, 0x137e6 <debug.dumpStackTrace+0x96>
   137d6: b7 95 02 00  	lui	a1, 41
   137da: 03 b5 85 13  	ld	a0, 312(a1)
   137de: 93 85 85 13  	addi	a1, a1, 312
   137e2: 8c 65        	ld	a1, 8(a1)
   137e4: 89 a0        	j	0x13826 <debug.dumpStackTrace+0xd6>
;             return .{
   137e6: 37 15 01 00  	lui	a0, 17
   137ea: 83 35 85 00  	ld	a1, 8(a0)
   137ee: 13 05 85 00  	addi	a0, a0, 8
   137f2: 10 65        	ld	a2, 8(a0)
;         return (State{}).promote(child_allocator);
   137f4: 37 95 02 00  	lui	a0, 41
   137f8: 23 38 b5 14  	sd	a1, 336(a0)
   137fc: 13 05 05 15  	addi	a0, a0, 336
   13800: 23 38 05 00  	sd	zero, 16(a0)
   13804: 23 3c 05 00  	sd	zero, 24(a0)
   13808: 10 e5        	sd	a2, 8(a0)
;     debug_info_allocator = allocator;
   1380a: b7 95 02 00  	lui	a1, 41
   1380e: 23 bc a5 12  	sd	a0, 312(a1)
   13812: 13 86 85 13  	addi	a2, a1, 312
   13816: b7 15 01 00  	lui	a1, 17
   1381a: 93 85 05 02  	addi	a1, a1, 32
   1381e: 0c e6        	sd	a1, 8(a2)
   13820: 85 46        	li	a3, 1
   13822: 23 08 d6 00  	sb	a3, 16(a2)
;             return .{
   13826: 37 96 02 00  	lui	a2, 41
   1382a: 93 06 06 10  	addi	a3, a2, 256
   1382e: 23 bc 06 00  	sd	zero, 24(a3)
   13832: 23 b8 06 00  	sd	zero, 16(a3)
;         self_debug_info = try openSelfDebugInfo(getDebugInfoAllocator());
   13836: 23 30 a6 10  	sd	a0, 256(a2)
   1383a: 8c e6        	sd	a1, 8(a3)
   1383c: 88 f2        	sd	a0, 32(a3)
   1383e: 8c f6        	sd	a1, 40(a3)
   13840: 13 85 06 03  	addi	a0, a3, 48
   13844: 85 45        	li	a1, 1
   13846: 23 00 b5 00  	sb	a1, 0(a0)
;         return os.getenv(key) != null;
   1384a: 37 25 01 00  	lui	a0, 18
   1384e: 13 05 c5 bd  	addi	a0, a0, -1060
   13852: bd 45        	li	a1, 15
   13854: 97 f0 00 00  	auipc	ra, 15
   13858: e7 80 20 c9  	jalr	-878(ra)
;     } else if (process.hasEnvVarConstant("ZIG_DEBUG_COLOR")) {
   1385c: 11 c5        	beqz	a0, 0x13868 <debug.dumpStackTrace+0x118>
   1385e: 37 15 01 00  	lui	a0, 17
   13862: 03 4a 85 01  	lbu	s4, 24(a0)
   13866: b1 a0        	j	0x138b2 <debug.dumpStackTrace+0x162>
;         return os.getenv(key) != null;
   13868: 37 25 01 00  	lui	a0, 18
   1386c: 13 05 35 bd  	addi	a0, a0, -1069
   13870: a1 45        	li	a1, 8
   13872: 97 f0 00 00  	auipc	ra, 15
   13876: e7 80 40 c7  	jalr	-908(ra)
   1387a: 01 4a        	li	s4, 0
;     } else if (process.hasEnvVarConstant("NO_COLOR")) {
   1387c: 1d e9        	bnez	a0, 0x138b2 <debug.dumpStackTrace+0x162>
   1387e: 37 55 02 00  	lui	a0, 37
   13882: 83 36 85 31  	ld	a3, 792(a0)
   13886: 15 65        	lui	a0, 5
   13888: 9b 05 35 41  	addiw	a1, a0, 1043
   1388c: 7d 75        	lui	a0, 1048575
   1388e: 1b 07 15 00  	addiw	a4, a0, 1
   13892: 41 65        	lui	a0, 16
   13894: 9b 07 c5 ff  	addiw	a5, a0, -4
   13898: f5 48        	li	a7, 29
;             var wsz: linux.winsize = undefined;
   1389a: 36 e3        	sd	a3, 384(sp)
;     return asm volatile ("ecall"
   1389c: 09 45        	li	a0, 2
   1389e: 10 03        	addi	a2, sp, 384
   138a0: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   138a4: 63 6d e5 28  	bltu	a0, a4, 0x13b3e <debug.dumpStackTrace+0x3ee>
;             switch (linux.getErrno(rc)) {
   138a8: 42 15        	slli	a0, a0, 48
   138aa: 41 91        	srli	a0, a0, 48
   138ac: e3 07 f5 fe  	beq	a0, a5, 0x1389a <debug.dumpStackTrace+0x14a>
   138b0: 01 4a        	li	s4, 0
   138b2: a3 03 41 13  	sb	s4, 295(sp)
;     var frames_left: usize = std.math.min(stack_trace.index, stack_trace.instruction_addresses.len);
   138b6: 83 3a 09 00  	ld	s5, 0(s2)
   138ba: 83 34 09 01  	ld	s1, 16(s2)
   138be: 56 8b        	mv	s6, s5
   138c0: 63 e3 9a 00  	bltu	s5, s1, 0x138c6 <debug.dumpStackTrace+0x176>
   138c4: 26 8b        	mv	s6, s1
   138c6: 92 69        	ld	s3, 256(sp)
;     while (frames_left != 0) : ({
   138c8: 63 0e 0b 04  	beqz	s6, 0x13924 <debug.dumpStackTrace+0x1d4>
   138cc: 01 44        	li	s0, 0
   138ce: 37 95 02 00  	lui	a0, 41
   138d2: 93 0a 05 10  	addi	s5, a0, 256
;         const return_address = stack_trace.instruction_addresses[frame_index];
   138d6: 63 75 94 3c  	bgeu	s0, s1, 0x13ca0 <debug.dumpStackTrace+0x550>
   138da: 03 35 89 00  	ld	a0, 8(s2)
   138de: 93 15 34 00  	slli	a1, s0, 3
   138e2: 2e 95        	add	a0, a0, a1
   138e4: 08 61        	ld	a0, 0(a0)
;         try printSourceAtAddress(debug_info, out_stream, return_address - 1, tty_config);
   138e6: 93 06 f5 ff  	addi	a3, a0, -1
   138ea: 63 6b d5 38  	bltu	a0, a3, 0x13c80 <debug.dumpStackTrace+0x530>
   138ee: 08 02        	addi	a0, sp, 256
   138f0: 30 0a        	addi	a2, sp, 280
   138f2: 13 07 71 12  	addi	a4, sp, 295
   138f6: d6 85        	mv	a1, s5
   138f8: 97 90 00 00  	auipc	ra, 9
   138fc: e7 80 40 00  	jalr	4(ra)
   13900: aa 84        	mv	s1, a0
   13902: 42 15        	slli	a0, a0, 48
   13904: 41 91        	srli	a0, a0, 48
   13906: 63 1a 05 2c  	bnez	a0, 0x13bda <debug.dumpStackTrace+0x48a>
;         frame_index = (frame_index + 1) % stack_trace.instruction_addresses.len;
   1390a: 83 34 09 01  	ld	s1, 16(s2)
   1390e: 63 83 04 3a  	beqz	s1, 0x13cb4 <debug.dumpStackTrace+0x564>
   13912: 13 05 14 00  	addi	a0, s0, 1
;         frames_left -= 1;
   13916: 7d 1b        	addi	s6, s6, -1
;         frame_index = (frame_index + 1) % stack_trace.instruction_addresses.len;
   13918: 33 74 95 02  	remu	s0, a0, s1
;     while (frames_left != 0) : ({
   1391c: e3 1d 0b fa  	bnez	s6, 0x138d6 <debug.dumpStackTrace+0x186>
;     if (stack_trace.index > stack_trace.instruction_addresses.len) {
   13920: 83 3a 09 00  	ld	s5, 0(s2)
   13924: 63 f8 54 2f  	bgeu	s1, s5, 0x13c14 <debug.dumpStackTrace+0x4c4>
;         tty_config.setColor(out_stream, .Bold) catch {};
   13928: 13 79 3a 00  	andi	s2, s4, 3
;             nosuspend switch (conf) {
   1392c: 63 04 09 04  	beqz	s2, 0x13974 <debug.dumpStackTrace+0x224>
   13930: 05 45        	li	a0, 1
;             nosuspend switch (conf) {
   13932: 63 1b a9 38  	bne	s2, a0, 0x13cc8 <debug.dumpStackTrace+0x578>
   13936: 01 44        	li	s0, 0
   13938: 15 4a        	li	s4, 5
   1393a: 37 25 01 00  	lui	a0, 18
   1393e: 93 0b 85 85  	addi	s7, a0, -1960
   13942: 11 4b        	li	s6, 4
;                 index += try self.write(bytes[index..]);
   13944: 63 73 44 35  	bgeu	s0, s4, 0x13c8a <debug.dumpStackTrace+0x53a>
   13948: b3 86 8b 00  	add	a3, s7, s0
   1394c: 33 07 8b 40  	sub	a4, s6, s0
;             return writeFn(self.context, bytes);
   13950: 08 03        	addi	a0, sp, 384
   13952: 0c 02        	addi	a1, sp, 256
   13954: 09 46        	li	a2, 2
   13956: 97 00 00 00  	auipc	ra, 0
   1395a: e7 80 60 50  	jalr	1286(ra)
   1395e: 03 55 81 18  	lhu	a0, 392(sp)
   13962: 63 17 05 2c  	bnez	a0, 0x13c30 <debug.dumpStackTrace+0x4e0>
   13966: 1a 65        	ld	a0, 384(sp)
;                 index += try self.write(bytes[index..]);
   13968: 22 95        	add	a0, a0, s0
   1396a: 63 6b 85 30  	bltu	a0, s0, 0x13c80 <debug.dumpStackTrace+0x530>
   1396e: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   13970: e3 1a 65 fd  	bne	a0, s6, 0x13944 <debug.dumpStackTrace+0x1f4>
   13974: 01 44        	li	s0, 0
   13976: b3 8a 9a 40  	sub	s5, s5, s1
   1397a: 09 4a        	li	s4, 2
;         try out_stream.print("({d} additional stack frames skipped...)\n", .{dropped_frames});
   1397c: 23 2c 41 17  	sw	s4, 376(sp)
   13980: 37 25 01 00  	lui	a0, 18
   13984: 13 0b b5 df  	addi	s6, a0, -517
   13988: 85 4b        	li	s7, 1
;                 index += try self.write(bytes[index..]);
   1398a: 63 70 44 31  	bgeu	s0, s4, 0x13c8a <debug.dumpStackTrace+0x53a>
   1398e: b3 06 8b 00  	add	a3, s6, s0
   13992: 33 87 8b 40  	sub	a4, s7, s0
;             return writeFn(self.context, bytes);
   13996: 08 03        	addi	a0, sp, 384
   13998: 0c 02        	addi	a1, sp, 256
   1399a: 09 46        	li	a2, 2
   1399c: 97 00 00 00  	auipc	ra, 0
   139a0: e7 80 00 4c  	jalr	1216(ra)
   139a4: 83 54 81 18  	lhu	s1, 392(sp)
   139a8: 63 95 04 20  	bnez	s1, 0x13bb2 <debug.dumpStackTrace+0x462>
   139ac: 1a 65        	ld	a0, 384(sp)
;                 index += try self.write(bytes[index..]);
   139ae: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   139b0: e3 1d 74 fd  	bne	s0, s7, 0x1398a <debug.dumpStackTrace+0x23a>
   139b4: 13 0a 01 18  	addi	s4, sp, 384
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   139b8: 08 03        	addi	a0, sp, 384
   139ba: 93 05 a0 0a  	li	a1, 170
   139be: 13 06 10 04  	li	a2, 65
   139c2: 93 04 10 04  	li	s1, 65
   139c6: 97 10 01 00  	auipc	ra, 17
   139ca: e7 80 40 8d  	jalr	-1836(ra)
   139ce: 13 08 40 06  	li	a6, 100
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   139d2: 63 ee 0a 07  	bltu	s5, a6, 0x13a4e <debug.dumpStackTrace+0x2fe>
   139d6: 93 04 10 04  	li	s1, 65
   139da: 37 55 02 00  	lui	a0, 37
   139de: 03 36 05 32  	ld	a2, 800(a0)
   139e2: 37 25 01 00  	lui	a0, 18
   139e6: 93 06 25 c0  	addi	a3, a0, -1022
   139ea: 13 07 00 27  	li	a4, 624
   139ee: 26 85        	mv	a0, s1
;             index -= 2;
   139f0: f9 14        	addi	s1, s1, -2
   139f2: 63 67 95 28  	bltu	a0, s1, 0x13c80 <debug.dumpStackTrace+0x530>
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   139f6: 13 d5 2a 00  	srli	a0, s5, 2
   139fa: 33 35 c5 02  	mulhu	a0, a0, a2
   139fe: 09 81        	srli	a0, a0, 2
   13a00: b3 07 05 03  	mul	a5, a0, a6
   13a04: b3 87 fa 40  	sub	a5, s5, a5
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   13a08: 86 07        	slli	a5, a5, 1
   13a0a: b6 97        	add	a5, a5, a3
;     return ("0001020304050607080910111213141516171819" ++
   13a0c: 03 84 17 00  	lb	s0, 1(a5)
   13a10: 83 c7 07 00  	lbu	a5, 0(a5)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   13a14: b3 05 9a 00  	add	a1, s4, s1
   13a18: a3 80 85 00  	sb	s0, 1(a1)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   13a1c: 13 d4 4a 00  	srli	s0, s5, 4
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   13a20: 23 80 f5 00  	sb	a5, 0(a1)
   13a24: aa 8a        	mv	s5, a0
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   13a26: e3 64 87 fc  	bltu	a4, s0, 0x139ee <debug.dumpStackTrace+0x29e>
   13a2a: a5 45        	li	a1, 9
;         if (a < 10) {
   13a2c: 63 e5 a5 02  	bltu	a1, a0, 0x13a56 <debug.dumpStackTrace+0x306>
;             index -= 1;
   13a30: 13 86 f4 ff  	addi	a2, s1, -1
   13a34: 63 e6 c4 24  	bltu	s1, a2, 0x13c80 <debug.dumpStackTrace+0x530>
   13a38: 93 05 10 04  	li	a1, 65
;             buf[index] = '0' + @intCast(u8, a);
   13a3c: 63 72 b6 26  	bgeu	a2, a1, 0x13ca0 <debug.dumpStackTrace+0x550>
   13a40: 1b 05 05 03  	addiw	a0, a0, 48
   13a44: 0c 03        	addi	a1, sp, 384
   13a46: b2 95        	add	a1, a1, a2
   13a48: 23 80 a5 00  	sb	a0, 0(a1)
   13a4c: 2d a8        	j	0x13a86 <debug.dumpStackTrace+0x336>
   13a4e: 56 85        	mv	a0, s5
   13a50: a5 45        	li	a1, 9
;         if (a < 10) {
   13a52: e3 ff a5 fc  	bgeu	a1, a0, 0x13a30 <debug.dumpStackTrace+0x2e0>
;             index -= 2;
   13a56: 13 86 e4 ff  	addi	a2, s1, -2
   13a5a: 63 e3 c4 22  	bltu	s1, a2, 0x13c80 <debug.dumpStackTrace+0x530>
   13a5e: 93 05 20 04  	li	a1, 66
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   13a62: 63 74 b6 22  	bgeu	a2, a1, 0x13c8a <debug.dumpStackTrace+0x53a>
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   13a66: 06 05        	slli	a0, a0, 1
   13a68: b7 25 01 00  	lui	a1, 18
   13a6c: 93 85 25 c0  	addi	a1, a1, -1022
   13a70: 2e 95        	add	a0, a0, a1
;     return ("0001020304050607080910111213141516171819" ++
   13a72: 83 05 15 00  	lb	a1, 1(a0)
   13a76: 03 45 05 00  	lbu	a0, 0(a0)
   13a7a: 14 03        	addi	a3, sp, 384
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   13a7c: b2 96        	add	a3, a3, a2
   13a7e: a3 80 b6 00  	sb	a1, 1(a3)
   13a82: 23 80 a6 00  	sb	a0, 0(a3)
   13a86: 08 03        	addi	a0, sp, 384
;     return formatBuf(buf[index..], options, writer);
   13a88: b3 05 c5 00  	add	a1, a0, a2
   13a8c: 13 05 10 04  	li	a0, 65
   13a90: 33 06 c5 40  	sub	a2, a0, a2
   13a94: 37 15 01 00  	lui	a0, 17
   13a98: 93 06 85 11  	addi	a3, a0, 280
   13a9c: 08 02        	addi	a0, sp, 256
   13a9e: b8 1a        	addi	a4, sp, 376
   13aa0: 97 e0 00 00  	auipc	ra, 14
   13aa4: e7 80 00 29  	jalr	656(ra)
   13aa8: aa 84        	mv	s1, a0
   13aaa: 42 15        	slli	a0, a0, 48
   13aac: 41 91        	srli	a0, a0, 48
   13aae: 65 e9        	bnez	a0, 0x13b9e <debug.dumpStackTrace+0x44e>
   13ab0: 01 44        	li	s0, 0
   13ab2: 13 0a 60 02  	li	s4, 38
   13ab6: 37 25 01 00  	lui	a0, 18
   13aba: 13 0b b5 df  	addi	s6, a0, -517
   13abe: 93 0a 50 02  	li	s5, 37
;                 index += try self.write(bytes[index..]);
   13ac2: 63 74 44 1d  	bgeu	s0, s4, 0x13c8a <debug.dumpStackTrace+0x53a>
   13ac6: 33 05 8b 00  	add	a0, s6, s0
   13aca: 93 06 45 00  	addi	a3, a0, 4
   13ace: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   13ad2: 08 03        	addi	a0, sp, 384
   13ad4: 0c 02        	addi	a1, sp, 256
   13ad6: 09 46        	li	a2, 2
   13ad8: 97 00 00 00  	auipc	ra, 0
   13adc: e7 80 40 38  	jalr	900(ra)
   13ae0: 83 54 81 18  	lhu	s1, 392(sp)
   13ae4: f9 e4        	bnez	s1, 0x13bb2 <debug.dumpStackTrace+0x462>
   13ae6: 1a 65        	ld	a0, 384(sp)
;                 index += try self.write(bytes[index..]);
   13ae8: 22 95        	add	a0, a0, s0
   13aea: 63 6b 85 18  	bltu	a0, s0, 0x13c80 <debug.dumpStackTrace+0x530>
   13aee: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   13af0: e3 19 55 fd  	bne	a0, s5, 0x13ac2 <debug.dumpStackTrace+0x372>
;             nosuspend switch (conf) {
   13af4: 63 00 09 12  	beqz	s2, 0x13c14 <debug.dumpStackTrace+0x4c4>
   13af8: 05 45        	li	a0, 1
;             nosuspend switch (conf) {
   13afa: 63 17 a9 1c  	bne	s2, a0, 0x13cc8 <debug.dumpStackTrace+0x578>
   13afe: 01 44        	li	s0, 0
   13b00: 15 49        	li	s2, 5
   13b02: 37 25 01 00  	lui	a0, 18
   13b06: 93 04 55 86  	addi	s1, a0, -1947
   13b0a: 11 4a        	li	s4, 4
;                 index += try self.write(bytes[index..]);
   13b0c: 63 7f 24 17  	bgeu	s0, s2, 0x13c8a <debug.dumpStackTrace+0x53a>
   13b10: b3 86 84 00  	add	a3, s1, s0
   13b14: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   13b18: 08 03        	addi	a0, sp, 384
   13b1a: 0c 02        	addi	a1, sp, 256
   13b1c: 09 46        	li	a2, 2
   13b1e: 97 00 00 00  	auipc	ra, 0
   13b22: e7 80 e0 33  	jalr	830(ra)
   13b26: 03 55 81 18  	lhu	a0, 392(sp)
   13b2a: 63 14 05 12  	bnez	a0, 0x13c52 <debug.dumpStackTrace+0x502>
   13b2e: 1a 65        	ld	a0, 384(sp)
;                 index += try self.write(bytes[index..]);
   13b30: 22 95        	add	a0, a0, s0
   13b32: 63 67 85 14  	bltu	a0, s0, 0x13c80 <debug.dumpStackTrace+0x530>
   13b36: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   13b38: e3 1a 45 fd  	bne	a0, s4, 0x13b0c <debug.dumpStackTrace+0x3bc>
   13b3c: e1 a8        	j	0x13c14 <debug.dumpStackTrace+0x4c4>
;     return getenv(mem.sliceTo(key, 0));
   13b3e: 37 25 01 00  	lui	a0, 18
   13b42: 13 05 c5 be  	addi	a0, a0, -1044
   13b46: 91 45        	li	a1, 4
   13b48: 97 f0 00 00  	auipc	ra, 15
   13b4c: e7 80 e0 99  	jalr	-1634(ra)
;                 if (os.getenvZ("TERM")) |term| {
   13b50: 33 36 a0 00  	snez	a2, a0
   13b54: f1 15        	addi	a1, a1, -4
   13b56: 93 b5 15 00  	seqz	a1, a1
   13b5a: f1 8d        	and	a1, a1, a2
   13b5c: e3 81 05 d0  	beqz	a1, 0x1385e <debug.dumpStackTrace+0x10e>
;     if (a.ptr == b.ptr) return true;
   13b60: b7 25 01 00  	lui	a1, 18
   13b64: 93 85 f5 ba  	addi	a1, a1, -1105
   13b68: e3 04 b5 d4  	beq	a0, a1, 0x138b0 <debug.dumpStackTrace+0x160>
;     for (a) |item, index| {
   13b6c: 83 45 05 00  	lbu	a1, 0(a0)
   13b70: 13 06 40 06  	li	a2, 100
;         if (b[index] != item) return false;
   13b74: e3 95 c5 ce  	bne	a1, a2, 0x1385e <debug.dumpStackTrace+0x10e>
;     for (a) |item, index| {
   13b78: 83 45 15 00  	lbu	a1, 1(a0)
   13b7c: 13 06 50 07  	li	a2, 117
;         if (b[index] != item) return false;
   13b80: e3 9f c5 cc  	bne	a1, a2, 0x1385e <debug.dumpStackTrace+0x10e>
;     for (a) |item, index| {
   13b84: 83 45 25 00  	lbu	a1, 2(a0)
   13b88: 13 06 d0 06  	li	a2, 109
;         if (b[index] != item) return false;
   13b8c: e3 99 c5 cc  	bne	a1, a2, 0x1385e <debug.dumpStackTrace+0x10e>
;     for (a) |item, index| {
   13b90: 03 45 35 00  	lbu	a0, 3(a0)
   13b94: 93 05 20 06  	li	a1, 98
;     } else if (file.supportsAnsiEscapeCodes()) {
   13b98: e3 13 b5 cc  	bne	a0, a1, 0x1385e <debug.dumpStackTrace+0x10e>
   13b9c: 11 bb        	j	0x138b0 <debug.dumpStackTrace+0x160>
;     return formatBuf(buf[index..], options, writer);
   13b9e: 08 02        	addi	a0, sp, 256
   13ba0: 97 00 01 00  	auipc	ra, 16
   13ba4: e7 80 80 05  	jalr	88(ra)
;     return formatInt(int_value, radix, case, options, writer);
   13ba8: 08 02        	addi	a0, sp, 256
   13baa: 97 00 01 00  	auipc	ra, 16
   13bae: e7 80 e0 04  	jalr	78(ra)
   13bb2: 08 02        	addi	a0, sp, 256
   13bb4: 97 00 01 00  	auipc	ra, 16
   13bb8: e7 80 40 04  	jalr	68(ra)
   13bbc: 08 02        	addi	a0, sp, 256
   13bbe: 97 00 01 00  	auipc	ra, 16
   13bc2: e7 80 a0 03  	jalr	58(ra)
   13bc6: 08 02        	addi	a0, sp, 256
   13bc8: 97 00 01 00  	auipc	ra, 16
   13bcc: e7 80 00 03  	jalr	48(ra)
;             return std.fmt.format(self, format, args);
   13bd0: 08 02        	addi	a0, sp, 256
   13bd2: 97 00 01 00  	auipc	ra, 16
   13bd6: e7 80 60 02  	jalr	38(ra)
   13bda: 08 02        	addi	a0, sp, 256
   13bdc: 97 00 01 00  	auipc	ra, 16
   13be0: e7 80 c0 01  	jalr	28(ra)
;             stderr.print("Unable to dump stack trace: {s}\n", .{@errorName(err)}) catch return;
   13be4: 13 95 04 03  	slli	a0, s1, 48
   13be8: 41 95        	srai	a0, a0, 48
   13bea: b7 15 01 00  	lui	a1, 17
   13bee: 93 85 05 14  	addi	a1, a1, 320
   13bf2: 12 05        	slli	a0, a0, 4
   13bf4: 2e 95        	add	a0, a0, a1
   13bf6: 0c 61        	ld	a1, 0(a0)
   13bf8: 08 65        	ld	a0, 8(a0)
   13bfa: 2e f6        	sd	a1, 296(sp)
   13bfc: 2a fa        	sd	a0, 304(sp)
;             return std.fmt.format(self, format, args);
   13bfe: 08 02        	addi	a0, sp, 256
   13c00: 0c 12        	addi	a1, sp, 288
   13c02: 30 12        	addi	a2, sp, 296
   13c04: 97 e0 00 00  	auipc	ra, 14
   13c08: e7 80 60 01  	jalr	22(ra)
   13c0c: 42 15        	slli	a0, a0, 48
   13c0e: 41 91        	srli	a0, a0, 48
   13c10: 35 e1        	bnez	a0, 0x13c74 <debug.dumpStackTrace+0x524>
   13c12: 02 e2        	sd	zero, 256(sp)
   13c14: 83 30 81 20  	ld	ra, 520(sp)
   13c18: 03 34 01 20  	ld	s0, 512(sp)
   13c1c: fe 74        	ld	s1, 504(sp)
   13c1e: 5e 79        	ld	s2, 496(sp)
   13c20: be 79        	ld	s3, 488(sp)
   13c22: 1e 7a        	ld	s4, 480(sp)
   13c24: fe 6a        	ld	s5, 472(sp)
   13c26: 5e 6b        	ld	s6, 464(sp)
   13c28: be 6b        	ld	s7, 456(sp)
   13c2a: 13 01 01 21  	addi	sp, sp, 528
   13c2e: 82 80        	ret
;             return writeFn(self.context, bytes);
   13c30: 08 02        	addi	a0, sp, 256
   13c32: 97 00 01 00  	auipc	ra, 16
   13c36: e7 80 60 fc  	jalr	-58(ra)
;                 index += try self.write(bytes[index..]);
   13c3a: 08 02        	addi	a0, sp, 256
   13c3c: 97 00 01 00  	auipc	ra, 16
   13c40: e7 80 c0 fb  	jalr	-68(ra)
;                     try out_stream.writeAll(color_string);
   13c44: 08 02        	addi	a0, sp, 256
   13c46: 97 00 01 00  	auipc	ra, 16
   13c4a: e7 80 20 fb  	jalr	-78(ra)
;         tty_config.setColor(out_stream, .Bold) catch {};
   13c4e: 4e e2        	sd	s3, 256(sp)
   13c50: 15 b3        	j	0x13974 <debug.dumpStackTrace+0x224>
;             return writeFn(self.context, bytes);
   13c52: 08 02        	addi	a0, sp, 256
   13c54: 97 00 01 00  	auipc	ra, 16
   13c58: e7 80 40 fa  	jalr	-92(ra)
;                 index += try self.write(bytes[index..]);
   13c5c: 08 02        	addi	a0, sp, 256
   13c5e: 97 00 01 00  	auipc	ra, 16
   13c62: e7 80 a0 f9  	jalr	-102(ra)
;                     try out_stream.writeAll(color_string);
   13c66: 08 02        	addi	a0, sp, 256
   13c68: 97 00 01 00  	auipc	ra, 16
   13c6c: e7 80 00 f9  	jalr	-112(ra)
;         tty_config.setColor(out_stream, .Reset) catch {};
   13c70: 4e e2        	sd	s3, 256(sp)
   13c72: 4d b7        	j	0x13c14 <debug.dumpStackTrace+0x4c4>
;             return std.fmt.format(self, format, args);
   13c74: 08 02        	addi	a0, sp, 256
   13c76: 97 00 01 00  	auipc	ra, 16
   13c7a: e7 80 20 f8  	jalr	-126(ra)
   13c7e: 51 bf        	j	0x13c12 <debug.dumpStackTrace+0x4c2>
   13c80: 37 15 01 00  	lui	a0, 17
   13c84: 13 05 95 5d  	addi	a0, a0, 1497
   13c88: 15 a8        	j	0x13cbc <debug.dumpStackTrace+0x56c>
   13c8a: 37 15 01 00  	lui	a0, 17
   13c8e: 13 05 45 5b  	addi	a0, a0, 1460
   13c92: 93 05 40 02  	li	a1, 36
   13c96: 81 46        	li	a3, 0
   13c98: 97 f0 00 00  	auipc	ra, 15
   13c9c: e7 80 20 6e  	jalr	1762(ra)
   13ca0: 37 15 01 00  	lui	a0, 17
   13ca4: 13 05 35 6e  	addi	a0, a0, 1763
   13ca8: cd 45        	li	a1, 19
   13caa: 81 46        	li	a3, 0
   13cac: 97 f0 00 00  	auipc	ra, 15
   13cb0: e7 80 e0 6c  	jalr	1742(ra)
;         frame_index = (frame_index + 1) % stack_trace.instruction_addresses.len;
   13cb4: 37 15 01 00  	lui	a0, 17
   13cb8: 13 05 75 78  	addi	a0, a0, 1927
   13cbc: c1 45        	li	a1, 16
   13cbe: 81 46        	li	a3, 0
   13cc0: 97 f0 00 00  	auipc	ra, 15
   13cc4: e7 80 a0 6b  	jalr	1722(ra)
   13cc8: 09 45        	li	a0, 2
   13cca: 63 1c a9 00  	bne	s2, a0, 0x13ce2 <debug.dumpStackTrace+0x592>
   13cce: 37 25 01 00  	lui	a0, 18
   13cd2: 13 05 b5 a7  	addi	a0, a0, -1413
   13cd6: e1 45        	li	a1, 24
   13cd8: 81 46        	li	a3, 0
   13cda: 97 f0 00 00  	auipc	ra, 15
   13cde: e7 80 00 6a  	jalr	1696(ra)
   13ce2: 37 25 01 00  	lui	a0, 18
   13ce6: 13 05 a5 99  	addi	a0, a0, -1638
   13cea: dd 45        	li	a1, 23
   13cec: 81 46        	li	a3, 0
   13cee: 97 f0 00 00  	auipc	ra, 15
   13cf2: e7 80 c0 68  	jalr	1676(ra)

0000000000013cf6 <os.exit>:
;         linux.exit_group(status);
   13cf6: 13 75 f5 0f  	andi	a0, a0, 255
   13cfa: 97 00 00 00  	auipc	ra, 0
   13cfe: e7 80 20 14  	jalr	322(ra)

0000000000013d02 <os.mmap>:
; ) MMapError![]align(mem.page_size) u8 {
   13d02: 79 71        	addi	sp, sp, -48
   13d04: 06 f4        	sd	ra, 40(sp)
   13d06: 22 f0        	sd	s0, 32(sp)
   13d08: 26 ec        	sd	s1, 24(sp)
   13d0a: 4a e8        	sd	s2, 16(sp)
   13d0c: 4e e4        	sd	s3, 8(sp)
   13d0e: b6 84        	mv	s1, a3
   13d10: b2 82        	mv	t0, a2
   13d12: 2e 89        	mv	s2, a1
   13d14: aa 89        	mv	s3, a0
;     const rc = mmap_sym(ptr, length, prot, flags, fd, ioffset);
   13d16: 13 15 07 02  	slli	a0, a4, 32
   13d1a: 13 56 05 02  	srli	a2, a0, 32
;             @ptrToInt(address),
   13d1e: 1b 07 08 00  	sext.w	a4, a6
   13d22: 13 95 07 02  	slli	a0, a5, 32
   13d26: 93 56 05 02  	srli	a3, a0, 32
;     return asm volatile ("ecall"
   13d2a: 93 08 e0 0d  	li	a7, 222
   13d2e: 7d 75        	lui	a0, 1048575
   13d30: 1b 04 15 00  	addiw	s0, a0, 1
   13d34: 16 85        	mv	a0, t0
   13d36: a6 85        	mv	a1, s1
   13d38: 81 47        	li	a5, 0
   13d3a: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   13d3e: 63 74 85 02  	bgeu	a0, s0, 0x13d66 <os.mmap+0x64>
;         if (err == .SUCCESS) return @intToPtr([*]align(mem.page_size) u8, rc)[0..length];
   13d42: 5d cd        	beqz	a0, 0x13e00 <.LBB15_12+0x1a>
   13d44: 93 15 45 03  	slli	a1, a0, 52
   13d48: d1 91        	srli	a1, a1, 52
   13d4a: e9 e5        	bnez	a1, 0x13e14 <.LBB15_12+0x2e>
   13d4c: 23 b0 a9 00  	sd	a0, 0(s3)
   13d50: 23 b4 99 00  	sd	s1, 8(s3)
   13d54: 23 98 09 00  	sh	zero, 16(s3)
   13d58: a2 70        	ld	ra, 40(sp)
   13d5a: 02 74        	ld	s0, 32(sp)
   13d5c: e2 64        	ld	s1, 24(sp)
   13d5e: 42 69        	ld	s2, 16(sp)
   13d60: a2 69        	ld	s3, 8(sp)
   13d62: 45 61        	addi	sp, sp, 48
   13d64: 82 80        	ret
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   13d66: 3b 05 a0 40  	negw	a0, a0
;         if (err == .SUCCESS) return @intToPtr([*]align(mem.page_size) u8, rc)[0..length];
   13d6a: 42 15        	slli	a0, a0, 48
   13d6c: 41 91        	srli	a0, a0, 48
   13d6e: 7d 15        	addi	a0, a0, -1
   13d70: 93 05 a0 04  	li	a1, 74
   13d74: 63 e8 a5 02  	bltu	a1, a0, 0x13da4 <.LBB15_9>
   13d78: 0a 05        	slli	a0, a0, 2
   13d7a: b7 05 01 00  	lui	a1, 16
   13d7e: 93 85 05 19  	addi	a1, a1, 400
   13d82: 2e 95        	add	a0, a0, a1
   13d84: 08 41        	lw	a0, 0(a0)
   13d86: 02 85        	jr	a0

0000000000013d88 <.LBB15_7>:
   13d88: 4a 85        	mv	a0, s2
   13d8a: 97 00 01 00  	auipc	ra, 16
   13d8e: e7 80 e0 e6  	jalr	-402(ra)
   13d92: 15 45        	li	a0, 5
   13d94: b9 a8        	j	0x13df2 <.LBB15_12+0xc>

0000000000013d96 <.LBB15_8>:
;         .PERM => return error.PermissionDenied,
   13d96: 4a 85        	mv	a0, s2
   13d98: 97 00 01 00  	auipc	ra, 16
   13d9c: e7 80 00 e6  	jalr	-416(ra)
   13da0: 3d 45        	li	a0, 15
   13da2: 81 a8        	j	0x13df2 <.LBB15_12+0xc>

0000000000013da4 <.LBB15_9>:
;     return error.Unexpected;
   13da4: 4a 85        	mv	a0, s2
   13da6: 97 00 01 00  	auipc	ra, 16
   13daa: e7 80 20 e5  	jalr	-430(ra)
   13dae: 35 45        	li	a0, 13
;         else => return unexpectedErrno(err),
   13db0: 23 98 a9 00  	sh	a0, 16(s3)
   13db4: 4a 85        	mv	a0, s2
   13db6: a2 70        	ld	ra, 40(sp)
   13db8: 02 74        	ld	s0, 32(sp)
   13dba: e2 64        	ld	s1, 24(sp)
   13dbc: 42 69        	ld	s2, 16(sp)
   13dbe: a2 69        	ld	s3, 8(sp)
   13dc0: 45 61        	addi	sp, sp, 48
   13dc2: 17 03 01 00  	auipc	t1, 16
   13dc6: 67 00 63 e3  	jr	-458(t1)

0000000000013dca <.LBB15_10>:
;         .AGAIN => return error.LockedMemoryLimitExceeded,
   13dca: 4a 85        	mv	a0, s2
   13dcc: 97 00 01 00  	auipc	ra, 16
   13dd0: e7 80 c0 e2  	jalr	-468(ra)
   13dd4: 41 45        	li	a0, 16
   13dd6: 31 a8        	j	0x13df2 <.LBB15_12+0xc>

0000000000013dd8 <.LBB15_11>:
;         .NOMEM => return error.OutOfMemory,
   13dd8: 4a 85        	mv	a0, s2
   13dda: 97 00 01 00  	auipc	ra, 16
   13dde: e7 80 e0 e1  	jalr	-482(ra)
   13de2: 45 45        	li	a0, 17
   13de4: 39 a0        	j	0x13df2 <.LBB15_12+0xc>

0000000000013de6 <.LBB15_12>:
;         .NODEV => return error.MemoryMappingNotSupported,
   13de6: 4a 85        	mv	a0, s2
   13de8: 97 00 01 00  	auipc	ra, 16
   13dec: e7 80 00 e1  	jalr	-496(ra)
   13df0: 39 45        	li	a0, 14
   13df2: 23 b8 a9 00  	sd	a0, 16(s3)
   13df6: 23 b4 09 00  	sd	zero, 8(s3)
   13dfa: 23 b0 09 00  	sd	zero, 0(s3)
   13dfe: a9 bf        	j	0x13d58 <os.mmap+0x56>
;         if (err == .SUCCESS) return @intToPtr([*]align(mem.page_size) u8, rc)[0..length];
   13e00: 37 25 01 00  	lui	a0, 18
   13e04: 13 05 a5 86  	addi	a0, a0, -1942
   13e08: f9 45        	li	a1, 30
   13e0a: 81 46        	li	a3, 0
   13e0c: 97 f0 00 00  	auipc	ra, 15
   13e10: e7 80 e0 56  	jalr	1390(ra)
   13e14: 37 15 01 00  	lui	a0, 17
   13e18: 13 05 75 63  	addi	a0, a0, 1591
   13e1c: cd 45        	li	a1, 19
   13e1e: 81 46        	li	a3, 0
   13e20: 97 f0 00 00  	auipc	ra, 15
   13e24: e7 80 a0 55  	jalr	1370(ra)

0000000000013e28 <.LBB15_16>:
   13e28: 37 25 01 00  	lui	a0, 18
   13e2c: 13 05 b5 a7  	addi	a0, a0, -1413
   13e30: e1 45        	li	a1, 24
   13e32: 81 46        	li	a3, 0
   13e34: 97 f0 00 00  	auipc	ra, 15
   13e38: e7 80 60 54  	jalr	1350(ra)

0000000000013e3c <os.linux.exit_group>:
; pub fn exit_group(status: i32) noreturn {
   13e3c: 02 15        	slli	a0, a0, 32
   13e3e: 01 91        	srli	a0, a0, 32
;     return asm volatile ("ecall"
   13e40: 93 08 e0 05  	li	a7, 94
   13e44: 73 00 00 00  	ecall	
;     unreachable;
   13e48: 37 25 01 00  	lui	a0, 18
   13e4c: 13 05 b5 a7  	addi	a0, a0, -1413
   13e50: e1 45        	li	a1, 24
   13e52: 81 46        	li	a3, 0
   13e54: 97 f0 00 00  	auipc	ra, 15
   13e58: e7 80 60 52  	jalr	1318(ra)

0000000000013e5c <fs.file.File.write>:
;     pub fn write(self: File, bytes: []const u8) WriteError!usize {
   13e5c: 79 71        	addi	sp, sp, -48
   13e5e: 06 f4        	sd	ra, 40(sp)
   13e60: 22 f0        	sd	s0, 32(sp)
   13e62: 26 ec        	sd	s1, 24(sp)
   13e64: 4a e8        	sd	s2, 16(sp)
   13e66: 4e e4        	sd	s3, 8(sp)
   13e68: aa 89        	mv	s3, a0
;     if (bytes.len == 0) return 0;
   13e6a: 35 c7        	beqz	a4, 0x13ed6 <.LBB17_8+0x14>
   13e6c: 2e 89        	mv	s2, a1
   13e6e: 37 f5 ff 7f  	lui	a0, 524287
;     const adjusted_len = @min(max_count, bytes.len);
   13e72: 63 64 a7 00  	bltu	a4, a0, 0x13e7a <fs.file.File.write+0x1e>
   13e76: 37 f7 ff 7f  	lui	a4, 524287
   13e7a: 9b 07 06 00  	sext.w	a5, a2
   13e7e: 7d 75        	lui	a0, 1048575
   13e80: 9b 04 15 00  	addiw	s1, a0, 1
   13e84: 11 44        	li	s0, 4
   13e86: 93 08 00 04  	li	a7, 64
;     return asm volatile ("ecall"
   13e8a: 3e 85        	mv	a0, a5
   13e8c: b6 85        	mv	a1, a3
   13e8e: 3a 86        	mv	a2, a4
   13e90: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   13e94: 63 65 95 04  	bltu	a0, s1, 0x13ede <.LBB17_8+0x1c>
   13e98: 3b 05 a0 40  	negw	a0, a0
   13e9c: 42 15        	slli	a0, a0, 48
   13e9e: 41 91        	srli	a0, a0, 48
;         switch (errno(rc)) {
   13ea0: e3 05 85 fe  	beq	a0, s0, 0x13e8a <fs.file.File.write+0x2e>
   13ea4: 93 05 f5 ff  	addi	a1, a0, -1
   13ea8: 13 06 70 06  	li	a2, 103
   13eac: 63 60 b6 06  	bltu	a2, a1, 0x13f0c <.LBB17_8+0x4a>
   13eb0: 13 95 25 00  	slli	a0, a1, 2
   13eb4: b7 05 01 00  	lui	a1, 16
   13eb8: 93 85 c5 2b  	addi	a1, a1, 700
   13ebc: 2e 95        	add	a0, a0, a1
   13ebe: 08 41        	lw	a0, 0(a0)
   13ec0: 02 85        	jr	a0

0000000000013ec2 <.LBB17_8>:
;             .PERM => return error.AccessDenied,
   13ec2: 4a 85        	mv	a0, s2
   13ec4: 97 00 01 00  	auipc	ra, 16
   13ec8: e7 80 40 d3  	jalr	-716(ra)
   13ecc: 23 12 01 00  	sh	zero, 4(sp)
   13ed0: 02 c0        	sw	zero, 0(sp)
   13ed2: 15 45        	li	a0, 5
   13ed4: dd a8        	j	0x13fca <.LBB17_20+0x12>
   13ed6: 01 45        	li	a0, 0
;     if (bytes.len == 0) return 0;
   13ed8: 23 12 01 00  	sh	zero, 4(sp)
   13edc: 02 c0        	sw	zero, 0(sp)
;             return os.write(self.handle, bytes);
   13ede: 83 15 01 00  	lh	a1, 0(sp)
   13ee2: 03 16 21 00  	lh	a2, 2(sp)
   13ee6: 23 b0 a9 00  	sd	a0, 0(s3)
   13eea: 03 15 41 00  	lh	a0, 4(sp)
   13eee: 23 95 b9 00  	sh	a1, 10(s3)
   13ef2: 23 96 c9 00  	sh	a2, 12(s3)
   13ef6: 23 94 09 00  	sh	zero, 8(s3)
   13efa: 23 97 a9 00  	sh	a0, 14(s3)
   13efe: a2 70        	ld	ra, 40(sp)
   13f00: 02 74        	ld	s0, 32(sp)
   13f02: e2 64        	ld	s1, 24(sp)
   13f04: 42 69        	ld	s2, 16(sp)
   13f06: a2 69        	ld	s3, 8(sp)
   13f08: 45 61        	addi	sp, sp, 48
   13f0a: 82 80        	ret
   13f0c: 93 05 a0 07  	li	a1, 122
;         switch (errno(rc)) {
   13f10: 63 1c b5 00  	bne	a0, a1, 0x13f28 <.LBB17_13>
;             .DQUOT => return error.DiskQuota,
   13f14: 4a 85        	mv	a0, s2
   13f16: 97 00 01 00  	auipc	ra, 16
   13f1a: e7 80 20 ce  	jalr	-798(ra)
   13f1e: 23 12 01 00  	sh	zero, 4(sp)
   13f22: 02 c0        	sw	zero, 0(sp)
   13f24: 05 45        	li	a0, 1
   13f26: 55 a0        	j	0x13fca <.LBB17_20+0x12>

0000000000013f28 <.LBB17_13>:
;     return error.Unexpected;
   13f28: 4a 85        	mv	a0, s2
   13f2a: 97 00 01 00  	auipc	ra, 16
   13f2e: e7 80 e0 cc  	jalr	-818(ra)
;             else => |err| return unexpectedErrno(err),
   13f32: 4a 85        	mv	a0, s2
   13f34: 97 00 01 00  	auipc	ra, 16
   13f38: e7 80 40 cc  	jalr	-828(ra)
   13f3c: 35 45        	li	a0, 13
   13f3e: 71 a0        	j	0x13fca <.LBB17_20+0x12>

0000000000013f40 <.LBB17_14>:
;             .IO => return error.InputOutput,
   13f40: 4a 85        	mv	a0, s2
   13f42: 97 00 01 00  	auipc	ra, 16
   13f46: e7 80 60 cb  	jalr	-842(ra)
   13f4a: 23 12 01 00  	sh	zero, 4(sp)
   13f4e: 02 c0        	sw	zero, 0(sp)
   13f50: 0d 45        	li	a0, 3
   13f52: a5 a8        	j	0x13fca <.LBB17_20+0x12>

0000000000013f54 <.LBB17_15>:
;             .BADF => return error.NotOpenForWriting, // can be a race condition.
   13f54: 4a 85        	mv	a0, s2
   13f56: 97 00 01 00  	auipc	ra, 16
   13f5a: e7 80 20 ca  	jalr	-862(ra)
   13f5e: 23 12 01 00  	sh	zero, 4(sp)
   13f62: 02 c0        	sw	zero, 0(sp)
   13f64: 25 45        	li	a0, 9
   13f66: 95 a0        	j	0x13fca <.LBB17_20+0x12>

0000000000013f68 <.LBB17_16>:
;             .AGAIN => return error.WouldBlock,
   13f68: 4a 85        	mv	a0, s2
   13f6a: 97 00 01 00  	auipc	ra, 16
   13f6e: e7 80 e0 c8  	jalr	-882(ra)
   13f72: 23 12 01 00  	sh	zero, 4(sp)
   13f76: 02 c0        	sw	zero, 0(sp)
   13f78: 2d 45        	li	a0, 11
   13f7a: 81 a8        	j	0x13fca <.LBB17_20+0x12>

0000000000013f7c <.LBB17_17>:
;             .FBIG => return error.FileTooBig,
   13f7c: 4a 85        	mv	a0, s2
   13f7e: 97 00 01 00  	auipc	ra, 16
   13f82: e7 80 a0 c7  	jalr	-902(ra)
   13f86: 23 12 01 00  	sh	zero, 4(sp)
   13f8a: 02 c0        	sw	zero, 0(sp)
   13f8c: 09 45        	li	a0, 2
   13f8e: 35 a8        	j	0x13fca <.LBB17_20+0x12>

0000000000013f90 <.LBB17_18>:
;             .NOSPC => return error.NoSpaceLeft,
   13f90: 4a 85        	mv	a0, s2
   13f92: 97 00 01 00  	auipc	ra, 16
   13f96: e7 80 60 c6  	jalr	-922(ra)
   13f9a: 23 12 01 00  	sh	zero, 4(sp)
   13f9e: 02 c0        	sw	zero, 0(sp)
   13fa0: 11 45        	li	a0, 4
   13fa2: 25 a0        	j	0x13fca <.LBB17_20+0x12>

0000000000013fa4 <.LBB17_19>:
;             .PIPE => return error.BrokenPipe,
   13fa4: 4a 85        	mv	a0, s2
   13fa6: 97 00 01 00  	auipc	ra, 16
   13faa: e7 80 20 c5  	jalr	-942(ra)
   13fae: 23 12 01 00  	sh	zero, 4(sp)
   13fb2: 02 c0        	sw	zero, 0(sp)
   13fb4: 19 45        	li	a0, 6
   13fb6: 11 a8        	j	0x13fca <.LBB17_20+0x12>

0000000000013fb8 <.LBB17_20>:
;             .CONNRESET => return error.ConnectionResetByPeer,
   13fb8: 4a 85        	mv	a0, s2
   13fba: 97 00 01 00  	auipc	ra, 16
   13fbe: e7 80 e0 c3  	jalr	-962(ra)
   13fc2: 23 12 01 00  	sh	zero, 4(sp)
   13fc6: 02 c0        	sw	zero, 0(sp)
   13fc8: 31 45        	li	a0, 12
;             return os.write(self.handle, bytes);
   13fca: 83 15 01 00  	lh	a1, 0(sp)
   13fce: 03 16 21 00  	lh	a2, 2(sp)
   13fd2: 83 16 41 00  	lh	a3, 4(sp)
   13fd6: 23 94 a9 00  	sh	a0, 8(s3)
   13fda: 23 95 b9 00  	sh	a1, 10(s3)
   13fde: 23 96 c9 00  	sh	a2, 12(s3)
   13fe2: 23 97 d9 00  	sh	a3, 14(s3)
   13fe6: 4a 85        	mv	a0, s2
   13fe8: a2 70        	ld	ra, 40(sp)
   13fea: 02 74        	ld	s0, 32(sp)
   13fec: e2 64        	ld	s1, 24(sp)
   13fee: 42 69        	ld	s2, 16(sp)
   13ff0: a2 69        	ld	s3, 8(sp)
   13ff2: 45 61        	addi	sp, sp, 48
   13ff4: 17 03 01 00  	auipc	t1, 16
   13ff8: 67 00 43 c0  	jr	-1020(t1)

0000000000013ffc <.LBB17_22>:
   13ffc: 37 25 01 00  	lui	a0, 18
   14000: 13 05 b5 a7  	addi	a0, a0, -1413
   14004: e1 45        	li	a1, 24
   14006: 81 46        	li	a3, 0
   14008: 97 f0 00 00  	auipc	ra, 15
   1400c: e7 80 20 37  	jalr	882(ra)

0000000000014010 <debug.DebugInfo.lookupModuleDl__struct_4676.callback>:
;             fn callback(info: *os.dl_phdr_info, size: usize, context: *CtxTy) !void {
   14010: 79 71        	addi	sp, sp, -48
   14012: 06 f4        	sd	ra, 40(sp)
   14014: 22 f0        	sd	s0, 32(sp)
   14016: 26 ec        	sd	s1, 24(sp)
   14018: 4a e8        	sd	s2, 16(sp)
   1401a: 4e e4        	sd	s3, 8(sp)
   1401c: b2 89        	mv	s3, a2
   1401e: ae 84        	mv	s1, a1
;                 if (context.address < info.dlpi_addr)
   14020: 0c 62        	ld	a1, 0(a2)
   14022: 90 60        	ld	a2, 0(s1)
   14024: 63 f4 c5 00  	bgeu	a1, a2, 0x1402c <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x1c>
   14028: 01 45        	li	a0, 0
   1402a: bd a0        	j	0x14098 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x88>
   1402c: 2a 89        	mv	s2, a0
;                 const phdrs = info.dlpi_phdr[0..info.dlpi_phnum];
   1402e: 03 d5 84 01  	lhu	a0, 24(s1)
;                 for (phdrs) |*phdr| {
   14032: 3d c1        	beqz	a0, 0x14098 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x88>
   14034: 94 68        	ld	a3, 16(s1)
   14036: 05 47        	li	a4, 1
   14038: 29 a0        	j	0x14042 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x32>
;                 for (phdrs) |*phdr| {
   1403a: 7d 15        	addi	a0, a0, -1
   1403c: 93 86 86 03  	addi	a3, a3, 56
   14040: 21 cd        	beqz	a0, 0x14098 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x88>
;                     if (phdr.p_type != elf.PT_LOAD) continue;
   14042: 9c 42        	lw	a5, 0(a3)
   14044: e3 9b e7 fe  	bne	a5, a4, 0x1403a <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x2a>
;                     const seg_start = info.dlpi_addr + phdr.p_vaddr;
   14048: 9c 6a        	ld	a5, 16(a3)
   1404a: b2 97        	add	a5, a5, a2
   1404c: 63 ed c7 04  	bltu	a5, a2, 0x140a6 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x96>
;                     const seg_end = seg_start + phdr.p_memsz;
   14050: 80 76        	ld	s0, 40(a3)
   14052: 3e 94        	add	s0, s0, a5
   14054: 63 69 f4 04  	bltu	s0, a5, 0x140a6 <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x96>
;                     if (context.address >= seg_start and context.address < seg_end) {
   14058: b3 b7 f5 00  	sltu	a5, a1, a5
   1405c: 93 c7 17 00  	xori	a5, a5, 1
   14060: 33 b4 85 00  	sltu	s0, a1, s0
   14064: e1 8f        	and	a5, a5, s0
   14066: f1 db        	beqz	a5, 0x1403a <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x2a>
;                         context.name = mem.sliceTo(info.dlpi_name, 0) orelse "";
   14068: 88 64        	ld	a0, 8(s1)
   1406a: 97 00 00 00  	auipc	ra, 0
   1406e: e7 80 00 05  	jalr	80(ra)
   14072: 11 e5        	bnez	a0, 0x1407e <debug.DebugInfo.lookupModuleDl__struct_4676.callback+0x6e>
   14074: 81 45        	li	a1, 0
;                         context.name = mem.sliceTo(info.dlpi_name, 0) orelse "";
   14076: 37 25 01 00  	lui	a0, 18
   1407a: 13 05 45 e2  	addi	a0, a0, -476
   1407e: 23 b8 a9 00  	sd	a0, 16(s3)
;                         context.name = mem.sliceTo(info.dlpi_name, 0) orelse "";
   14082: 23 bc b9 00  	sd	a1, 24(s3)
;                         context.base_address = info.dlpi_addr;
   14086: 88 60        	ld	a0, 0(s1)
   14088: 23 b4 a9 00  	sd	a0, 8(s3)
;                         return error.Found;
   1408c: 4a 85        	mv	a0, s2
   1408e: 97 00 01 00  	auipc	ra, 16
   14092: e7 80 a0 b6  	jalr	-1174(ra)
   14096: 55 45        	li	a0, 21
   14098: a2 70        	ld	ra, 40(sp)
   1409a: 02 74        	ld	s0, 32(sp)
   1409c: e2 64        	ld	s1, 24(sp)
   1409e: 42 69        	ld	s2, 16(sp)
   140a0: a2 69        	ld	s3, 8(sp)
   140a2: 45 61        	addi	sp, sp, 48
   140a4: 82 80        	ret
   140a6: 37 15 01 00  	lui	a0, 17
   140aa: 13 05 95 5d  	addi	a0, a0, 1497
   140ae: c1 45        	li	a1, 16
   140b0: 81 46        	li	a3, 0
   140b2: 97 f0 00 00  	auipc	ra, 15
   140b6: e7 80 80 2c  	jalr	712(ra)

00000000000140ba <mem.sliceTo__anon_4679>:
;         const non_null = ptr orelse return null;
   140ba: 09 cd        	beqz	a0, 0x140d4 <mem.sliceTo__anon_4679+0x1a>
;                 while (ptr[i] != end and ptr[i] != sentinel) i += 1;
   140bc: 83 45 05 00  	lbu	a1, 0(a0)
   140c0: 89 c9        	beqz	a1, 0x140d2 <mem.sliceTo__anon_4679+0x18>
   140c2: 81 45        	li	a1, 0
;                 while (ptr[i] != end and ptr[i] != sentinel) i += 1;
   140c4: 85 05        	addi	a1, a1, 1
   140c6: 89 c9        	beqz	a1, 0x140d8 <mem.sliceTo__anon_4679+0x1e>
   140c8: 33 06 b5 00  	add	a2, a0, a1
   140cc: 03 46 06 00  	lbu	a2, 0(a2)
   140d0: 75 fa        	bnez	a2, 0x140c4 <mem.sliceTo__anon_4679+0xa>
   140d2: 82 80        	ret
   140d4: 81 45        	li	a1, 0
   140d6: 82 80        	ret
;                 while (ptr[i] != end and ptr[i] != sentinel) i += 1;
   140d8: 37 15 01 00  	lui	a0, 17
   140dc: 13 05 95 5d  	addi	a0, a0, 1497
   140e0: c1 45        	li	a1, 16
   140e2: 81 46        	li	a3, 0
   140e4: 97 f0 00 00  	auipc	ra, 15
   140e8: e7 80 60 29  	jalr	662(ra)

00000000000140ec <fs.file.File.close>:
;     return syscall1(.close, @bitCast(usize, @as(isize, fd)));
   140ec: 01 25        	sext.w	a0, a0
;     return asm volatile ("ecall"
   140ee: 93 08 90 03  	li	a7, 57
   140f2: 73 00 00 00  	ecall	
   140f6: fd 75        	lui	a1, 1048575
   140f8: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   140fa: b3 35 b5 00  	sltu	a1, a0, a1
   140fe: 42 15        	slli	a0, a0, 48
   14100: 41 91        	srli	a0, a0, 48
   14102: 41 66        	lui	a2, 16
   14104: 5d 36        	addiw	a2, a2, -9
   14106: 31 8d        	xor	a0, a0, a2
   14108: 33 35 a0 00  	snez	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1410c: 4d 8d        	or	a0, a0, a1
   1410e: 11 c1        	beqz	a0, 0x14112 <fs.file.File.close+0x26>
;             os.close(self.handle);
   14110: 82 80        	ret
;         .BADF => unreachable, // Always a race condition.
   14112: 37 25 01 00  	lui	a0, 18
   14116: 13 05 b5 a7  	addi	a0, a0, -1413
   1411a: e1 45        	li	a1, 24
   1411c: 81 46        	li	a3, 0
   1411e: 97 f0 00 00  	auipc	ra, 15
   14122: e7 80 c0 25  	jalr	604(ra)

0000000000014126 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927>:
;         pub fn readInt(self: Self, comptime T: type, endian: std.builtin.Endian) !T {
   14126: 1d 71        	addi	sp, sp, -96
   14128: 86 ec        	sd	ra, 88(sp)
   1412a: a2 e8        	sd	s0, 80(sp)
   1412c: a6 e4        	sd	s1, 72(sp)
   1412e: ca e0        	sd	s2, 64(sp)
   14130: 4e fc        	sd	s3, 56(sp)
   14132: 52 f8        	sd	s4, 48(sp)
   14134: 56 f4        	sd	s5, 40(sp)
   14136: 5a f0        	sd	s6, 32(sp)
   14138: 36 8a        	mv	s4, a3
   1413a: 32 8b        	mv	s6, a2
   1413c: 2e 89        	mv	s2, a1
   1413e: aa 89        	mv	s3, a0
   14140: 01 44        	li	s0, 0
   14142: 37 b5 aa aa  	lui	a0, 699051
   14146: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   1414a: 2a c6        	sw	a0, 12(sp)
   1414c: 93 0a c1 00  	addi	s5, sp, 12
   14150: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   14152: 33 86 8a 00  	add	a2, s5, s0
   14156: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1415a: 08 08        	addi	a0, sp, 16
   1415c: da 85        	mv	a1, s6
   1415e: 97 d0 00 00  	auipc	ra, 13
   14162: e7 80 a0 55  	jalr	1370(ra)
   14166: 42 65        	ld	a0, 16(sp)
;                 if (amt == 0) break;
   14168: 21 cd        	beqz	a0, 0x141c0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927+0x9a>
;                 index += amt;
   1416a: 22 95        	add	a0, a0, s0
   1416c: 63 6c 85 06  	bltu	a0, s0, 0x141e4 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927+0xbe>
   14170: 2a 84        	mv	s0, a0
;             while (index < len) {
   14172: e3 60 95 fe  	bltu	a0, s1, 0x14152 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927+0x2c>
;             return bytes;
   14176: 03 65 c1 00  	lwu	a0, 12(sp)
;     if (endian == native_endian) {
   1417a: 93 75 1a 00  	andi	a1, s4, 1
   1417e: 95 e1        	bnez	a1, 0x141a2 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927+0x7c>
   14180: 93 55 85 00  	srli	a1, a0, 8
   14184: 41 66        	lui	a2, 16
   14186: 1b 06 06 f0  	addiw	a2, a2, -256
   1418a: f1 8d        	and	a1, a1, a2
   1418c: 13 56 85 01  	srli	a2, a0, 24
   14190: d1 8d        	or	a1, a1, a2
   14192: 13 16 85 00  	slli	a2, a0, 8
   14196: b7 06 ff 00  	lui	a3, 4080
   1419a: 75 8e        	and	a2, a2, a3
   1419c: 62 05        	slli	a0, a0, 24
   1419e: 51 8d        	or	a0, a0, a2
   141a0: 4d 8d        	or	a0, a0, a1
   141a2: 81 45        	li	a1, 0
;             return mem.readInt(T, &bytes, endian);
   141a4: 23 a0 a9 00  	sw	a0, 0(s3)
   141a8: 23 92 b9 00  	sh	a1, 4(s3)
   141ac: e6 60        	ld	ra, 88(sp)
   141ae: 46 64        	ld	s0, 80(sp)
   141b0: a6 64        	ld	s1, 72(sp)
   141b2: 06 69        	ld	s2, 64(sp)
   141b4: e2 79        	ld	s3, 56(sp)
   141b6: 42 7a        	ld	s4, 48(sp)
   141b8: a2 7a        	ld	s5, 40(sp)
   141ba: 02 7b        	ld	s6, 32(sp)
   141bc: 25 61        	addi	sp, sp, 96
   141be: 82 80        	ret
;             if (amt_read < buf.len) return error.EndOfStream;
   141c0: 4a 85        	mv	a0, s2
   141c2: 97 00 01 00  	auipc	ra, 16
   141c6: e7 80 60 a3  	jalr	-1482(ra)
;             try self.readNoEof(&bytes);
   141ca: 4a 85        	mv	a0, s2
   141cc: 97 00 01 00  	auipc	ra, 16
   141d0: e7 80 c0 a2  	jalr	-1492(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   141d4: 4a 85        	mv	a0, s2
   141d6: 97 00 01 00  	auipc	ra, 16
   141da: e7 80 20 a2  	jalr	-1502(ra)
   141de: 93 05 10 03  	li	a1, 49
   141e2: d9 b7        	j	0x141a8 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4927+0x82>
;                 index += amt;
   141e4: 37 15 01 00  	lui	a0, 17
   141e8: 13 05 95 5d  	addi	a0, a0, 1497
   141ec: c1 45        	li	a1, 16
   141ee: 81 46        	li	a3, 0
   141f0: 97 f0 00 00  	auipc	ra, 15
   141f4: e7 80 a0 18  	jalr	394(ra)

00000000000141f8 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930>:
;         pub fn readInt(self: Self, comptime T: type, endian: std.builtin.Endian) !T {
   141f8: 1d 71        	addi	sp, sp, -96
   141fa: 86 ec        	sd	ra, 88(sp)
   141fc: a2 e8        	sd	s0, 80(sp)
   141fe: a6 e4        	sd	s1, 72(sp)
   14200: ca e0        	sd	s2, 64(sp)
   14202: 4e fc        	sd	s3, 56(sp)
   14204: 52 f8        	sd	s4, 48(sp)
   14206: 56 f4        	sd	s5, 40(sp)
   14208: 5a f0        	sd	s6, 32(sp)
   1420a: 37 57 02 00  	lui	a4, 37
   1420e: 03 37 87 32  	ld	a4, 808(a4)
   14212: 36 8a        	mv	s4, a3
   14214: 32 8b        	mv	s6, a2
   14216: 2e 89        	mv	s2, a1
   14218: aa 89        	mv	s3, a0
   1421a: 01 44        	li	s0, 0
;             var bytes: [num_bytes]u8 = undefined;
   1421c: 3a e4        	sd	a4, 8(sp)
   1421e: 93 0a 81 00  	addi	s5, sp, 8
   14222: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   14224: 33 86 8a 00  	add	a2, s5, s0
   14228: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1422c: 08 08        	addi	a0, sp, 16
   1422e: da 85        	mv	a1, s6
   14230: 97 d0 00 00  	auipc	ra, 13
   14234: e7 80 80 48  	jalr	1160(ra)
   14238: 42 65        	ld	a0, 16(sp)
;                 if (amt == 0) break;
   1423a: 51 c1        	beqz	a0, 0x142be <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930+0xc6>
;                 index += amt;
   1423c: 22 95        	add	a0, a0, s0
   1423e: 63 62 85 0a  	bltu	a0, s0, 0x142e2 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930+0xea>
   14242: 2a 84        	mv	s0, a0
;             while (index < len) {
   14244: e3 60 95 fe  	bltu	a0, s1, 0x14224 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930+0x2c>
;             return bytes;
   14248: 22 65        	ld	a0, 8(sp)
;     if (endian == native_endian) {
   1424a: 93 75 1a 00  	andi	a1, s4, 1
   1424e: a9 e9        	bnez	a1, 0x142a0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930+0xa8>
   14250: 93 55 85 01  	srli	a1, a0, 24
   14254: 37 06 ff 00  	lui	a2, 4080
   14258: f1 8d        	and	a1, a1, a2
   1425a: 13 56 85 00  	srli	a2, a0, 8
   1425e: 93 06 f0 0f  	li	a3, 255
   14262: 13 97 86 01  	slli	a4, a3, 24
   14266: 79 8e        	and	a2, a2, a4
   14268: d1 8d        	or	a1, a1, a2
   1426a: 13 56 85 02  	srli	a2, a0, 40
   1426e: 41 67        	lui	a4, 16
   14270: 1b 07 07 f0  	addiw	a4, a4, -256
   14274: 79 8e        	and	a2, a2, a4
   14276: 13 57 85 03  	srli	a4, a0, 56
   1427a: 59 8e        	or	a2, a2, a4
   1427c: d1 8d        	or	a1, a1, a2
   1427e: 13 16 85 01  	slli	a2, a0, 24
   14282: 13 97 86 02  	slli	a4, a3, 40
   14286: 79 8e        	and	a2, a2, a4
   14288: 1b 57 85 01  	srliw	a4, a0, 24
   1428c: 02 17        	slli	a4, a4, 32
   1428e: 59 8e        	or	a2, a2, a4
   14290: 13 17 85 02  	slli	a4, a0, 40
   14294: c2 16        	slli	a3, a3, 48
   14296: f9 8e        	and	a3, a3, a4
   14298: 62 15        	slli	a0, a0, 56
   1429a: 55 8d        	or	a0, a0, a3
   1429c: 51 8d        	or	a0, a0, a2
   1429e: 4d 8d        	or	a0, a0, a1
   142a0: 81 45        	li	a1, 0
;             return mem.readInt(T, &bytes, endian);
   142a2: 23 b0 a9 00  	sd	a0, 0(s3)
   142a6: 23 94 b9 00  	sh	a1, 8(s3)
   142aa: e6 60        	ld	ra, 88(sp)
   142ac: 46 64        	ld	s0, 80(sp)
   142ae: a6 64        	ld	s1, 72(sp)
   142b0: 06 69        	ld	s2, 64(sp)
   142b2: e2 79        	ld	s3, 56(sp)
   142b4: 42 7a        	ld	s4, 48(sp)
   142b6: a2 7a        	ld	s5, 40(sp)
   142b8: 02 7b        	ld	s6, 32(sp)
   142ba: 25 61        	addi	sp, sp, 96
   142bc: 82 80        	ret
;             if (amt_read < buf.len) return error.EndOfStream;
   142be: 4a 85        	mv	a0, s2
   142c0: 97 00 01 00  	auipc	ra, 16
   142c4: e7 80 80 93  	jalr	-1736(ra)
;             try self.readNoEof(&bytes);
   142c8: 4a 85        	mv	a0, s2
   142ca: 97 00 01 00  	auipc	ra, 16
   142ce: e7 80 e0 92  	jalr	-1746(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   142d2: 4a 85        	mv	a0, s2
   142d4: 97 00 01 00  	auipc	ra, 16
   142d8: e7 80 40 92  	jalr	-1756(ra)
   142dc: 93 05 10 03  	li	a1, 49
   142e0: d9 b7        	j	0x142a6 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readInt__anon_4930+0xae>
;                 index += amt;
   142e2: 37 15 01 00  	lui	a0, 17
   142e6: 13 05 95 5d  	addi	a0, a0, 1497
   142ea: c1 45        	li	a1, 16
   142ec: 81 46        	li	a3, 0
   142ee: 97 f0 00 00  	auipc	ra, 15
   142f2: e7 80 c0 08  	jalr	140(ra)

00000000000142f6 <leb128.readULEB128__anon_4970>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   142f6: 39 71        	addi	sp, sp, -64
   142f8: 06 fc        	sd	ra, 56(sp)
   142fa: 22 f8        	sd	s0, 48(sp)
   142fc: 26 f4        	sd	s1, 40(sp)
   142fe: 4a f0        	sd	s2, 32(sp)
   14300: 4e ec        	sd	s3, 24(sp)
   14302: b2 84        	mv	s1, a2
   14304: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   14308: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1430c: 98 60        	ld	a4, 0(s1)
   1430e: 2e 89        	mv	s2, a1
   14310: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   14312: 28 00        	addi	a0, sp, 8
   14314: 13 06 71 00  	addi	a2, sp, 7
   14318: 85 46        	li	a3, 1
   1431a: ba 85        	mv	a1, a4
   1431c: 97 d0 00 00  	auipc	ra, 13
   14320: e7 80 c0 39  	jalr	924(ra)
   14324: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14326: 63 0a 05 1c  	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   1432a: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1432e: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   14332: 63 59 05 1a  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14336: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1433a: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1433e: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   14340: 28 00        	addi	a0, sp, 8
   14342: 13 06 71 00  	addi	a2, sp, 7
   14346: 85 46        	li	a3, 1
   14348: 97 d0 00 00  	auipc	ra, 13
   1434c: e7 80 00 37  	jalr	880(ra)
   14350: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14352: 63 04 05 1a  	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   14356: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1435a: 93 75 f5 07  	andi	a1, a0, 127
   1435e: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   14360: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   14362: 63 51 05 18  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14366: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1436a: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1436e: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   14370: 28 00        	addi	a0, sp, 8
   14372: 13 06 71 00  	addi	a2, sp, 7
   14376: 85 46        	li	a3, 1
   14378: 97 d0 00 00  	auipc	ra, 13
   1437c: e7 80 00 34  	jalr	832(ra)
   14380: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14382: 63 0c 05 16  	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   14386: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1438a: 93 75 f5 07  	andi	a1, a0, 127
   1438e: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   14390: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   14392: 63 59 05 14  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14396: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1439a: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1439e: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   143a0: 28 00        	addi	a0, sp, 8
   143a2: 13 06 71 00  	addi	a2, sp, 7
   143a6: 85 46        	li	a3, 1
   143a8: 97 d0 00 00  	auipc	ra, 13
   143ac: e7 80 00 31  	jalr	784(ra)
   143b0: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   143b2: 63 04 05 14  	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   143b6: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   143ba: 93 75 f5 07  	andi	a1, a0, 127
   143be: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   143c0: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   143c2: 63 51 05 12  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   143c6: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   143ca: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   143ce: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   143d0: 28 00        	addi	a0, sp, 8
   143d2: 13 06 71 00  	addi	a2, sp, 7
   143d6: 85 46        	li	a3, 1
   143d8: 97 d0 00 00  	auipc	ra, 13
   143dc: e7 80 00 2e  	jalr	736(ra)
   143e0: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   143e2: 63 0c 05 10  	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   143e6: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   143ea: 93 75 f5 07  	andi	a1, a0, 127
   143ee: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   143f0: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   143f2: 63 59 05 0e  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   143f6: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   143fa: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   143fe: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   14400: 28 00        	addi	a0, sp, 8
   14402: 13 06 71 00  	addi	a2, sp, 7
   14406: 85 46        	li	a3, 1
   14408: 97 d0 00 00  	auipc	ra, 13
   1440c: e7 80 00 2b  	jalr	688(ra)
   14410: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14412: 65 c5        	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   14414: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14418: 93 75 f5 07  	andi	a1, a0, 127
   1441c: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   1441e: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   14420: 63 52 05 0c  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14424: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14428: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1442c: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1442e: 28 00        	addi	a0, sp, 8
   14430: 13 06 71 00  	addi	a2, sp, 7
   14434: 85 46        	li	a3, 1
   14436: 97 d0 00 00  	auipc	ra, 13
   1443a: e7 80 20 28  	jalr	642(ra)
   1443e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14440: 4d cd        	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   14442: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14446: 93 75 f5 07  	andi	a1, a0, 127
   1444a: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   1444c: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1444e: 63 5b 05 08  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14452: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14456: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1445a: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1445c: 28 00        	addi	a0, sp, 8
   1445e: 13 06 71 00  	addi	a2, sp, 7
   14462: 85 46        	li	a3, 1
   14464: 97 d0 00 00  	auipc	ra, 13
   14468: e7 80 40 25  	jalr	596(ra)
   1446c: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1446e: 51 c5        	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   14470: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14474: 93 75 f5 07  	andi	a1, a0, 127
   14478: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   1447a: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1447c: 63 54 05 06  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   14480: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14484: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14488: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1448a: 28 00        	addi	a0, sp, 8
   1448c: 13 06 71 00  	addi	a2, sp, 7
   14490: 85 46        	li	a3, 1
   14492: 97 d0 00 00  	auipc	ra, 13
   14496: e7 80 60 22  	jalr	550(ra)
   1449a: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1449c: 39 cd        	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   1449e: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   144a2: 93 75 f5 07  	andi	a1, a0, 127
   144a6: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   144a8: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   144aa: 63 5d 05 02  	bgez	a0, 0x144e4 <leb128.readULEB128__anon_4970+0x1ee>
   144ae: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   144b2: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   144b6: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   144b8: 28 00        	addi	a0, sp, 8
   144ba: 13 06 71 00  	addi	a2, sp, 7
   144be: 85 46        	li	a3, 1
   144c0: 97 d0 00 00  	auipc	ra, 13
   144c4: e7 80 80 1f  	jalr	504(ra)
   144c8: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   144ca: 05 c9        	beqz	a0, 0x144fa <leb128.readULEB128__anon_4970+0x204>
;             return result[0];
   144cc: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   144d0: 93 75 e5 07  	andi	a1, a0, 126
;         if (ov[1] != 0) return error.Overflow;
   144d4: b1 e1        	bnez	a1, 0x14518 <leb128.readULEB128__anon_4970+0x222>
   144d6: 93 15 85 03  	slli	a1, a0, 56
   144da: e1 95        	srai	a1, a1, 56
;         if (byte & 0x80 == 0) break;
   144dc: 63 ce 05 02  	bltz	a1, 0x14518 <leb128.readULEB128__anon_4970+0x222>
   144e0: 7e 15        	slli	a0, a0, 63
   144e2: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   144e4: 23 b0 89 00  	sd	s0, 0(s3)
   144e8: 23 94 09 00  	sh	zero, 8(s3)
   144ec: e2 70        	ld	ra, 56(sp)
   144ee: 42 74        	ld	s0, 48(sp)
   144f0: a2 74        	ld	s1, 40(sp)
   144f2: 02 79        	ld	s2, 32(sp)
   144f4: e2 69        	ld	s3, 24(sp)
   144f6: 21 61        	addi	sp, sp, 64
   144f8: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   144fa: 4a 85        	mv	a0, s2
   144fc: 97 f0 00 00  	auipc	ra, 15
   14500: e7 80 c0 6f  	jalr	1788(ra)
;         const byte = try reader.readByte();
   14504: 4a 85        	mv	a0, s2
   14506: 97 f0 00 00  	auipc	ra, 15
   1450a: e7 80 20 6f  	jalr	1778(ra)
   1450e: 13 05 10 03  	li	a0, 49
   14512: 23 94 a9 00  	sh	a0, 8(s3)
   14516: d9 bf        	j	0x144ec <leb128.readULEB128__anon_4970+0x1f6>
   14518: 4a 85        	mv	a0, s2
   1451a: 97 f0 00 00  	auipc	ra, 15
   1451e: e7 80 e0 6d  	jalr	1758(ra)
   14522: 13 05 00 03  	li	a0, 48
   14526: 23 b4 a9 00  	sd	a0, 8(s3)
   1452a: 23 b0 09 00  	sd	zero, 0(s3)
   1452e: 7d bf        	j	0x144ec <leb128.readULEB128__anon_4970+0x1f6>

0000000000014530 <leb128.readILEB128__anon_5026>:
; pub fn readILEB128(comptime T: type, reader: anytype) !T {
   14530: 39 71        	addi	sp, sp, -64
   14532: 06 fc        	sd	ra, 56(sp)
   14534: 22 f8        	sd	s0, 48(sp)
   14536: 26 f4        	sd	s1, 40(sp)
   14538: 4a f0        	sd	s2, 32(sp)
   1453a: 4e ec        	sd	s3, 24(sp)
   1453c: b2 84        	mv	s1, a2
   1453e: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   14542: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14546: 98 60        	ld	a4, 0(s1)
   14548: 2e 89        	mv	s2, a1
   1454a: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   1454c: 28 00        	addi	a0, sp, 8
   1454e: 13 06 71 00  	addi	a2, sp, 7
   14552: 85 46        	li	a3, 1
   14554: ba 85        	mv	a1, a4
   14556: 97 d0 00 00  	auipc	ra, 13
   1455a: e7 80 20 16  	jalr	354(ra)
   1455e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14560: 63 03 05 24  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   14564: 83 45 71 00  	lbu	a1, 7(sp)
   14568: 13 95 85 03  	slli	a0, a1, 56
   1456c: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   1456e: 13 f4 f5 07  	andi	s0, a1, 127
   14572: 9d 45        	li	a1, 7
;         if (byte & 0x80 == 0) {
   14574: 63 54 05 1c  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   14578: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1457c: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14580: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   14582: 28 00        	addi	a0, sp, 8
   14584: 13 06 71 00  	addi	a2, sp, 7
   14588: 85 46        	li	a3, 1
   1458a: 97 d0 00 00  	auipc	ra, 13
   1458e: e7 80 e0 12  	jalr	302(ra)
   14592: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14594: 63 09 05 20  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   14598: 83 45 71 00  	lbu	a1, 7(sp)
   1459c: 13 95 85 03  	slli	a0, a1, 56
   145a0: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   145a2: 93 f5 f5 07  	andi	a1, a1, 127
   145a6: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   145a8: 4d 8c        	or	s0, s0, a1
   145aa: b9 45        	li	a1, 14
;         if (byte & 0x80 == 0) {
   145ac: 63 58 05 18  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   145b0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   145b4: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   145b8: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   145ba: 28 00        	addi	a0, sp, 8
   145bc: 13 06 71 00  	addi	a2, sp, 7
   145c0: 85 46        	li	a3, 1
   145c2: 97 d0 00 00  	auipc	ra, 13
   145c6: e7 80 60 0f  	jalr	246(ra)
   145ca: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   145cc: 63 0d 05 1c  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   145d0: 83 45 71 00  	lbu	a1, 7(sp)
   145d4: 13 95 85 03  	slli	a0, a1, 56
   145d8: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   145da: 93 f5 f5 07  	andi	a1, a1, 127
   145de: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   145e0: 4d 8c        	or	s0, s0, a1
   145e2: d5 45        	li	a1, 21
;         if (byte & 0x80 == 0) {
   145e4: 63 5c 05 14  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   145e8: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   145ec: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   145f0: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   145f2: 28 00        	addi	a0, sp, 8
   145f4: 13 06 71 00  	addi	a2, sp, 7
   145f8: 85 46        	li	a3, 1
   145fa: 97 d0 00 00  	auipc	ra, 13
   145fe: e7 80 e0 0b  	jalr	190(ra)
   14602: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14604: 63 01 05 1a  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   14608: 83 45 71 00  	lbu	a1, 7(sp)
   1460c: 13 95 85 03  	slli	a0, a1, 56
   14610: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   14612: 93 f5 f5 07  	andi	a1, a1, 127
   14616: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   14618: 4d 8c        	or	s0, s0, a1
   1461a: f1 45        	li	a1, 28
;         if (byte & 0x80 == 0) {
   1461c: 63 50 05 12  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   14620: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14624: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14628: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1462a: 28 00        	addi	a0, sp, 8
   1462c: 13 06 71 00  	addi	a2, sp, 7
   14630: 85 46        	li	a3, 1
   14632: 97 d0 00 00  	auipc	ra, 13
   14636: e7 80 60 08  	jalr	134(ra)
   1463a: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1463c: 63 05 05 16  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   14640: 83 45 71 00  	lbu	a1, 7(sp)
   14644: 13 95 85 03  	slli	a0, a1, 56
   14648: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   1464a: 93 f5 f5 07  	andi	a1, a1, 127
   1464e: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   14650: 4d 8c        	or	s0, s0, a1
   14652: 93 05 30 02  	li	a1, 35
;         if (byte & 0x80 == 0) {
   14656: 63 53 05 0e  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   1465a: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1465e: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14662: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   14664: 28 00        	addi	a0, sp, 8
   14666: 13 06 71 00  	addi	a2, sp, 7
   1466a: 85 46        	li	a3, 1
   1466c: 97 d0 00 00  	auipc	ra, 13
   14670: e7 80 c0 04  	jalr	76(ra)
   14674: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14676: 63 08 05 12  	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   1467a: 83 45 71 00  	lbu	a1, 7(sp)
   1467e: 13 95 85 03  	slli	a0, a1, 56
   14682: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   14684: 93 f5 f5 07  	andi	a1, a1, 127
   14688: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   1468a: 4d 8c        	or	s0, s0, a1
   1468c: 93 05 a0 02  	li	a1, 42
;         if (byte & 0x80 == 0) {
   14690: 63 56 05 0a  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   14694: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14698: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1469c: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1469e: 28 00        	addi	a0, sp, 8
   146a0: 13 06 71 00  	addi	a2, sp, 7
   146a4: 85 46        	li	a3, 1
   146a6: 97 d0 00 00  	auipc	ra, 13
   146aa: e7 80 20 01  	jalr	18(ra)
   146ae: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   146b0: 7d c9        	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   146b2: 83 45 71 00  	lbu	a1, 7(sp)
   146b6: 13 95 85 03  	slli	a0, a1, 56
   146ba: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   146bc: 93 f5 f5 07  	andi	a1, a1, 127
   146c0: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   146c2: 4d 8c        	or	s0, s0, a1
   146c4: 93 05 10 03  	li	a1, 49
;         if (byte & 0x80 == 0) {
   146c8: 63 5a 05 06  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   146cc: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   146d0: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   146d4: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   146d6: 28 00        	addi	a0, sp, 8
   146d8: 13 06 71 00  	addi	a2, sp, 7
   146dc: 85 46        	li	a3, 1
   146de: 97 d0 00 00  	auipc	ra, 13
   146e2: e7 80 a0 fd  	jalr	-38(ra)
   146e6: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   146e8: 5d cd        	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   146ea: 83 45 71 00  	lbu	a1, 7(sp)
   146ee: 13 95 85 03  	slli	a0, a1, 56
   146f2: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   146f4: 93 f5 f5 07  	andi	a1, a1, 127
   146f8: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   146fa: 4d 8c        	or	s0, s0, a1
   146fc: 93 05 80 03  	li	a1, 56
;         if (byte & 0x80 == 0) {
   14700: 63 5e 05 02  	bgez	a0, 0x1473c <leb128.readILEB128__anon_5026+0x20c>
   14704: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14708: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1470c: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1470e: 28 00        	addi	a0, sp, 8
   14710: 13 06 71 00  	addi	a2, sp, 7
   14714: 85 46        	li	a3, 1
   14716: 97 d0 00 00  	auipc	ra, 13
   1471a: e7 80 20 fa  	jalr	-94(ra)
   1471e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   14720: 59 c1        	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   14722: 83 45 71 00  	lbu	a1, 7(sp)
   14726: 13 95 85 03  	slli	a0, a1, 56
   1472a: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   1472c: 93 f5 f5 07  	andi	a1, a1, 127
   14730: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   14732: 4d 8c        	or	s0, s0, a1
   14734: 93 05 f0 03  	li	a1, 63
;         if (byte & 0x80 == 0) {
   14738: 63 44 05 02  	bltz	a0, 0x14760 <leb128.readILEB128__anon_5026+0x230>
;             if (byte & 0x40 != 0 and needs_sign_ext) {
   1473c: 13 75 05 04  	andi	a0, a0, 64
   14740: 09 c5        	beqz	a0, 0x1474a <leb128.readILEB128__anon_5026+0x21a>
   14742: 7d 55        	li	a0, -1
;                 value |= @bitCast(U, ones) << (shift + 7);
   14744: 33 15 b5 00  	sll	a0, a0, a1
   14748: 49 8c        	or	s0, s0, a0
;     return @truncate(T, result);
   1474a: 23 b0 89 00  	sd	s0, 0(s3)
   1474e: 23 94 09 00  	sh	zero, 8(s3)
   14752: e2 70        	ld	ra, 56(sp)
   14754: 42 74        	ld	s0, 48(sp)
   14756: a2 74        	ld	s1, 40(sp)
   14758: 02 79        	ld	s2, 32(sp)
   1475a: e2 69        	ld	s3, 24(sp)
   1475c: 21 61        	addi	sp, sp, 64
   1475e: 82 80        	ret
   14760: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   14764: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   14768: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1476a: 28 00        	addi	a0, sp, 8
   1476c: 13 06 71 00  	addi	a2, sp, 7
   14770: 85 46        	li	a3, 1
   14772: 97 d0 00 00  	auipc	ra, 13
   14776: e7 80 60 f4  	jalr	-186(ra)
   1477a: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1477c: 0d c5        	beqz	a0, 0x147a6 <leb128.readILEB128__anon_5026+0x276>
;             return result[0];
   1477e: 03 45 71 00  	lbu	a0, 7(sp)
   14782: 93 15 85 03  	slli	a1, a0, 56
   14786: e1 95        	srai	a1, a1, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   14788: 13 76 e5 07  	andi	a2, a0, 126
   1478c: 7e 15        	slli	a0, a0, 63
;         if (ov[1] != 0) {
   1478e: 1d ca        	beqz	a2, 0x147c4 <leb128.readILEB128__anon_5026+0x294>
;             if (byte & 0x80 != 0) return error.Overflow;
   14790: 63 c4 05 04  	bltz	a1, 0x147d8 <leb128.readILEB128__anon_5026+0x2a8>
;             if (@bitCast(S, ov[0]) >= 0) return error.Overflow;
   14794: 31 c1        	beqz	a0, 0x147d8 <leb128.readILEB128__anon_5026+0x2a8>
   14796: 13 05 e0 07  	li	a0, 126
;             if (remaining_bits != -1) return error.Overflow;
   1479a: 63 1f a6 02  	bne	a2, a0, 0x147d8 <leb128.readILEB128__anon_5026+0x2a8>
   1479e: 7d 55        	li	a0, -1
   147a0: 7e 15        	slli	a0, a0, 63
;         value |= ov[0];
   147a2: 49 8c        	or	s0, s0, a0
   147a4: 5d b7        	j	0x1474a <leb128.readILEB128__anon_5026+0x21a>
;             if (amt_read < 1) return error.EndOfStream;
   147a6: 4a 85        	mv	a0, s2
   147a8: 97 f0 00 00  	auipc	ra, 15
   147ac: e7 80 00 45  	jalr	1104(ra)
;         const byte = try reader.readByte();
   147b0: 4a 85        	mv	a0, s2
   147b2: 97 f0 00 00  	auipc	ra, 15
   147b6: e7 80 60 44  	jalr	1094(ra)
   147ba: 13 05 10 03  	li	a0, 49
   147be: 23 94 a9 00  	sh	a0, 8(s3)
   147c2: 41 bf        	j	0x14752 <leb128.readILEB128__anon_5026+0x222>
   147c4: 13 a6 05 00  	slti	a2, a1, 0
   147c8: 13 46 16 00  	xori	a2, a2, 1
;             if ((byte & 0x80 == 0) and (@bitCast(S, ov[0]) < 0)) {
   147cc: b3 36 a0 00  	snez	a3, a0
   147d0: 75 8e        	and	a2, a2, a3
   147d2: 19 e2        	bnez	a2, 0x147d8 <leb128.readILEB128__anon_5026+0x2a8>
;         if (byte & 0x80 == 0) {
   147d4: e3 da 05 f6  	bgez	a1, 0x14748 <leb128.readILEB128__anon_5026+0x218>
   147d8: 4a 85        	mv	a0, s2
   147da: 97 f0 00 00  	auipc	ra, 15
   147de: e7 80 e0 41  	jalr	1054(ra)
   147e2: 13 05 00 03  	li	a0, 48
   147e6: 23 b4 a9 00  	sd	a0, 8(s3)
   147ea: 23 b0 09 00  	sd	zero, 0(s3)
   147ee: 95 b7        	j	0x14752 <leb128.readILEB128__anon_5026+0x222>

00000000000147f0 <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit>:
;         pub fn deinit(self: Self) void {
   147f0: 79 71        	addi	sp, sp, -48
;                 self.allocator.free(self.allocatedSlice());
   147f2: 06 f4        	sd	ra, 40(sp)
   147f4: 22 f0        	sd	s0, 32(sp)
   147f6: 26 ec        	sd	s1, 24(sp)
   147f8: 4a e8        	sd	s2, 16(sp)
   147fa: 4e e4        	sd	s3, 8(sp)
   147fc: 52 e0        	sd	s4, 0(sp)
   147fe: 03 39 85 01  	ld	s2, 24(a0)
   14802: 0c 69        	ld	a1, 16(a0)
   14804: 03 3a 05 02  	ld	s4, 32(a0)
   14808: 86 89        	mv	s3, ra
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1480a: a9 c1        	beqz	a1, 0x1484c <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit+0x5c>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1480c: 13 94 65 00  	slli	s0, a1, 6
   14810: 13 56 64 00  	srli	a2, s0, 6
   14814: 63 17 b6 04  	bne	a2, a1, 0x14862 <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit+0x72>
   14818: 04 61        	ld	s1, 0(a0)
;     if (bytes_len == 0) return;
   1481a: 05 cc        	beqz	s0, 0x14852 <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit+0x62>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1481c: a9 cc        	beqz	s1, 0x14876 <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit+0x86>
;     @memset(non_const_ptr, undefined, bytes_len);
   1481e: 93 05 a0 0a  	li	a1, 170
   14822: 26 85        	mv	a0, s1
   14824: 22 86        	mv	a2, s0
   14826: 97 00 01 00  	auipc	ra, 16
   1482a: e7 80 40 a7  	jalr	-1420(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1482e: 83 37 0a 01  	ld	a5, 16(s4)
   14832: 8d 46        	li	a3, 3
   14834: 4a 85        	mv	a0, s2
   14836: a6 85        	mv	a1, s1
   14838: 22 86        	mv	a2, s0
   1483a: 4e 87        	mv	a4, s3
   1483c: a2 70        	ld	ra, 40(sp)
   1483e: 02 74        	ld	s0, 32(sp)
   14840: e2 64        	ld	s1, 24(sp)
   14842: 42 69        	ld	s2, 16(sp)
   14844: a2 69        	ld	s3, 8(sp)
   14846: 02 6a        	ld	s4, 0(sp)
   14848: 45 61        	addi	sp, sp, 48
   1484a: 82 87        	jr	a5
   1484c: 01 44        	li	s0, 0
   1484e: a1 44        	li	s1, 8
;     if (bytes_len == 0) return;
   14850: 71 f4        	bnez	s0, 0x1481c <array_list.ArrayListAligned(dwarf.AbbrevTableEntry,null).deinit+0x2c>
;                 self.allocator.free(self.allocatedSlice());
   14852: a2 70        	ld	ra, 40(sp)
   14854: 02 74        	ld	s0, 32(sp)
   14856: e2 64        	ld	s1, 24(sp)
   14858: 42 69        	ld	s2, 16(sp)
   1485a: a2 69        	ld	s3, 8(sp)
   1485c: 02 6a        	ld	s4, 0(sp)
   1485e: 45 61        	addi	sp, sp, 48
   14860: 82 80        	ret
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   14862: 37 15 01 00  	lui	a0, 17
   14866: 13 05 95 5d  	addi	a0, a0, 1497
   1486a: c1 45        	li	a1, 16
   1486c: 81 46        	li	a3, 0
   1486e: 97 f0 00 00  	auipc	ra, 15
   14872: e7 80 c0 b0  	jalr	-1268(ra)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   14876: 37 25 01 00  	lui	a0, 18
   1487a: 13 05 a5 86  	addi	a0, a0, -1942
   1487e: f9 45        	li	a1, 30
   14880: 81 46        	li	a3, 0
   14882: 97 f0 00 00  	auipc	ra, 15
   14886: e7 80 80 af  	jalr	-1288(ra)

000000000001488a <dwarf.DwarfInfo.getAbbrevTable>:
;     fn getAbbrevTable(di: *DwarfInfo, allocator: mem.Allocator, abbrev_offset: u64) !*const AbbrevTable {
   1488a: 13 01 01 d4  	addi	sp, sp, -704
   1488e: 23 3c 11 2a  	sd	ra, 696(sp)
   14892: 23 38 81 2a  	sd	s0, 688(sp)
   14896: 23 34 91 2a  	sd	s1, 680(sp)
   1489a: 23 30 21 2b  	sd	s2, 672(sp)
   1489e: 23 3c 31 29  	sd	s3, 664(sp)
   148a2: 23 38 41 29  	sd	s4, 656(sp)
   148a6: 23 34 51 29  	sd	s5, 648(sp)
   148aa: 23 30 61 29  	sd	s6, 640(sp)
   148ae: 23 3c 71 27  	sd	s7, 632(sp)
   148b2: 23 38 81 27  	sd	s8, 624(sp)
   148b6: 23 34 91 27  	sd	s9, 616(sp)
   148ba: 23 30 a1 27  	sd	s10, 608(sp)
   148be: 23 3c b1 25  	sd	s11, 600(sp)
   148c2: 32 84        	mv	s0, a2
;         for (di.abbrev_table_list.items) |*header| {
   148c4: 70 66        	ld	a2, 200(a2)
   148c6: 86 8c        	mv	s9, ra
   148c8: ba 84        	mv	s1, a4
   148ca: b6 8a        	mv	s5, a3
   148cc: ae 8b        	mv	s7, a1
   148ce: aa 86        	mv	a3, a0
;         for (di.abbrev_table_list.items) |*header| {
   148d0: 19 ca        	beqz	a2, 0x148e6 <dwarf.DwarfInfo.getAbbrevTable+0x5c>
   148d2: 68 60        	ld	a0, 192(s0)
;         for (di.abbrev_table_list.items) |*header| {
   148d4: 21 05        	addi	a0, a0, 8
;             if (header.offset == abbrev_offset) {
   148d6: 83 35 85 ff  	ld	a1, -8(a0)
   148da: e3 88 95 20  	beq	a1, s1, 0x152ea <dwarf.DwarfInfo.getAbbrevTable+0xa60>
;         for (di.abbrev_table_list.items) |*header| {
   148de: 7d 16        	addi	a2, a2, -1
   148e0: 13 05 05 03  	addi	a0, a0, 48
   148e4: 6d fa        	bnez	a2, 0x148d6 <dwarf.DwarfInfo.getAbbrevTable+0x4c>
   148e6: 36 e8        	sd	a3, 16(sp)
;         var stream = io.fixedBufferStream(di.debug_abbrev);
   148e8: 0c 68        	ld	a1, 16(s0)
   148ea: 08 6c        	ld	a0, 24(s0)
   148ec: 2e f1        	sd	a1, 160(sp)
   148ee: 2a f5        	sd	a0, 168(sp)
   148f0: 0c 11        	addi	a1, sp, 160
;         const in = &stream.reader();
   148f2: 2e fd        	sd	a1, 184(sp)
   148f4: 63 63 95 00  	bltu	a0, s1, 0x148fa <dwarf.DwarfInfo.getAbbrevTable+0x70>
   148f8: 26 85        	mv	a0, s1
   148fa: 2a f9        	sd	a0, 176(sp)
;             return Self{
   148fc: 82 e5        	sd	zero, 200(sp)
   148fe: 82 e9        	sd	zero, 208(sp)
   14900: 03 b5 0a 00  	ld	a0, 0(s5)
   14904: aa ed        	sd	a0, 216(sp)
   14906: 03 b5 8a 00  	ld	a0, 8(s5)
   1490a: b7 55 02 00  	lui	a1, 37
   1490e: 83 b5 05 33  	ld	a1, 816(a1)
   14912: aa f1        	sd	a0, 224(sp)
   14914: 2e f4        	sd	a1, 40(sp)
;         var result = AbbrevTable.init(allocator);
   14916: ae e1        	sd	a1, 192(sp)
;             const abbrev_code = try leb.readULEB128(u64, in);
   14918: a8 11        	addi	a0, sp, 232
   1491a: 30 19        	addi	a2, sp, 184
   1491c: de 85        	mv	a1, s7
   1491e: 97 00 00 00  	auipc	ra, 0
   14922: e7 80 80 9d  	jalr	-1576(ra)
   14926: 03 5c 01 0f  	lhu	s8, 240(sp)
   1492a: 63 04 0c 00  	beqz	s8, 0x14932 <dwarf.DwarfInfo.getAbbrevTable+0xa8>
   1492e: 6f 10 40 01  	j	0x15942 <dwarf.DwarfInfo.getAbbrevTable+0x10b8>
   14932: 26 e0        	sd	s1, 0(sp)
   14934: 22 e4        	sd	s0, 8(sp)
   14936: 00 11        	addi	s0, sp, 160
   14938: 55 45        	li	a0, 21
   1493a: 93 15 95 03  	slli	a1, a0, 57
   1493e: 2e f0        	sd	a1, 32(sp)
   14940: 93 15 25 03  	slli	a1, a0, 50
   14944: 2e f8        	sd	a1, 48(sp)
   14946: 93 15 b5 02  	slli	a1, a0, 43
   1494a: ae e0        	sd	a1, 64(sp)
   1494c: 93 15 45 02  	slli	a1, a0, 36
   14950: ae e4        	sd	a1, 72(sp)
   14952: 76 05        	slli	a0, a0, 29
   14954: aa e8        	sd	a0, 80(sp)
   14956: 05 65        	lui	a0, 1
   14958: 1b 05 05 50  	addiw	a0, a0, 1280
   1495c: aa ec        	sd	a0, 88(sp)
   1495e: 37 55 02 00  	lui	a0, 37
   14962: 03 35 85 33  	ld	a0, 824(a0)
   14966: 2a fc        	sd	a0, 56(sp)
   14968: de f0        	sd	s7, 96(sp)
;             const abbrev_code = try leb.readULEB128(u64, in);
   1496a: 56 ec        	sd	s5, 24(sp)
   1496c: 31 a8        	j	0x14988 <dwarf.DwarfInfo.getAbbrevTable+0xfe>
   1496e: a8 11        	addi	a0, sp, 232
   14970: 30 19        	addi	a2, sp, 184
   14972: de 85        	mv	a1, s7
   14974: 97 00 00 00  	auipc	ra, 0
   14978: e7 80 20 98  	jalr	-1662(ra)
   1497c: 03 5c 01 0f  	lhu	s8, 240(sp)
   14980: c6 7c        	ld	s9, 112(sp)
   14982: e2 6a        	ld	s5, 24(sp)
   14984: e3 1c 0c 66  	bnez	s8, 0x157fc <dwarf.DwarfInfo.getAbbrevTable+0xf72>
   14988: 2e 7a        	ld	s4, 232(sp)
;             if (abbrev_code == 0) return result;
   1498a: e3 06 0a 2a  	beqz	s4, 0x15436 <dwarf.DwarfInfo.getAbbrevTable+0xbac>
;                 .tag_id = try leb.readULEB128(u64, in),
   1498e: a8 19        	addi	a0, sp, 248
   14990: 30 19        	addi	a2, sp, 184
   14992: de 85        	mv	a1, s7
   14994: 97 00 00 00  	auipc	ra, 0
   14998: e7 80 20 96  	jalr	-1694(ra)
   1499c: 03 5c 01 10  	lhu	s8, 256(sp)
   149a0: e3 1d 0c 52  	bnez	s8, 0x156da <dwarf.DwarfInfo.getAbbrevTable+0xe50>
   149a4: 6e 7b        	ld	s6, 248(sp)
;             var result: [1]u8 = undefined;
   149a6: 13 05 a0 0a  	li	a0, 170
   149aa: 23 00 a1 14  	sb	a0, 320(sp)
;             return readFn(self.context, buffer);
   149ae: a8 0a        	addi	a0, sp, 344
   149b0: 90 02        	addi	a2, sp, 320
   149b2: 85 46        	li	a3, 1
   149b4: a2 85        	mv	a1, s0
   149b6: 97 d0 00 00  	auipc	ra, 13
   149ba: e7 80 20 d0  	jalr	-766(ra)
   149be: 76 65        	ld	a0, 344(sp)
;             if (amt_read < 1) return error.EndOfStream;
   149c0: e3 07 05 52  	beqz	a0, 0x156ee <dwarf.DwarfInfo.getAbbrevTable+0xe64>
   149c4: e6 f8        	sd	s9, 112(sp)
;             return Self{
   149c6: 02 f2        	sd	zero, 288(sp)
   149c8: 02 f6        	sd	zero, 296(sp)
   149ca: 03 b5 0a 00  	ld	a0, 0(s5)
   149ce: 2a ea        	sd	a0, 272(sp)
;             try self.ensureTotalCapacity(self.items.len + 1);
   149d0: ae 6d        	ld	s11, 200(sp)
;             return Self{
   149d2: 83 b5 8a 00  	ld	a1, 8(s5)
;             return result[0];
   149d6: 03 4d 01 14  	lbu	s10, 320(sp)
;             try self.ensureTotalCapacity(self.items.len + 1);
   149da: 13 85 1d 00  	addi	a0, s11, 1
;             return Self{
   149de: 2e ee        	sd	a1, 280(sp)
;             try self.ensureTotalCapacity(self.items.len + 1);
   149e0: e3 0b 05 0e  	beqz	a0, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             if (self.capacity >= new_capacity) return;
   149e4: ce 6b        	ld	s7, 208(sp)
   149e6: e6 6c        	ld	s9, 88(sp)
   149e8: 61 48        	li	a6, 24
   149ea: 63 f5 ab 16  	bgeu	s7, a0, 0x14b54 <dwarf.DwarfInfo.getAbbrevTable+0x2ca>
   149ee: 5e 84        	mv	s0, s7
   149f0: 19 a0        	j	0x149f6 <dwarf.DwarfInfo.getAbbrevTable+0x16c>
;                 if (better_capacity >= new_capacity) break;
   149f2: 63 7c a4 00  	bgeu	s0, a0, 0x14a0a <dwarf.DwarfInfo.getAbbrevTable+0x180>
   149f6: 22 86        	mv	a2, s0
;                 better_capacity +|= better_capacity / 2 + 8;
   149f8: 93 55 14 00  	srli	a1, s0, 1
   149fc: a2 95        	add	a1, a1, s0
   149fe: a1 05        	addi	a1, a1, 8
   14a00: 7d 54        	li	s0, -1
   14a02: e3 e8 c5 fe  	bltu	a1, a2, 0x149f2 <dwarf.DwarfInfo.getAbbrevTable+0x168>
   14a06: 2e 84        	mv	s0, a1
   14a08: ed b7        	j	0x149f2 <dwarf.DwarfInfo.getAbbrevTable+0x168>
;             if (self.capacity >= new_capacity) return;
   14a0a: 63 f5 8b 14  	bgeu	s7, s0, 0x14b54 <dwarf.DwarfInfo.getAbbrevTable+0x2ca>
;             const old_memory = self.allocatedSlice();
   14a0e: 0e 6c        	ld	s8, 192(sp)
   14a10: a8 0a        	addi	a0, sp, 344
   14a12: aa e6        	sd	a0, 328(sp)
   14a14: 13 05 00 02  	li	a0, 32
   14a18: aa ea        	sd	a0, 336(sp)
   14a1a: 82 e2        	sd	zero, 320(sp)
   14a1c: 93 9c 6b 00  	slli	s9, s7, 6
;     if (old_mem.len == 0) {
   14a20: 63 8d 0b 02  	beqz	s7, 0x14a5a <dwarf.DwarfInfo.getAbbrevTable+0x1d0>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   14a24: 13 d5 6c 00  	srli	a0, s9, 6
   14a28: e3 17 75 0b  	bne	a0, s7, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     const ov = @mulWithOverflow(a, b);
   14a2c: 13 19 64 00  	slli	s2, s0, 6
   14a30: 13 55 69 00  	srli	a0, s2, 6
;     if (ov[1] != 0) return error.Overflow;
   14a34: 63 04 85 00  	beq	a0, s0, 0x14a3c <dwarf.DwarfInfo.getAbbrevTable+0x1b2>
   14a38: 6f 00 70 7a  	j	0x159de <dwarf.DwarfInfo.getAbbrevTable+0x1154>
;     return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());
   14a3c: 8e 7a        	ld	s5, 224(sp)
   14a3e: ee 69        	ld	s3, 216(sp)
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   14a40: 03 b8 8a 00  	ld	a6, 8(s5)
   14a44: 8d 46        	li	a3, 3
   14a46: 4e 85        	mv	a0, s3
   14a48: e2 85        	mv	a1, s8
   14a4a: 66 86        	mv	a2, s9
   14a4c: 4a 87        	mv	a4, s2
   14a4e: c6 77        	ld	a5, 112(sp)
   14a50: 02 98        	jalr	a6
   14a52: 05 89        	andi	a0, a0, 1
;             if (self.allocator.resize(old_memory, new_capacity)) {
   14a54: 09 cd        	beqz	a0, 0x14a6e <dwarf.DwarfInfo.getAbbrevTable+0x1e4>
   14a56: 61 48        	li	a6, 24
   14a58: dd a8        	j	0x14b4e <dwarf.DwarfInfo.getAbbrevTable+0x2c4>
;     const ov = @mulWithOverflow(a, b);
   14a5a: 13 19 64 00  	slli	s2, s0, 6
   14a5e: 13 55 69 00  	srli	a0, s2, 6
;     if (ov[1] != 0) return error.Overflow;
   14a62: 63 04 85 00  	beq	a0, s0, 0x14a6a <dwarf.DwarfInfo.getAbbrevTable+0x1e0>
   14a66: 6f 00 30 78  	j	0x159e8 <dwarf.DwarfInfo.getAbbrevTable+0x115e>
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   14a6a: 8e 7a        	ld	s5, 224(sp)
   14a6c: ee 69        	ld	s3, 216(sp)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   14a6e: 03 b7 0a 00  	ld	a4, 0(s5)
   14a72: 0d 46        	li	a2, 3
   14a74: 4e 85        	mv	a0, s3
   14a76: ca 85        	mv	a1, s2
   14a78: c6 76        	ld	a3, 112(sp)
   14a7a: 02 97        	jalr	a4
   14a7c: 19 e1        	bnez	a0, 0x14a82 <dwarf.DwarfInfo.getAbbrevTable+0x1f8>
   14a7e: 6f 00 d0 75  	j	0x159da <dwarf.DwarfInfo.getAbbrevTable+0x1150>
   14a82: aa 89        	mv	s3, a0
;     @memset(byte_ptr, undefined, byte_count);
   14a84: 93 05 a0 0a  	li	a1, 170
   14a88: 4a 86        	mv	a2, s2
   14a8a: 97 00 01 00  	auipc	ra, 16
   14a8e: e7 80 00 81  	jalr	-2032(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   14a92: 13 f5 79 00  	andi	a0, s3, 7
   14a96: 13 35 15 00  	seqz	a0, a0
   14a9a: 93 35 19 00  	seqz	a1, s2
   14a9e: 4d 8d        	or	a0, a0, a1
   14aa0: 19 e1        	bnez	a0, 0x14aa6 <dwarf.DwarfInfo.getAbbrevTable+0x21c>
   14aa2: 6f 10 60 0a  	j	0x15b48 <dwarf.DwarfInfo.getAbbrevTable+0x12be>
   14aa6: 01 44        	li	s0, 0
   14aa8: a2 7a        	ld	s5, 40(sp)
;     if (bytes.len == 0) {
   14aaa: 63 05 09 00  	beqz	s2, 0x14ab4 <dwarf.DwarfInfo.getAbbrevTable+0x22a>
   14aae: 13 54 69 00  	srli	s0, s2, 6
   14ab2: ce 8a        	mv	s5, s3
;     if (!ok) unreachable; // assertion failure
   14ab4: 63 74 b4 01  	bgeu	s0, s11, 0x14abc <dwarf.DwarfInfo.getAbbrevTable+0x232>
   14ab8: 6f 10 c0 07  	j	0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
   14abc: 6e 85        	mv	a0, s11
   14abe: d6 85        	mv	a1, s5
   14ac0: 62 86        	mv	a2, s8
;     for (source) |s, i|
   14ac2: 63 80 0d 04  	beqz	s11, 0x14b02 <dwarf.DwarfInfo.getAbbrevTable+0x278>
;         dest[i] = s;
   14ac6: 03 38 06 00  	ld	a6, 0(a2)
   14aca: 83 38 86 00  	ld	a7, 8(a2)
   14ace: 83 32 06 01  	ld	t0, 16(a2)
   14ad2: 03 33 86 01  	ld	t1, 24(a2)
   14ad6: 14 7e        	ld	a3, 56(a2)
   14ad8: 18 7a        	ld	a4, 48(a2)
   14ada: 1c 76        	ld	a5, 40(a2)
   14adc: 04 72        	ld	s1, 32(a2)
   14ade: 94 fd        	sd	a3, 56(a1)
   14ae0: 98 f9        	sd	a4, 48(a1)
   14ae2: 9c f5        	sd	a5, 40(a1)
   14ae4: 84 f1        	sd	s1, 32(a1)
   14ae6: 23 bc 65 00  	sd	t1, 24(a1)
   14aea: 23 b8 55 00  	sd	t0, 16(a1)
   14aee: 23 b4 15 01  	sd	a7, 8(a1)
   14af2: 23 b0 05 01  	sd	a6, 0(a1)
;     for (source) |s, i|
   14af6: 13 06 06 04  	addi	a2, a2, 64
   14afa: 7d 15        	addi	a0, a0, -1
   14afc: 93 85 05 04  	addi	a1, a1, 64
   14b00: 79 f1        	bnez	a0, 0x14ac6 <dwarf.DwarfInfo.getAbbrevTable+0x23c>
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   14b02: 63 8a 0b 00  	beqz	s7, 0x14b16 <dwarf.DwarfInfo.getAbbrevTable+0x28c>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   14b06: 13 d5 6c 00  	srli	a0, s9, 6
   14b0a: 61 48        	li	a6, 24
   14b0c: 63 15 75 7d  	bne	a0, s7, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     if (bytes_len == 0) return;
   14b10: 63 98 0c 00  	bnez	s9, 0x14b20 <dwarf.DwarfInfo.getAbbrevTable+0x296>
   14b14: 25 a8        	j	0x14b4c <dwarf.DwarfInfo.getAbbrevTable+0x2c2>
   14b16: 81 4c        	li	s9, 0
   14b18: 21 4c        	li	s8, 8
   14b1a: 61 48        	li	a6, 24
;     if (bytes_len == 0) return;
   14b1c: 63 88 0c 02  	beqz	s9, 0x14b4c <dwarf.DwarfInfo.getAbbrevTable+0x2c2>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   14b20: 63 14 0c 00  	bnez	s8, 0x14b28 <dwarf.DwarfInfo.getAbbrevTable+0x29e>
   14b24: 6f 00 d0 7f  	j	0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   14b28: 93 05 a0 0a  	li	a1, 170
   14b2c: 62 85        	mv	a0, s8
   14b2e: 66 86        	mv	a2, s9
   14b30: 97 f0 00 00  	auipc	ra, 15
   14b34: e7 80 a0 76  	jalr	1898(ra)
;     self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());
   14b38: 8e 75        	ld	a1, 224(sp)
   14b3a: 6e 65        	ld	a0, 216(sp)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   14b3c: 9c 69        	ld	a5, 16(a1)
   14b3e: 8d 46        	li	a3, 3
   14b40: e2 85        	mv	a1, s8
   14b42: 66 86        	mv	a2, s9
   14b44: 46 77        	ld	a4, 112(sp)
   14b46: 82 97        	jalr	a5
;             assert(self.items.len < self.capacity);
   14b48: ae 6d        	ld	s11, 200(sp)
   14b4a: 61 48        	li	a6, 24
;                 self.items.ptr = new_memory.ptr;
   14b4c: d6 e1        	sd	s5, 192(sp)
   14b4e: a2 e9        	sd	s0, 208(sp)
   14b50: a2 8b        	mv	s7, s0
   14b52: e6 6c        	ld	s9, 88(sp)
;     if (!ok) unreachable; // assertion failure
   14b54: 63 e4 7d 01  	bltu	s11, s7, 0x14b5c <dwarf.DwarfInfo.getAbbrevTable+0x2d2>
   14b58: 6f 00 d0 7d  	j	0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
;             self.items.len += 1;
   14b5c: 13 85 1d 00  	addi	a0, s11, 1
   14b60: aa e5        	sd	a0, 200(sp)
;             return &self.items[self.items.len - 1];
   14b62: 0e 65        	ld	a0, 192(sp)
   14b64: 93 95 6d 00  	slli	a1, s11, 6
   14b68: 2e 95        	add	a0, a0, a1
;             new_item_ptr.* = item;
   14b6a: 23 30 45 01  	sd	s4, 0(a0)
   14b6e: 23 34 65 01  	sd	s6, 8(a0)
   14b72: a2 75        	ld	a1, 40(sp)
   14b74: 0c e9        	sd	a1, 16(a0)
   14b76: 92 75        	ld	a1, 288(sp)
   14b78: 0c ed        	sd	a1, 24(a0)
   14b7a: b2 75        	ld	a1, 296(sp)
   14b7c: 0c f1        	sd	a1, 32(a0)
   14b7e: d2 65        	ld	a1, 272(sp)
   14b80: 0c f5        	sd	a1, 40(a0)
   14b82: f2 65        	ld	a1, 280(sp)
;                 .has_children = (try in.readByte()) == CHILDREN.yes,
   14b84: 13 06 fd ff  	addi	a2, s10, -1
   14b88: 13 36 16 00  	seqz	a2, a2
;             new_item_ptr.* = item;
   14b8c: 0c f9        	sd	a1, 48(a0)
   14b8e: 23 0c c5 02  	sb	a2, 56(a0)
   14b92: 83 05 f1 10  	lb	a1, 271(sp)
   14b96: a3 0f b5 02  	sb	a1, 63(a0)
   14b9a: 83 05 e1 10  	lb	a1, 270(sp)
   14b9e: 23 0f b5 02  	sb	a1, 62(a0)
   14ba2: 83 05 d1 10  	lb	a1, 269(sp)
   14ba6: a3 0e b5 02  	sb	a1, 61(a0)
   14baa: 83 05 c1 10  	lb	a1, 268(sp)
   14bae: 23 0e b5 02  	sb	a1, 60(a0)
   14bb2: 83 05 b1 10  	lb	a1, 267(sp)
   14bb6: a3 0d b5 02  	sb	a1, 59(a0)
   14bba: 83 05 a1 10  	lb	a1, 266(sp)
   14bbe: 23 0d b5 02  	sb	a1, 58(a0)
   14bc2: 83 05 91 10  	lb	a1, 265(sp)
   14bc6: a3 0c b5 02  	sb	a1, 57(a0)
   14bca: 6a 74        	ld	s0, 184(sp)
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14bcc: 0c 64        	ld	a1, 8(s0)
   14bce: 1c 68        	ld	a5, 16(s0)
   14bd0: 33 87 f5 40  	sub	a4, a1, a5
   14bd4: 86 7b        	ld	s7, 96(sp)
   14bd6: 63 e0 e5 70  	bltu	a1, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14bda: 93 0d 05 01  	addi	s11, a0, 16
   14bde: 13 06 85 02  	addi	a2, a0, 40
   14be2: b2 f4        	sd	a2, 104(sp)
   14be4: 13 0a 05 02  	addi	s4, a0, 32
   14be8: 13 05 04 01  	addi	a0, s0, 16
   14bec: 33 36 e0 00  	snez	a2, a4
;             const end = self.pos + size;
   14bf0: b3 86 c7 00  	add	a3, a5, a2
   14bf4: 63 e1 f6 6e  	bltu	a3, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14bf8: e3 ea d5 70  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14bfc: 10 60        	ld	a2, 0(s0)
   14bfe: 63 97 f6 00  	bne	a3, a5, 0x14c0c <dwarf.DwarfInfo.getAbbrevTable+0x382>
;             self.pos = end;
   14c02: 1c e1        	sd	a5, 0(a0)
   14c04: 13 0b a0 02  	li	s6, 42
;             if (amt_read < 1) return error.EndOfStream;
   14c08: 01 ef        	bnez	a4, 0x14c20 <dwarf.DwarfInfo.getAbbrevTable+0x396>
   14c0a: dd a5        	j	0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14c0c: b2 97        	add	a5, a5, a2
;     for (source) |s, i|
   14c0e: 83 87 07 00  	lb	a5, 0(a5)
;             self.pos = end;
   14c12: 14 e1        	sd	a3, 0(a0)
   14c14: 63 0e 07 6c  	beqz	a4, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14c18: 13 fb f7 07  	andi	s6, a5, 127
   14c1c: 63 db 07 1c  	bgez	a5, 0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14c20: b3 87 d5 40  	sub	a5, a1, a3
   14c24: 63 e9 f5 6a  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14c28: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14c2c: 36 97        	add	a4, a4, a3
   14c2e: 63 64 d7 6a  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14c32: e3 ed e5 6c  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   14c36: 63 18 d7 00  	bne	a4, a3, 0x14c46 <dwarf.DwarfInfo.getAbbrevTable+0x3bc>
;             self.pos = end;
   14c3a: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14c3c: 63 8a 07 6a  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14c40: 33 6b 9b 01  	or	s6, s6, s9
   14c44: 31 a8        	j	0x14c60 <dwarf.DwarfInfo.getAbbrevTable+0x3d6>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14c46: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14c48: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14c4c: 18 e1        	sd	a4, 0(a0)
   14c4e: 63 81 07 6a  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14c52: 93 f7 f6 07  	andi	a5, a3, 127
   14c56: 9e 07        	slli	a5, a5, 7
;         value |= ov[0];
   14c58: 33 eb 67 01  	or	s6, a5, s6
   14c5c: 63 da 06 18  	bgez	a3, 0x14df0 <dwarf.DwarfInfo.getAbbrevTable+0x566>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14c60: b3 87 e5 40  	sub	a5, a1, a4
   14c64: 63 e9 f5 66  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14c68: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14c6c: ba 96        	add	a3, a3, a4
   14c6e: 63 e4 e6 66  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14c72: e3 ed d5 68  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   14c76: 63 9a e6 00  	bne	a3, a4, 0x14c8a <dwarf.DwarfInfo.getAbbrevTable+0x400>
;             self.pos = end;
   14c7a: 18 e1        	sd	a4, 0(a0)
   14c7c: 63 8a 07 66  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14c80: 37 87 0a 00  	lui	a4, 168
   14c84: 33 6b eb 00  	or	s6, s6, a4
   14c88: 31 a8        	j	0x14ca4 <dwarf.DwarfInfo.getAbbrevTable+0x41a>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14c8a: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14c8c: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14c90: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14c92: 63 8f 07 64  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14c96: 93 77 f7 07  	andi	a5, a4, 127
   14c9a: ba 07        	slli	a5, a5, 14
;         value |= ov[0];
   14c9c: 33 eb 67 01  	or	s6, a5, s6
   14ca0: 63 59 07 14  	bgez	a4, 0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14ca4: b3 87 d5 40  	sub	a5, a1, a3
   14ca8: 63 e7 f5 62  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14cac: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14cb0: 36 97        	add	a4, a4, a3
   14cb2: 63 62 d7 62  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14cb6: e3 eb e5 64  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14cba: 63 1a d7 00  	bne	a4, a3, 0x14cce <dwarf.DwarfInfo.getAbbrevTable+0x444>
;             self.pos = end;
   14cbe: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14cc0: 63 88 07 62  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14cc4: b7 06 40 05  	lui	a3, 21504
   14cc8: 33 6b db 00  	or	s6, s6, a3
   14ccc: 31 a8        	j	0x14ce8 <dwarf.DwarfInfo.getAbbrevTable+0x45e>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14cce: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14cd0: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14cd4: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14cd6: 63 8d 07 60  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14cda: 93 f7 f6 07  	andi	a5, a3, 127
   14cde: d6 07        	slli	a5, a5, 21
;         value |= ov[0];
   14ce0: 33 eb 67 01  	or	s6, a5, s6
   14ce4: 63 d6 06 10  	bgez	a3, 0x14df0 <dwarf.DwarfInfo.getAbbrevTable+0x566>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14ce8: b3 87 e5 40  	sub	a5, a1, a4
   14cec: 63 e5 f5 5e  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14cf0: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14cf4: ba 96        	add	a3, a3, a4
   14cf6: 63 e0 e6 5e  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14cfa: e3 e9 d5 60  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14cfe: 63 99 e6 00  	bne	a3, a4, 0x14d10 <dwarf.DwarfInfo.getAbbrevTable+0x486>
;             self.pos = end;
   14d02: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d04: 63 86 07 5e  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14d08: 46 67        	ld	a4, 80(sp)
   14d0a: 33 6b eb 00  	or	s6, s6, a4
   14d0e: 31 a8        	j	0x14d2a <dwarf.DwarfInfo.getAbbrevTable+0x4a0>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14d10: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14d12: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14d16: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d18: 63 8c 07 5c  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14d1c: 93 77 f7 07  	andi	a5, a4, 127
   14d20: f2 07        	slli	a5, a5, 28
;         value |= ov[0];
   14d22: 33 eb 67 01  	or	s6, a5, s6
   14d26: 63 56 07 0c  	bgez	a4, 0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14d2a: b3 87 d5 40  	sub	a5, a1, a3
   14d2e: 63 e4 f5 5a  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14d32: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14d36: 36 97        	add	a4, a4, a3
   14d38: 63 6f d7 58  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14d3c: e3 e8 e5 5c  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14d40: 63 19 d7 00  	bne	a4, a3, 0x14d52 <dwarf.DwarfInfo.getAbbrevTable+0x4c8>
;             self.pos = end;
   14d44: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d46: 63 85 07 5a  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14d4a: a6 66        	ld	a3, 72(sp)
   14d4c: 33 6b db 00  	or	s6, s6, a3
   14d50: 31 a8        	j	0x14d6c <dwarf.DwarfInfo.getAbbrevTable+0x4e2>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14d52: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14d54: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14d58: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d5a: 63 8b 07 58  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14d5e: 93 f7 f6 07  	andi	a5, a3, 127
   14d62: 8e 17        	slli	a5, a5, 35
;         value |= ov[0];
   14d64: 33 eb 67 01  	or	s6, a5, s6
   14d68: 63 d4 06 08  	bgez	a3, 0x14df0 <dwarf.DwarfInfo.getAbbrevTable+0x566>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14d6c: b3 87 e5 40  	sub	a5, a1, a4
   14d70: 63 e3 f5 56  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14d74: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14d78: ba 96        	add	a3, a3, a4
   14d7a: 63 ee e6 54  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14d7e: e3 e7 d5 58  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14d82: 63 99 e6 00  	bne	a3, a4, 0x14d94 <dwarf.DwarfInfo.getAbbrevTable+0x50a>
;             self.pos = end;
   14d86: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d88: 63 84 07 56  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14d8c: 06 67        	ld	a4, 64(sp)
   14d8e: 33 6b eb 00  	or	s6, s6, a4
   14d92: 31 a8        	j	0x14dae <dwarf.DwarfInfo.getAbbrevTable+0x524>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14d94: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14d96: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14d9a: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14d9c: 63 8a 07 54  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14da0: 93 77 f7 07  	andi	a5, a4, 127
   14da4: aa 17        	slli	a5, a5, 42
;         value |= ov[0];
   14da6: 33 eb 67 01  	or	s6, a5, s6
   14daa: 63 54 07 04  	bgez	a4, 0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14dae: b3 87 d5 40  	sub	a5, a1, a3
   14db2: 63 e2 f5 52  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14db6: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14dba: 36 97        	add	a4, a4, a3
   14dbc: 63 6d d7 50  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14dc0: e3 e6 e5 54  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14dc4: 63 19 d7 00  	bne	a4, a3, 0x14dd6 <dwarf.DwarfInfo.getAbbrevTable+0x54c>
;             self.pos = end;
   14dc8: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14dca: 63 83 07 52  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   14dce: c2 76        	ld	a3, 48(sp)
   14dd0: 33 6b db 00  	or	s6, s6, a3
   14dd4: 31 a4        	j	0x14fe0 <dwarf.DwarfInfo.getAbbrevTable+0x756>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14dd6: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14dd8: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14ddc: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14dde: 63 89 07 50  	beqz	a5, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14de2: 93 f7 f6 07  	andi	a5, a3, 127
   14de6: c6 17        	slli	a5, a5, 49
;         value |= ov[0];
   14de8: 33 eb 67 01  	or	s6, a5, s6
   14dec: 63 ca 06 1e  	bltz	a3, 0x14fe0 <dwarf.DwarfInfo.getAbbrevTable+0x756>
   14df0: ba 86        	mv	a3, a4
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14df2: b3 87 d5 40  	sub	a5, a1, a3
   14df6: 63 e0 f5 4e  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14dfa: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14dfe: 36 97        	add	a4, a4, a3
   14e00: 63 6b d7 4c  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14e04: e3 e4 e5 50  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   14e08: 63 17 d7 00  	bne	a4, a3, 0x14e16 <dwarf.DwarfInfo.getAbbrevTable+0x58c>
;             self.pos = end;
   14e0c: 14 e1        	sd	a3, 0(a0)
   14e0e: 13 0d a0 02  	li	s10, 42
;             if (amt_read < 1) return error.EndOfStream;
   14e12: 81 ef        	bnez	a5, 0x14e2a <dwarf.DwarfInfo.getAbbrevTable+0x5a0>
   14e14: 01 ab        	j	0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14e16: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14e18: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14e1c: 18 e1        	sd	a4, 0(a0)
   14e1e: 63 83 07 50  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14e22: 13 fd f6 07  	andi	s10, a3, 127
   14e26: 63 d8 06 2e  	bgez	a3, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14e2a: b3 87 e5 40  	sub	a5, a1, a4
   14e2e: 63 e4 f5 4a  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14e32: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14e36: ba 96        	add	a3, a3, a4
   14e38: 63 ef e6 48  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14e3c: e3 e8 d5 4c  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   14e40: 63 98 e6 00  	bne	a3, a4, 0x14e50 <dwarf.DwarfInfo.getAbbrevTable+0x5c6>
;             self.pos = end;
   14e44: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14e46: 63 8f 07 4c  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14e4a: 33 6d 9d 01  	or	s10, s10, s9
   14e4e: 31 a8        	j	0x14e6a <dwarf.DwarfInfo.getAbbrevTable+0x5e0>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14e50: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14e52: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14e56: 14 e1        	sd	a3, 0(a0)
   14e58: 63 86 07 4c  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14e5c: 93 77 f7 07  	andi	a5, a4, 127
   14e60: 9e 07        	slli	a5, a5, 7
;         value |= ov[0];
   14e62: 33 ed a7 01  	or	s10, a5, s10
   14e66: 63 58 07 2a  	bgez	a4, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14e6a: b3 87 d5 40  	sub	a5, a1, a3
   14e6e: 63 e4 f5 46  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14e72: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14e76: 36 97        	add	a4, a4, a3
   14e78: 63 6f d7 44  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14e7c: e3 e8 e5 48  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14e80: 63 1a d7 00  	bne	a4, a3, 0x14e94 <dwarf.DwarfInfo.getAbbrevTable+0x60a>
;             self.pos = end;
   14e84: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14e86: 63 8f 07 48  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14e8a: b7 86 0a 00  	lui	a3, 168
   14e8e: 33 6d dd 00  	or	s10, s10, a3
   14e92: 31 a8        	j	0x14eae <dwarf.DwarfInfo.getAbbrevTable+0x624>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14e94: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14e96: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14e9a: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14e9c: 63 84 07 48  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14ea0: 93 f7 f6 07  	andi	a5, a3, 127
   14ea4: ba 07        	slli	a5, a5, 14
;         value |= ov[0];
   14ea6: 33 ed a7 01  	or	s10, a5, s10
   14eaa: 63 d6 06 26  	bgez	a3, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14eae: b3 87 e5 40  	sub	a5, a1, a4
   14eb2: 63 e2 f5 42  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14eb6: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14eba: ba 96        	add	a3, a3, a4
   14ebc: 63 ed e6 40  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14ec0: e3 e6 d5 44  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14ec4: 63 9a e6 00  	bne	a3, a4, 0x14ed8 <dwarf.DwarfInfo.getAbbrevTable+0x64e>
;             self.pos = end;
   14ec8: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14eca: 63 8d 07 44  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14ece: 37 07 40 05  	lui	a4, 21504
   14ed2: 33 6d ed 00  	or	s10, s10, a4
   14ed6: 31 a8        	j	0x14ef2 <dwarf.DwarfInfo.getAbbrevTable+0x668>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14ed8: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14eda: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14ede: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14ee0: 63 82 07 44  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14ee4: 93 77 f7 07  	andi	a5, a4, 127
   14ee8: d6 07        	slli	a5, a5, 21
;         value |= ov[0];
   14eea: 33 ed a7 01  	or	s10, a5, s10
   14eee: 63 54 07 22  	bgez	a4, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14ef2: b3 87 d5 40  	sub	a5, a1, a3
   14ef6: 63 e0 f5 3e  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14efa: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14efe: 36 97        	add	a4, a4, a3
   14f00: 63 6b d7 3c  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f04: e3 e4 e5 40  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14f08: 63 19 d7 00  	bne	a4, a3, 0x14f1a <dwarf.DwarfInfo.getAbbrevTable+0x690>
;             self.pos = end;
   14f0c: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14f0e: 63 8b 07 40  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14f12: c6 66        	ld	a3, 80(sp)
   14f14: 33 6d dd 00  	or	s10, s10, a3
   14f18: 31 a8        	j	0x14f34 <dwarf.DwarfInfo.getAbbrevTable+0x6aa>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f1a: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14f1c: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14f20: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14f22: 63 81 07 40  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14f26: 93 f7 f6 07  	andi	a5, a3, 127
   14f2a: f2 07        	slli	a5, a5, 28
;         value |= ov[0];
   14f2c: 33 ed a7 01  	or	s10, a5, s10
   14f30: 63 d3 06 1e  	bgez	a3, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14f34: b3 87 e5 40  	sub	a5, a1, a4
   14f38: 63 ef f5 38  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14f3c: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14f40: ba 96        	add	a3, a3, a4
   14f42: 63 ea e6 38  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f46: e3 e3 d5 3c  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14f4a: 63 99 e6 00  	bne	a3, a4, 0x14f5c <dwarf.DwarfInfo.getAbbrevTable+0x6d2>
;             self.pos = end;
   14f4e: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14f50: 63 8a 07 3c  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14f54: 26 67        	ld	a4, 72(sp)
   14f56: 33 6d ed 00  	or	s10, s10, a4
   14f5a: 31 a8        	j	0x14f76 <dwarf.DwarfInfo.getAbbrevTable+0x6ec>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f5c: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   14f5e: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   14f62: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14f64: 63 80 07 3c  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14f68: 93 77 f7 07  	andi	a5, a4, 127
   14f6c: 8e 17        	slli	a5, a5, 35
;         value |= ov[0];
   14f6e: 33 ed a7 01  	or	s10, a5, s10
   14f72: 63 52 07 1a  	bgez	a4, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14f76: b3 87 d5 40  	sub	a5, a1, a3
   14f7a: 63 ee f5 34  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14f7e: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   14f82: 36 97        	add	a4, a4, a3
   14f84: 63 69 d7 34  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f88: e3 e2 e5 38  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14f8c: 63 19 d7 00  	bne	a4, a3, 0x14f9e <dwarf.DwarfInfo.getAbbrevTable+0x714>
;             self.pos = end;
   14f90: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14f92: 63 89 07 38  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14f96: 86 66        	ld	a3, 64(sp)
   14f98: 33 6d dd 00  	or	s10, s10, a3
   14f9c: 31 a8        	j	0x14fb8 <dwarf.DwarfInfo.getAbbrevTable+0x72e>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14f9e: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   14fa0: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   14fa4: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14fa6: 63 8f 07 36  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   14faa: 93 f7 f6 07  	andi	a5, a3, 127
   14fae: aa 17        	slli	a5, a5, 42
;         value |= ov[0];
   14fb0: 33 ed a7 01  	or	s10, a5, s10
   14fb4: 63 d1 06 16  	bgez	a3, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14fb8: b3 87 e5 40  	sub	a5, a1, a4
   14fbc: 63 ed f5 30  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14fc0: b3 36 f0 00  	snez	a3, a5
;             const end = self.pos + size;
   14fc4: ba 96        	add	a3, a3, a4
   14fc6: 63 e8 e6 30  	bltu	a3, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14fca: e3 e1 d5 34  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14fce: 63 9d e6 02  	bne	a3, a4, 0x15008 <dwarf.DwarfInfo.getAbbrevTable+0x77e>
;             self.pos = end;
   14fd2: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14fd4: 63 88 07 34  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   14fd8: 42 77        	ld	a4, 48(sp)
   14fda: 33 6d ed 00  	or	s10, s10, a4
   14fde: 91 a0        	j	0x15022 <dwarf.DwarfInfo.getAbbrevTable+0x798>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   14fe0: b3 86 e5 40  	sub	a3, a1, a4
   14fe4: 63 e9 d5 2e  	bltu	a1, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   14fe8: b3 37 d0 00  	snez	a5, a3
;             const end = self.pos + size;
   14fec: ba 97        	add	a5, a5, a4
   14fee: 63 e4 e7 2e  	bltu	a5, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   14ff2: e3 ed f5 30  	bltu	a1, a5, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   14ff6: 63 9a e7 04  	bne	a5, a4, 0x1504a <dwarf.DwarfInfo.getAbbrevTable+0x7c0>
;             self.pos = end;
   14ffa: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   14ffc: 63 8a 06 2e  	beqz	a3, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         value |= ov[0];
   15000: 82 76        	ld	a3, 32(sp)
   15002: 33 6b db 00  	or	s6, s6, a3
   15006: 8d a0        	j	0x15068 <dwarf.DwarfInfo.getAbbrevTable+0x7de>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   15008: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   1500a: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   1500e: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   15010: 63 8a 07 30  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15014: 93 77 f7 07  	andi	a5, a4, 127
   15018: c6 17        	slli	a5, a5, 49
;         value |= ov[0];
   1501a: 33 ed a7 01  	or	s10, a5, s10
   1501e: 63 5c 07 0e  	bgez	a4, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   15022: b3 87 d5 40  	sub	a5, a1, a3
   15026: 63 e8 f5 2a  	bltu	a1, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1502a: 33 37 f0 00  	snez	a4, a5
;             const end = self.pos + size;
   1502e: 36 97        	add	a4, a4, a3
   15030: 63 63 d7 2a  	bltu	a4, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   15034: e3 ec e5 2c  	bltu	a1, a4, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
;     for (source) |s, i|
   15038: 63 1d d7 06  	bne	a4, a3, 0x150b2 <dwarf.DwarfInfo.getAbbrevTable+0x828>
;             self.pos = end;
   1503c: 14 e1        	sd	a3, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1503e: 63 83 07 2e  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         value |= ov[0];
   15042: 82 76        	ld	a3, 32(sp)
   15044: 33 6d dd 00  	or	s10, s10, a3
   15048: 51 a0        	j	0x150cc <dwarf.DwarfInfo.getAbbrevTable+0x842>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   1504a: 32 97        	add	a4, a4, a2
;     for (source) |s, i|
   1504c: 03 07 07 00  	lb	a4, 0(a4)
;             self.pos = end;
   15050: 1c e1        	sd	a5, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   15052: 63 8f 06 28  	beqz	a3, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15056: 93 76 f7 07  	andi	a3, a4, 127
   1505a: e2 16        	slli	a3, a3, 56
;         value |= ov[0];
   1505c: 33 eb 66 01  	or	s6, a3, s6
   15060: 63 44 07 00  	bltz	a4, 0x15068 <dwarf.DwarfInfo.getAbbrevTable+0x7de>
   15064: be 86        	mv	a3, a5
   15066: 71 b3        	j	0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   15068: 33 87 f5 40  	sub	a4, a1, a5
   1506c: 63 e5 e5 26  	bltu	a1, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15070: b3 36 e0 00  	snez	a3, a4
;             const end = self.pos + size;
   15074: be 96        	add	a3, a3, a5
   15076: 63 e0 f6 26  	bltu	a3, a5, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1507a: e3 e9 d5 28  	bltu	a1, a3, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   1507e: 93 04 a0 0a  	li	s1, 170
   15082: 63 85 f6 00  	beq	a3, a5, 0x1508c <dwarf.DwarfInfo.getAbbrevTable+0x802>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   15086: b2 97        	add	a5, a5, a2
;     for (source) |s, i|
   15088: 83 c4 07 00  	lbu	s1, 0(a5)
;             self.pos = end;
   1508c: 14 e1        	sd	a3, 0(a0)
   1508e: 63 01 07 26  	beqz	a4, 0x152f0 <dwarf.DwarfInfo.getAbbrevTable+0xa66>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15092: 13 f7 e4 07  	andi	a4, s1, 126
   15096: 13 0c 00 03  	li	s8, 48
   1509a: 63 12 07 26  	bnez	a4, 0x152fe <dwarf.DwarfInfo.getAbbrevTable+0xa74>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1509e: 13 97 84 03  	slli	a4, s1, 56
   150a2: 61 97        	srai	a4, a4, 56
   150a4: 63 4d 07 24  	bltz	a4, 0x152fe <dwarf.DwarfInfo.getAbbrevTable+0xa74>
   150a8: 13 97 f4 03  	slli	a4, s1, 63
   150ac: 33 6b 67 01  	or	s6, a4, s6
   150b0: 89 b3        	j	0x14df2 <dwarf.DwarfInfo.getAbbrevTable+0x568>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   150b2: b2 96        	add	a3, a3, a2
;     for (source) |s, i|
   150b4: 83 86 06 00  	lb	a3, 0(a3)
;             self.pos = end;
   150b8: 18 e1        	sd	a4, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   150ba: 63 85 07 26  	beqz	a5, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   150be: 93 f7 f6 07  	andi	a5, a3, 127
   150c2: e2 17        	slli	a5, a5, 56
;         value |= ov[0];
   150c4: 33 ed a7 01  	or	s10, a5, s10
   150c8: 63 d7 06 04  	bgez	a3, 0x15116 <dwarf.DwarfInfo.getAbbrevTable+0x88c>
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   150cc: b3 86 e5 40  	sub	a3, a1, a4
   150d0: 63 e3 d5 20  	bltu	a1, a3, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   150d4: b3 37 d0 00  	snez	a5, a3
;             const end = self.pos + size;
   150d8: ba 97        	add	a5, a5, a4
   150da: 63 ee e7 1e  	bltu	a5, a4, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   150de: e3 e7 f5 22  	bltu	a1, a5, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   150e2: 93 05 a0 0a  	li	a1, 170
;     for (source) |s, i|
   150e6: 63 86 e7 00  	beq	a5, a4, 0x150f2 <dwarf.DwarfInfo.getAbbrevTable+0x868>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   150ea: b3 05 e6 00  	add	a1, a2, a4
;     for (source) |s, i|
   150ee: 83 c5 05 00  	lbu	a1, 0(a1)
;             self.pos = end;
   150f2: 1c e1        	sd	a5, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   150f4: 63 88 06 22  	beqz	a3, 0x15324 <dwarf.DwarfInfo.getAbbrevTable+0xa9a>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   150f8: 13 f5 e5 07  	andi	a0, a1, 126
   150fc: 13 0c 00 03  	li	s8, 48
;         if (ov[1] != 0) return error.Overflow;
   15100: 63 19 05 22  	bnez	a0, 0x15332 <dwarf.DwarfInfo.getAbbrevTable+0xaa8>
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15104: 13 95 85 03  	slli	a0, a1, 56
   15108: 61 95        	srai	a0, a0, 56
;         if (byte & 0x80 == 0) break;
   1510a: 63 44 05 22  	bltz	a0, 0x15332 <dwarf.DwarfInfo.getAbbrevTable+0xaa8>
   1510e: 13 95 f5 03  	slli	a0, a1, 63
   15112: 33 6d a5 01  	or	s10, a0, s10
;                 if (attr_id == 0 and form_id == 0) break;
   15116: 33 65 ab 01  	or	a0, s6, s10
   1511a: e3 0a 05 84  	beqz	a0, 0x1496e <dwarf.DwarfInfo.getAbbrevTable+0xe4>
;                 const payload = if (form_id == FORM.implicit_const) try leb.readILEB128(i64, in) else undefined;
   1511e: 13 05 10 02  	li	a0, 33
   15122: 63 1f ad 00  	bne	s10, a0, 0x15140 <dwarf.DwarfInfo.getAbbrevTable+0x8b6>
   15126: 08 1a        	addi	a0, sp, 304
   15128: 30 19        	addi	a2, sp, 184
   1512a: de 85        	mv	a1, s7
   1512c: 97 f0 ff ff  	auipc	ra, 1048575
   15130: e7 80 40 40  	jalr	1028(ra)
   15134: 03 5c 81 13  	lhu	s8, 312(sp)
   15138: 63 11 0c 34  	bnez	s8, 0x1547a <dwarf.DwarfInfo.getAbbrevTable+0xbf0>
   1513c: d2 79        	ld	s3, 304(sp)
   1513e: 61 48        	li	a6, 24
;             try self.ensureTotalCapacity(self.items.len + 1);
   15140: 03 b5 8d 00  	ld	a0, 8(s11)
   15144: 93 05 15 00  	addi	a1, a0, 1
   15148: 63 87 05 18  	beqz	a1, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             if (self.capacity >= new_capacity) return;
   1514c: 03 39 0a 00  	ld	s2, 0(s4)
   15150: 63 79 b9 14  	bgeu	s2, a1, 0x152a2 <dwarf.DwarfInfo.getAbbrevTable+0xa18>
   15154: ca 8a        	mv	s5, s2
   15156: 19 a0        	j	0x1515c <dwarf.DwarfInfo.getAbbrevTable+0x8d2>
;                 if (better_capacity >= new_capacity) break;
   15158: 63 fc ba 00  	bgeu	s5, a1, 0x15170 <dwarf.DwarfInfo.getAbbrevTable+0x8e6>
   1515c: d6 86        	mv	a3, s5
;                 better_capacity +|= better_capacity / 2 + 8;
   1515e: 13 d6 1a 00  	srli	a2, s5, 1
   15162: 56 96        	add	a2, a2, s5
   15164: 21 06        	addi	a2, a2, 8
   15166: fd 5a        	li	s5, -1
   15168: e3 68 d6 fe  	bltu	a2, a3, 0x15158 <dwarf.DwarfInfo.getAbbrevTable+0x8ce>
   1516c: b2 8a        	mv	s5, a2
   1516e: ed b7        	j	0x15158 <dwarf.DwarfInfo.getAbbrevTable+0x8ce>
;             if (self.capacity >= new_capacity) return;
   15170: 63 79 59 13  	bgeu	s2, s5, 0x152a2 <dwarf.DwarfInfo.getAbbrevTable+0xa18>
;             const old_memory = self.allocatedSlice();
   15174: 03 bc 0d 00  	ld	s8, 0(s11)
   15178: a8 0a        	addi	a0, sp, 344
   1517a: aa e6        	sd	a0, 328(sp)
   1517c: 13 05 00 02  	li	a0, 32
   15180: aa ea        	sd	a0, 336(sp)
   15182: 82 e2        	sd	zero, 320(sp)
   15184: b3 0c 09 03  	mul	s9, s2, a6
   15188: b3 3b 09 03  	mulhu	s7, s2, a6
;     if (old_mem.len == 0) {
   1518c: 63 08 09 02  	beqz	s2, 0x151bc <dwarf.DwarfInfo.getAbbrevTable+0x932>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15190: 63 93 0b 14  	bnez	s7, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     const ov = @mulWithOverflow(a, b);
   15194: 33 b5 0a 03  	mulhu	a0, s5, a6
;     if (ov[1] != 0) return error.Overflow;
   15198: 63 1e 05 3c  	bnez	a0, 0x15574 <dwarf.DwarfInfo.getAbbrevTable+0xcea>
   1519c: 26 75        	ld	a0, 104(sp)
;     return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());
   1519e: 0c 65        	ld	a1, 8(a0)
   151a0: 08 61        	ld	a0, 0(a0)
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   151a2: 80 65        	ld	s0, 8(a1)
   151a4: b3 84 0a 03  	mul	s1, s5, a6
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   151a8: 8d 46        	li	a3, 3
   151aa: e2 85        	mv	a1, s8
   151ac: 66 86        	mv	a2, s9
   151ae: 26 87        	mv	a4, s1
   151b0: c6 77        	ld	a5, 112(sp)
   151b2: 02 94        	jalr	s0
   151b4: 61 48        	li	a6, 24
   151b6: 05 89        	andi	a0, a0, 1
;             if (self.allocator.resize(old_memory, new_capacity)) {
   151b8: 01 c9        	beqz	a0, 0x151c8 <dwarf.DwarfInfo.getAbbrevTable+0x93e>
   151ba: e9 a8        	j	0x15294 <dwarf.DwarfInfo.getAbbrevTable+0xa0a>
;     const ov = @mulWithOverflow(a, b);
   151bc: 33 b5 0a 03  	mulhu	a0, s5, a6
;     if (ov[1] != 0) return error.Overflow;
   151c0: 63 1f 05 3a  	bnez	a0, 0x1557e <dwarf.DwarfInfo.getAbbrevTable+0xcf4>
   151c4: b3 84 0a 03  	mul	s1, s5, a6
   151c8: 26 75        	ld	a0, 104(sp)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   151ca: 0c 65        	ld	a1, 8(a0)
   151cc: 08 61        	ld	a0, 0(a0)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   151ce: 98 61        	ld	a4, 0(a1)
   151d0: 0d 46        	li	a2, 3
   151d2: a6 85        	mv	a1, s1
   151d4: c6 76        	ld	a3, 112(sp)
   151d6: 02 97        	jalr	a4
   151d8: 63 08 05 3a  	beqz	a0, 0x15588 <dwarf.DwarfInfo.getAbbrevTable+0xcfe>
   151dc: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   151de: 93 05 a0 0a  	li	a1, 170
   151e2: 26 86        	mv	a2, s1
   151e4: 97 f0 00 00  	auipc	ra, 15
   151e8: e7 80 60 0b  	jalr	182(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   151ec: 13 75 74 00  	andi	a0, s0, 7
   151f0: 13 35 15 00  	seqz	a0, a0
   151f4: 93 b5 14 00  	seqz	a1, s1
   151f8: 4d 8d        	or	a0, a0, a1
   151fa: e3 07 05 14  	beqz	a0, 0x15b48 <dwarf.DwarfInfo.getAbbrevTable+0x12be>
   151fe: 61 48        	li	a6, 24
;     if (bytes.len == 0) {
   15200: 95 c0        	beqz	s1, 0x15224 <dwarf.DwarfInfo.getAbbrevTable+0x99a>
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   15202: 62 75        	ld	a0, 56(sp)
   15204: 33 b5 a4 02  	mulhu	a0, s1, a0
   15208: 93 5a 45 00  	srli	s5, a0, 4
   1520c: 33 85 0a 03  	mul	a0, s5, a6
   15210: 33 85 a4 40  	sub	a0, s1, a0
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   15214: 63 18 05 4a  	bnez	a0, 0x156c4 <dwarf.DwarfInfo.getAbbrevTable+0xe3a>
;                 mem.copy(T, new_memory, self.items);
   15218: 03 b5 8d 00  	ld	a0, 8(s11)
;     if (!ok) unreachable; // assertion failure
   1521c: 63 fd aa 00  	bgeu	s5, a0, 0x15236 <dwarf.DwarfInfo.getAbbrevTable+0x9ac>
   15220: 6f 00 50 11  	j	0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
   15224: 37 55 02 00  	lui	a0, 37
   15228: 03 34 05 33  	ld	s0, 816(a0)
   1522c: 81 4a        	li	s5, 0
;                 mem.copy(T, new_memory, self.items);
   1522e: 03 b5 8d 00  	ld	a0, 8(s11)
;     if (!ok) unreachable; // assertion failure
   15232: e3 e1 aa 10  	bltu	s5, a0, 0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
;     for (source) |s, i|
   15236: 11 cd        	beqz	a0, 0x15252 <dwarf.DwarfInfo.getAbbrevTable+0x9c8>
   15238: 83 b5 0d 00  	ld	a1, 0(s11)
   1523c: 22 86        	mv	a2, s0
;         dest[i] = s;
   1523e: 94 69        	ld	a3, 16(a1)
   15240: 98 65        	ld	a4, 8(a1)
   15242: 9c 61        	ld	a5, 0(a1)
   15244: 14 ea        	sd	a3, 16(a2)
   15246: 18 e6        	sd	a4, 8(a2)
   15248: 1c e2        	sd	a5, 0(a2)
;     for (source) |s, i|
   1524a: e1 05        	addi	a1, a1, 24
   1524c: 7d 15        	addi	a0, a0, -1
   1524e: 61 06        	addi	a2, a2, 24
   15250: 7d f5        	bnez	a0, 0x1523e <dwarf.DwarfInfo.getAbbrevTable+0x9b4>
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   15252: 63 07 09 00  	beqz	s2, 0x15260 <dwarf.DwarfInfo.getAbbrevTable+0x9d6>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15256: 63 90 0b 08  	bnez	s7, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     if (bytes_len == 0) return;
   1525a: 63 97 0c 00  	bnez	s9, 0x15268 <dwarf.DwarfInfo.getAbbrevTable+0x9de>
   1525e: 0d a8        	j	0x15290 <dwarf.DwarfInfo.getAbbrevTable+0xa06>
   15260: 81 4c        	li	s9, 0
   15262: 21 4c        	li	s8, 8
;     if (bytes_len == 0) return;
   15264: 63 86 0c 02  	beqz	s9, 0x15290 <dwarf.DwarfInfo.getAbbrevTable+0xa06>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   15268: e3 0c 0c 0a  	beqz	s8, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   1526c: 93 05 a0 0a  	li	a1, 170
   15270: 62 85        	mv	a0, s8
   15272: 66 86        	mv	a2, s9
   15274: 97 f0 00 00  	auipc	ra, 15
   15278: e7 80 60 02  	jalr	38(ra)
   1527c: 26 75        	ld	a0, 104(sp)
;     self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());
   1527e: 0c 65        	ld	a1, 8(a0)
   15280: 08 61        	ld	a0, 0(a0)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15282: 9c 69        	ld	a5, 16(a1)
   15284: 8d 46        	li	a3, 3
   15286: e2 85        	mv	a1, s8
   15288: 66 86        	mv	a2, s9
   1528a: 46 77        	ld	a4, 112(sp)
   1528c: 82 97        	jalr	a5
   1528e: 61 48        	li	a6, 24
;                 self.items.ptr = new_memory.ptr;
   15290: 23 b0 8d 00  	sd	s0, 0(s11)
   15294: 23 30 5a 01  	sd	s5, 0(s4)
;             assert(self.items.len < self.capacity);
   15298: 03 b5 8d 00  	ld	a0, 8(s11)
   1529c: 56 89        	mv	s2, s5
   1529e: 86 7b        	ld	s7, 96(sp)
   152a0: e6 6c        	ld	s9, 88(sp)
;     if (!ok) unreachable; // assertion failure
   152a2: e3 79 25 09  	bgeu	a0, s2, 0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
;             return &self.items[self.items.len - 1];
   152a6: 83 b5 0d 00  	ld	a1, 0(s11)
;             self.items.len += 1;
   152aa: 13 06 15 00  	addi	a2, a0, 1
   152ae: 23 b4 cd 00  	sd	a2, 8(s11)
;             return &self.items[self.items.len - 1];
   152b2: 33 05 05 03  	mul	a0, a0, a6
   152b6: 2e 95        	add	a0, a0, a1
;             new_item_ptr.* = item;
   152b8: 23 30 65 01  	sd	s6, 0(a0)
   152bc: 23 34 a5 01  	sd	s10, 8(a0)
   152c0: 23 38 35 01  	sd	s3, 16(a0)
   152c4: 6a 74        	ld	s0, 184(sp)
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   152c6: 0c 64        	ld	a1, 8(s0)
   152c8: 1c 68        	ld	a5, 16(s0)
   152ca: 33 87 f5 40  	sub	a4, a1, a5
   152ce: 13 05 04 01  	addi	a0, s0, 16
   152d2: e3 fd e5 90  	bgeu	a1, a4, 0x14bec <dwarf.DwarfInfo.getAbbrevTable+0x362>
   152d6: 37 15 01 00  	lui	a0, 17
   152da: 13 05 95 5d  	addi	a0, a0, 1497
   152de: c1 45        	li	a1, 16
   152e0: 81 46        	li	a3, 0
   152e2: 97 e0 00 00  	auipc	ra, 14
   152e6: e7 80 80 09  	jalr	152(ra)
   152ea: 01 4c        	li	s8, 0
   152ec: 88 e2        	sd	a0, 0(a3)
   152ee: 7d a5        	j	0x1599c <dwarf.DwarfInfo.getAbbrevTable+0x1112>
;             if (amt_read < 1) return error.EndOfStream;
   152f0: 5e 85        	mv	a0, s7
   152f2: 97 f0 00 00  	auipc	ra, 15
   152f6: e7 80 60 90  	jalr	-1786(ra)
   152fa: 13 0c 10 03  	li	s8, 49
   152fe: 5e 85        	mv	a0, s7
   15300: 97 f0 00 00  	auipc	ra, 15
   15304: e7 80 80 8f  	jalr	-1800(ra)
;             for (result.items) |*entry| {
   15308: 2e 69        	ld	s2, 200(sp)
   1530a: c6 7c        	ld	s9, 112(sp)
   1530c: 63 1b 09 04  	bnez	s2, 0x15362 <dwarf.DwarfInfo.getAbbrevTable+0xad8>
;                 self.allocator.free(self.allocatedSlice());
   15310: ee 69        	ld	s3, 216(sp)
   15312: 4e 65        	ld	a0, 208(sp)
   15314: 0e 79        	ld	s2, 224(sp)
   15316: 1d e9        	bnez	a0, 0x1534c <dwarf.DwarfInfo.getAbbrevTable+0xac2>
   15318: 81 44        	li	s1, 0
   1531a: 21 44        	li	s0, 8
   1531c: 86 7b        	ld	s7, 96(sp)
   1531e: 63 92 04 64  	bnez	s1, 0x15962 <dwarf.DwarfInfo.getAbbrevTable+0x10d8>
   15322: 95 a5        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
;             if (amt_read < 1) return error.EndOfStream;
   15324: 5e 85        	mv	a0, s7
   15326: 97 f0 00 00  	auipc	ra, 15
   1532a: e7 80 20 8d  	jalr	-1838(ra)
   1532e: 13 0c 10 03  	li	s8, 49
   15332: 5e 85        	mv	a0, s7
   15334: 97 f0 00 00  	auipc	ra, 15
   15338: e7 80 40 8c  	jalr	-1852(ra)
;             for (result.items) |*entry| {
   1533c: 2e 69        	ld	s2, 200(sp)
   1533e: c6 7c        	ld	s9, 112(sp)
   15340: 63 16 09 08  	bnez	s2, 0x153cc <dwarf.DwarfInfo.getAbbrevTable+0xb42>
;                 self.allocator.free(self.allocatedSlice());
   15344: ee 69        	ld	s3, 216(sp)
   15346: 4e 65        	ld	a0, 208(sp)
   15348: 0e 79        	ld	s2, 224(sp)
   1534a: 79 d5        	beqz	a0, 0x15318 <dwarf.DwarfInfo.getAbbrevTable+0xa8e>
   1534c: 93 14 65 00  	slli	s1, a0, 6
   15350: 93 d5 64 00  	srli	a1, s1, 6
   15354: 86 7b        	ld	s7, 96(sp)
   15356: e3 90 a5 f8  	bne	a1, a0, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1535a: 0e 64        	ld	s0, 192(sp)
   1535c: 63 85 04 62  	beqz	s1, 0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
   15360: 09 a5        	j	0x15962 <dwarf.DwarfInfo.getAbbrevTable+0x10d8>
   15362: 81 44        	li	s1, 0
   15364: 01 44        	li	s0, 0
   15366: 61 4b        	li	s6, 24
   15368: 31 a0        	j	0x15374 <dwarf.DwarfInfo.getAbbrevTable+0xaea>
;                 entry.attrs.deinit();
   1536a: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   1536c: 93 84 04 04  	addi	s1, s1, 64
   15370: e3 00 89 fa  	beq	s2, s0, 0x15310 <dwarf.DwarfInfo.getAbbrevTable+0xa86>
   15374: 2e 65        	ld	a0, 200(sp)
   15376: 63 7b a4 78  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   1537a: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   1537c: 26 95        	add	a0, a0, s1
   1537e: 83 39 85 02  	ld	s3, 40(a0)
   15382: 0c 71        	ld	a1, 32(a0)
   15384: 83 3b 05 03  	ld	s7, 48(a0)
   15388: 99 c9        	beqz	a1, 0x1539e <dwarf.DwarfInfo.getAbbrevTable+0xb14>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1538a: 33 b6 65 03  	mulhu	a2, a1, s6
   1538e: 21 f6        	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15390: 03 3a 05 01  	ld	s4, 16(a0)
   15394: b3 8a 65 03  	mul	s5, a1, s6
   15398: 63 97 0a 00  	bnez	s5, 0x153a6 <dwarf.DwarfInfo.getAbbrevTable+0xb1c>
   1539c: f9 b7        	j	0x1536a <dwarf.DwarfInfo.getAbbrevTable+0xae0>
   1539e: 81 4a        	li	s5, 0
   153a0: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   153a2: e3 84 0a fc  	beqz	s5, 0x1536a <dwarf.DwarfInfo.getAbbrevTable+0xae0>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   153a6: 63 0d 0a 76  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   153aa: 93 05 a0 0a  	li	a1, 170
   153ae: 52 85        	mv	a0, s4
   153b0: 56 86        	mv	a2, s5
   153b2: 97 f0 00 00  	auipc	ra, 15
   153b6: e7 80 80 ee  	jalr	-280(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   153ba: 83 b7 0b 01  	ld	a5, 16(s7)
   153be: 8d 46        	li	a3, 3
   153c0: 4e 85        	mv	a0, s3
   153c2: d2 85        	mv	a1, s4
   153c4: 56 86        	mv	a2, s5
   153c6: 66 87        	mv	a4, s9
   153c8: 82 97        	jalr	a5
   153ca: 45 b7        	j	0x1536a <dwarf.DwarfInfo.getAbbrevTable+0xae0>
   153cc: 81 44        	li	s1, 0
   153ce: 01 44        	li	s0, 0
   153d0: 61 4b        	li	s6, 24
   153d2: 25 a8        	j	0x1540a <dwarf.DwarfInfo.getAbbrevTable+0xb80>
   153d4: 81 4a        	li	s5, 0
   153d6: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   153d8: 63 84 0a 02  	beqz	s5, 0x15400 <dwarf.DwarfInfo.getAbbrevTable+0xb76>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   153dc: 63 02 0a 74  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   153e0: 93 05 a0 0a  	li	a1, 170
   153e4: 52 85        	mv	a0, s4
   153e6: 56 86        	mv	a2, s5
   153e8: 97 f0 00 00  	auipc	ra, 15
   153ec: e7 80 20 eb  	jalr	-334(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   153f0: 83 b7 0b 01  	ld	a5, 16(s7)
   153f4: 8d 46        	li	a3, 3
   153f6: 4e 85        	mv	a0, s3
   153f8: d2 85        	mv	a1, s4
   153fa: 56 86        	mv	a2, s5
   153fc: 66 87        	mv	a4, s9
   153fe: 82 97        	jalr	a5
;                 entry.attrs.deinit();
   15400: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   15402: 93 84 04 04  	addi	s1, s1, 64
   15406: e3 0f 89 f2  	beq	s2, s0, 0x15344 <dwarf.DwarfInfo.getAbbrevTable+0xaba>
   1540a: 2e 65        	ld	a0, 200(sp)
   1540c: 63 70 a4 70  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   15410: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   15412: 26 95        	add	a0, a0, s1
   15414: 83 39 85 02  	ld	s3, 40(a0)
   15418: 0c 71        	ld	a1, 32(a0)
   1541a: 83 3b 05 03  	ld	s7, 48(a0)
   1541e: dd d9        	beqz	a1, 0x153d4 <dwarf.DwarfInfo.getAbbrevTable+0xb4a>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15420: 33 b6 65 03  	mulhu	a2, a1, s6
   15424: e3 19 06 ea  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15428: 03 3a 05 01  	ld	s4, 16(a0)
   1542c: b3 8a 65 03  	mul	s5, a1, s6
   15430: e3 96 0a fa  	bnez	s5, 0x153dc <dwarf.DwarfInfo.getAbbrevTable+0xb52>
   15434: f1 b7        	j	0x15400 <dwarf.DwarfInfo.getAbbrevTable+0xb76>
;             if (abbrev_code == 0) return result;
   15436: 0e 75        	ld	a0, 224(sp)
   15438: 2a ed        	sd	a0, 152(sp)
   1543a: 6e 65        	ld	a0, 216(sp)
   1543c: ce 65        	ld	a1, 208(sp)
   1543e: 2e 66        	ld	a2, 200(sp)
   15440: 8e 66        	ld	a3, 192(sp)
   15442: 2a e9        	sd	a0, 144(sp)
   15444: 2e e5        	sd	a1, 136(sp)
   15446: 32 e1        	sd	a2, 128(sp)
   15448: b6 fc        	sd	a3, 120(sp)
   1544a: 22 64        	ld	s0, 8(sp)
;             const newlen = self.items.len + 1;
   1544c: 68 64        	ld	a0, 200(s0)
   1544e: 93 05 15 00  	addi	a1, a0, 1
   15452: e3 82 05 e8  	beqz	a1, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;             if (self.capacity >= new_capacity) return;
   15456: 03 3a 04 0d  	ld	s4, 208(s0)
   1545a: 63 7c ba 08  	bgeu	s4, a1, 0x154f2 <dwarf.DwarfInfo.getAbbrevTable+0xc68>
   1545e: d2 84        	mv	s1, s4
   15460: 19 a0        	j	0x15466 <dwarf.DwarfInfo.getAbbrevTable+0xbdc>
;                 if (better_capacity >= new_capacity) break;
   15462: 63 fa b4 02  	bgeu	s1, a1, 0x15496 <dwarf.DwarfInfo.getAbbrevTable+0xc0c>
   15466: a6 86        	mv	a3, s1
;                 better_capacity +|= better_capacity / 2 + 8;
   15468: 13 d6 14 00  	srli	a2, s1, 1
   1546c: 26 96        	add	a2, a2, s1
   1546e: 21 06        	addi	a2, a2, 8
   15470: fd 54        	li	s1, -1
   15472: e3 68 d6 fe  	bltu	a2, a3, 0x15462 <dwarf.DwarfInfo.getAbbrevTable+0xbd8>
   15476: b2 84        	mv	s1, a2
   15478: ed b7        	j	0x15462 <dwarf.DwarfInfo.getAbbrevTable+0xbd8>
;             for (result.items) |*entry| {
   1547a: 2e 69        	ld	s2, 200(sp)
   1547c: c6 7c        	ld	s9, 112(sp)
   1547e: 63 1e 09 06  	bnez	s2, 0x154fa <dwarf.DwarfInfo.getAbbrevTable+0xc70>
;                 self.allocator.free(self.allocatedSlice());
   15482: ee 69        	ld	s3, 216(sp)
   15484: 4e 65        	ld	a0, 208(sp)
   15486: 0e 79        	ld	s2, 224(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   15488: 71 ed        	bnez	a0, 0x15564 <dwarf.DwarfInfo.getAbbrevTable+0xcda>
   1548a: 81 44        	li	s1, 0
   1548c: 21 44        	li	s0, 8
   1548e: 86 7b        	ld	s7, 96(sp)
   15490: 63 99 04 4c  	bnez	s1, 0x15962 <dwarf.DwarfInfo.getAbbrevTable+0x10d8>
   15494: cd a9        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
;             if (self.capacity >= new_capacity) return;
   15496: 63 7e 9a 04  	bgeu	s4, s1, 0x154f2 <dwarf.DwarfInfo.getAbbrevTable+0xc68>
;             const old_memory = self.allocatedSlice();
   1549a: 03 3c 04 0c  	ld	s8, 192(s0)
;             if (allocator.resize(old_memory, new_capacity)) {
   1549e: 03 b5 0a 00  	ld	a0, 0(s5)
   154a2: 83 b5 8a 00  	ld	a1, 8(s5)
   154a6: b0 0a        	addi	a2, sp, 344
   154a8: b2 e5        	sd	a2, 200(sp)
   154aa: 13 06 00 02  	li	a2, 32
   154ae: b2 e9        	sd	a2, 208(sp)
   154b0: 82 e1        	sd	zero, 192(sp)
;     if (old_mem.len == 0) {
   154b2: 63 08 0a 1a  	beqz	s4, 0x15662 <dwarf.DwarfInfo.getAbbrevTable+0xdd8>
   154b6: 93 06 00 03  	li	a3, 48
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   154ba: 33 36 da 02  	mulhu	a2, s4, a3
   154be: e3 1c 06 e0  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     const ov = @mulWithOverflow(a, b);
   154c2: 33 b6 d4 02  	mulhu	a2, s1, a3
;     if (ov[1] != 0) return error.Overflow;
   154c6: 63 14 06 5e  	bnez	a2, 0x15aae <dwarf.DwarfInfo.getAbbrevTable+0x1224>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   154ca: 03 b8 85 00  	ld	a6, 8(a1)
   154ce: 33 06 da 02  	mul	a2, s4, a3
   154d2: b3 89 d4 02  	mul	s3, s1, a3
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   154d6: 8d 46        	li	a3, 3
   154d8: e2 85        	mv	a1, s8
   154da: 4e 87        	mv	a4, s3
   154dc: e6 87        	mv	a5, s9
   154de: 02 98        	jalr	a6
   154e0: 05 89        	andi	a0, a0, 1
   154e2: c2 66        	ld	a3, 16(sp)
;             if (allocator.resize(old_memory, new_capacity)) {
   154e4: 63 12 05 2c  	bnez	a0, 0x157a8 <dwarf.DwarfInfo.getAbbrevTable+0xf1e>
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   154e8: 83 b5 8a 00  	ld	a1, 8(s5)
   154ec: 03 b5 0a 00  	ld	a0, 0(s5)
   154f0: 49 a2        	j	0x15672 <dwarf.DwarfInfo.getAbbrevTable+0xde8>
   154f2: c2 66        	ld	a3, 16(sp)
   154f4: 63 6f 45 2b  	bltu	a0, s4, 0x157b2 <dwarf.DwarfInfo.getAbbrevTable+0xf28>
   154f8: 35 ad        	j	0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
   154fa: 81 44        	li	s1, 0
   154fc: 01 44        	li	s0, 0
   154fe: 61 4b        	li	s6, 24
   15500: 25 a8        	j	0x15538 <dwarf.DwarfInfo.getAbbrevTable+0xcae>
   15502: 81 4a        	li	s5, 0
   15504: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   15506: 63 84 0a 02  	beqz	s5, 0x1552e <dwarf.DwarfInfo.getAbbrevTable+0xca4>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1550a: 63 0b 0a 60  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   1550e: 93 05 a0 0a  	li	a1, 170
   15512: 52 85        	mv	a0, s4
   15514: 56 86        	mv	a2, s5
   15516: 97 f0 00 00  	auipc	ra, 15
   1551a: e7 80 40 d8  	jalr	-636(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1551e: 83 b7 0b 01  	ld	a5, 16(s7)
   15522: 8d 46        	li	a3, 3
   15524: 4e 85        	mv	a0, s3
   15526: d2 85        	mv	a1, s4
   15528: 56 86        	mv	a2, s5
   1552a: 66 87        	mv	a4, s9
   1552c: 82 97        	jalr	a5
;                 entry.attrs.deinit();
   1552e: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   15530: 93 84 04 04  	addi	s1, s1, 64
   15534: e3 07 89 f4  	beq	s2, s0, 0x15482 <dwarf.DwarfInfo.getAbbrevTable+0xbf8>
   15538: 2e 65        	ld	a0, 200(sp)
   1553a: 63 79 a4 5c  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   1553e: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   15540: 26 95        	add	a0, a0, s1
   15542: 83 39 85 02  	ld	s3, 40(a0)
   15546: 0c 71        	ld	a1, 32(a0)
   15548: 83 3b 05 03  	ld	s7, 48(a0)
   1554c: dd d9        	beqz	a1, 0x15502 <dwarf.DwarfInfo.getAbbrevTable+0xc78>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1554e: 33 b6 65 03  	mulhu	a2, a1, s6
   15552: e3 12 06 d8  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15556: 03 3a 05 01  	ld	s4, 16(a0)
   1555a: b3 8a 65 03  	mul	s5, a1, s6
   1555e: e3 96 0a fa  	bnez	s5, 0x1550a <dwarf.DwarfInfo.getAbbrevTable+0xc80>
   15562: f1 b7        	j	0x1552e <dwarf.DwarfInfo.getAbbrevTable+0xca4>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15564: 93 14 65 00  	slli	s1, a0, 6
   15568: 93 d5 64 00  	srli	a1, s1, 6
   1556c: 86 7b        	ld	s7, 96(sp)
   1556e: 63 88 a5 3e  	beq	a1, a0, 0x1595e <dwarf.DwarfInfo.getAbbrevTable+0x10d4>
   15572: 95 b3        	j	0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
;     if (ov[1] != 0) return error.Overflow;
   15574: 88 02        	addi	a0, sp, 320
   15576: 97 e0 00 00  	auipc	ra, 14
   1557a: e7 80 20 68  	jalr	1666(ra)
   1557e: 06 75        	ld	a0, 96(sp)
   15580: 97 e0 00 00  	auipc	ra, 14
   15584: e7 80 80 67  	jalr	1656(ra)
   15588: 06 74        	ld	s0, 96(sp)
   1558a: 22 85        	mv	a0, s0
   1558c: 97 e0 00 00  	auipc	ra, 14
   15590: e7 80 c0 66  	jalr	1644(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   15594: 22 85        	mv	a0, s0
   15596: 97 e0 00 00  	auipc	ra, 14
   1559a: e7 80 20 66  	jalr	1634(ra)
;                 const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
   1559e: 22 85        	mv	a0, s0
   155a0: 97 e0 00 00  	auipc	ra, 14
   155a4: e7 80 80 65  	jalr	1624(ra)
;             return self.ensureTotalCapacityPrecise(better_capacity);
   155a8: 22 85        	mv	a0, s0
   155aa: 97 e0 00 00  	auipc	ra, 14
   155ae: e7 80 e0 64  	jalr	1614(ra)
;             try self.ensureTotalCapacity(self.items.len + 1);
   155b2: 22 85        	mv	a0, s0
   155b4: 97 e0 00 00  	auipc	ra, 14
   155b8: e7 80 40 64  	jalr	1604(ra)
;             const new_item_ptr = try self.addOne();
   155bc: 22 85        	mv	a0, s0
   155be: 97 e0 00 00  	auipc	ra, 14
   155c2: e7 80 a0 63  	jalr	1594(ra)
;             for (result.items) |*entry| {
   155c6: 2e 69        	ld	s2, 200(sp)
   155c8: c6 7c        	ld	s9, 112(sp)
   155ca: 63 1a 09 00  	bnez	s2, 0x155de <dwarf.DwarfInfo.getAbbrevTable+0xd54>
;                 self.allocator.free(self.allocatedSlice());
   155ce: ee 69        	ld	s3, 216(sp)
   155d0: 4e 65        	ld	a0, 208(sp)
   155d2: 0e 79        	ld	s2, 224(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   155d4: 3d e9        	bnez	a0, 0x1564a <dwarf.DwarfInfo.getAbbrevTable+0xdc0>
   155d6: 81 44        	li	s1, 0
   155d8: 21 44        	li	s0, 8
   155da: 86 7b        	ld	s7, 96(sp)
   155dc: bd a8        	j	0x1565a <dwarf.DwarfInfo.getAbbrevTable+0xdd0>
   155de: 81 44        	li	s1, 0
   155e0: 01 44        	li	s0, 0
   155e2: 61 4b        	li	s6, 24
   155e4: 31 a0        	j	0x155f0 <dwarf.DwarfInfo.getAbbrevTable+0xd66>
;                 entry.attrs.deinit();
   155e6: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   155e8: 93 84 04 04  	addi	s1, s1, 64
   155ec: e3 01 89 fe  	beq	s2, s0, 0x155ce <dwarf.DwarfInfo.getAbbrevTable+0xd44>
   155f0: 2e 65        	ld	a0, 200(sp)
   155f2: 63 7d a4 50  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   155f6: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   155f8: 26 95        	add	a0, a0, s1
   155fa: 83 39 85 02  	ld	s3, 40(a0)
   155fe: 0c 71        	ld	a1, 32(a0)
   15600: 83 3b 05 03  	ld	s7, 48(a0)
   15604: 81 cd        	beqz	a1, 0x1561c <dwarf.DwarfInfo.getAbbrevTable+0xd92>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15606: 33 b6 65 03  	mulhu	a2, a1, s6
   1560a: e3 16 06 cc  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1560e: 03 3a 05 01  	ld	s4, 16(a0)
   15612: b3 8a 65 03  	mul	s5, a1, s6
   15616: 63 97 0a 00  	bnez	s5, 0x15624 <dwarf.DwarfInfo.getAbbrevTable+0xd9a>
   1561a: f1 b7        	j	0x155e6 <dwarf.DwarfInfo.getAbbrevTable+0xd5c>
   1561c: 81 4a        	li	s5, 0
   1561e: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   15620: e3 83 0a fc  	beqz	s5, 0x155e6 <dwarf.DwarfInfo.getAbbrevTable+0xd5c>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   15624: 63 0e 0a 4e  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   15628: 93 05 a0 0a  	li	a1, 170
   1562c: 52 85        	mv	a0, s4
   1562e: 56 86        	mv	a2, s5
   15630: 97 f0 00 00  	auipc	ra, 15
   15634: e7 80 a0 c6  	jalr	-918(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15638: 83 b7 0b 01  	ld	a5, 16(s7)
   1563c: 8d 46        	li	a3, 3
   1563e: 4e 85        	mv	a0, s3
   15640: d2 85        	mv	a1, s4
   15642: 56 86        	mv	a2, s5
   15644: 66 87        	mv	a4, s9
   15646: 82 97        	jalr	a5
   15648: 79 bf        	j	0x155e6 <dwarf.DwarfInfo.getAbbrevTable+0xd5c>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1564a: 93 14 65 00  	slli	s1, a0, 6
   1564e: 93 d5 64 00  	srli	a1, s1, 6
   15652: 86 7b        	ld	s7, 96(sp)
   15654: e3 91 a5 c8  	bne	a1, a0, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15658: 0e 64        	ld	s0, 192(sp)
   1565a: 45 4c        	li	s8, 17
;     if (bytes_len == 0) return;
   1565c: 63 93 04 30  	bnez	s1, 0x15962 <dwarf.DwarfInfo.getAbbrevTable+0x10d8>
   15660: 1d a6        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
   15662: 13 06 00 03  	li	a2, 48
;     const ov = @mulWithOverflow(a, b);
   15666: b3 b6 c4 02  	mulhu	a3, s1, a2
;     if (ov[1] != 0) return error.Overflow;
   1566a: 63 97 06 44  	bnez	a3, 0x15ab8 <dwarf.DwarfInfo.getAbbrevTable+0x122e>
   1566e: b3 89 c4 02  	mul	s3, s1, a2
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   15672: 98 61        	ld	a4, 0(a1)
   15674: 0d 46        	li	a2, 3
   15676: ce 85        	mv	a1, s3
   15678: e6 86        	mv	a3, s9
   1567a: 02 97        	jalr	a4
   1567c: 63 03 05 44  	beqz	a0, 0x15ac2 <dwarf.DwarfInfo.getAbbrevTable+0x1238>
   15680: 2a 89        	mv	s2, a0
;     @memset(byte_ptr, undefined, byte_count);
   15682: 93 05 a0 0a  	li	a1, 170
   15686: 4e 86        	mv	a2, s3
   15688: 97 f0 00 00  	auipc	ra, 15
   1568c: e7 80 20 c1  	jalr	-1006(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   15690: 13 75 79 00  	andi	a0, s2, 7
   15694: 13 35 15 00  	seqz	a0, a0
   15698: 93 b5 19 00  	seqz	a1, s3
   1569c: 4d 8d        	or	a0, a0, a1
   1569e: 63 05 05 4a  	beqz	a0, 0x15b48 <dwarf.DwarfInfo.getAbbrevTable+0x12be>
;     if (bytes.len == 0) {
   156a2: 63 87 09 06  	beqz	s3, 0x15710 <dwarf.DwarfInfo.getAbbrevTable+0xe86>
   156a6: 37 55 02 00  	lui	a0, 37
   156aa: 03 35 85 33  	ld	a0, 824(a0)
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   156ae: 33 b5 a9 02  	mulhu	a0, s3, a0
   156b2: 93 54 55 00  	srli	s1, a0, 5
   156b6: 13 05 00 03  	li	a0, 48
   156ba: 33 85 a4 02  	mul	a0, s1, a0
   156be: 33 85 a9 40  	sub	a0, s3, a0
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   156c2: 21 cd        	beqz	a0, 0x1571a <dwarf.DwarfInfo.getAbbrevTable+0xe90>
   156c4: 37 15 01 00  	lui	a0, 17
   156c8: 13 05 d5 74  	addi	a0, a0, 1869
   156cc: 93 05 10 02  	li	a1, 33
   156d0: 81 46        	li	a3, 0
   156d2: 97 e0 00 00  	auipc	ra, 14
   156d6: e7 80 80 ca  	jalr	-856(ra)
;             for (result.items) |*entry| {
   156da: 2e 69        	ld	s2, 200(sp)
   156dc: 63 18 09 18  	bnez	s2, 0x1586c <dwarf.DwarfInfo.getAbbrevTable+0xfe2>
;             result.deinit();
   156e0: 88 01        	addi	a0, sp, 192
   156e2: 97 f0 ff ff  	auipc	ra, 1048575
   156e6: e7 80 e0 10  	jalr	270(ra)
   156ea: 86 7b        	ld	s7, 96(sp)
   156ec: 69 ac        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
;             if (amt_read < 1) return error.EndOfStream;
   156ee: 5e 85        	mv	a0, s7
   156f0: 97 e0 00 00  	auipc	ra, 14
   156f4: e7 80 80 50  	jalr	1288(ra)
;             for (result.items) |*entry| {
   156f8: 2e 69        	ld	s2, 200(sp)
   156fa: 63 1e 09 1c  	bnez	s2, 0x158d6 <dwarf.DwarfInfo.getAbbrevTable+0x104c>
;             result.deinit();
   156fe: 88 01        	addi	a0, sp, 192
   15700: 97 f0 ff ff  	auipc	ra, 1048575
   15704: e7 80 00 0f  	jalr	240(ra)
   15708: 13 0c 10 03  	li	s8, 49
   1570c: 86 7b        	ld	s7, 96(sp)
   1570e: a5 ac        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
   15710: 37 55 02 00  	lui	a0, 37
   15714: 03 39 05 33  	ld	s2, 816(a0)
   15718: 81 44        	li	s1, 0
;                 mem.copy(T, new_memory, self.items);
   1571a: 68 64        	ld	a0, 200(s0)
;     if (!ok) unreachable; // assertion failure
   1571c: 63 ec a4 40  	bltu	s1, a0, 0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
;     for (source) |s, i|
   15720: 15 c9        	beqz	a0, 0x15754 <dwarf.DwarfInfo.getAbbrevTable+0xeca>
   15722: a2 65        	ld	a1, 8(sp)
   15724: ec 61        	ld	a1, 192(a1)
   15726: 4a 86        	mv	a2, s2
;         dest[i] = s;
   15728: 03 b8 05 00  	ld	a6, 0(a1)
   1572c: 83 b8 85 00  	ld	a7, 8(a1)
   15730: 9c 75        	ld	a5, 40(a1)
   15732: 80 71        	ld	s0, 32(a1)
   15734: 94 6d        	ld	a3, 24(a1)
   15736: 98 69        	ld	a4, 16(a1)
   15738: 1c f6        	sd	a5, 40(a2)
   1573a: 00 f2        	sd	s0, 32(a2)
   1573c: 14 ee        	sd	a3, 24(a2)
   1573e: 18 ea        	sd	a4, 16(a2)
   15740: 23 34 16 01  	sd	a7, 8(a2)
   15744: 23 30 06 01  	sd	a6, 0(a2)
;     for (source) |s, i|
   15748: 93 85 05 03  	addi	a1, a1, 48
   1574c: 7d 15        	addi	a0, a0, -1
   1574e: 13 06 06 03  	addi	a2, a2, 48
   15752: 79 f9        	bnez	a0, 0x15728 <dwarf.DwarfInfo.getAbbrevTable+0xe9e>
;                 allocator.free(old_memory);
   15754: 03 bb 0a 00  	ld	s6, 0(s5)
   15758: 83 b9 8a 00  	ld	s3, 8(s5)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1575c: 63 0c 0a 00  	beqz	s4, 0x15774 <dwarf.DwarfInfo.getAbbrevTable+0xeea>
   15760: 13 05 00 03  	li	a0, 48
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15764: b3 35 aa 02  	mulhu	a1, s4, a0
   15768: c2 66        	ld	a3, 16(sp)
   1576a: e3 96 05 b6  	bnez	a1, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1576e: 33 04 aa 02  	mul	s0, s4, a0
   15772: 21 a0        	j	0x1577a <dwarf.DwarfInfo.getAbbrevTable+0xef0>
   15774: 01 44        	li	s0, 0
   15776: 21 4c        	li	s8, 8
   15778: c2 66        	ld	a3, 16(sp)
;     if (bytes_len == 0) return;
   1577a: 05 c4        	beqz	s0, 0x157a2 <dwarf.DwarfInfo.getAbbrevTable+0xf18>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1577c: 63 02 0c 3a  	beqz	s8, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   15780: 93 05 a0 0a  	li	a1, 170
   15784: 62 85        	mv	a0, s8
   15786: 22 86        	mv	a2, s0
   15788: 97 f0 00 00  	auipc	ra, 15
   1578c: e7 80 20 b1  	jalr	-1262(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15790: 83 b7 09 01  	ld	a5, 16(s3)
   15794: 8d 46        	li	a3, 3
   15796: 5a 85        	mv	a0, s6
   15798: e2 85        	mv	a1, s8
   1579a: 22 86        	mv	a2, s0
   1579c: 66 87        	mv	a4, s9
   1579e: 82 97        	jalr	a5
   157a0: c2 66        	ld	a3, 16(sp)
   157a2: 22 64        	ld	s0, 8(sp)
;                 self.items.ptr = new_memory.ptr;
   157a4: 23 30 24 0d  	sd	s2, 192(s0)
;             assert(self.items.len < self.capacity);
   157a8: 68 64        	ld	a0, 200(s0)
   157aa: 64 e8        	sd	s1, 208(s0)
   157ac: 26 8a        	mv	s4, s1
;     if (!ok) unreachable; // assertion failure
   157ae: 63 73 45 39  	bgeu	a0, s4, 0x15b34 <dwarf.DwarfInfo.getAbbrevTable+0x12aa>
;             self.items.len += 1;
   157b2: 93 05 15 00  	addi	a1, a0, 1
;             return &self.items[self.items.len - 1];
   157b6: 70 60        	ld	a2, 192(s0)
;             self.items.len += 1;
   157b8: 6c e4        	sd	a1, 200(s0)
   157ba: 93 05 00 03  	li	a1, 48
;             return &self.items[self.items.len - 1];
   157be: 33 05 b5 02  	mul	a0, a0, a1
   157c2: 32 95        	add	a0, a0, a2
;             new_item_ptr.* = item;
   157c4: 82 65        	ld	a1, 0(sp)
   157c6: 0c e1        	sd	a1, 0(a0)
   157c8: ea 65        	ld	a1, 152(sp)
   157ca: 0c f5        	sd	a1, 40(a0)
   157cc: ca 65        	ld	a1, 144(sp)
   157ce: 0c f1        	sd	a1, 32(a0)
   157d0: aa 65        	ld	a1, 136(sp)
   157d2: 0c ed        	sd	a1, 24(a0)
   157d4: 8a 65        	ld	a1, 128(sp)
   157d6: 0c e9        	sd	a1, 16(a0)
   157d8: e6 75        	ld	a1, 120(sp)
   157da: 0c e5        	sd	a1, 8(a0)
;         return &di.abbrev_table_list.items[di.abbrev_table_list.items.len - 1].table;
   157dc: 6c 64        	ld	a1, 200(s0)
   157de: 13 85 f5 ff  	addi	a0, a1, -1
   157e2: e3 ea a5 ae  	bltu	a1, a0, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   157e6: 63 73 b5 32  	bgeu	a0, a1, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   157ea: 6c 60        	ld	a1, 192(s0)
   157ec: 01 4c        	li	s8, 0
   157ee: 13 06 00 03  	li	a2, 48
;         return &di.abbrev_table_list.items[di.abbrev_table_list.items.len - 1].table;
   157f2: 33 05 c5 02  	mul	a0, a0, a2
   157f6: 2e 95        	add	a0, a0, a1
   157f8: 21 05        	addi	a0, a0, 8
   157fa: cd bc        	j	0x152ec <dwarf.DwarfInfo.getAbbrevTable+0xa62>
;             for (result.items) |*entry| {
   157fc: 2e 69        	ld	s2, 200(sp)
   157fe: 63 02 09 14  	beqz	s2, 0x15942 <dwarf.DwarfInfo.getAbbrevTable+0x10b8>
   15802: 81 44        	li	s1, 0
   15804: 01 44        	li	s0, 0
   15806: 61 4b        	li	s6, 24
   15808: 25 a8        	j	0x15840 <dwarf.DwarfInfo.getAbbrevTable+0xfb6>
   1580a: 81 4a        	li	s5, 0
   1580c: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   1580e: 63 84 0a 02  	beqz	s5, 0x15836 <dwarf.DwarfInfo.getAbbrevTable+0xfac>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   15812: 63 07 0a 30  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   15816: 93 05 a0 0a  	li	a1, 170
   1581a: 52 85        	mv	a0, s4
   1581c: 56 86        	mv	a2, s5
   1581e: 97 f0 00 00  	auipc	ra, 15
   15822: e7 80 c0 a7  	jalr	-1412(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15826: 83 b7 0b 01  	ld	a5, 16(s7)
   1582a: 8d 46        	li	a3, 3
   1582c: 4e 85        	mv	a0, s3
   1582e: d2 85        	mv	a1, s4
   15830: 56 86        	mv	a2, s5
   15832: 66 87        	mv	a4, s9
   15834: 82 97        	jalr	a5
;                 entry.attrs.deinit();
   15836: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   15838: 93 84 04 04  	addi	s1, s1, 64
   1583c: 63 02 89 10  	beq	s2, s0, 0x15940 <dwarf.DwarfInfo.getAbbrevTable+0x10b6>
   15840: 2e 65        	ld	a0, 200(sp)
   15842: 63 75 a4 2c  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   15846: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   15848: 26 95        	add	a0, a0, s1
   1584a: 83 39 85 02  	ld	s3, 40(a0)
   1584e: 0c 71        	ld	a1, 32(a0)
   15850: 83 3b 05 03  	ld	s7, 48(a0)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   15854: dd d9        	beqz	a1, 0x1580a <dwarf.DwarfInfo.getAbbrevTable+0xf80>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15856: 33 b6 65 03  	mulhu	a2, a1, s6
   1585a: e3 1e 06 a6  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1585e: 03 3a 05 01  	ld	s4, 16(a0)
   15862: b3 8a 65 03  	mul	s5, a1, s6
   15866: e3 96 0a fa  	bnez	s5, 0x15812 <dwarf.DwarfInfo.getAbbrevTable+0xf88>
   1586a: f1 b7        	j	0x15836 <dwarf.DwarfInfo.getAbbrevTable+0xfac>
   1586c: 81 44        	li	s1, 0
   1586e: 01 44        	li	s0, 0
   15870: 61 4b        	li	s6, 24
   15872: 25 a8        	j	0x158aa <dwarf.DwarfInfo.getAbbrevTable+0x1020>
   15874: 81 4a        	li	s5, 0
   15876: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   15878: 63 84 0a 02  	beqz	s5, 0x158a0 <dwarf.DwarfInfo.getAbbrevTable+0x1016>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1587c: 63 02 0a 2a  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   15880: 93 05 a0 0a  	li	a1, 170
   15884: 52 85        	mv	a0, s4
   15886: 56 86        	mv	a2, s5
   15888: 97 f0 00 00  	auipc	ra, 15
   1588c: e7 80 20 a1  	jalr	-1518(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15890: 83 b7 0b 01  	ld	a5, 16(s7)
   15894: 8d 46        	li	a3, 3
   15896: 4e 85        	mv	a0, s3
   15898: d2 85        	mv	a1, s4
   1589a: 56 86        	mv	a2, s5
   1589c: 66 87        	mv	a4, s9
   1589e: 82 97        	jalr	a5
;                 entry.attrs.deinit();
   158a0: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   158a2: 93 84 04 04  	addi	s1, s1, 64
   158a6: e3 0d 89 e2  	beq	s2, s0, 0x156e0 <dwarf.DwarfInfo.getAbbrevTable+0xe56>
   158aa: 2e 65        	ld	a0, 200(sp)
   158ac: 63 70 a4 26  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   158b0: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   158b2: 26 95        	add	a0, a0, s1
   158b4: 83 39 85 02  	ld	s3, 40(a0)
   158b8: 0c 71        	ld	a1, 32(a0)
   158ba: 83 3b 05 03  	ld	s7, 48(a0)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   158be: dd d9        	beqz	a1, 0x15874 <dwarf.DwarfInfo.getAbbrevTable+0xfea>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   158c0: 33 b6 65 03  	mulhu	a2, a1, s6
   158c4: e3 19 06 a0  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   158c8: 03 3a 05 01  	ld	s4, 16(a0)
   158cc: b3 8a 65 03  	mul	s5, a1, s6
   158d0: e3 96 0a fa  	bnez	s5, 0x1587c <dwarf.DwarfInfo.getAbbrevTable+0xff2>
   158d4: f1 b7        	j	0x158a0 <dwarf.DwarfInfo.getAbbrevTable+0x1016>
   158d6: 81 44        	li	s1, 0
   158d8: 01 44        	li	s0, 0
   158da: 61 4b        	li	s6, 24
   158dc: 25 a8        	j	0x15914 <dwarf.DwarfInfo.getAbbrevTable+0x108a>
   158de: 81 4a        	li	s5, 0
   158e0: 21 4a        	li	s4, 8
;     if (bytes_len == 0) return;
   158e2: 63 84 0a 02  	beqz	s5, 0x1590a <dwarf.DwarfInfo.getAbbrevTable+0x1080>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   158e6: 63 0d 0a 22  	beqz	s4, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   158ea: 93 05 a0 0a  	li	a1, 170
   158ee: 52 85        	mv	a0, s4
   158f0: 56 86        	mv	a2, s5
   158f2: 97 f0 00 00  	auipc	ra, 15
   158f6: e7 80 80 9a  	jalr	-1624(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   158fa: 83 b7 0b 01  	ld	a5, 16(s7)
   158fe: 8d 46        	li	a3, 3
   15900: 4e 85        	mv	a0, s3
   15902: d2 85        	mv	a1, s4
   15904: 56 86        	mv	a2, s5
   15906: 66 87        	mv	a4, s9
   15908: 82 97        	jalr	a5
;                 entry.attrs.deinit();
   1590a: 05 04        	addi	s0, s0, 1
;             for (result.items) |*entry| {
   1590c: 93 84 04 04  	addi	s1, s1, 64
   15910: e3 07 89 de  	beq	s2, s0, 0x156fe <dwarf.DwarfInfo.getAbbrevTable+0xe74>
   15914: 2e 65        	ld	a0, 200(sp)
   15916: 63 7b a4 1e  	bgeu	s0, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   1591a: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   1591c: 26 95        	add	a0, a0, s1
   1591e: 83 39 85 02  	ld	s3, 40(a0)
   15922: 0c 71        	ld	a1, 32(a0)
   15924: 83 3b 05 03  	ld	s7, 48(a0)
   15928: dd d9        	beqz	a1, 0x158de <dwarf.DwarfInfo.getAbbrevTable+0x1054>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1592a: 33 b6 65 03  	mulhu	a2, a1, s6
   1592e: e3 14 06 9a  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15932: 03 3a 05 01  	ld	s4, 16(a0)
   15936: b3 8a 65 03  	mul	s5, a1, s6
   1593a: e3 96 0a fa  	bnez	s5, 0x158e6 <dwarf.DwarfInfo.getAbbrevTable+0x105c>
   1593e: f1 b7        	j	0x1590a <dwarf.DwarfInfo.getAbbrevTable+0x1080>
   15940: 86 7b        	ld	s7, 96(sp)
;                 self.allocator.free(self.allocatedSlice());
   15942: ee 69        	ld	s3, 216(sp)
   15944: 4e 65        	ld	a0, 208(sp)
   15946: 0e 79        	ld	s2, 224(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   15948: 09 e5        	bnez	a0, 0x15952 <dwarf.DwarfInfo.getAbbrevTable+0x10c8>
   1594a: 81 44        	li	s1, 0
   1594c: 21 44        	li	s0, 8
   1594e: 91 e8        	bnez	s1, 0x15962 <dwarf.DwarfInfo.getAbbrevTable+0x10d8>
   15950: 1d a8        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15952: 93 14 65 00  	slli	s1, a0, 6
   15956: 93 d5 64 00  	srli	a1, s1, 6
   1595a: e3 9e a5 96  	bne	a1, a0, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   1595e: 0e 64        	ld	s0, 192(sp)
   15960: 9d c0        	beqz	s1, 0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
   15962: 63 0f 04 1a  	beqz	s0, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
   15966: 93 05 a0 0a  	li	a1, 170
   1596a: 22 85        	mv	a0, s0
   1596c: 26 86        	mv	a2, s1
   1596e: 97 f0 00 00  	auipc	ra, 15
   15972: e7 80 c0 92  	jalr	-1748(ra)
   15976: 83 37 09 01  	ld	a5, 16(s2)
   1597a: 8d 46        	li	a3, 3
   1597c: 4e 85        	mv	a0, s3
   1597e: a2 85        	mv	a1, s0
   15980: 26 86        	mv	a2, s1
   15982: 66 87        	mv	a4, s9
   15984: 82 97        	jalr	a5
   15986: 5e 85        	mv	a0, s7
   15988: 97 e0 00 00  	auipc	ra, 14
   1598c: e7 80 00 27  	jalr	624(ra)
;             .table = try di.parseAbbrevTable(allocator, abbrev_offset),
   15990: 5e 85        	mv	a0, s7
   15992: 97 e0 00 00  	auipc	ra, 14
   15996: e7 80 60 26  	jalr	614(ra)
   1599a: c2 66        	ld	a3, 16(sp)
   1599c: 23 94 86 01  	sh	s8, 8(a3)
   159a0: 83 30 81 2b  	ld	ra, 696(sp)
   159a4: 03 34 01 2b  	ld	s0, 688(sp)
   159a8: 83 34 81 2a  	ld	s1, 680(sp)
   159ac: 03 39 01 2a  	ld	s2, 672(sp)
   159b0: 83 39 81 29  	ld	s3, 664(sp)
   159b4: 03 3a 01 29  	ld	s4, 656(sp)
   159b8: 83 3a 81 28  	ld	s5, 648(sp)
   159bc: 03 3b 01 28  	ld	s6, 640(sp)
   159c0: 83 3b 81 27  	ld	s7, 632(sp)
   159c4: 03 3c 01 27  	ld	s8, 624(sp)
   159c8: 83 3c 81 26  	ld	s9, 616(sp)
   159cc: 03 3d 01 26  	ld	s10, 608(sp)
   159d0: 83 3d 81 25  	ld	s11, 600(sp)
   159d4: 13 01 01 2c  	addi	sp, sp, 704
   159d8: 82 80        	ret
   159da: 86 7b        	ld	s7, 96(sp)
   159dc: 21 a8        	j	0x159f4 <dwarf.DwarfInfo.getAbbrevTable+0x116a>
;     if (ov[1] != 0) return error.Overflow;
   159de: 88 02        	addi	a0, sp, 320
   159e0: 97 e0 00 00  	auipc	ra, 14
   159e4: e7 80 80 21  	jalr	536(ra)
   159e8: 86 7b        	ld	s7, 96(sp)
;     if (ov[1] != 0) return error.Overflow;
   159ea: 5e 85        	mv	a0, s7
   159ec: 97 e0 00 00  	auipc	ra, 14
   159f0: e7 80 c0 20  	jalr	524(ra)
   159f4: 5e 85        	mv	a0, s7
   159f6: 97 e0 00 00  	auipc	ra, 14
   159fa: e7 80 20 20  	jalr	514(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   159fe: 5e 85        	mv	a0, s7
   15a00: 97 e0 00 00  	auipc	ra, 14
   15a04: e7 80 80 1f  	jalr	504(ra)
;                 const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
   15a08: 5e 85        	mv	a0, s7
   15a0a: 97 e0 00 00  	auipc	ra, 14
   15a0e: e7 80 e0 1e  	jalr	494(ra)
;             return self.ensureTotalCapacityPrecise(better_capacity);
   15a12: 5e 85        	mv	a0, s7
   15a14: 97 e0 00 00  	auipc	ra, 14
   15a18: e7 80 40 1e  	jalr	484(ra)
;             try self.ensureTotalCapacity(self.items.len + 1);
   15a1c: 5e 85        	mv	a0, s7
   15a1e: 97 e0 00 00  	auipc	ra, 14
   15a22: e7 80 a0 1d  	jalr	474(ra)
;             const new_item_ptr = try self.addOne();
   15a26: 5e 85        	mv	a0, s7
   15a28: 97 e0 00 00  	auipc	ra, 14
   15a2c: e7 80 00 1d  	jalr	464(ra)
   15a30: 63 99 0d 00  	bnez	s11, 0x15a42 <dwarf.DwarfInfo.getAbbrevTable+0x11b8>
;             result.deinit();
   15a34: 88 01        	addi	a0, sp, 192
   15a36: 97 f0 ff ff  	auipc	ra, 1048575
   15a3a: e7 80 a0 db  	jalr	-582(ra)
   15a3e: 45 4c        	li	s8, 17
   15a40: 99 b7        	j	0x15986 <dwarf.DwarfInfo.getAbbrevTable+0x10fc>
   15a42: 01 44        	li	s0, 0
   15a44: 81 44        	li	s1, 0
   15a46: e1 4a        	li	s5, 24
   15a48: 31 a0        	j	0x15a54 <dwarf.DwarfInfo.getAbbrevTable+0x11ca>
;                 entry.attrs.deinit();
   15a4a: 85 04        	addi	s1, s1, 1
;             for (result.items) |*entry| {
   15a4c: 13 04 04 04  	addi	s0, s0, 64
   15a50: e3 82 9d fe  	beq	s11, s1, 0x15a34 <dwarf.DwarfInfo.getAbbrevTable+0x11aa>
   15a54: 2e 65        	ld	a0, 200(sp)
   15a56: 63 fb a4 0a  	bgeu	s1, a0, 0x15b0c <dwarf.DwarfInfo.getAbbrevTable+0x1282>
   15a5a: 0e 65        	ld	a0, 192(sp)
;                 self.allocator.free(self.allocatedSlice());
   15a5c: 22 95        	add	a0, a0, s0
   15a5e: 83 39 85 02  	ld	s3, 40(a0)
   15a62: 0c 71        	ld	a1, 32(a0)
   15a64: 03 3b 05 03  	ld	s6, 48(a0)
   15a68: 81 cd        	beqz	a1, 0x15a80 <dwarf.DwarfInfo.getAbbrevTable+0x11f6>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   15a6a: 33 b6 55 03  	mulhu	a2, a1, s5
   15a6e: e3 14 06 86  	bnez	a2, 0x152d6 <dwarf.DwarfInfo.getAbbrevTable+0xa4c>
   15a72: 03 39 05 01  	ld	s2, 16(a0)
   15a76: 33 8a 55 03  	mul	s4, a1, s5
   15a7a: 63 17 0a 00  	bnez	s4, 0x15a88 <dwarf.DwarfInfo.getAbbrevTable+0x11fe>
   15a7e: f1 b7        	j	0x15a4a <dwarf.DwarfInfo.getAbbrevTable+0x11c0>
   15a80: 01 4a        	li	s4, 0
   15a82: 21 49        	li	s2, 8
;     if (bytes_len == 0) return;
   15a84: e3 03 0a fc  	beqz	s4, 0x15a4a <dwarf.DwarfInfo.getAbbrevTable+0x11c0>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   15a88: 63 0c 09 08  	beqz	s2, 0x15b20 <dwarf.DwarfInfo.getAbbrevTable+0x1296>
;     @memset(non_const_ptr, undefined, bytes_len);
   15a8c: 93 05 a0 0a  	li	a1, 170
   15a90: 4a 85        	mv	a0, s2
   15a92: 52 86        	mv	a2, s4
   15a94: 97 f0 00 00  	auipc	ra, 15
   15a98: e7 80 60 80  	jalr	-2042(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   15a9c: 83 37 0b 01  	ld	a5, 16(s6)
   15aa0: 8d 46        	li	a3, 3
   15aa2: 4e 85        	mv	a0, s3
   15aa4: ca 85        	mv	a1, s2
   15aa6: 52 86        	mv	a2, s4
   15aa8: 46 77        	ld	a4, 112(sp)
   15aaa: 82 97        	jalr	a5
   15aac: 79 bf        	j	0x15a4a <dwarf.DwarfInfo.getAbbrevTable+0x11c0>
;     if (ov[1] != 0) return error.Overflow;
   15aae: 88 01        	addi	a0, sp, 192
   15ab0: 97 e0 00 00  	auipc	ra, 14
   15ab4: e7 80 80 14  	jalr	328(ra)
   15ab8: 5e 85        	mv	a0, s7
   15aba: 97 e0 00 00  	auipc	ra, 14
   15abe: e7 80 e0 13  	jalr	318(ra)
   15ac2: 5e 85        	mv	a0, s7
   15ac4: 97 e0 00 00  	auipc	ra, 14
   15ac8: e7 80 40 13  	jalr	308(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   15acc: 5e 85        	mv	a0, s7
   15ace: 97 e0 00 00  	auipc	ra, 14
   15ad2: e7 80 a0 12  	jalr	298(ra)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   15ad6: 5e 85        	mv	a0, s7
   15ad8: 97 e0 00 00  	auipc	ra, 14
   15adc: e7 80 00 12  	jalr	288(ra)
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   15ae0: 5e 85        	mv	a0, s7
   15ae2: 97 e0 00 00  	auipc	ra, 14
   15ae6: e7 80 60 11  	jalr	278(ra)
;             try self.ensureTotalCapacity(allocator, newlen);
   15aea: 5e 85        	mv	a0, s7
   15aec: 97 e0 00 00  	auipc	ra, 14
   15af0: e7 80 c0 10  	jalr	268(ra)
;             const new_item_ptr = try self.addOne(allocator);
   15af4: 5e 85        	mv	a0, s7
   15af6: 97 e0 00 00  	auipc	ra, 14
   15afa: e7 80 20 10  	jalr	258(ra)
;         try di.abbrev_table_list.append(allocator, AbbrevTableHeader{
   15afe: 5e 85        	mv	a0, s7
   15b00: 97 e0 00 00  	auipc	ra, 14
   15b04: e7 80 80 0f  	jalr	248(ra)
   15b08: 45 4c        	li	s8, 17
   15b0a: 41 bd        	j	0x1599a <dwarf.DwarfInfo.getAbbrevTable+0x1110>
   15b0c: 37 15 01 00  	lui	a0, 17
   15b10: 13 05 35 6e  	addi	a0, a0, 1763
   15b14: cd 45        	li	a1, 19
   15b16: 81 46        	li	a3, 0
   15b18: 97 e0 00 00  	auipc	ra, 14
   15b1c: e7 80 20 86  	jalr	-1950(ra)
   15b20: 37 25 01 00  	lui	a0, 18
   15b24: 13 05 a5 86  	addi	a0, a0, -1942
   15b28: f9 45        	li	a1, 30
   15b2a: 81 46        	li	a3, 0
   15b2c: 97 e0 00 00  	auipc	ra, 14
   15b30: e7 80 e0 84  	jalr	-1970(ra)
   15b34: 37 25 01 00  	lui	a0, 18
   15b38: 13 05 b5 a7  	addi	a0, a0, -1413
   15b3c: e1 45        	li	a1, 24
   15b3e: 81 46        	li	a3, 0
   15b40: 97 e0 00 00  	auipc	ra, 14
   15b44: e7 80 a0 83  	jalr	-1990(ra)
   15b48: 37 15 01 00  	lui	a0, 17
   15b4c: 13 05 75 63  	addi	a0, a0, 1591
   15b50: cd 45        	li	a1, 19
   15b52: 81 46        	li	a3, 0
   15b54: 97 e0 00 00  	auipc	ra, 14
   15b58: e7 80 60 82  	jalr	-2010(ra)

0000000000015b5c <leb128.readULEB128__anon_5028>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   15b5c: 39 71        	addi	sp, sp, -64
   15b5e: 06 fc        	sd	ra, 56(sp)
   15b60: 22 f8        	sd	s0, 48(sp)
   15b62: 26 f4        	sd	s1, 40(sp)
   15b64: 4a f0        	sd	s2, 32(sp)
   15b66: 4e ec        	sd	s3, 24(sp)
   15b68: b2 84        	mv	s1, a2
;         const byte = try reader.readByte();
   15b6a: 18 62        	ld	a4, 0(a2)
   15b6c: 2e 89        	mv	s2, a1
   15b6e: aa 89        	mv	s3, a0
   15b70: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15b74: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15b78: 28 00        	addi	a0, sp, 8
   15b7a: 13 06 71 00  	addi	a2, sp, 7
   15b7e: 85 46        	li	a3, 1
   15b80: ba 85        	mv	a1, a4
   15b82: 97 c0 00 00  	auipc	ra, 12
   15b86: e7 80 60 b3  	jalr	-1226(ra)
   15b8a: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15b8c: 63 0a 05 1c  	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15b90: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15b94: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   15b98: 63 59 05 1a  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15b9c: 8c 60        	ld	a1, 0(s1)
   15b9e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15ba2: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15ba6: 28 00        	addi	a0, sp, 8
   15ba8: 13 06 71 00  	addi	a2, sp, 7
   15bac: 85 46        	li	a3, 1
   15bae: 97 c0 00 00  	auipc	ra, 12
   15bb2: e7 80 a0 b0  	jalr	-1270(ra)
   15bb6: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15bb8: 63 04 05 1a  	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15bbc: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15bc0: 93 75 f5 07  	andi	a1, a0, 127
   15bc4: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   15bc6: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15bc8: 63 51 05 18  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15bcc: 8c 60        	ld	a1, 0(s1)
   15bce: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15bd2: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15bd6: 28 00        	addi	a0, sp, 8
   15bd8: 13 06 71 00  	addi	a2, sp, 7
   15bdc: 85 46        	li	a3, 1
   15bde: 97 c0 00 00  	auipc	ra, 12
   15be2: e7 80 a0 ad  	jalr	-1318(ra)
   15be6: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15be8: 63 0c 05 16  	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15bec: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15bf0: 93 75 f5 07  	andi	a1, a0, 127
   15bf4: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   15bf6: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15bf8: 63 59 05 14  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15bfc: 8c 60        	ld	a1, 0(s1)
   15bfe: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15c02: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15c06: 28 00        	addi	a0, sp, 8
   15c08: 13 06 71 00  	addi	a2, sp, 7
   15c0c: 85 46        	li	a3, 1
   15c0e: 97 c0 00 00  	auipc	ra, 12
   15c12: e7 80 a0 aa  	jalr	-1366(ra)
   15c16: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15c18: 63 04 05 14  	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15c1c: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15c20: 93 75 f5 07  	andi	a1, a0, 127
   15c24: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   15c26: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15c28: 63 51 05 12  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15c2c: 8c 60        	ld	a1, 0(s1)
   15c2e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15c32: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15c36: 28 00        	addi	a0, sp, 8
   15c38: 13 06 71 00  	addi	a2, sp, 7
   15c3c: 85 46        	li	a3, 1
   15c3e: 97 c0 00 00  	auipc	ra, 12
   15c42: e7 80 a0 a7  	jalr	-1414(ra)
   15c46: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15c48: 63 0c 05 10  	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15c4c: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15c50: 93 75 f5 07  	andi	a1, a0, 127
   15c54: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   15c56: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15c58: 63 59 05 0e  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15c5c: 8c 60        	ld	a1, 0(s1)
   15c5e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15c62: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15c66: 28 00        	addi	a0, sp, 8
   15c68: 13 06 71 00  	addi	a2, sp, 7
   15c6c: 85 46        	li	a3, 1
   15c6e: 97 c0 00 00  	auipc	ra, 12
   15c72: e7 80 a0 a4  	jalr	-1462(ra)
   15c76: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15c78: 65 c5        	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15c7a: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15c7e: 93 75 f5 07  	andi	a1, a0, 127
   15c82: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   15c84: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15c86: 63 52 05 0c  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15c8a: 8c 60        	ld	a1, 0(s1)
   15c8c: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15c90: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15c94: 28 00        	addi	a0, sp, 8
   15c96: 13 06 71 00  	addi	a2, sp, 7
   15c9a: 85 46        	li	a3, 1
   15c9c: 97 c0 00 00  	auipc	ra, 12
   15ca0: e7 80 c0 a1  	jalr	-1508(ra)
   15ca4: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15ca6: 4d cd        	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15ca8: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15cac: 93 75 f5 07  	andi	a1, a0, 127
   15cb0: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   15cb2: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15cb4: 63 5b 05 08  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15cb8: 8c 60        	ld	a1, 0(s1)
   15cba: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15cbe: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15cc2: 28 00        	addi	a0, sp, 8
   15cc4: 13 06 71 00  	addi	a2, sp, 7
   15cc8: 85 46        	li	a3, 1
   15cca: 97 c0 00 00  	auipc	ra, 12
   15cce: e7 80 e0 9e  	jalr	-1554(ra)
   15cd2: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15cd4: 51 c5        	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15cd6: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15cda: 93 75 f5 07  	andi	a1, a0, 127
   15cde: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   15ce0: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15ce2: 63 54 05 06  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15ce6: 8c 60        	ld	a1, 0(s1)
   15ce8: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15cec: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15cf0: 28 00        	addi	a0, sp, 8
   15cf2: 13 06 71 00  	addi	a2, sp, 7
   15cf6: 85 46        	li	a3, 1
   15cf8: 97 c0 00 00  	auipc	ra, 12
   15cfc: e7 80 00 9c  	jalr	-1600(ra)
   15d00: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15d02: 39 cd        	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15d04: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15d08: 93 75 f5 07  	andi	a1, a0, 127
   15d0c: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   15d0e: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   15d10: 63 5d 05 02  	bgez	a0, 0x15d4a <leb128.readULEB128__anon_5028+0x1ee>
;         const byte = try reader.readByte();
   15d14: 8c 60        	ld	a1, 0(s1)
   15d16: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   15d1a: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   15d1e: 28 00        	addi	a0, sp, 8
   15d20: 13 06 71 00  	addi	a2, sp, 7
   15d24: 85 46        	li	a3, 1
   15d26: 97 c0 00 00  	auipc	ra, 12
   15d2a: e7 80 20 99  	jalr	-1646(ra)
   15d2e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   15d30: 05 c9        	beqz	a0, 0x15d60 <leb128.readULEB128__anon_5028+0x204>
;             return result[0];
   15d32: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   15d36: 93 75 e5 07  	andi	a1, a0, 126
;         if (ov[1] != 0) return error.Overflow;
   15d3a: b1 e1        	bnez	a1, 0x15d7e <leb128.readULEB128__anon_5028+0x222>
   15d3c: 93 15 85 03  	slli	a1, a0, 56
   15d40: e1 95        	srai	a1, a1, 56
;         if (byte & 0x80 == 0) break;
   15d42: 63 ce 05 02  	bltz	a1, 0x15d7e <leb128.readULEB128__anon_5028+0x222>
   15d46: 7e 15        	slli	a0, a0, 63
   15d48: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   15d4a: 23 b0 89 00  	sd	s0, 0(s3)
   15d4e: 23 94 09 00  	sh	zero, 8(s3)
   15d52: e2 70        	ld	ra, 56(sp)
   15d54: 42 74        	ld	s0, 48(sp)
   15d56: a2 74        	ld	s1, 40(sp)
   15d58: 02 79        	ld	s2, 32(sp)
   15d5a: e2 69        	ld	s3, 24(sp)
   15d5c: 21 61        	addi	sp, sp, 64
   15d5e: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   15d60: 4a 85        	mv	a0, s2
   15d62: 97 e0 00 00  	auipc	ra, 14
   15d66: e7 80 60 e9  	jalr	-362(ra)
;         const byte = try reader.readByte();
   15d6a: 4a 85        	mv	a0, s2
   15d6c: 97 e0 00 00  	auipc	ra, 14
   15d70: e7 80 c0 e8  	jalr	-372(ra)
   15d74: 13 05 10 03  	li	a0, 49
   15d78: 23 94 a9 00  	sh	a0, 8(s3)
   15d7c: d9 bf        	j	0x15d52 <leb128.readULEB128__anon_5028+0x1f6>
   15d7e: 4a 85        	mv	a0, s2
   15d80: 97 e0 00 00  	auipc	ra, 14
   15d84: e7 80 80 e7  	jalr	-392(ra)
   15d88: 13 05 00 03  	li	a0, 48
   15d8c: 23 b4 a9 00  	sd	a0, 8(s3)
   15d90: 23 b0 09 00  	sd	zero, 0(s3)
   15d94: 7d bf        	j	0x15d52 <leb128.readULEB128__anon_5028+0x1f6>

0000000000015d96 <dwarf.DwarfInfo.parseDie__anon_5027>:
;     ) !?Die {
   15d96: 69 71        	addi	sp, sp, -304
   15d98: 06 f6        	sd	ra, 296(sp)
   15d9a: 22 f2        	sd	s0, 288(sp)
   15d9c: 26 ee        	sd	s1, 280(sp)
   15d9e: 4a ea        	sd	s2, 272(sp)
   15da0: 4e e6        	sd	s3, 264(sp)
   15da2: 52 e2        	sd	s4, 256(sp)
   15da4: d6 fd        	sd	s5, 248(sp)
   15da6: da f9        	sd	s6, 240(sp)
   15da8: de f5        	sd	s7, 232(sp)
   15daa: e2 f1        	sd	s8, 224(sp)
   15dac: e6 ed        	sd	s9, 216(sp)
   15dae: ea e9        	sd	s10, 208(sp)
   15db0: ee e5        	sd	s11, 200(sp)
   15db2: 42 e8        	sd	a6, 16(sp)
   15db4: 3e 8b        	mv	s6, a5
   15db6: 3a 8c        	mv	s8, a4
   15db8: b6 8a        	mv	s5, a3
   15dba: 32 e4        	sd	a2, 8(sp)
   15dbc: aa 89        	mv	s3, a0
;         const abbrev_code = try leb.readULEB128(u64, in_stream);
   15dbe: 08 10        	addi	a0, sp, 32
   15dc0: 2e ec        	sd	a1, 24(sp)
   15dc2: 3a 86        	mv	a2, a4
   15dc4: 97 00 00 00  	auipc	ra, 0
   15dc8: e7 80 80 d9  	jalr	-616(ra)
   15dcc: 03 54 81 02  	lhu	s0, 40(sp)
   15dd0: 63 1e 04 1c  	bnez	s0, 0x15fac <dwarf.DwarfInfo.parseDie__anon_5027+0x216>
   15dd4: 02 75        	ld	a0, 32(sp)
;         if (abbrev_code == 0) return null;
   15dd6: 4d c1        	beqz	a0, 0x15e78 <dwarf.DwarfInfo.parseDie__anon_5027+0xe2>
;     for (abbrev_table.items) |*table_entry| {
   15dd8: 83 35 8b 00  	ld	a1, 8(s6)
   15ddc: 91 c9        	beqz	a1, 0x15df0 <dwarf.DwarfInfo.parseDie__anon_5027+0x5a>
   15dde: 83 34 0b 00  	ld	s1, 0(s6)
;         if (table_entry.abbrev_code == abbrev_code) return table_entry;
   15de2: 90 60        	ld	a2, 0(s1)
   15de4: 63 03 a6 04  	beq	a2, a0, 0x15e2a <dwarf.DwarfInfo.parseDie__anon_5027+0x94>
;     for (abbrev_table.items) |*table_entry| {
   15de8: fd 15        	addi	a1, a1, -1
   15dea: 93 84 04 04  	addi	s1, s1, 64
   15dee: f5 f9        	bnez	a1, 0x15de2 <dwarf.DwarfInfo.parseDie__anon_5027+0x4c>
   15df0: 62 64        	ld	s0, 24(sp)
;     return error.InvalidDebugInfo;
   15df2: 22 85        	mv	a0, s0
   15df4: 97 e0 00 00  	auipc	ra, 14
   15df8: e7 80 40 e0  	jalr	-508(ra)
   15dfc: 13 05 20 03  	li	a0, 50
;         const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return badDwarf();
   15e00: 23 98 a9 04  	sh	a0, 80(s3)
   15e04: 22 85        	mv	a0, s0
   15e06: b2 70        	ld	ra, 296(sp)
   15e08: 12 74        	ld	s0, 288(sp)
   15e0a: f2 64        	ld	s1, 280(sp)
   15e0c: 52 69        	ld	s2, 272(sp)
   15e0e: b2 69        	ld	s3, 264(sp)
   15e10: 12 6a        	ld	s4, 256(sp)
   15e12: ee 7a        	ld	s5, 248(sp)
   15e14: 4e 7b        	ld	s6, 240(sp)
   15e16: ae 7b        	ld	s7, 232(sp)
   15e18: 0e 7c        	ld	s8, 224(sp)
   15e1a: ee 6c        	ld	s9, 216(sp)
   15e1c: 4e 6d        	ld	s10, 208(sp)
   15e1e: ae 6d        	ld	s11, 200(sp)
   15e20: 55 61        	addi	sp, sp, 304
   15e22: 17 e3 00 00  	auipc	t1, 14
   15e26: 67 00 63 dd  	jr	-554(t1)
;             return .{
   15e2a: 03 b5 0a 00  	ld	a0, 0(s5)
   15e2e: 83 b5 8a 00  	ld	a1, 8(s5)
;         return (State{}).promote(child_allocator);
   15e32: 2a f8        	sd	a0, 48(sp)
   15e34: 2e fc        	sd	a1, 56(sp)
   15e36: 82 e0        	sd	zero, 64(sp)
   15e38: 82 e4        	sd	zero, 72(sp)
;             .tag_id = table_entry.tag_id,
   15e3a: 88 64        	ld	a0, 8(s1)
   15e3c: aa e8        	sd	a0, 80(sp)
;             .has_children = table_entry.has_children,
   15e3e: 03 c5 84 03  	lbu	a0, 56(s1)
   15e42: b7 55 02 00  	lui	a1, 37
   15e46: 83 b5 05 34  	ld	a1, 832(a1)
   15e4a: 05 89        	andi	a0, a0, 1
   15e4c: 23 08 a1 06  	sb	a0, 112(sp)
   15e50: ae ec        	sd	a1, 88(sp)
   15e52: 82 f0        	sd	zero, 96(sp)
   15e54: 82 f4        	sd	zero, 104(sp)
;         try result.attrs.resize(allocator, table_entry.attrs.items.len);
   15e56: 80 6c        	ld	s0, 24(s1)
;             if (self.capacity >= new_capacity) return;
   15e58: 2d c0        	beqz	s0, 0x15eba <dwarf.DwarfInfo.parseDie__anon_5027+0x124>
   15e5a: 81 46        	li	a3, 0
   15e5c: ac 08        	addi	a1, sp, 88
   15e5e: 19 a0        	j	0x15e64 <dwarf.DwarfInfo.parseDie__anon_5027+0xce>
;                 if (better_capacity >= new_capacity) break;
   15e60: 63 f2 86 04  	bgeu	a3, s0, 0x15ea4 <dwarf.DwarfInfo.parseDie__anon_5027+0x10e>
   15e64: 36 86        	mv	a2, a3
;                 better_capacity +|= better_capacity / 2 + 8;
   15e66: 13 d5 16 00  	srli	a0, a3, 1
   15e6a: 36 95        	add	a0, a0, a3
   15e6c: 21 05        	addi	a0, a0, 8
   15e6e: fd 56        	li	a3, -1
   15e70: e3 68 c5 fe  	bltu	a0, a2, 0x15e60 <dwarf.DwarfInfo.parseDie__anon_5027+0xca>
   15e74: aa 86        	mv	a3, a0
   15e76: ed b7        	j	0x15e60 <dwarf.DwarfInfo.parseDie__anon_5027+0xca>
;         if (abbrev_code == 0) return null;
   15e78: 13 06 80 05  	li	a2, 88
   15e7c: 4e 85        	mv	a0, s3
   15e7e: 81 45        	li	a1, 0
   15e80: b2 70        	ld	ra, 296(sp)
   15e82: 12 74        	ld	s0, 288(sp)
   15e84: f2 64        	ld	s1, 280(sp)
   15e86: 52 69        	ld	s2, 272(sp)
   15e88: b2 69        	ld	s3, 264(sp)
   15e8a: 12 6a        	ld	s4, 256(sp)
   15e8c: ee 7a        	ld	s5, 248(sp)
   15e8e: 4e 7b        	ld	s6, 240(sp)
   15e90: ae 7b        	ld	s7, 232(sp)
   15e92: 0e 7c        	ld	s8, 224(sp)
   15e94: ee 6c        	ld	s9, 216(sp)
   15e96: 4e 6d        	ld	s10, 208(sp)
   15e98: ae 6d        	ld	s11, 200(sp)
   15e9a: 55 61        	addi	sp, sp, 304
   15e9c: 17 e3 00 00  	auipc	t1, 14
   15ea0: 67 00 e3 3f  	jr	1022(t1)
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   15ea4: 62 65        	ld	a0, 24(sp)
   15ea6: 56 86        	mv	a2, s5
   15ea8: 97 d0 00 00  	auipc	ra, 13
   15eac: e7 80 e0 b0  	jalr	-1266(ra)
   15eb0: 2a 89        	mv	s2, a0
   15eb2: 42 15        	slli	a0, a0, 48
   15eb4: 41 91        	srli	a0, a0, 48
   15eb6: 63 13 05 10  	bnez	a0, 0x15fbc <dwarf.DwarfInfo.parseDie__anon_5027+0x226>
   15eba: 4e e0        	sd	s3, 0(sp)
;             self.items.len = new_len;
   15ebc: a2 f0        	sd	s0, 96(sp)
;         for (table_entry.attrs.items) |attr, i| {
   15ebe: 83 ba 84 01  	ld	s5, 24(s1)
   15ec2: 63 88 0a 0a  	beqz	s5, 0x15f72 <dwarf.DwarfInfo.parseDie__anon_5027+0x1dc>
   15ec6: 88 68        	ld	a0, 16(s1)
   15ec8: 01 4b        	li	s6, 0
   15eca: 01 44        	li	s0, 0
;         for (table_entry.attrs.items) |attr, i| {
   15ecc: 93 04 05 01  	addi	s1, a0, 16
   15ed0: 13 0d 01 03  	addi	s10, sp, 48
   15ed4: 37 15 01 00  	lui	a0, 17
   15ed8: 93 0d 05 02  	addi	s11, a0, 32
   15edc: 13 09 10 02  	li	s2, 33
   15ee0: 09 a8        	j	0x15ef2 <dwarf.DwarfInfo.parseDie__anon_5027+0x15c>
;                 result.attrs.items[i].value.Const.payload = @bitCast(u64, attr.payload);
   15ee2: 23 34 35 01  	sd	s3, 8(a0)
   15ee6: 05 04        	addi	s0, s0, 1
;         for (table_entry.attrs.items) |attr, i| {
   15ee8: e1 04        	addi	s1, s1, 24
   15eea: 13 0b 0b 02  	addi	s6, s6, 32
   15eee: 63 82 8a 08  	beq	s5, s0, 0x15f72 <dwarf.DwarfInfo.parseDie__anon_5027+0x1dc>
;             result.attrs.items[i] = Die.Attr{
   15ef2: 06 75        	ld	a0, 96(sp)
   15ef4: 63 70 a4 10  	bgeu	s0, a0, 0x15ff4 <dwarf.DwarfInfo.parseDie__anon_5027+0x25e>
   15ef8: 66 65        	ld	a0, 88(sp)
;         for (table_entry.attrs.items) |attr, i| {
   15efa: 83 b5 04 ff  	ld	a1, -16(s1)
   15efe: 83 bc 84 ff  	ld	s9, -8(s1)
   15f02: 83 b9 04 00  	ld	s3, 0(s1)
;                 .id = attr.attr_id,
   15f06: 33 0a 65 01  	add	s4, a0, s6
   15f0a: 23 30 ba 00  	sd	a1, 0(s4)
;         return .{
   15f0e: ea fc        	sd	s10, 120(sp)
   15f10: 6e e1        	sd	s11, 128(sp)
;                     di.endian,
   15f12: 22 65        	ld	a0, 8(sp)
   15f14: 83 07 85 10  	lb	a5, 264(a0)
   15f18: 28 01        	addi	a0, sp, 136
   15f1a: b0 18        	addi	a2, sp, 120
   15f1c: e2 65        	ld	a1, 24(sp)
   15f1e: e2 86        	mv	a3, s8
   15f20: 66 87        	mv	a4, s9
   15f22: 42 68        	ld	a6, 16(sp)
   15f24: 97 00 00 00  	auipc	ra, 0
   15f28: e7 80 40 0e  	jalr	228(ra)
   15f2c: 83 5b 01 0a  	lhu	s7, 160(sp)
   15f30: 63 99 0b 0a  	bnez	s7, 0x15fe2 <dwarf.DwarfInfo.parseDie__anon_5027+0x24c>
;                 .value = try parseFormValue(
   15f34: 6a 65        	ld	a0, 152(sp)
   15f36: 23 3c aa 00  	sd	a0, 24(s4)
   15f3a: 4a 65        	ld	a0, 144(sp)
   15f3c: 23 38 aa 00  	sd	a0, 16(s4)
   15f40: 2a 65        	ld	a0, 136(sp)
   15f42: 23 34 aa 00  	sd	a0, 8(s4)
;             if (attr.form_id == FORM.implicit_const) {
   15f46: e3 90 2c fb  	bne	s9, s2, 0x15ee6 <dwarf.DwarfInfo.parseDie__anon_5027+0x150>
;                 result.attrs.items[i].value.Const.payload = @bitCast(u64, attr.payload);
   15f4a: 06 75        	ld	a0, 96(sp)
   15f4c: 63 74 a4 0a  	bgeu	s0, a0, 0x15ff4 <dwarf.DwarfInfo.parseDie__anon_5027+0x25e>
   15f50: 66 65        	ld	a0, 88(sp)
   15f52: 5a 95        	add	a0, a0, s6
   15f54: 83 45 85 01  	lbu	a1, 24(a0)
   15f58: 0d 46        	li	a2, 3
   15f5a: e3 84 c5 f8  	beq	a1, a2, 0x15ee2 <dwarf.DwarfInfo.parseDie__anon_5027+0x14c>
   15f5e: 37 25 01 00  	lui	a0, 18
   15f62: 13 05 a5 aa  	addi	a0, a0, -1366
   15f66: f9 45        	li	a1, 30
   15f68: 81 46        	li	a3, 0
   15f6a: 97 d0 00 00  	auipc	ra, 13
   15f6e: e7 80 00 41  	jalr	1040(ra)
;         return result;
   15f72: 0c 18        	addi	a1, sp, 48
   15f74: 13 06 80 04  	li	a2, 72
   15f78: 02 64        	ld	s0, 0(sp)
   15f7a: 22 85        	mv	a0, s0
   15f7c: 97 e0 00 00  	auipc	ra, 14
   15f80: e7 80 80 2f  	jalr	760(ra)
   15f84: 05 45        	li	a0, 1
   15f86: 23 04 a4 04  	sb	a0, 72(s0)
   15f8a: 23 18 04 04  	sh	zero, 80(s0)
   15f8e: b2 70        	ld	ra, 296(sp)
   15f90: 12 74        	ld	s0, 288(sp)
   15f92: f2 64        	ld	s1, 280(sp)
   15f94: 52 69        	ld	s2, 272(sp)
   15f96: b2 69        	ld	s3, 264(sp)
   15f98: 12 6a        	ld	s4, 256(sp)
   15f9a: ee 7a        	ld	s5, 248(sp)
   15f9c: 4e 7b        	ld	s6, 240(sp)
   15f9e: ae 7b        	ld	s7, 232(sp)
   15fa0: 0e 7c        	ld	s8, 224(sp)
   15fa2: ee 6c        	ld	s9, 216(sp)
   15fa4: 4e 6d        	ld	s10, 208(sp)
   15fa6: ae 6d        	ld	s11, 200(sp)
   15fa8: 55 61        	addi	sp, sp, 304
   15faa: 82 80        	ret
;         const abbrev_code = try leb.readULEB128(u64, in_stream);
   15fac: 62 65        	ld	a0, 24(sp)
   15fae: 97 e0 00 00  	auipc	ra, 14
   15fb2: e7 80 a0 c4  	jalr	-950(ra)
   15fb6: 23 98 89 04  	sh	s0, 80(s3)
   15fba: d1 bf        	j	0x15f8e <dwarf.DwarfInfo.parseDie__anon_5027+0x1f8>
   15fbc: 62 64        	ld	s0, 24(sp)
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   15fbe: 22 85        	mv	a0, s0
   15fc0: 97 e0 00 00  	auipc	ra, 14
   15fc4: e7 80 80 c3  	jalr	-968(ra)
;             try self.ensureTotalCapacity(allocator, new_len);
   15fc8: 22 85        	mv	a0, s0
   15fca: 97 e0 00 00  	auipc	ra, 14
   15fce: e7 80 e0 c2  	jalr	-978(ra)
;         try result.attrs.resize(allocator, table_entry.attrs.items.len);
   15fd2: 22 85        	mv	a0, s0
   15fd4: 97 e0 00 00  	auipc	ra, 14
   15fd8: e7 80 40 c2  	jalr	-988(ra)
   15fdc: 23 98 29 05  	sh	s2, 80(s3)
   15fe0: 7d b7        	j	0x15f8e <dwarf.DwarfInfo.parseDie__anon_5027+0x1f8>
;                 .value = try parseFormValue(
   15fe2: 62 65        	ld	a0, 24(sp)
   15fe4: 97 e0 00 00  	auipc	ra, 14
   15fe8: e7 80 40 c1  	jalr	-1004(ra)
   15fec: 02 65        	ld	a0, 0(sp)
   15fee: 23 18 75 05  	sh	s7, 80(a0)
   15ff2: 71 bf        	j	0x15f8e <dwarf.DwarfInfo.parseDie__anon_5027+0x1f8>
   15ff4: 37 15 01 00  	lui	a0, 17
   15ff8: 13 05 35 6e  	addi	a0, a0, 1763
   15ffc: cd 45        	li	a1, 19
   15ffe: 81 46        	li	a3, 0
   16000: 97 d0 00 00  	auipc	ra, 13
   16004: e7 80 a0 37  	jalr	890(ra)

0000000000016008 <dwarf.parseFormValue__anon_5029>:
; fn parseFormValue(allocator: mem.Allocator, in_stream: anytype, form_id: u64, endian: std.builtin.Endian, is_64: bool) anyerror!FormValue {
   16008: 09 71        	addi	sp, sp, -384
;     return switch (form_id) {
   1600a: 86 fe        	sd	ra, 376(sp)
   1600c: a2 fa        	sd	s0, 368(sp)
   1600e: a6 f6        	sd	s1, 360(sp)
   16010: ca f2        	sd	s2, 352(sp)
   16012: ce ee        	sd	s3, 344(sp)
   16014: d2 ea        	sd	s4, 336(sp)
   16016: d6 e6        	sd	s5, 328(sp)
   16018: da e2        	sd	s6, 320(sp)
   1601a: 5e fe        	sd	s7, 312(sp)
   1601c: 62 fa        	sd	s8, 304(sp)
   1601e: 93 04 f7 ff  	addi	s1, a4, -1
   16022: 13 04 b0 02  	li	s0, 43
   16026: 2e 89        	mv	s2, a1
   16028: aa 89        	mv	s3, a0
;     return switch (form_id) {
   1602a: 63 74 94 00  	bgeu	s0, s1, 0x16032 <dwarf.parseFormValue__anon_5029+0x2a>
   1602e: 6f 10 80 0a  	j	0x170d6 <.LBB29_231>
   16032: c2 8b        	mv	s7, a6
   16034: 3e 8a        	mv	s4, a5
   16036: b6 8a        	mv	s5, a3
   16038: 32 8b        	mv	s6, a2
   1603a: 13 95 24 00  	slli	a0, s1, 2
   1603e: b7 05 01 00  	lui	a1, 16
   16042: 93 85 c5 45  	addi	a1, a1, 1116
   16046: 2e 95        	add	a0, a0, a1
   16048: 08 41        	lw	a0, 0(a0)
   1604a: 02 85        	jr	a0

000000000001604c <.LBB29_2>:
;             const signed = form_id == FORM.sdata;
   1604c: 13 05 37 ff  	addi	a0, a4, -13
   16050: 13 35 15 00  	seqz	a0, a0
   16054: b5 45        	li	a1, 13
;     return FormValue{
   16056: 23 0c a1 0e  	sb	a0, 248(sp)
;                     if (signed) {
   1605a: e3 17 b7 68  	bne	a4, a1, 0x16ee8 <.LBB29_190+0x86>
;         const byte = try reader.readByte();
   1605e: 83 b5 0a 00  	ld	a1, 0(s5)
   16062: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   16066: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   1606a: 08 0a        	addi	a0, sp, 272
   1606c: 13 06 f1 12  	addi	a2, sp, 303
   16070: 85 46        	li	a3, 1
   16072: 97 b0 00 00  	auipc	ra, 11
   16076: e7 80 60 64  	jalr	1606(ra)
   1607a: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1607c: 19 e1        	bnez	a0, 0x16082 <.LBB29_2+0x36>
   1607e: 6f 10 a0 28  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   16082: 83 45 f1 12  	lbu	a1, 303(sp)
   16086: 13 95 85 03  	slli	a0, a1, 56
   1608a: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   1608c: 13 f4 f5 07  	andi	s0, a1, 127
   16090: 9d 45        	li	a1, 7
;         if (byte & 0x80 == 0) {
   16092: 63 59 05 1e  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   16096: 83 b5 0a 00  	ld	a1, 0(s5)
   1609a: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1609e: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   160a2: 08 0a        	addi	a0, sp, 272
   160a4: 13 06 f1 12  	addi	a2, sp, 303
   160a8: 85 46        	li	a3, 1
   160aa: 97 b0 00 00  	auipc	ra, 11
   160ae: e7 80 e0 60  	jalr	1550(ra)
   160b2: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   160b4: 19 e1        	bnez	a0, 0x160ba <.LBB29_2+0x6e>
   160b6: 6f 10 20 25  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   160ba: 83 45 f1 12  	lbu	a1, 303(sp)
   160be: 13 95 85 03  	slli	a0, a1, 56
   160c2: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   160c4: 93 f5 f5 07  	andi	a1, a1, 127
   160c8: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   160ca: 4d 8c        	or	s0, s0, a1
   160cc: b9 45        	li	a1, 14
;         if (byte & 0x80 == 0) {
   160ce: 63 5b 05 1a  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   160d2: 83 b5 0a 00  	ld	a1, 0(s5)
   160d6: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   160da: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   160de: 08 0a        	addi	a0, sp, 272
   160e0: 13 06 f1 12  	addi	a2, sp, 303
   160e4: 85 46        	li	a3, 1
   160e6: 97 b0 00 00  	auipc	ra, 11
   160ea: e7 80 20 5d  	jalr	1490(ra)
   160ee: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   160f0: 19 e1        	bnez	a0, 0x160f6 <.LBB29_2+0xaa>
   160f2: 6f 10 60 21  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   160f6: 83 45 f1 12  	lbu	a1, 303(sp)
   160fa: 13 95 85 03  	slli	a0, a1, 56
   160fe: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   16100: 93 f5 f5 07  	andi	a1, a1, 127
   16104: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   16106: 4d 8c        	or	s0, s0, a1
   16108: d5 45        	li	a1, 21
;         if (byte & 0x80 == 0) {
   1610a: 63 5d 05 16  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   1610e: 83 b5 0a 00  	ld	a1, 0(s5)
   16112: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   16116: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   1611a: 08 0a        	addi	a0, sp, 272
   1611c: 13 06 f1 12  	addi	a2, sp, 303
   16120: 85 46        	li	a3, 1
   16122: 97 b0 00 00  	auipc	ra, 11
   16126: e7 80 60 59  	jalr	1430(ra)
   1612a: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1612c: 19 e1        	bnez	a0, 0x16132 <.LBB29_2+0xe6>
   1612e: 6f 10 a0 1d  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   16132: 83 45 f1 12  	lbu	a1, 303(sp)
   16136: 13 95 85 03  	slli	a0, a1, 56
   1613a: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   1613c: 93 f5 f5 07  	andi	a1, a1, 127
   16140: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   16142: 4d 8c        	or	s0, s0, a1
   16144: f1 45        	li	a1, 28
;         if (byte & 0x80 == 0) {
   16146: 63 5f 05 12  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   1614a: 83 b5 0a 00  	ld	a1, 0(s5)
   1614e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   16152: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   16156: 08 0a        	addi	a0, sp, 272
   16158: 13 06 f1 12  	addi	a2, sp, 303
   1615c: 85 46        	li	a3, 1
   1615e: 97 b0 00 00  	auipc	ra, 11
   16162: e7 80 a0 55  	jalr	1370(ra)
   16166: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   16168: 19 e1        	bnez	a0, 0x1616e <.LBB29_2+0x122>
   1616a: 6f 10 e0 19  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   1616e: 83 45 f1 12  	lbu	a1, 303(sp)
   16172: 13 95 85 03  	slli	a0, a1, 56
   16176: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   16178: 93 f5 f5 07  	andi	a1, a1, 127
   1617c: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   1617e: 4d 8c        	or	s0, s0, a1
   16180: 93 05 30 02  	li	a1, 35
;         if (byte & 0x80 == 0) {
   16184: 63 50 05 10  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   16188: 83 b5 0a 00  	ld	a1, 0(s5)
   1618c: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   16190: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   16194: 08 0a        	addi	a0, sp, 272
   16196: 13 06 f1 12  	addi	a2, sp, 303
   1619a: 85 46        	li	a3, 1
   1619c: 97 b0 00 00  	auipc	ra, 11
   161a0: e7 80 c0 51  	jalr	1308(ra)
   161a4: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   161a6: 19 e1        	bnez	a0, 0x161ac <.LBB29_2+0x160>
   161a8: 6f 10 00 16  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   161ac: 83 45 f1 12  	lbu	a1, 303(sp)
   161b0: 13 95 85 03  	slli	a0, a1, 56
   161b4: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   161b6: 93 f5 f5 07  	andi	a1, a1, 127
   161ba: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   161bc: 4d 8c        	or	s0, s0, a1
   161be: 93 05 a0 02  	li	a1, 42
;         if (byte & 0x80 == 0) {
   161c2: 63 51 05 0c  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   161c6: 83 b5 0a 00  	ld	a1, 0(s5)
   161ca: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   161ce: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   161d2: 08 0a        	addi	a0, sp, 272
   161d4: 13 06 f1 12  	addi	a2, sp, 303
   161d8: 85 46        	li	a3, 1
   161da: 97 b0 00 00  	auipc	ra, 11
   161de: e7 80 e0 4d  	jalr	1246(ra)
   161e2: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   161e4: 19 e1        	bnez	a0, 0x161ea <.LBB29_2+0x19e>
   161e6: 6f 10 20 12  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   161ea: 83 45 f1 12  	lbu	a1, 303(sp)
   161ee: 13 95 85 03  	slli	a0, a1, 56
   161f2: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   161f4: 93 f5 f5 07  	andi	a1, a1, 127
   161f8: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   161fa: 4d 8c        	or	s0, s0, a1
   161fc: 93 05 10 03  	li	a1, 49
;         if (byte & 0x80 == 0) {
   16200: 63 52 05 08  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   16204: 83 b5 0a 00  	ld	a1, 0(s5)
   16208: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1620c: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   16210: 08 0a        	addi	a0, sp, 272
   16212: 13 06 f1 12  	addi	a2, sp, 303
   16216: 85 46        	li	a3, 1
   16218: 97 b0 00 00  	auipc	ra, 11
   1621c: e7 80 00 4a  	jalr	1184(ra)
   16220: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   16222: 19 e1        	bnez	a0, 0x16228 <.LBB29_2+0x1dc>
   16224: 6f 10 40 0e  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   16228: 83 45 f1 12  	lbu	a1, 303(sp)
   1622c: 13 95 85 03  	slli	a0, a1, 56
   16230: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   16232: 93 f5 f5 07  	andi	a1, a1, 127
   16236: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   16238: 4d 8c        	or	s0, s0, a1
   1623a: 93 05 80 03  	li	a1, 56
;         if (byte & 0x80 == 0) {
   1623e: 63 53 05 04  	bgez	a0, 0x16284 <.LBB29_2+0x238>
;         const byte = try reader.readByte();
   16242: 83 b5 0a 00  	ld	a1, 0(s5)
   16246: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1624a: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   1624e: 08 0a        	addi	a0, sp, 272
   16250: 13 06 f1 12  	addi	a2, sp, 303
   16254: 85 46        	li	a3, 1
   16256: 97 b0 00 00  	auipc	ra, 11
   1625a: e7 80 20 46  	jalr	1122(ra)
   1625e: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   16260: 19 e1        	bnez	a0, 0x16266 <.LBB29_2+0x21a>
   16262: 6f 10 60 0a  	j	0x17308 <.LBB29_231+0x232>
;             return result[0];
   16266: 83 45 f1 12  	lbu	a1, 303(sp)
   1626a: 13 95 85 03  	slli	a0, a1, 56
   1626e: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   16270: 93 f5 f5 07  	andi	a1, a1, 127
   16274: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   16276: 4d 8c        	or	s0, s0, a1
   16278: 93 05 f0 03  	li	a1, 63
;         if (byte & 0x80 == 0) {
   1627c: 63 54 05 00  	bgez	a0, 0x16284 <.LBB29_2+0x238>
   16280: 6f 10 c0 03  	j	0x172bc <.LBB29_231+0x1e6>
;             if (byte & 0x40 != 0 and needs_sign_ext) {
   16284: 13 75 05 04  	andi	a0, a0, 64
   16288: e3 0c 05 46  	beqz	a0, 0x16f00 <.LBB29_190+0x9e>
   1628c: 7d 55        	li	a0, -1
;                 value |= @bitCast(U, ones) << (shift + 7);
   1628e: 33 15 b5 00  	sll	a0, a0, a1
   16292: 49 8c        	or	s0, s0, a0
   16294: 6f 00 d0 46  	j	0x16f00 <.LBB29_190+0x9e>

0000000000016298 <.LBB29_23>:
   16298: 37 55 02 00  	lui	a0, 37
   1629c: 03 35 85 34  	ld	a0, 840(a0)
   162a0: 01 44        	li	s0, 0
;     return switch (form_id) {
   162a2: 23 9c 09 00  	sh	zero, 24(s3)
;         try in_stream.readInt(u64, endian)
   162a6: 03 bb 0a 00  	ld	s6, 0(s5)
;             var bytes: [num_bytes]u8 = undefined;
   162aa: 2a e2        	sd	a0, 256(sp)
   162ac: 93 0a 01 10  	addi	s5, sp, 256
   162b0: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   162b2: 33 86 8a 00  	add	a2, s5, s0
   162b6: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   162ba: 08 0a        	addi	a0, sp, 272
   162bc: da 85        	mv	a1, s6
   162be: 97 b0 00 00  	auipc	ra, 11
   162c2: e7 80 a0 3f  	jalr	1018(ra)
   162c6: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   162c8: e3 01 05 62  	beqz	a0, 0x170ea <.LBB29_231+0x14>
;                 index += amt;
   162cc: 22 95        	add	a0, a0, s0
   162ce: 63 74 85 00  	bgeu	a0, s0, 0x162d6 <.LBB29_23+0x3e>
   162d2: 6f 00 70 7d  	j	0x172a8 <.LBB29_231+0x1d2>
   162d6: 2a 84        	mv	s0, a0
;             while (index < len) {
   162d8: e3 6d 95 fc  	bltu	a0, s1, 0x162b2 <.LBB29_23+0x1a>
;             return bytes;
   162dc: 12 65        	ld	a0, 256(sp)
;     if (endian == native_endian) {
   162de: 93 75 1a 00  	andi	a1, s4, 1
   162e2: a9 e9        	bnez	a1, 0x16334 <.LBB29_23+0x9c>
   162e4: 93 55 85 01  	srli	a1, a0, 24
   162e8: 37 06 ff 00  	lui	a2, 4080
   162ec: f1 8d        	and	a1, a1, a2
   162ee: 13 56 85 00  	srli	a2, a0, 8
   162f2: 93 06 f0 0f  	li	a3, 255
   162f6: 13 97 86 01  	slli	a4, a3, 24
   162fa: 79 8e        	and	a2, a2, a4
   162fc: d1 8d        	or	a1, a1, a2
   162fe: 13 56 85 02  	srli	a2, a0, 40
   16302: 41 67        	lui	a4, 16
   16304: 1b 07 07 f0  	addiw	a4, a4, -256
   16308: 79 8e        	and	a2, a2, a4
   1630a: 13 57 85 03  	srli	a4, a0, 56
   1630e: 59 8e        	or	a2, a2, a4
   16310: d1 8d        	or	a1, a1, a2
   16312: 13 16 85 01  	slli	a2, a0, 24
   16316: 13 97 86 02  	slli	a4, a3, 40
   1631a: 79 8e        	and	a2, a2, a4
   1631c: 1b 57 85 01  	srliw	a4, a0, 24
   16320: 02 17        	slli	a4, a4, 32
   16322: 59 8e        	or	a2, a2, a4
   16324: 13 17 85 02  	slli	a4, a0, 40
   16328: c2 16        	slli	a3, a3, 48
   1632a: f9 8e        	and	a3, a3, a4
   1632c: 62 15        	slli	a0, a0, 56
   1632e: 55 8d        	or	a0, a0, a3
   16330: 51 8d        	or	a0, a0, a2
   16332: 4d 8d        	or	a0, a0, a1
;         FORM.addr => FormValue{ .Address = try readAddress(in_stream, endian, @sizeOf(usize) == 8) },
   16334: 23 b0 a9 00  	sd	a0, 0(s3)
   16338: 23 88 09 00  	sb	zero, 16(s3)
;     return switch (form_id) {
   1633c: 03 d5 89 01  	lhu	a0, 24(s3)
   16340: e3 0e 05 4e  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16344: 6f 00 90 7f  	j	0x1733c <.LBB29_231+0x266>

0000000000016348 <.LBB29_30>:
   16348: 37 55 02 00  	lui	a0, 37
   1634c: 03 35 85 34  	ld	a0, 840(a0)
   16350: 81 44        	li	s1, 0
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   16352: 03 b4 0a 00  	ld	s0, 0(s5)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   16356: 2a e2        	sd	a0, 256(sp)
   16358: 93 0b 01 10  	addi	s7, sp, 256
   1635c: 09 4c        	li	s8, 2
;                 const amt = try self.read(buffer[index..]);
   1635e: 33 86 9b 00  	add	a2, s7, s1
   16362: b3 06 9c 40  	sub	a3, s8, s1
;             return readFn(self.context, buffer);
   16366: 08 0a        	addi	a0, sp, 272
   16368: a2 85        	mv	a1, s0
   1636a: 97 b0 00 00  	auipc	ra, 11
   1636e: e7 80 e0 34  	jalr	846(ra)
   16372: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16374: e3 04 05 52  	beqz	a0, 0x1709c <.LBB29_190+0x23a>
;                 index += amt;
   16378: 26 95        	add	a0, a0, s1
   1637a: e3 67 95 72  	bltu	a0, s1, 0x172a8 <.LBB29_231+0x1d2>
   1637e: aa 84        	mv	s1, a0
;             while (index < len) {
   16380: e3 6f 85 fd  	bltu	a0, s8, 0x1635e <.LBB29_30+0x16>
   16384: 03 45 01 10  	lbu	a0, 256(sp)
;     switch (endian) {
   16388: 93 75 1a 00  	andi	a1, s4, 1
   1638c: e3 8b 05 42  	beqz	a1, 0x16fc2 <.LBB29_190+0x160>
;             for (bytes) |b, index| {
   16390: 83 45 11 10  	lbu	a1, 257(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   16394: a2 05        	slli	a1, a1, 8
   16396: 33 e7 a5 00  	or	a4, a1, a0
   1639a: 6f 00 30 43  	j	0x16fcc <.LBB29_190+0x16a>

000000000001639e <.LBB29_36>:
   1639e: 37 55 02 00  	lui	a0, 37
   163a2: 03 35 85 34  	ld	a0, 840(a0)
   163a6: 81 44        	li	s1, 0
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   163a8: 03 b4 0a 00  	ld	s0, 0(s5)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   163ac: 2a e2        	sd	a0, 256(sp)
   163ae: 93 0b 01 10  	addi	s7, sp, 256
   163b2: 11 4c        	li	s8, 4
;                 const amt = try self.read(buffer[index..]);
   163b4: 33 86 9b 00  	add	a2, s7, s1
   163b8: b3 06 9c 40  	sub	a3, s8, s1
;             return readFn(self.context, buffer);
   163bc: 08 0a        	addi	a0, sp, 272
   163be: a2 85        	mv	a1, s0
   163c0: 97 b0 00 00  	auipc	ra, 11
   163c4: e7 80 80 2f  	jalr	760(ra)
   163c8: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   163ca: e3 0e 05 54  	beqz	a0, 0x17126 <.LBB29_231+0x50>
;                 index += amt;
   163ce: 26 95        	add	a0, a0, s1
   163d0: e3 6c 95 6c  	bltu	a0, s1, 0x172a8 <.LBB29_231+0x1d2>
   163d4: aa 84        	mv	s1, a0
;             while (index < len) {
   163d6: e3 6f 85 fd  	bltu	a0, s8, 0x163b4 <.LBB29_36+0x16>
   163da: 03 45 01 10  	lbu	a0, 256(sp)
   163de: 83 45 11 10  	lbu	a1, 257(sp)
;     switch (endian) {
   163e2: 13 76 1a 00  	andi	a2, s4, 1
   163e6: e3 05 06 40  	beqz	a2, 0x16ff0 <.LBB29_190+0x18e>
;             for (bytes) |b, index| {
   163ea: 03 46 21 10  	lbu	a2, 258(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   163ee: a2 05        	slli	a1, a1, 8
;             for (bytes) |b, index| {
   163f0: 83 46 31 10  	lbu	a3, 259(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   163f4: 4d 8d        	or	a0, a0, a1
   163f6: 93 15 06 01  	slli	a1, a2, 16
   163fa: 4d 8d        	or	a0, a0, a1
   163fc: 93 95 86 01  	slli	a1, a3, 24
   16400: 33 67 b5 00  	or	a4, a0, a1
   16404: 6f 00 30 40  	j	0x17006 <.LBB29_190+0x1a4>

0000000000016408 <.LBB29_42>:
   16408: 01 44        	li	s0, 0
;     return FormValue{
   1640a: 23 08 01 02  	sb	zero, 48(sp)
;                 2 => try nosuspend in_stream.readInt(u16, endian),
   1640e: 03 bb 0a 00  	ld	s6, 0(s5)
   16412: 2d 65        	lui	a0, 11
   16414: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16418: 23 10 a1 10  	sh	a0, 256(sp)
   1641c: 93 0a 01 10  	addi	s5, sp, 256
   16420: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   16422: 33 86 8a 00  	add	a2, s5, s0
   16426: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1642a: 08 0a        	addi	a0, sp, 272
   1642c: da 85        	mv	a1, s6
   1642e: 97 b0 00 00  	auipc	ra, 11
   16432: e7 80 a0 28  	jalr	650(ra)
   16436: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16438: e3 09 05 50  	beqz	a0, 0x1714a <.LBB29_231+0x74>
;                 index += amt;
   1643c: 22 95        	add	a0, a0, s0
   1643e: e3 65 85 66  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16442: 2a 84        	mv	s0, a0
;             while (index < len) {
   16444: e3 6f 95 fc  	bltu	a0, s1, 0x16422 <.LBB29_42+0x1a>
;             return bytes;
   16448: 03 55 01 10  	lhu	a0, 256(sp)
;     if (endian == native_endian) {
   1644c: 93 75 1a 00  	andi	a1, s4, 1
   16450: 89 e5        	bnez	a1, 0x1645a <.LBB29_42+0x52>
   16452: 93 55 85 00  	srli	a1, a0, 8
   16456: 22 05        	slli	a0, a0, 8
   16458: 4d 8d        	or	a0, a0, a1
   1645a: 81 45        	li	a1, 0
;                 2 => try nosuspend in_stream.readInt(u16, endian),
   1645c: 42 15        	slli	a0, a0, 48
   1645e: 41 91        	srli	a0, a0, 48
;         FORM.data2 => parseFormValueConstant(in_stream, false, endian, 2),
   16460: 03 06 01 03  	lb	a2, 48(sp)
   16464: 29 aa        	j	0x1657e <.LBB29_57+0x9e>

0000000000016466 <.LBB29_50>:
   16466: 01 44        	li	s0, 0
;     return FormValue{
   16468: 23 0c 01 02  	sb	zero, 56(sp)
;                 4 => try nosuspend in_stream.readInt(u32, endian),
   1646c: 03 bb 0a 00  	ld	s6, 0(s5)
   16470: 37 b5 aa aa  	lui	a0, 699051
   16474: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16478: 23 20 a1 10  	sw	a0, 256(sp)
   1647c: 93 0a 01 10  	addi	s5, sp, 256
   16480: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   16482: 33 86 8a 00  	add	a2, s5, s0
   16486: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1648a: 08 0a        	addi	a0, sp, 272
   1648c: da 85        	mv	a1, s6
   1648e: 97 b0 00 00  	auipc	ra, 11
   16492: e7 80 a0 22  	jalr	554(ra)
   16496: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16498: e3 01 05 4e  	beqz	a0, 0x1717a <.LBB29_231+0xa4>
;                 index += amt;
   1649c: 22 95        	add	a0, a0, s0
   1649e: e3 65 85 60  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   164a2: 2a 84        	mv	s0, a0
;             while (index < len) {
   164a4: e3 6f 95 fc  	bltu	a0, s1, 0x16482 <.LBB29_50+0x1c>
;             return bytes;
   164a8: 03 65 01 10  	lwu	a0, 256(sp)
;     if (endian == native_endian) {
   164ac: 93 75 1a 00  	andi	a1, s4, 1
   164b0: 95 e1        	bnez	a1, 0x164d4 <.LBB29_50+0x6e>
   164b2: 93 55 85 00  	srli	a1, a0, 8
   164b6: 41 66        	lui	a2, 16
   164b8: 1b 06 06 f0  	addiw	a2, a2, -256
   164bc: f1 8d        	and	a1, a1, a2
   164be: 13 56 85 01  	srli	a2, a0, 24
   164c2: d1 8d        	or	a1, a1, a2
   164c4: 13 16 85 00  	slli	a2, a0, 8
   164c8: b7 06 ff 00  	lui	a3, 4080
   164cc: 75 8e        	and	a2, a2, a3
   164ce: 62 05        	slli	a0, a0, 24
   164d0: 51 8d        	or	a0, a0, a2
   164d2: 4d 8d        	or	a0, a0, a1
   164d4: 81 45        	li	a1, 0
;                 4 => try nosuspend in_stream.readInt(u32, endian),
   164d6: 02 15        	slli	a0, a0, 32
   164d8: 01 91        	srli	a0, a0, 32
;         FORM.data4 => parseFormValueConstant(in_stream, false, endian, 4),
   164da: 03 06 81 03  	lb	a2, 56(sp)
   164de: 45 a0        	j	0x1657e <.LBB29_57+0x9e>

00000000000164e0 <.LBB29_57>:
   164e0: 37 55 02 00  	lui	a0, 37
   164e4: 03 35 85 34  	ld	a0, 840(a0)
   164e8: 01 44        	li	s0, 0
;     return FormValue{
   164ea: 23 00 01 04  	sb	zero, 64(sp)
;                 8 => try nosuspend in_stream.readInt(u64, endian),
   164ee: 03 bb 0a 00  	ld	s6, 0(s5)
;             var bytes: [num_bytes]u8 = undefined;
   164f2: 2a e2        	sd	a0, 256(sp)
   164f4: 93 0a 01 10  	addi	s5, sp, 256
   164f8: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   164fa: 33 86 8a 00  	add	a2, s5, s0
   164fe: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16502: 08 0a        	addi	a0, sp, 272
   16504: da 85        	mv	a1, s6
   16506: 97 b0 00 00  	auipc	ra, 11
   1650a: e7 80 20 1b  	jalr	434(ra)
   1650e: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16510: e3 0f 05 48  	beqz	a0, 0x171ae <.LBB29_231+0xd8>
;                 index += amt;
   16514: 22 95        	add	a0, a0, s0
   16516: e3 69 85 58  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   1651a: 2a 84        	mv	s0, a0
;             while (index < len) {
   1651c: e3 6f 95 fc  	bltu	a0, s1, 0x164fa <.LBB29_57+0x1a>
;             return bytes;
   16520: 12 65        	ld	a0, 256(sp)
;     if (endian == native_endian) {
   16522: 93 75 1a 00  	andi	a1, s4, 1
   16526: a9 e9        	bnez	a1, 0x16578 <.LBB29_57+0x98>
   16528: 93 55 85 01  	srli	a1, a0, 24
   1652c: 37 06 ff 00  	lui	a2, 4080
   16530: f1 8d        	and	a1, a1, a2
   16532: 13 56 85 00  	srli	a2, a0, 8
   16536: 93 06 f0 0f  	li	a3, 255
   1653a: 13 97 86 01  	slli	a4, a3, 24
   1653e: 79 8e        	and	a2, a2, a4
   16540: d1 8d        	or	a1, a1, a2
   16542: 13 56 85 02  	srli	a2, a0, 40
   16546: 41 67        	lui	a4, 16
   16548: 1b 07 07 f0  	addiw	a4, a4, -256
   1654c: 79 8e        	and	a2, a2, a4
   1654e: 13 57 85 03  	srli	a4, a0, 56
   16552: 59 8e        	or	a2, a2, a4
   16554: d1 8d        	or	a1, a1, a2
   16556: 13 16 85 01  	slli	a2, a0, 24
   1655a: 13 97 86 02  	slli	a4, a3, 40
   1655e: 79 8e        	and	a2, a2, a4
   16560: 1b 57 85 01  	srliw	a4, a0, 24
   16564: 02 17        	slli	a4, a4, 32
   16566: 59 8e        	or	a2, a2, a4
   16568: 13 17 85 02  	slli	a4, a0, 40
   1656c: c2 16        	slli	a3, a3, 48
   1656e: f9 8e        	and	a3, a3, a4
   16570: 62 15        	slli	a0, a0, 56
   16572: 55 8d        	or	a0, a0, a3
   16574: 51 8d        	or	a0, a0, a2
   16576: 4d 8d        	or	a0, a0, a1
   16578: 81 45        	li	a1, 0
;         FORM.data8 => parseFormValueConstant(in_stream, false, endian, 8),
   1657a: 03 06 01 04  	lb	a2, 64(sp)
   1657e: 23 b0 a9 00  	sd	a0, 0(s3)
   16582: 23 84 c9 00  	sb	a2, 8(s3)
   16586: 0d 45        	li	a0, 3
   16588: 0d a6        	j	0x168aa <.LBB29_102+0x9c>

000000000001658a <.LBB29_66>:
;         FORM.ref_sig8 => FormValue{ .Ref = try nosuspend in_stream.readInt(u64, endian) },
   1658a: 23 9c 09 00  	sh	zero, 24(s3)
;         FORM.string => FormValue{ .String = try in_stream.readUntilDelimiterAlloc(allocator, 0, math.maxInt(usize)) },
   1658e: 03 b6 0a 00  	ld	a2, 0(s5)
   16592: 08 01        	addi	a0, sp, 128
   16594: ca 85        	mv	a1, s2
   16596: da 86        	mv	a3, s6
   16598: 97 30 00 00  	auipc	ra, 3
   1659c: e7 80 60 3b  	jalr	950(ra)
   165a0: 03 54 01 09  	lhu	s0, 144(sp)
   165a4: e3 1d 04 2a  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   165a8: 0a 65        	ld	a0, 128(sp)
   165aa: aa 65        	ld	a1, 136(sp)
   165ac: 23 b0 a9 00  	sd	a0, 0(s3)
   165b0: 23 b4 b9 00  	sd	a1, 8(s3)
   165b4: 25 45        	li	a0, 9
   165b6: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   165ba: 03 d5 89 01  	lhu	a0, 24(s3)
   165be: e3 0f 05 26  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   165c2: 6f 00 b0 57  	j	0x1733c <.LBB29_231+0x266>

00000000000165c6 <.LBB29_68>:
;             const block_len = try nosuspend leb.readULEB128(usize, in_stream);
   165c6: 28 08        	addi	a0, sp, 24
   165c8: ca 85        	mv	a1, s2
   165ca: 56 86        	mv	a2, s5
   165cc: 97 b0 00 00  	auipc	ra, 11
   165d0: e7 80 20 18  	jalr	386(ra)
   165d4: 03 54 01 02  	lhu	s0, 32(sp)
   165d8: e3 13 04 28  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   165dc: 62 67        	ld	a4, 24(sp)
;     const buf = try readAllocBytes(allocator, in_stream, size);
   165de: 08 0a        	addi	a0, sp, 272
   165e0: ca 85        	mv	a1, s2
   165e2: 5a 86        	mv	a2, s6
   165e4: d6 86        	mv	a3, s5
   165e6: 97 b0 00 00  	auipc	ra, 11
   165ea: e7 80 20 3a  	jalr	930(ra)
   165ee: 03 54 01 12  	lhu	s0, 288(sp)
   165f2: e3 15 04 48  	bnez	s0, 0x1727c <.LBB29_231+0x1a6>
   165f6: 52 65        	ld	a0, 272(sp)
   165f8: f2 65        	ld	a1, 280(sp)
;             return parseFormValueBlockLen(allocator, in_stream, block_len);
   165fa: 23 b0 a9 00  	sd	a0, 0(s3)
   165fe: 23 b4 b9 00  	sd	a1, 8(s3)
   16602: 09 45        	li	a0, 2
   16604: 6f 00 b0 10  	j	0x16f0e <.LBB29_190+0xac>

0000000000016608 <.LBB29_71>:
   16608: 37 55 02 00  	lui	a0, 37
   1660c: 03 35 85 34  	ld	a0, 840(a0)
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   16610: 83 b5 0a 00  	ld	a1, 0(s5)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   16614: 2a e2        	sd	a0, 256(sp)
;             return readFn(self.context, buffer);
   16616: 08 0a        	addi	a0, sp, 272
   16618: 10 02        	addi	a2, sp, 256
   1661a: 85 46        	li	a3, 1
   1661c: 97 b0 00 00  	auipc	ra, 11
   16620: e7 80 c0 09  	jalr	156(ra)
   16624: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16626: e3 0b 05 26  	beqz	a0, 0x1709c <.LBB29_190+0x23a>
   1662a: 03 47 01 10  	lbu	a4, 256(sp)
   1662e: 6f 00 f0 19  	j	0x16fcc <.LBB29_190+0x16a>

0000000000016632 <.LBB29_73>:
;     return FormValue{
   16632: 23 04 01 02  	sb	zero, 40(sp)
;                 1 => try nosuspend in_stream.readInt(u8, endian),
   16636: 83 b5 0a 00  	ld	a1, 0(s5)
   1663a: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   1663e: 23 00 a1 10  	sb	a0, 256(sp)
;             return readFn(self.context, buffer);
   16642: 08 0a        	addi	a0, sp, 272
   16644: 10 02        	addi	a2, sp, 256
   16646: 85 46        	li	a3, 1
   16648: 97 b0 00 00  	auipc	ra, 11
   1664c: e7 80 00 07  	jalr	112(ra)
   16650: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16652: e3 06 05 3a  	beqz	a0, 0x171fe <.LBB29_231+0x128>
;             return bytes;
   16656: 83 45 01 10  	lbu	a1, 256(sp)
   1665a: 01 45        	li	a0, 0
;         FORM.data1 => parseFormValueConstant(in_stream, false, endian, 1),
   1665c: 03 06 81 02  	lb	a2, 40(sp)
   16660: 23 b0 b9 00  	sd	a1, 0(s3)
   16664: 23 84 c9 00  	sb	a2, 8(s3)
   16668: 8d 45        	li	a1, 3
   1666a: e1 a0        	j	0x16732 <.LBB29_84+0x2c>

000000000001666c <.LBB29_76>:
;             return FormValue{ .ExprLoc = buf };
   1666c: 23 9c 09 00  	sh	zero, 24(s3)
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   16670: 83 b5 0a 00  	ld	a1, 0(s5)
   16674: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   16678: 23 00 a1 10  	sb	a0, 256(sp)
;             return readFn(self.context, buffer);
   1667c: 08 0a        	addi	a0, sp, 272
   1667e: 10 02        	addi	a2, sp, 256
   16680: 85 46        	li	a3, 1
   16682: 97 b0 00 00  	auipc	ra, 11
   16686: e7 80 60 03  	jalr	54(ra)
   1668a: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1668c: e3 0e 05 26  	beqz	a0, 0x17108 <.LBB29_231+0x32>
;             return result[0];
   16690: 03 45 01 10  	lbu	a0, 256(sp)
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   16694: 33 35 a0 00  	snez	a0, a0
   16698: 23 80 a9 00  	sb	a0, 0(s3)
   1669c: 15 45        	li	a0, 5
   1669e: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   166a2: 03 d5 89 01  	lhu	a0, 24(s3)
   166a6: e3 0b 05 18  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   166aa: 6f 00 30 49  	j	0x1733c <.LBB29_231+0x266>

00000000000166ae <.LBB29_78>:
;         FORM.string => FormValue{ .String = try in_stream.readUntilDelimiterAlloc(allocator, 0, math.maxInt(usize)) },
   166ae: 23 9c 09 00  	sh	zero, 24(s3)
   166b2: 03 b6 0a 00  	ld	a2, 0(s5)
;     return nosuspend if (is_64)
   166b6: 13 f5 1b 00  	andi	a0, s7, 1
   166ba: e3 0f 05 04  	beqz	a0, 0x16f18 <.LBB29_190+0xb6>
;         try in_stream.readInt(u64, endian)
   166be: 08 0a        	addi	a0, sp, 272
   166c0: ca 85        	mv	a1, s2
   166c2: d2 86        	mv	a3, s4
   166c4: 97 e0 ff ff  	auipc	ra, 1048574
   166c8: e7 80 40 b3  	jalr	-1228(ra)
   166cc: 03 54 81 11  	lhu	s0, 280(sp)
   166d0: e3 12 04 18  	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   166d4: 52 65        	ld	a0, 272(sp)
   166d6: 6f 00 d0 05  	j	0x16f32 <.LBB29_190+0xd0>

00000000000166da <.LBB29_81>:
;         FORM.ref_udata => parseFormValueRef(in_stream, endian, -1),
   166da: 23 9c 09 00  	sh	zero, 24(s3)
   166de: 03 b6 0a 00  	ld	a2, 0(s5)
;     return nosuspend if (is_64)
   166e2: 13 f5 1b 00  	andi	a0, s7, 1
   166e6: e3 0f 05 04  	beqz	a0, 0x16f44 <.LBB29_190+0xe2>
;         try in_stream.readInt(u64, endian)
   166ea: 08 0a        	addi	a0, sp, 272
   166ec: ca 85        	mv	a1, s2
   166ee: d2 86        	mv	a3, s4
   166f0: 97 e0 ff ff  	auipc	ra, 1048574
   166f4: e7 80 80 b0  	jalr	-1272(ra)
   166f8: 03 54 81 11  	lhu	s0, 280(sp)
   166fc: e3 1c 04 14  	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16700: 52 65        	ld	a0, 272(sp)
   16702: 6f 00 b0 05  	j	0x16f5c <.LBB29_190+0xfa>

0000000000016706 <.LBB29_84>:
;             1 => try nosuspend in_stream.readInt(u8, endian),
   16706: 83 b5 0a 00  	ld	a1, 0(s5)
   1670a: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   1670e: 23 00 a1 10  	sb	a0, 256(sp)
;             return readFn(self.context, buffer);
   16712: 08 0a        	addi	a0, sp, 272
   16714: 10 02        	addi	a2, sp, 256
   16716: 85 46        	li	a3, 1
   16718: 97 b0 00 00  	auipc	ra, 11
   1671c: e7 80 00 fa  	jalr	-96(ra)
   16720: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16722: e3 06 05 30  	beqz	a0, 0x1722e <.LBB29_231+0x158>
;             return bytes;
   16726: 83 45 01 10  	lbu	a1, 256(sp)
   1672a: 01 45        	li	a0, 0
;         FORM.ref1 => parseFormValueRef(in_stream, endian, 1),
   1672c: 23 b0 b9 00  	sd	a1, 0(s3)
   16730: 9d 45        	li	a1, 7
   16732: 23 88 b9 00  	sb	a1, 16(s3)
   16736: 23 9c a9 00  	sh	a0, 24(s3)
;     return switch (form_id) {
   1673a: 03 d5 89 01  	lhu	a0, 24(s3)
   1673e: e3 0f 05 0e  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16742: 6f 00 b0 3f  	j	0x1733c <.LBB29_231+0x266>

0000000000016746 <.LBB29_88>:
   16746: 01 44        	li	s0, 0
;             2 => try nosuspend in_stream.readInt(u16, endian),
   16748: 03 bb 0a 00  	ld	s6, 0(s5)
   1674c: 2d 65        	lui	a0, 11
   1674e: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16752: 23 10 a1 10  	sh	a0, 256(sp)
   16756: 93 0a 01 10  	addi	s5, sp, 256
   1675a: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   1675c: 33 86 8a 00  	add	a2, s5, s0
   16760: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16764: 08 0a        	addi	a0, sp, 272
   16766: da 85        	mv	a1, s6
   16768: 97 b0 00 00  	auipc	ra, 11
   1676c: e7 80 00 f5  	jalr	-176(ra)
   16770: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16772: e3 0e 05 0e  	beqz	a0, 0x1706e <.LBB29_190+0x20c>
;                 index += amt;
   16776: 22 95        	add	a0, a0, s0
   16778: e3 68 85 32  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   1677c: 2a 84        	mv	s0, a0
;             while (index < len) {
   1677e: e3 6f 95 fc  	bltu	a0, s1, 0x1675c <.LBB29_88+0x16>
;             return bytes;
   16782: 03 55 01 10  	lhu	a0, 256(sp)
;     if (endian == native_endian) {
   16786: 93 75 1a 00  	andi	a1, s4, 1
   1678a: 89 e5        	bnez	a1, 0x16794 <.LBB29_88+0x4e>
   1678c: 93 55 85 00  	srli	a1, a0, 8
   16790: 22 05        	slli	a0, a0, 8
   16792: 4d 8d        	or	a0, a0, a1
   16794: 81 45        	li	a1, 0
;             2 => try nosuspend in_stream.readInt(u16, endian),
   16796: 42 15        	slli	a0, a0, 48
   16798: 41 91        	srli	a0, a0, 48
   1679a: 29 a2        	j	0x168a4 <.LBB29_102+0x96>

000000000001679c <.LBB29_95>:
   1679c: 01 44        	li	s0, 0
;             4 => try nosuspend in_stream.readInt(u32, endian),
   1679e: 03 bb 0a 00  	ld	s6, 0(s5)
   167a2: 37 b5 aa aa  	lui	a0, 699051
   167a6: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   167aa: 23 20 a1 10  	sw	a0, 256(sp)
   167ae: 93 0a 01 10  	addi	s5, sp, 256
   167b2: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   167b4: 33 86 8a 00  	add	a2, s5, s0
   167b8: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   167bc: 08 0a        	addi	a0, sp, 272
   167be: da 85        	mv	a1, s6
   167c0: 97 b0 00 00  	auipc	ra, 11
   167c4: e7 80 80 ef  	jalr	-264(ra)
   167c8: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   167ca: e3 02 05 0a  	beqz	a0, 0x1706e <.LBB29_190+0x20c>
;                 index += amt;
   167ce: 22 95        	add	a0, a0, s0
   167d0: e3 6c 85 2c  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   167d4: 2a 84        	mv	s0, a0
;             while (index < len) {
   167d6: e3 6f 95 fc  	bltu	a0, s1, 0x167b4 <.LBB29_95+0x18>
;             return bytes;
   167da: 03 65 01 10  	lwu	a0, 256(sp)
;     if (endian == native_endian) {
   167de: 93 75 1a 00  	andi	a1, s4, 1
   167e2: 95 e1        	bnez	a1, 0x16806 <.LBB29_95+0x6a>
   167e4: 93 55 85 00  	srli	a1, a0, 8
   167e8: 41 66        	lui	a2, 16
   167ea: 1b 06 06 f0  	addiw	a2, a2, -256
   167ee: f1 8d        	and	a1, a1, a2
   167f0: 13 56 85 01  	srli	a2, a0, 24
   167f4: d1 8d        	or	a1, a1, a2
   167f6: 13 16 85 00  	slli	a2, a0, 8
   167fa: b7 06 ff 00  	lui	a3, 4080
   167fe: 75 8e        	and	a2, a2, a3
   16800: 62 05        	slli	a0, a0, 24
   16802: 51 8d        	or	a0, a0, a2
   16804: 4d 8d        	or	a0, a0, a1
   16806: 81 45        	li	a1, 0
;             4 => try nosuspend in_stream.readInt(u32, endian),
   16808: 02 15        	slli	a0, a0, 32
   1680a: 01 91        	srli	a0, a0, 32
   1680c: 61 a8        	j	0x168a4 <.LBB29_102+0x96>

000000000001680e <.LBB29_102>:
   1680e: 37 55 02 00  	lui	a0, 37
   16812: 03 35 85 34  	ld	a0, 840(a0)
   16816: 81 44        	li	s1, 0
;             8 => try nosuspend in_stream.readInt(u64, endian),
   16818: 03 b4 0a 00  	ld	s0, 0(s5)
;             var bytes: [num_bytes]u8 = undefined;
   1681c: 2a e2        	sd	a0, 256(sp)
   1681e: 93 0a 01 10  	addi	s5, sp, 256
   16822: 21 4b        	li	s6, 8
;                 const amt = try self.read(buffer[index..]);
   16824: 33 86 9a 00  	add	a2, s5, s1
   16828: b3 06 9b 40  	sub	a3, s6, s1
;             return readFn(self.context, buffer);
   1682c: 08 0a        	addi	a0, sp, 272
   1682e: a2 85        	mv	a1, s0
   16830: 97 b0 00 00  	auipc	ra, 11
   16834: e7 80 80 e8  	jalr	-376(ra)
   16838: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   1683a: e3 0a 05 02  	beqz	a0, 0x1706e <.LBB29_190+0x20c>
;                 index += amt;
   1683e: 26 95        	add	a0, a0, s1
   16840: e3 64 95 26  	bltu	a0, s1, 0x172a8 <.LBB29_231+0x1d2>
   16844: aa 84        	mv	s1, a0
;             while (index < len) {
   16846: e3 6f 65 fd  	bltu	a0, s6, 0x16824 <.LBB29_102+0x16>
;             return bytes;
   1684a: 12 65        	ld	a0, 256(sp)
;     if (endian == native_endian) {
   1684c: 93 75 1a 00  	andi	a1, s4, 1
   16850: a9 e9        	bnez	a1, 0x168a2 <.LBB29_102+0x94>
   16852: 93 55 85 01  	srli	a1, a0, 24
   16856: 37 06 ff 00  	lui	a2, 4080
   1685a: f1 8d        	and	a1, a1, a2
   1685c: 13 56 85 00  	srli	a2, a0, 8
   16860: 93 06 f0 0f  	li	a3, 255
   16864: 13 97 86 01  	slli	a4, a3, 24
   16868: 79 8e        	and	a2, a2, a4
   1686a: d1 8d        	or	a1, a1, a2
   1686c: 13 56 85 02  	srli	a2, a0, 40
   16870: 41 67        	lui	a4, 16
   16872: 1b 07 07 f0  	addiw	a4, a4, -256
   16876: 79 8e        	and	a2, a2, a4
   16878: 13 57 85 03  	srli	a4, a0, 56
   1687c: 59 8e        	or	a2, a2, a4
   1687e: d1 8d        	or	a1, a1, a2
   16880: 13 16 85 01  	slli	a2, a0, 24
   16884: 13 97 86 02  	slli	a4, a3, 40
   16888: 79 8e        	and	a2, a2, a4
   1688a: 1b 57 85 01  	srliw	a4, a0, 24
   1688e: 02 17        	slli	a4, a4, 32
   16890: 59 8e        	or	a2, a2, a4
   16892: 13 17 85 02  	slli	a4, a0, 40
   16896: c2 16        	slli	a3, a3, 48
   16898: f9 8e        	and	a3, a3, a4
   1689a: 62 15        	slli	a0, a0, 56
   1689c: 55 8d        	or	a0, a0, a3
   1689e: 51 8d        	or	a0, a0, a2
   168a0: 4d 8d        	or	a0, a0, a1
   168a2: 81 45        	li	a1, 0
   168a4: 23 b0 a9 00  	sd	a0, 0(s3)
   168a8: 1d 45        	li	a0, 7
   168aa: 23 88 a9 00  	sb	a0, 16(s3)
   168ae: 23 9c b9 00  	sh	a1, 24(s3)
;     return switch (form_id) {
   168b2: 03 d5 89 01  	lhu	a0, 24(s3)
   168b6: 63 03 05 78  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   168ba: 6f 00 30 28  	j	0x1733c <.LBB29_231+0x266>

00000000000168be <.LBB29_111>:
;             -1 => try nosuspend leb.readULEB128(u64, in_stream),
   168be: 08 0a        	addi	a0, sp, 272
   168c0: ca 85        	mv	a1, s2
   168c2: 56 86        	mv	a2, s5
   168c4: 97 f0 ff ff  	auipc	ra, 1048575
   168c8: e7 80 80 29  	jalr	664(ra)
   168cc: 03 54 81 11  	lhu	s0, 280(sp)
   168d0: e3 17 04 18  	bnez	s0, 0x1725e <.LBB29_231+0x188>
   168d4: 52 65        	ld	a0, 272(sp)
;         FORM.ref_udata => parseFormValueRef(in_stream, endian, -1),
   168d6: 23 b0 a9 00  	sd	a0, 0(s3)
   168da: 1d 45        	li	a0, 7
   168dc: 81 af        	j	0x1702c <.LBB29_190+0x1ca>

00000000000168de <.LBB29_114>:
;             const child_form_id = try nosuspend leb.readULEB128(u64, in_stream);
   168de: 28 11        	addi	a0, sp, 168
   168e0: ca 85        	mv	a1, s2
   168e2: 56 86        	mv	a2, s5
   168e4: 97 f0 ff ff  	auipc	ra, 1048575
   168e8: e7 80 80 27  	jalr	632(ra)
   168ec: 83 54 01 0b  	lhu	s1, 176(sp)
   168f0: e3 9e 04 16  	bnez	s1, 0x1726c <.LBB29_231+0x196>
   168f4: 2a 77        	ld	a4, 168(sp)
;                 return parseFormValue(allocator, in_stream, child_form_id, endian, is_64);
   168f6: 28 19        	addi	a0, sp, 184
   168f8: ca 85        	mv	a1, s2
   168fa: 5a 86        	mv	a2, s6
   168fc: d6 86        	mv	a3, s5
   168fe: d2 87        	mv	a5, s4
   16900: 5e 88        	mv	a6, s7
   16902: 97 f0 ff ff  	auipc	ra, 1048575
   16906: e7 80 60 70  	jalr	1798(ra)
   1690a: 2e 65        	ld	a0, 200(sp)
   1690c: 8e 65        	ld	a1, 192(sp)
   1690e: 4e 66        	ld	a2, 208(sp)
   16910: 23 b8 a9 00  	sd	a0, 16(s3)
   16914: 23 b4 b9 00  	sd	a1, 8(s3)
   16918: 6a 75        	ld	a0, 184(sp)
   1691a: 23 bc c9 00  	sd	a2, 24(s3)
   1691e: 93 15 06 03  	slli	a1, a2, 48
   16922: c1 91        	srli	a1, a1, 48
   16924: 23 b0 a9 00  	sd	a0, 0(s3)
   16928: 63 8a 05 70  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   1692c: 4a 85        	mv	a0, s2
   1692e: 97 d0 00 00  	auipc	ra, 13
   16932: e7 80 a0 2c  	jalr	714(ra)
   16936: 19 a7        	j	0x1703c <.LBB29_190+0x1da>

0000000000016938 <.LBB29_117>:
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   16938: 23 9c 09 00  	sh	zero, 24(s3)
   1693c: 03 b6 0a 00  	ld	a2, 0(s5)
;     return nosuspend if (is_64)
   16940: 13 f5 1b 00  	andi	a0, s7, 1
   16944: 63 05 05 62  	beqz	a0, 0x16f6e <.LBB29_190+0x10c>
;         try in_stream.readInt(u64, endian)
   16948: 08 0a        	addi	a0, sp, 272
   1694a: ca 85        	mv	a1, s2
   1694c: d2 86        	mv	a3, s4
   1694e: 97 e0 ff ff  	auipc	ra, 1048574
   16952: e7 80 a0 8a  	jalr	-1878(ra)
   16956: 03 54 81 11  	lhu	s0, 280(sp)
   1695a: 63 1d 04 6e  	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   1695e: 52 65        	ld	a0, 272(sp)
   16960: 1d a5        	j	0x16f86 <.LBB29_190+0x124>

0000000000016962 <.LBB29_120>:
;             const size = try nosuspend leb.readULEB128(usize, in_stream);
   16962: a8 08        	addi	a0, sp, 88
   16964: ca 85        	mv	a1, s2
   16966: 56 86        	mv	a2, s5
   16968: 97 b0 00 00  	auipc	ra, 11
   1696c: e7 80 60 de  	jalr	-538(ra)
   16970: 03 54 01 06  	lhu	s0, 96(sp)
   16974: 63 15 04 6e  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   16978: 66 67        	ld	a4, 88(sp)
;             const buf = try readAllocBytes(allocator, in_stream, size);
   1697a: a8 10        	addi	a0, sp, 104
   1697c: ca 85        	mv	a1, s2
   1697e: 5a 86        	mv	a2, s6
   16980: d6 86        	mv	a3, s5
   16982: 97 b0 00 00  	auipc	ra, 11
   16986: e7 80 60 00  	jalr	6(ra)
   1698a: 03 54 81 07  	lhu	s0, 120(sp)
   1698e: 63 18 04 6c  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   16992: 26 75        	ld	a0, 104(sp)
   16994: c6 75        	ld	a1, 112(sp)
;             return FormValue{ .ExprLoc = buf };
   16996: 23 9c 09 00  	sh	zero, 24(s3)
   1699a: 23 b0 a9 00  	sd	a0, 0(s3)
   1699e: 23 b4 b9 00  	sd	a1, 8(s3)
   169a2: 11 45        	li	a0, 4
   169a4: 23 88 a9 00  	sb	a0, 16(s3)
   169a8: 51 ad        	j	0x1703c <.LBB29_190+0x1da>

00000000000169aa <.LBB29_123>:
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   169aa: 37 15 01 00  	lui	a0, 17
   169ae: 83 35 85 06  	ld	a1, 104(a0)
   169b2: 13 05 85 06  	addi	a0, a0, 104
   169b6: bd aa        	j	0x16b34 <.LBB29_143+0xc>

00000000000169b8 <.LBB29_124>:
;         FORM.strx => return FormValue{ .StrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   169b8: 23 9c 09 00  	sh	zero, 24(s3)
   169bc: 28 09        	addi	a0, sp, 152
   169be: ca 85        	mv	a1, s2
   169c0: 56 86        	mv	a2, s5
   169c2: 97 b0 00 00  	auipc	ra, 11
   169c6: e7 80 c0 d8  	jalr	-628(ra)
   169ca: 03 54 01 0a  	lhu	s0, 160(sp)
   169ce: 63 18 04 68  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   169d2: 6a 65        	ld	a0, 152(sp)
   169d4: 19 a4        	j	0x16bda <.LBB29_149+0x28>

00000000000169d6 <.LBB29_126>:
;         FORM.addrx => return FormValue{ .AddrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   169d6: 23 9c 09 00  	sh	zero, 24(s3)
   169da: 28 00        	addi	a0, sp, 8
   169dc: ca 85        	mv	a1, s2
   169de: 56 86        	mv	a2, s5
   169e0: 97 b0 00 00  	auipc	ra, 11
   169e4: e7 80 e0 d6  	jalr	-658(ra)
   169e8: 03 54 01 01  	lhu	s0, 16(sp)
   169ec: 63 19 04 66  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   169f0: 22 65        	ld	a0, 8(sp)
   169f2: 83 d5 89 01  	lhu	a1, 24(s3)
   169f6: cd a1        	j	0x16ed8 <.LBB29_190+0x76>

00000000000169f8 <.LBB29_128>:
   169f8: 37 55 02 00  	lui	a0, 37
   169fc: 03 35 85 34  	ld	a0, 840(a0)
;             var buf: [16]u8 = undefined;
   16a00: aa e8        	sd	a0, 80(sp)
   16a02: aa e4        	sd	a0, 72(sp)
;             if ((try nosuspend in_stream.readAll(&buf)) < 16) return error.EndOfFile;
   16a04: 83 ba 0a 00  	ld	s5, 0(s5)
   16a08: 01 44        	li	s0, 0
   16a0a: 13 0a 81 04  	addi	s4, sp, 72
   16a0e: c1 44        	li	s1, 16
;                 const amt = try self.read(buffer[index..]);
   16a10: 33 06 8a 00  	add	a2, s4, s0
   16a14: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16a18: 08 0a        	addi	a0, sp, 272
   16a1a: d6 85        	mv	a1, s5
   16a1c: 97 b0 00 00  	auipc	ra, 11
   16a20: e7 80 c0 c9  	jalr	-868(ra)
   16a24: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16a26: 63 0c 05 7a  	beqz	a0, 0x171de <.LBB29_231+0x108>
;                 index += amt;
   16a2a: 22 95        	add	a0, a0, s0
   16a2c: e3 6e 85 06  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16a30: 2a 84        	mv	s0, a0
;             while (index < len) {
   16a32: e3 6f 95 fc  	bltu	a0, s1, 0x16a10 <.LBB29_128+0x18>
;             return FormValue{ .data16 = buf };
   16a36: 23 9c 09 00  	sh	zero, 24(s3)
   16a3a: ac 00        	addi	a1, sp, 72
   16a3c: 41 46        	li	a2, 16
   16a3e: 4e 85        	mv	a0, s3
   16a40: 97 e0 00 00  	auipc	ra, 14
   16a44: e7 80 40 83  	jalr	-1996(ra)
   16a48: 3d 45        	li	a0, 15
   16a4a: 23 88 a9 00  	sb	a0, 16(s3)
   16a4e: fd a3        	j	0x1703c <.LBB29_190+0x1da>

0000000000016a50 <.LBB29_133>:
;         FORM.strx => return FormValue{ .StrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   16a50: 23 9c 09 00  	sh	zero, 24(s3)
   16a54: 03 b6 0a 00  	ld	a2, 0(s5)
;     return nosuspend if (is_64)
   16a58: 13 f5 1b 00  	andi	a0, s7, 1
   16a5c: 63 0e 05 52  	beqz	a0, 0x16f98 <.LBB29_190+0x136>
;         try in_stream.readInt(u64, endian)
   16a60: 08 0a        	addi	a0, sp, 272
   16a62: ca 85        	mv	a1, s2
   16a64: d2 86        	mv	a3, s4
   16a66: 97 d0 ff ff  	auipc	ra, 1048573
   16a6a: e7 80 20 79  	jalr	1938(ra)
   16a6e: 03 54 81 11  	lhu	s0, 280(sp)
   16a72: 63 11 04 5e  	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16a76: 52 65        	ld	a0, 272(sp)
   16a78: 25 ab        	j	0x16fb0 <.LBB29_190+0x14e>

0000000000016a7a <.LBB29_136>:
   16a7a: 37 55 02 00  	lui	a0, 37
   16a7e: 03 35 85 34  	ld	a0, 840(a0)
   16a82: 01 44        	li	s0, 0
;         FORM.ref_addr => FormValue{ .RefAddr = try readAddress(in_stream, endian, is_64) },
   16a84: 23 9c 09 00  	sh	zero, 24(s3)
;         FORM.ref_sig8 => FormValue{ .Ref = try nosuspend in_stream.readInt(u64, endian) },
   16a88: 03 bb 0a 00  	ld	s6, 0(s5)
;             var bytes: [num_bytes]u8 = undefined;
   16a8c: 2a e2        	sd	a0, 256(sp)
   16a8e: 93 0a 01 10  	addi	s5, sp, 256
   16a92: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   16a94: 33 86 8a 00  	add	a2, s5, s0
   16a98: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16a9c: 08 0a        	addi	a0, sp, 272
   16a9e: da 85        	mv	a1, s6
   16aa0: 97 b0 00 00  	auipc	ra, 11
   16aa4: e7 80 80 c1  	jalr	-1000(ra)
   16aa8: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16aaa: 63 05 05 64  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16aae: 22 95        	add	a0, a0, s0
   16ab0: 63 6c 85 7e  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16ab4: 2a 84        	mv	s0, a0
;             while (index < len) {
   16ab6: e3 6f 95 fc  	bltu	a0, s1, 0x16a94 <.LBB29_136+0x1a>
;             return bytes;
   16aba: 12 65        	ld	a0, 256(sp)
;     if (endian == native_endian) {
   16abc: 93 75 1a 00  	andi	a1, s4, 1
   16ac0: a9 e9        	bnez	a1, 0x16b12 <.LBB29_136+0x98>
   16ac2: 93 55 85 01  	srli	a1, a0, 24
   16ac6: 37 06 ff 00  	lui	a2, 4080
   16aca: f1 8d        	and	a1, a1, a2
   16acc: 13 56 85 00  	srli	a2, a0, 8
   16ad0: 93 06 f0 0f  	li	a3, 255
   16ad4: 13 97 86 01  	slli	a4, a3, 24
   16ad8: 79 8e        	and	a2, a2, a4
   16ada: d1 8d        	or	a1, a1, a2
   16adc: 13 56 85 02  	srli	a2, a0, 40
   16ae0: 41 67        	lui	a4, 16
   16ae2: 1b 07 07 f0  	addiw	a4, a4, -256
   16ae6: 79 8e        	and	a2, a2, a4
   16ae8: 13 57 85 03  	srli	a4, a0, 56
   16aec: 59 8e        	or	a2, a2, a4
   16aee: d1 8d        	or	a1, a1, a2
   16af0: 13 16 85 01  	slli	a2, a0, 24
   16af4: 13 97 86 02  	slli	a4, a3, 40
   16af8: 79 8e        	and	a2, a2, a4
   16afa: 1b 57 85 01  	srliw	a4, a0, 24
   16afe: 02 17        	slli	a4, a4, 32
   16b00: 59 8e        	or	a2, a2, a4
   16b02: 13 17 85 02  	slli	a4, a0, 40
   16b06: c2 16        	slli	a3, a3, 48
   16b08: f9 8e        	and	a3, a3, a4
   16b0a: 62 15        	slli	a0, a0, 56
   16b0c: 55 8d        	or	a0, a0, a3
   16b0e: 51 8d        	or	a0, a0, a2
   16b10: 4d 8d        	or	a0, a0, a1
;         FORM.ref_sig8 => FormValue{ .Ref = try nosuspend in_stream.readInt(u64, endian) },
   16b12: 23 b0 a9 00  	sd	a0, 0(s3)
   16b16: 1d 45        	li	a0, 7
   16b18: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   16b1c: 03 d5 89 01  	lhu	a0, 24(s3)
   16b20: 63 0e 05 50  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16b24: 6f 00 90 01  	j	0x1733c <.LBB29_231+0x266>

0000000000016b28 <.LBB29_143>:
;                 return parseFormValue(allocator, in_stream, child_form_id, endian, is_64);
   16b28: 37 15 01 00  	lui	a0, 17
   16b2c: 83 35 05 08  	ld	a1, 128(a0)
   16b30: 13 05 05 08  	addi	a0, a0, 128
   16b34: 10 65        	ld	a2, 8(a0)
   16b36: 08 69        	ld	a0, 16(a0)
   16b38: 23 b0 b9 00  	sd	a1, 0(s3)
   16b3c: 23 9c 09 00  	sh	zero, 24(s3)
   16b40: 23 b4 c9 00  	sd	a2, 8(s3)
   16b44: 23 b8 a9 00  	sd	a0, 16(s3)
;     return switch (form_id) {
   16b48: 03 d5 89 01  	lhu	a0, 24(s3)
   16b4c: 63 08 05 4e  	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16b50: f5 a7        	j	0x1733c <.LBB29_231+0x266>

0000000000016b52 <.LBB29_145>:
;         FORM.loclistx => return FormValue{ .LocListOffset = try nosuspend leb.readULEB128(u64, in_stream) },
   16b52: 23 9c 09 00  	sh	zero, 24(s3)
   16b56: a8 09        	addi	a0, sp, 216
   16b58: ca 85        	mv	a1, s2
   16b5a: 56 86        	mv	a2, s5
   16b5c: 97 f0 ff ff  	auipc	ra, 1048575
   16b60: e7 80 00 00  	jalr	ra
   16b64: 03 54 01 0e  	lhu	s0, 224(sp)
   16b68: 63 1b 04 4e  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   16b6c: 6e 65        	ld	a0, 216(sp)
   16b6e: 83 d5 89 01  	lhu	a1, 24(s3)
   16b72: 23 b0 a9 00  	sd	a0, 0(s3)
   16b76: 35 45        	li	a0, 13
   16b78: 23 88 a9 00  	sb	a0, 16(s3)
   16b7c: 63 80 05 4c  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   16b80: 75 af        	j	0x1733c <.LBB29_231+0x266>

0000000000016b82 <.LBB29_147>:
;         FORM.rnglistx => return FormValue{ .RangeListOffset = try nosuspend leb.readULEB128(u64, in_stream) },
   16b82: 23 9c 09 00  	sh	zero, 24(s3)
   16b86: a8 11        	addi	a0, sp, 232
   16b88: ca 85        	mv	a1, s2
   16b8a: 56 86        	mv	a2, s5
   16b8c: 97 f0 ff ff  	auipc	ra, 1048575
   16b90: e7 80 00 fd  	jalr	-48(ra)
   16b94: 03 54 01 0f  	lhu	s0, 240(sp)
   16b98: 63 13 04 4c  	bnez	s0, 0x1705e <.LBB29_190+0x1fc>
   16b9c: 2e 75        	ld	a0, 232(sp)
   16b9e: 83 d5 89 01  	lhu	a1, 24(s3)
   16ba2: 23 b0 a9 00  	sd	a0, 0(s3)
   16ba6: 39 45        	li	a0, 14
   16ba8: 23 88 a9 00  	sb	a0, 16(s3)
   16bac: 63 88 05 48  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   16bb0: 71 a7        	j	0x1733c <.LBB29_231+0x266>

0000000000016bb2 <.LBB29_149>:
;         FORM.strx1 => return FormValue{ .StrOffset = try in_stream.readInt(u8, endian) },
   16bb2: 23 9c 09 00  	sh	zero, 24(s3)
   16bb6: 83 b5 0a 00  	ld	a1, 0(s5)
   16bba: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   16bbe: 23 00 a1 10  	sb	a0, 256(sp)
;             return readFn(self.context, buffer);
   16bc2: 08 0a        	addi	a0, sp, 272
   16bc4: 10 02        	addi	a2, sp, 256
   16bc6: 85 46        	li	a3, 1
   16bc8: 97 b0 00 00  	auipc	ra, 11
   16bcc: e7 80 00 af  	jalr	-1296(ra)
   16bd0: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16bd2: 63 01 05 52  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;             return bytes;
   16bd6: 03 45 01 10  	lbu	a0, 256(sp)
   16bda: 83 d5 89 01  	lhu	a1, 24(s3)
   16bde: a1 aa        	j	0x16d36 <.LBB29_166+0x76>

0000000000016be0 <.LBB29_152>:
   16be0: 01 44        	li	s0, 0
;         FORM.strx2 => return FormValue{ .StrOffset = try in_stream.readInt(u16, endian) },
   16be2: 23 9c 09 00  	sh	zero, 24(s3)
   16be6: 03 bb 0a 00  	ld	s6, 0(s5)
   16bea: 2d 65        	lui	a0, 11
   16bec: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16bf0: 23 10 a1 10  	sh	a0, 256(sp)
   16bf4: 93 0a 01 10  	addi	s5, sp, 256
   16bf8: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   16bfa: 33 86 8a 00  	add	a2, s5, s0
   16bfe: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16c02: 08 0a        	addi	a0, sp, 272
   16c04: da 85        	mv	a1, s6
   16c06: 97 b0 00 00  	auipc	ra, 11
   16c0a: e7 80 20 ab  	jalr	-1358(ra)
   16c0e: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16c10: 63 02 05 4e  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16c14: 22 95        	add	a0, a0, s0
   16c16: 63 69 85 68  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16c1a: 2a 84        	mv	s0, a0
;             while (index < len) {
   16c1c: e3 6f 95 fc  	bltu	a0, s1, 0x16bfa <.LBB29_152+0x1a>
;             return bytes;
   16c20: 03 55 01 10  	lhu	a0, 256(sp)
;     if (endian == native_endian) {
   16c24: 93 75 1a 00  	andi	a1, s4, 1
   16c28: 89 e5        	bnez	a1, 0x16c32 <.LBB29_152+0x52>
   16c2a: 93 55 85 00  	srli	a1, a0, 8
   16c2e: 22 05        	slli	a0, a0, 8
   16c30: 4d 8d        	or	a0, a0, a1
;         FORM.strx2 => return FormValue{ .StrOffset = try in_stream.readInt(u16, endian) },
   16c32: 42 15        	slli	a0, a0, 48
   16c34: 83 d5 89 01  	lhu	a1, 24(s3)
   16c38: 41 91        	srli	a0, a0, 48
   16c3a: f5 a8        	j	0x16d36 <.LBB29_166+0x76>

0000000000016c3c <.LBB29_159>:
   16c3c: 81 44        	li	s1, 0
;         FORM.strx3 => return FormValue{ .StrOffset = try in_stream.readInt(u24, endian) },
   16c3e: 23 9c 09 00  	sh	zero, 24(s3)
   16c42: 03 bb 0a 00  	ld	s6, 0(s5)
   16c46: 13 05 a0 fa  	li	a0, -86
;             var bytes: [num_bytes]u8 = undefined;
   16c4a: 23 01 a1 10  	sb	a0, 258(sp)
   16c4e: 6d 75        	lui	a0, 1048571
   16c50: 1b 05 a5 aa  	addiw	a0, a0, -1366
   16c54: 23 10 a1 10  	sh	a0, 256(sp)
   16c58: 93 0a 01 10  	addi	s5, sp, 256
   16c5c: 0d 44        	li	s0, 3
;                 const amt = try self.read(buffer[index..]);
   16c5e: 33 86 9a 00  	add	a2, s5, s1
   16c62: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   16c66: 08 0a        	addi	a0, sp, 272
   16c68: da 85        	mv	a1, s6
   16c6a: 97 b0 00 00  	auipc	ra, 11
   16c6e: e7 80 e0 a4  	jalr	-1458(ra)
   16c72: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16c74: 63 00 05 48  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16c78: 26 95        	add	a0, a0, s1
   16c7a: 63 67 95 62  	bltu	a0, s1, 0x172a8 <.LBB29_231+0x1d2>
   16c7e: aa 84        	mv	s1, a0
;             while (index < len) {
   16c80: e3 6f 85 fc  	bltu	a0, s0, 0x16c5e <.LBB29_159+0x22>
;             return bytes;
   16c84: 03 05 21 10  	lb	a0, 258(sp)
   16c88: 83 55 01 10  	lhu	a1, 256(sp)
   16c8c: 42 05        	slli	a0, a0, 16
;     if (endian == native_endian) {
   16c8e: 13 76 1a 00  	andi	a2, s4, 1
;             return bytes;
   16c92: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   16c94: 0d e2        	bnez	a2, 0x16cb6 <.LBB29_159+0x7a>
;     return @byteSwap(readIntNative(T, bytes));
   16c96: 93 55 85 00  	srli	a1, a0, 8
   16c9a: 41 66        	lui	a2, 16
   16c9c: 1b 06 06 f0  	addiw	a2, a2, -256
   16ca0: f1 8d        	and	a1, a1, a2
   16ca2: 13 16 85 00  	slli	a2, a0, 8
   16ca6: b7 06 ff 00  	lui	a3, 4080
   16caa: 75 8e        	and	a2, a2, a3
   16cac: 62 05        	slli	a0, a0, 24
   16cae: 51 8d        	or	a0, a0, a2
   16cb0: 4d 8d        	or	a0, a0, a1
   16cb2: 1b 55 85 00  	srliw	a0, a0, 8
;         FORM.strx3 => return FormValue{ .StrOffset = try in_stream.readInt(u24, endian) },
   16cb6: 22 15        	slli	a0, a0, 40
   16cb8: 83 d5 89 01  	lhu	a1, 24(s3)
   16cbc: 21 91        	srli	a0, a0, 40
   16cbe: a5 a8        	j	0x16d36 <.LBB29_166+0x76>

0000000000016cc0 <.LBB29_166>:
   16cc0: 01 44        	li	s0, 0
;         FORM.strx4 => return FormValue{ .StrOffset = try in_stream.readInt(u32, endian) },
   16cc2: 23 9c 09 00  	sh	zero, 24(s3)
   16cc6: 03 bb 0a 00  	ld	s6, 0(s5)
   16cca: 37 b5 aa aa  	lui	a0, 699051
   16cce: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16cd2: 23 20 a1 10  	sw	a0, 256(sp)
   16cd6: 93 0a 01 10  	addi	s5, sp, 256
   16cda: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   16cdc: 33 86 8a 00  	add	a2, s5, s0
   16ce0: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16ce4: 08 0a        	addi	a0, sp, 272
   16ce6: da 85        	mv	a1, s6
   16ce8: 97 b0 00 00  	auipc	ra, 11
   16cec: e7 80 00 9d  	jalr	-1584(ra)
   16cf0: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16cf2: 63 01 05 40  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16cf6: 22 95        	add	a0, a0, s0
   16cf8: 63 68 85 5a  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16cfc: 2a 84        	mv	s0, a0
;             while (index < len) {
   16cfe: e3 6f 95 fc  	bltu	a0, s1, 0x16cdc <.LBB29_166+0x1c>
;             return bytes;
   16d02: 03 65 01 10  	lwu	a0, 256(sp)
;     if (endian == native_endian) {
   16d06: 93 75 1a 00  	andi	a1, s4, 1
   16d0a: 95 e1        	bnez	a1, 0x16d2e <.LBB29_166+0x6e>
   16d0c: 93 55 85 00  	srli	a1, a0, 8
   16d10: 41 66        	lui	a2, 16
   16d12: 1b 06 06 f0  	addiw	a2, a2, -256
   16d16: f1 8d        	and	a1, a1, a2
   16d18: 13 56 85 01  	srli	a2, a0, 24
   16d1c: d1 8d        	or	a1, a1, a2
   16d1e: 13 16 85 00  	slli	a2, a0, 8
   16d22: b7 06 ff 00  	lui	a3, 4080
   16d26: 75 8e        	and	a2, a2, a3
   16d28: 62 05        	slli	a0, a0, 24
   16d2a: 51 8d        	or	a0, a0, a2
   16d2c: 4d 8d        	or	a0, a0, a1
;         FORM.strx4 => return FormValue{ .StrOffset = try in_stream.readInt(u32, endian) },
   16d2e: 02 15        	slli	a0, a0, 32
   16d30: 83 d5 89 01  	lhu	a1, 24(s3)
   16d34: 01 91        	srli	a0, a0, 32
   16d36: 23 b0 a9 00  	sd	a0, 0(s3)
   16d3a: 2d 45        	li	a0, 11
   16d3c: 23 88 a9 00  	sb	a0, 16(s3)
   16d40: 63 8e 05 2e  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   16d44: e5 ab        	j	0x1733c <.LBB29_231+0x266>

0000000000016d46 <.LBB29_174>:
;         FORM.addrx1 => return FormValue{ .AddrOffset = try in_stream.readInt(u8, endian) },
   16d46: 23 9c 09 00  	sh	zero, 24(s3)
   16d4a: 83 b5 0a 00  	ld	a1, 0(s5)
   16d4e: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   16d52: 23 00 a1 10  	sb	a0, 256(sp)
;             return readFn(self.context, buffer);
   16d56: 08 0a        	addi	a0, sp, 272
   16d58: 10 02        	addi	a2, sp, 256
   16d5a: 85 46        	li	a3, 1
   16d5c: 05 44        	li	s0, 1
   16d5e: 97 b0 00 00  	auipc	ra, 11
   16d62: e7 80 a0 95  	jalr	-1702(ra)
   16d66: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16d68: 63 06 05 38  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;             return bytes;
   16d6c: 03 45 01 10  	lbu	a0, 256(sp)
;         FORM.addrx1 => return FormValue{ .AddrOffset = try in_stream.readInt(u8, endian) },
   16d70: 83 d5 89 01  	lhu	a1, 24(s3)
   16d74: 23 b0 a9 00  	sd	a0, 0(s3)
   16d78: 23 88 89 00  	sb	s0, 16(s3)
   16d7c: 63 80 05 2c  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   16d80: 75 ab        	j	0x1733c <.LBB29_231+0x266>

0000000000016d82 <.LBB29_176>:
   16d82: 01 44        	li	s0, 0
;         FORM.addrx2 => return FormValue{ .AddrOffset = try in_stream.readInt(u16, endian) },
   16d84: 23 9c 09 00  	sh	zero, 24(s3)
   16d88: 03 bb 0a 00  	ld	s6, 0(s5)
   16d8c: 2d 65        	lui	a0, 11
   16d8e: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16d92: 23 10 a1 10  	sh	a0, 256(sp)
   16d96: 93 0a 01 10  	addi	s5, sp, 256
   16d9a: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   16d9c: 33 86 8a 00  	add	a2, s5, s0
   16da0: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16da4: 08 0a        	addi	a0, sp, 272
   16da6: da 85        	mv	a1, s6
   16da8: 97 b0 00 00  	auipc	ra, 11
   16dac: e7 80 00 91  	jalr	-1776(ra)
   16db0: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16db2: 63 01 05 34  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16db6: 22 95        	add	a0, a0, s0
   16db8: 63 68 85 4e  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16dbc: 2a 84        	mv	s0, a0
;             while (index < len) {
   16dbe: e3 6f 95 fc  	bltu	a0, s1, 0x16d9c <.LBB29_176+0x1a>
;             return bytes;
   16dc2: 03 55 01 10  	lhu	a0, 256(sp)
;     if (endian == native_endian) {
   16dc6: 93 75 1a 00  	andi	a1, s4, 1
   16dca: 89 e5        	bnez	a1, 0x16dd4 <.LBB29_176+0x52>
   16dcc: 93 55 85 00  	srli	a1, a0, 8
   16dd0: 22 05        	slli	a0, a0, 8
   16dd2: 4d 8d        	or	a0, a0, a1
;         FORM.addrx2 => return FormValue{ .AddrOffset = try in_stream.readInt(u16, endian) },
   16dd4: 42 15        	slli	a0, a0, 48
   16dd6: 83 d5 89 01  	lhu	a1, 24(s3)
   16dda: 41 91        	srli	a0, a0, 48
   16ddc: f5 a8        	j	0x16ed8 <.LBB29_190+0x76>

0000000000016dde <.LBB29_183>:
   16dde: 81 44        	li	s1, 0
;         FORM.addrx3 => return FormValue{ .AddrOffset = try in_stream.readInt(u24, endian) },
   16de0: 23 9c 09 00  	sh	zero, 24(s3)
   16de4: 03 bb 0a 00  	ld	s6, 0(s5)
   16de8: 13 05 a0 fa  	li	a0, -86
;             var bytes: [num_bytes]u8 = undefined;
   16dec: 23 01 a1 10  	sb	a0, 258(sp)
   16df0: 6d 75        	lui	a0, 1048571
   16df2: 1b 05 a5 aa  	addiw	a0, a0, -1366
   16df6: 23 10 a1 10  	sh	a0, 256(sp)
   16dfa: 93 0a 01 10  	addi	s5, sp, 256
   16dfe: 0d 44        	li	s0, 3
;                 const amt = try self.read(buffer[index..]);
   16e00: 33 86 9a 00  	add	a2, s5, s1
   16e04: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   16e08: 08 0a        	addi	a0, sp, 272
   16e0a: da 85        	mv	a1, s6
   16e0c: 97 b0 00 00  	auipc	ra, 11
   16e10: e7 80 c0 8a  	jalr	-1876(ra)
   16e14: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16e16: 63 0f 05 2c  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16e1a: 26 95        	add	a0, a0, s1
   16e1c: 63 66 95 48  	bltu	a0, s1, 0x172a8 <.LBB29_231+0x1d2>
   16e20: aa 84        	mv	s1, a0
;             while (index < len) {
   16e22: e3 6f 85 fc  	bltu	a0, s0, 0x16e00 <.LBB29_183+0x22>
;             return bytes;
   16e26: 03 05 21 10  	lb	a0, 258(sp)
   16e2a: 83 55 01 10  	lhu	a1, 256(sp)
   16e2e: 42 05        	slli	a0, a0, 16
;     if (endian == native_endian) {
   16e30: 13 76 1a 00  	andi	a2, s4, 1
;             return bytes;
   16e34: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   16e36: 0d e2        	bnez	a2, 0x16e58 <.LBB29_183+0x7a>
;     return @byteSwap(readIntNative(T, bytes));
   16e38: 93 55 85 00  	srli	a1, a0, 8
   16e3c: 41 66        	lui	a2, 16
   16e3e: 1b 06 06 f0  	addiw	a2, a2, -256
   16e42: f1 8d        	and	a1, a1, a2
   16e44: 13 16 85 00  	slli	a2, a0, 8
   16e48: b7 06 ff 00  	lui	a3, 4080
   16e4c: 75 8e        	and	a2, a2, a3
   16e4e: 62 05        	slli	a0, a0, 24
   16e50: 51 8d        	or	a0, a0, a2
   16e52: 4d 8d        	or	a0, a0, a1
   16e54: 1b 55 85 00  	srliw	a0, a0, 8
;         FORM.addrx3 => return FormValue{ .AddrOffset = try in_stream.readInt(u24, endian) },
   16e58: 22 15        	slli	a0, a0, 40
   16e5a: 83 d5 89 01  	lhu	a1, 24(s3)
   16e5e: 21 91        	srli	a0, a0, 40
   16e60: a5 a8        	j	0x16ed8 <.LBB29_190+0x76>

0000000000016e62 <.LBB29_190>:
   16e62: 01 44        	li	s0, 0
;         FORM.addrx4 => return FormValue{ .AddrOffset = try in_stream.readInt(u32, endian) },
   16e64: 23 9c 09 00  	sh	zero, 24(s3)
   16e68: 03 bb 0a 00  	ld	s6, 0(s5)
   16e6c: 37 b5 aa aa  	lui	a0, 699051
   16e70: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   16e74: 23 20 a1 10  	sw	a0, 256(sp)
   16e78: 93 0a 01 10  	addi	s5, sp, 256
   16e7c: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   16e7e: 33 86 8a 00  	add	a2, s5, s0
   16e82: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   16e86: 08 0a        	addi	a0, sp, 272
   16e88: da 85        	mv	a1, s6
   16e8a: 97 b0 00 00  	auipc	ra, 11
   16e8e: e7 80 e0 82  	jalr	-2002(ra)
   16e92: 52 65        	ld	a0, 272(sp)
;                 if (amt == 0) break;
   16e94: 63 00 05 26  	beqz	a0, 0x170f4 <.LBB29_231+0x1e>
;                 index += amt;
   16e98: 22 95        	add	a0, a0, s0
   16e9a: 63 67 85 40  	bltu	a0, s0, 0x172a8 <.LBB29_231+0x1d2>
   16e9e: 2a 84        	mv	s0, a0
;             while (index < len) {
   16ea0: e3 6f 95 fc  	bltu	a0, s1, 0x16e7e <.LBB29_190+0x1c>
;             return bytes;
   16ea4: 03 65 01 10  	lwu	a0, 256(sp)
;     if (endian == native_endian) {
   16ea8: 93 75 1a 00  	andi	a1, s4, 1
   16eac: 95 e1        	bnez	a1, 0x16ed0 <.LBB29_190+0x6e>
   16eae: 93 55 85 00  	srli	a1, a0, 8
   16eb2: 41 66        	lui	a2, 16
   16eb4: 1b 06 06 f0  	addiw	a2, a2, -256
   16eb8: f1 8d        	and	a1, a1, a2
   16eba: 13 56 85 01  	srli	a2, a0, 24
   16ebe: d1 8d        	or	a1, a1, a2
   16ec0: 13 16 85 00  	slli	a2, a0, 8
   16ec4: b7 06 ff 00  	lui	a3, 4080
   16ec8: 75 8e        	and	a2, a2, a3
   16eca: 62 05        	slli	a0, a0, 24
   16ecc: 51 8d        	or	a0, a0, a2
   16ece: 4d 8d        	or	a0, a0, a1
;         FORM.addrx4 => return FormValue{ .AddrOffset = try in_stream.readInt(u32, endian) },
   16ed0: 02 15        	slli	a0, a0, 32
   16ed2: 83 d5 89 01  	lhu	a1, 24(s3)
   16ed6: 01 91        	srli	a0, a0, 32
   16ed8: 23 b0 a9 00  	sd	a0, 0(s3)
   16edc: 05 45        	li	a0, 1
   16ede: 23 88 a9 00  	sb	a0, 16(s3)
   16ee2: 63 8d 05 14  	beqz	a1, 0x1703c <.LBB29_190+0x1da>
   16ee6: 99 a9        	j	0x1733c <.LBB29_231+0x266>
;                         const x = try nosuspend leb.readULEB128(u64, in_stream);
   16ee8: 08 02        	addi	a0, sp, 256
   16eea: ca 85        	mv	a1, s2
   16eec: 56 86        	mv	a2, s5
   16eee: 97 f0 ff ff  	auipc	ra, 1048575
   16ef2: e7 80 e0 c6  	jalr	-914(ra)
   16ef6: 83 54 81 10  	lhu	s1, 264(sp)
   16efa: 63 93 04 42  	bnez	s1, 0x17320 <.LBB29_231+0x24a>
   16efe: 12 64        	ld	s0, 256(sp)
;             return parseFormValueConstant(in_stream, signed, endian, -1);
   16f00: 03 05 81 0f  	lb	a0, 248(sp)
   16f04: 23 b0 89 00  	sd	s0, 0(s3)
   16f08: 23 84 a9 00  	sb	a0, 8(s3)
   16f0c: 0d 45        	li	a0, 3
   16f0e: 23 88 a9 00  	sb	a0, 16(s3)
   16f12: 23 9c 09 00  	sh	zero, 24(s3)
   16f16: 1d a2        	j	0x1703c <.LBB29_190+0x1da>
;         @as(u64, try in_stream.readInt(u32, endian));
   16f18: 08 02        	addi	a0, sp, 256
   16f1a: ca 85        	mv	a1, s2
   16f1c: d2 86        	mv	a3, s4
   16f1e: 97 d0 ff ff  	auipc	ra, 1048573
   16f22: e7 80 80 20  	jalr	520(ra)
   16f26: 03 54 41 10  	lhu	s0, 260(sp)
   16f2a: 63 15 04 12  	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16f2e: 03 65 01 10  	lwu	a0, 256(sp)
;         FORM.strp => FormValue{ .StrPtr = try readAddress(in_stream, endian, is_64) },
   16f32: 23 b0 a9 00  	sd	a0, 0(s3)
   16f36: 29 45        	li	a0, 10
   16f38: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   16f3c: 03 d5 89 01  	lhu	a0, 24(s3)
   16f40: 75 cd        	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16f42: ed ae        	j	0x1733c <.LBB29_231+0x266>
;         @as(u64, try in_stream.readInt(u32, endian));
   16f44: 08 02        	addi	a0, sp, 256
   16f46: ca 85        	mv	a1, s2
   16f48: d2 86        	mv	a3, s4
   16f4a: 97 d0 ff ff  	auipc	ra, 1048573
   16f4e: e7 80 c0 1d  	jalr	476(ra)
   16f52: 03 54 41 10  	lhu	s0, 260(sp)
   16f56: 7d ec        	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16f58: 03 65 01 10  	lwu	a0, 256(sp)
;         FORM.ref_addr => FormValue{ .RefAddr = try readAddress(in_stream, endian, is_64) },
   16f5c: 23 b0 a9 00  	sd	a0, 0(s3)
   16f60: 21 45        	li	a0, 8
   16f62: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   16f66: 03 d5 89 01  	lhu	a0, 24(s3)
   16f6a: 69 c9        	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16f6c: c1 ae        	j	0x1733c <.LBB29_231+0x266>
;         @as(u64, try in_stream.readInt(u32, endian));
   16f6e: 08 02        	addi	a0, sp, 256
   16f70: ca 85        	mv	a1, s2
   16f72: d2 86        	mv	a3, s4
   16f74: 97 d0 ff ff  	auipc	ra, 1048573
   16f78: e7 80 20 1b  	jalr	434(ra)
   16f7c: 03 54 41 10  	lhu	s0, 260(sp)
   16f80: 71 e8        	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16f82: 03 65 01 10  	lwu	a0, 256(sp)
;         FORM.sec_offset => FormValue{ .SecOffset = try readAddress(in_stream, endian, is_64) },
   16f86: 23 b0 a9 00  	sd	a0, 0(s3)
   16f8a: 19 45        	li	a0, 6
   16f8c: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   16f90: 03 d5 89 01  	lhu	a0, 24(s3)
   16f94: 45 c5        	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16f96: 5d a6        	j	0x1733c <.LBB29_231+0x266>
;         @as(u64, try in_stream.readInt(u32, endian));
   16f98: 08 02        	addi	a0, sp, 256
   16f9a: ca 85        	mv	a1, s2
   16f9c: d2 86        	mv	a3, s4
   16f9e: 97 d0 ff ff  	auipc	ra, 1048573
   16fa2: e7 80 80 18  	jalr	392(ra)
   16fa6: 03 54 41 10  	lhu	s0, 260(sp)
   16faa: 4d e4        	bnez	s0, 0x17054 <.LBB29_190+0x1f2>
   16fac: 03 65 01 10  	lwu	a0, 256(sp)
;         FORM.line_strp => FormValue{ .LineStrPtr = try readAddress(in_stream, endian, is_64) },
   16fb0: 23 b0 a9 00  	sd	a0, 0(s3)
   16fb4: 31 45        	li	a0, 12
   16fb6: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   16fba: 03 d5 89 01  	lhu	a0, 24(s3)
   16fbe: 3d cd        	beqz	a0, 0x1703c <.LBB29_190+0x1da>
   16fc0: b5 ae        	j	0x1733c <.LBB29_231+0x266>
;             for (bytes) |b| {
   16fc2: 83 45 11 10  	lbu	a1, 257(sp)
;                 result = (result << 8) | b;
   16fc6: 22 05        	slli	a0, a0, 8
   16fc8: 33 67 b5 00  	or	a4, a0, a1
   16fcc: 08 0a        	addi	a0, sp, 272
   16fce: ca 85        	mv	a1, s2
   16fd0: 5a 86        	mv	a2, s6
   16fd2: d6 86        	mv	a3, s5
   16fd4: 97 b0 00 00  	auipc	ra, 11
   16fd8: e7 80 40 9b  	jalr	-1612(ra)
   16fdc: 03 54 01 12  	lhu	s0, 288(sp)
   16fe0: 65 e0        	bnez	s0, 0x170c0 <.LBB29_190+0x25e>
   16fe2: d2 65        	ld	a1, 272(sp)
   16fe4: 72 65        	ld	a0, 280(sp)
   16fe6: 23 b0 b9 00  	sd	a1, 0(s3)
   16fea: 23 b4 a9 00  	sd	a0, 8(s3)
   16fee: 35 a8        	j	0x1702a <.LBB29_190+0x1c8>
;                 result = (result << 8) | b;
   16ff0: 42 05        	slli	a0, a0, 16
;             for (bytes) |b| {
   16ff2: 03 46 21 10  	lbu	a2, 258(sp)
;                 result = (result << 8) | b;
   16ff6: a2 05        	slli	a1, a1, 8
;             for (bytes) |b| {
   16ff8: 83 46 31 10  	lbu	a3, 259(sp)
;                 result = (result << 8) | b;
   16ffc: 4d 8d        	or	a0, a0, a1
   16ffe: 51 8d        	or	a0, a0, a2
   17000: 22 05        	slli	a0, a0, 8
   17002: 33 67 d5 00  	or	a4, a0, a3
;     const buf = try readAllocBytes(allocator, in_stream, size);
   17006: 08 0a        	addi	a0, sp, 272
   17008: ca 85        	mv	a1, s2
   1700a: 5a 86        	mv	a2, s6
   1700c: d6 86        	mv	a3, s5
   1700e: 97 b0 00 00  	auipc	ra, 11
   17012: e7 80 a0 97  	jalr	-1670(ra)
   17016: 03 54 01 12  	lhu	s0, 288(sp)
   1701a: 63 1c 04 26  	bnez	s0, 0x17292 <.LBB29_231+0x1bc>
   1701e: 52 65        	ld	a0, 272(sp)
   17020: f2 65        	ld	a1, 280(sp)
;         FORM.block4 => parseFormValueBlock(allocator, in_stream, endian, 4),
   17022: 23 b0 a9 00  	sd	a0, 0(s3)
   17026: 23 b4 b9 00  	sd	a1, 8(s3)
   1702a: 09 45        	li	a0, 2
   1702c: 23 88 a9 00  	sb	a0, 16(s3)
   17030: 23 9c 89 00  	sh	s0, 24(s3)
;     return switch (form_id) {
   17034: 03 d5 89 01  	lhu	a0, 24(s3)
   17038: 63 12 05 30  	bnez	a0, 0x1733c <.LBB29_231+0x266>
   1703c: f6 70        	ld	ra, 376(sp)
   1703e: 56 74        	ld	s0, 368(sp)
   17040: b6 74        	ld	s1, 360(sp)
   17042: 16 79        	ld	s2, 352(sp)
   17044: f6 69        	ld	s3, 344(sp)
   17046: 56 6a        	ld	s4, 336(sp)
   17048: b6 6a        	ld	s5, 328(sp)
   1704a: 16 6b        	ld	s6, 320(sp)
   1704c: f2 7b        	ld	s7, 312(sp)
   1704e: 52 7c        	ld	s8, 304(sp)
   17050: 19 61        	addi	sp, sp, 384
   17052: 82 80        	ret
   17054: 4a 85        	mv	a0, s2
   17056: 97 d0 00 00  	auipc	ra, 13
   1705a: e7 80 20 ba  	jalr	-1118(ra)
   1705e: 4a 85        	mv	a0, s2
   17060: 97 d0 00 00  	auipc	ra, 13
   17064: e7 80 80 b9  	jalr	-1128(ra)
   17068: 23 9c 89 00  	sh	s0, 24(s3)
   1706c: c1 bf        	j	0x1703c <.LBB29_190+0x1da>
   1706e: 4a 85        	mv	a0, s2
   17070: 97 d0 00 00  	auipc	ra, 13
   17074: e7 80 80 b8  	jalr	-1144(ra)
   17078: 4a 85        	mv	a0, s2
   1707a: 97 d0 00 00  	auipc	ra, 13
   1707e: e7 80 e0 b7  	jalr	-1154(ra)
   17082: 4a 85        	mv	a0, s2
   17084: 97 d0 00 00  	auipc	ra, 13
   17088: e7 80 40 b7  	jalr	-1164(ra)
   1708c: 4a 85        	mv	a0, s2
   1708e: 97 d0 00 00  	auipc	ra, 13
   17092: e7 80 a0 b6  	jalr	-1174(ra)
   17096: 93 05 10 03  	li	a1, 49
   1709a: 29 b0        	j	0x168a4 <.LBB29_102+0x96>
   1709c: 4a 85        	mv	a0, s2
   1709e: 97 d0 00 00  	auipc	ra, 13
   170a2: e7 80 a0 b5  	jalr	-1190(ra)
   170a6: 4a 85        	mv	a0, s2
   170a8: 97 d0 00 00  	auipc	ra, 13
   170ac: e7 80 00 b5  	jalr	-1200(ra)
   170b0: 4a 85        	mv	a0, s2
   170b2: 97 d0 00 00  	auipc	ra, 13
   170b6: e7 80 60 b4  	jalr	-1210(ra)
   170ba: 13 04 10 03  	li	s0, 49
   170be: 19 a8        	j	0x170d4 <.LBB29_190+0x272>
   170c0: 4a 85        	mv	a0, s2
   170c2: 97 d0 00 00  	auipc	ra, 13
   170c6: e7 80 60 b3  	jalr	-1226(ra)
   170ca: 4a 85        	mv	a0, s2
   170cc: 97 d0 00 00  	auipc	ra, 13
   170d0: e7 80 c0 b2  	jalr	-1236(ra)
   170d4: 09 bf        	j	0x16fe6 <.LBB29_190+0x184>

00000000000170d6 <.LBB29_231>:
;     return error.InvalidDebugInfo;
   170d6: 4a 85        	mv	a0, s2
   170d8: 97 d0 00 00  	auipc	ra, 13
   170dc: e7 80 00 b2  	jalr	-1248(ra)
   170e0: 13 05 20 03  	li	a0, 50
;             return badDwarf();
   170e4: 23 9c a9 00  	sh	a0, 24(s3)
   170e8: 91 ac        	j	0x1733c <.LBB29_231+0x266>
;             if (amt_read < buf.len) return error.EndOfStream;
   170ea: 4a 85        	mv	a0, s2
   170ec: 97 d0 00 00  	auipc	ra, 13
   170f0: e7 80 c0 b0  	jalr	-1268(ra)
   170f4: 4a 85        	mv	a0, s2
   170f6: 97 d0 00 00  	auipc	ra, 13
   170fa: e7 80 20 b0  	jalr	-1278(ra)
   170fe: 4a 85        	mv	a0, s2
   17100: 97 d0 00 00  	auipc	ra, 13
   17104: e7 80 80 af  	jalr	-1288(ra)
   17108: 4a 85        	mv	a0, s2
   1710a: 97 d0 00 00  	auipc	ra, 13
   1710e: e7 80 e0 ae  	jalr	-1298(ra)
   17112: 4a 85        	mv	a0, s2
   17114: 97 d0 00 00  	auipc	ra, 13
   17118: e7 80 40 ae  	jalr	-1308(ra)
   1711c: 13 05 10 03  	li	a0, 49
   17120: 23 9c a9 00  	sh	a0, 24(s3)
   17124: 21 bf        	j	0x1703c <.LBB29_190+0x1da>
;             if (amt_read < buf.len) return error.EndOfStream;
   17126: 4a 85        	mv	a0, s2
   17128: 97 d0 00 00  	auipc	ra, 13
   1712c: e7 80 00 ad  	jalr	-1328(ra)
;             try self.readNoEof(bytes);
   17130: 4a 85        	mv	a0, s2
   17132: 97 d0 00 00  	auipc	ra, 13
   17136: e7 80 60 ac  	jalr	-1338(ra)
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   1713a: 4a 85        	mv	a0, s2
   1713c: 97 d0 00 00  	auipc	ra, 13
   17140: e7 80 c0 ab  	jalr	-1348(ra)
   17144: 13 04 10 03  	li	s0, 49
   17148: b9 aa        	j	0x172a6 <.LBB29_231+0x1d0>
;             if (amt_read < buf.len) return error.EndOfStream;
   1714a: 4a 85        	mv	a0, s2
   1714c: 97 d0 00 00  	auipc	ra, 13
   17150: e7 80 c0 aa  	jalr	-1364(ra)
;             try self.readNoEof(&bytes);
   17154: 4a 85        	mv	a0, s2
   17156: 97 d0 00 00  	auipc	ra, 13
   1715a: e7 80 20 aa  	jalr	-1374(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1715e: 4a 85        	mv	a0, s2
   17160: 97 d0 00 00  	auipc	ra, 13
   17164: e7 80 80 a9  	jalr	-1384(ra)
;                 2 => try nosuspend in_stream.readInt(u16, endian),
   17168: 4a 85        	mv	a0, s2
   1716a: 97 d0 00 00  	auipc	ra, 13
   1716e: e7 80 e0 a8  	jalr	-1394(ra)
   17172: 93 05 10 03  	li	a1, 49
   17176: 6f f0 af ae  	j	0x16460 <.LBB29_42+0x58>
;             if (amt_read < buf.len) return error.EndOfStream;
   1717a: 4a 85        	mv	a0, s2
   1717c: 97 d0 00 00  	auipc	ra, 13
   17180: e7 80 c0 a7  	jalr	-1412(ra)
;             try self.readNoEof(&bytes);
   17184: 4a 85        	mv	a0, s2
   17186: 97 d0 00 00  	auipc	ra, 13
   1718a: e7 80 20 a7  	jalr	-1422(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1718e: 4a 85        	mv	a0, s2
   17190: 97 d0 00 00  	auipc	ra, 13
   17194: e7 80 80 a6  	jalr	-1432(ra)
;                 4 => try nosuspend in_stream.readInt(u32, endian),
   17198: 4a 85        	mv	a0, s2
   1719a: 97 d0 00 00  	auipc	ra, 13
   1719e: e7 80 e0 a5  	jalr	-1442(ra)
   171a2: 93 05 10 03  	li	a1, 49
;         FORM.data4 => parseFormValueConstant(in_stream, false, endian, 4),
   171a6: 03 06 81 03  	lb	a2, 56(sp)
   171aa: 6f f0 4f bd  	j	0x1657e <.LBB29_57+0x9e>
;             if (amt_read < buf.len) return error.EndOfStream;
   171ae: 4a 85        	mv	a0, s2
   171b0: 97 d0 00 00  	auipc	ra, 13
   171b4: e7 80 80 a4  	jalr	-1464(ra)
;             try self.readNoEof(&bytes);
   171b8: 4a 85        	mv	a0, s2
   171ba: 97 d0 00 00  	auipc	ra, 13
   171be: e7 80 e0 a3  	jalr	-1474(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   171c2: 4a 85        	mv	a0, s2
   171c4: 97 d0 00 00  	auipc	ra, 13
   171c8: e7 80 40 a3  	jalr	-1484(ra)
;                 8 => try nosuspend in_stream.readInt(u64, endian),
   171cc: 4a 85        	mv	a0, s2
   171ce: 97 d0 00 00  	auipc	ra, 13
   171d2: e7 80 a0 a2  	jalr	-1494(ra)
   171d6: 93 05 10 03  	li	a1, 49
   171da: 6f f0 0f ba  	j	0x1657a <.LBB29_57+0x9a>
;             if ((try nosuspend in_stream.readAll(&buf)) < 16) return error.EndOfFile;
   171de: 4a 85        	mv	a0, s2
   171e0: 97 d0 00 00  	auipc	ra, 13
   171e4: e7 80 80 a1  	jalr	-1512(ra)
   171e8: 13 05 60 03  	li	a0, 54
   171ec: 23 bc a9 00  	sd	a0, 24(s3)
   171f0: 23 b8 09 00  	sd	zero, 16(s3)
   171f4: 23 b4 09 00  	sd	zero, 8(s3)
   171f8: 23 b0 09 00  	sd	zero, 0(s3)
   171fc: 81 b5        	j	0x1703c <.LBB29_190+0x1da>
;             if (amt_read < buf.len) return error.EndOfStream;
   171fe: 4a 85        	mv	a0, s2
   17200: 97 d0 00 00  	auipc	ra, 13
   17204: e7 80 80 9f  	jalr	-1544(ra)
;             try self.readNoEof(&bytes);
   17208: 4a 85        	mv	a0, s2
   1720a: 97 d0 00 00  	auipc	ra, 13
   1720e: e7 80 e0 9e  	jalr	-1554(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17212: 4a 85        	mv	a0, s2
   17214: 97 d0 00 00  	auipc	ra, 13
   17218: e7 80 40 9e  	jalr	-1564(ra)
;                 1 => try nosuspend in_stream.readInt(u8, endian),
   1721c: 4a 85        	mv	a0, s2
   1721e: 97 d0 00 00  	auipc	ra, 13
   17222: e7 80 a0 9d  	jalr	-1574(ra)
   17226: 13 05 10 03  	li	a0, 49
   1722a: 6f f0 2f c3  	j	0x1665c <.LBB29_73+0x2a>
;             if (amt_read < buf.len) return error.EndOfStream;
   1722e: 4a 85        	mv	a0, s2
   17230: 97 d0 00 00  	auipc	ra, 13
   17234: e7 80 80 9c  	jalr	-1592(ra)
;             try self.readNoEof(&bytes);
   17238: 4a 85        	mv	a0, s2
   1723a: 97 d0 00 00  	auipc	ra, 13
   1723e: e7 80 e0 9b  	jalr	-1602(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17242: 4a 85        	mv	a0, s2
   17244: 97 d0 00 00  	auipc	ra, 13
   17248: e7 80 40 9b  	jalr	-1612(ra)
;             1 => try nosuspend in_stream.readInt(u8, endian),
   1724c: 4a 85        	mv	a0, s2
   1724e: 97 d0 00 00  	auipc	ra, 13
   17252: e7 80 a0 9a  	jalr	-1622(ra)
   17256: 13 05 10 03  	li	a0, 49
   1725a: 6f f0 2f cd  	j	0x1672c <.LBB29_84+0x26>
;             -1 => try nosuspend leb.readULEB128(u64, in_stream),
   1725e: 4a 85        	mv	a0, s2
   17260: 97 d0 00 00  	auipc	ra, 13
   17264: e7 80 80 99  	jalr	-1640(ra)
   17268: 6f f0 ef e6  	j	0x168d6 <.LBB29_111+0x18>
;             const child_form_id = try nosuspend leb.readULEB128(u64, in_stream);
   1726c: 4a 85        	mv	a0, s2
   1726e: 97 d0 00 00  	auipc	ra, 13
   17272: e7 80 a0 98  	jalr	-1654(ra)
   17276: 23 9c 99 00  	sh	s1, 24(s3)
   1727a: c9 b3        	j	0x1703c <.LBB29_190+0x1da>
;     const buf = try readAllocBytes(allocator, in_stream, size);
   1727c: 4a 85        	mv	a0, s2
   1727e: 97 d0 00 00  	auipc	ra, 13
   17282: e7 80 a0 97  	jalr	-1670(ra)
   17286: 09 45        	li	a0, 2
;             return parseFormValueBlockLen(allocator, in_stream, block_len);
   17288: 23 88 a9 00  	sb	a0, 16(s3)
   1728c: 23 9c 89 00  	sh	s0, 24(s3)
   17290: 75 a0        	j	0x1733c <.LBB29_231+0x266>
;     const buf = try readAllocBytes(allocator, in_stream, size);
   17292: 4a 85        	mv	a0, s2
   17294: 97 d0 00 00  	auipc	ra, 13
   17298: e7 80 40 96  	jalr	-1692(ra)
;     return parseFormValueBlockLen(allocator, in_stream, block_len);
   1729c: 4a 85        	mv	a0, s2
   1729e: 97 d0 00 00  	auipc	ra, 13
   172a2: e7 80 a0 95  	jalr	-1702(ra)
   172a6: b5 bb        	j	0x17022 <.LBB29_190+0x1c0>
   172a8: 37 15 01 00  	lui	a0, 17
   172ac: 13 05 95 5d  	addi	a0, a0, 1497
   172b0: c1 45        	li	a1, 16
   172b2: 81 46        	li	a3, 0
   172b4: 97 c0 00 00  	auipc	ra, 12
   172b8: e7 80 60 0c  	jalr	198(ra)
;         const byte = try reader.readByte();
   172bc: 83 b5 0a 00  	ld	a1, 0(s5)
   172c0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   172c4: a3 07 a1 12  	sb	a0, 303(sp)
;             return readFn(self.context, buffer);
   172c8: 08 0a        	addi	a0, sp, 272
   172ca: 13 06 f1 12  	addi	a2, sp, 303
   172ce: 85 46        	li	a3, 1
   172d0: 97 a0 00 00  	auipc	ra, 10
   172d4: e7 80 80 3e  	jalr	1000(ra)
   172d8: 52 65        	ld	a0, 272(sp)
;             if (amt_read < 1) return error.EndOfStream;
   172da: 1d c5        	beqz	a0, 0x17308 <.LBB29_231+0x232>
;             return result[0];
   172dc: 83 45 f1 12  	lbu	a1, 303(sp)
   172e0: 13 95 85 03  	slli	a0, a1, 56
   172e4: 61 95        	srai	a0, a0, 56
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);
   172e6: 13 f6 e5 07  	andi	a2, a1, 126
   172ea: fe 15        	slli	a1, a1, 63
;         if (ov[1] != 0) {
   172ec: 25 ca        	beqz	a2, 0x1735c <.LBB29_231+0x286>
   172ee: b3 35 b0 00  	snez	a1, a1
;             if (byte & 0x80 != 0) return error.Overflow;
   172f2: 79 99        	andi	a0, a0, -2
   172f4: 13 05 25 f8  	addi	a0, a0, -126
   172f8: 13 35 15 00  	seqz	a0, a0
   172fc: 6d 8d        	and	a0, a0, a1
   172fe: 2d cd        	beqz	a0, 0x17378 <.LBB29_231+0x2a2>
   17300: 7d 55        	li	a0, -1
   17302: 7e 15        	slli	a0, a0, 63
;         value |= ov[0];
   17304: 49 8c        	or	s0, s0, a0
   17306: ed be        	j	0x16f00 <.LBB29_190+0x9e>
;             if (amt_read < 1) return error.EndOfStream;
   17308: 4a 85        	mv	a0, s2
   1730a: 97 d0 00 00  	auipc	ra, 13
   1730e: e7 80 e0 8e  	jalr	-1810(ra)
   17312: 93 04 10 03  	li	s1, 49
   17316: 4a 85        	mv	a0, s2
   17318: 97 d0 00 00  	auipc	ra, 13
   1731c: e7 80 00 8e  	jalr	-1824(ra)
   17320: 4a 85        	mv	a0, s2
   17322: 97 d0 00 00  	auipc	ra, 13
   17326: e7 80 60 8d  	jalr	-1834(ra)
;             return parseFormValueConstant(in_stream, signed, endian, -1);
   1732a: 03 05 81 0f  	lb	a0, 248(sp)
   1732e: 23 84 a9 00  	sb	a0, 8(s3)
   17332: 0d 45        	li	a0, 3
   17334: 23 88 a9 00  	sb	a0, 16(s3)
   17338: 23 9c 99 00  	sh	s1, 24(s3)
   1733c: 4a 85        	mv	a0, s2
   1733e: f6 70        	ld	ra, 376(sp)
   17340: 56 74        	ld	s0, 368(sp)
   17342: b6 74        	ld	s1, 360(sp)
   17344: 16 79        	ld	s2, 352(sp)
   17346: f6 69        	ld	s3, 344(sp)
   17348: 56 6a        	ld	s4, 336(sp)
   1734a: b6 6a        	ld	s5, 328(sp)
   1734c: 16 6b        	ld	s6, 320(sp)
   1734e: f2 7b        	ld	s7, 312(sp)
   17350: 52 7c        	ld	s8, 304(sp)
   17352: 19 61        	addi	sp, sp, 384
   17354: 17 d3 00 00  	auipc	t1, 13
   17358: 67 00 43 8a  	jr	-1884(t1)
;             if ((byte & 0x80 == 0) and (@bitCast(S, ov[0]) < 0)) {
   1735c: 13 26 05 00  	slti	a2, a0, 0
   17360: 13 46 16 00  	xori	a2, a2, 1
   17364: b3 36 b0 00  	snez	a3, a1
   17368: 75 8e        	and	a2, a2, a3
   1736a: 93 04 00 03  	li	s1, 48
   1736e: 45 f6        	bnez	a2, 0x17316 <.LBB29_231+0x240>
;         if (byte & 0x80 == 0) {
   17370: e3 43 05 fa  	bltz	a0, 0x17316 <.LBB29_231+0x240>
   17374: 4d 8c        	or	s0, s0, a1
   17376: 69 b6        	j	0x16f00 <.LBB29_190+0x9e>
   17378: 93 04 00 03  	li	s1, 48
   1737c: 69 bf        	j	0x17316 <.LBB29_231+0x240>

000000000001737e <heap.arena_allocator.ArenaAllocator.deinit>:
;     pub fn deinit(self: ArenaAllocator) void {
   1737e: 5d 71        	addi	sp, sp, -80
;         var it = self.state.buffer_list.first;
   17380: 86 e4        	sd	ra, 72(sp)
   17382: a2 e0        	sd	s0, 64(sp)
   17384: 26 fc        	sd	s1, 56(sp)
   17386: 4a f8        	sd	s2, 48(sp)
   17388: 4e f4        	sd	s3, 40(sp)
   1738a: 52 f0        	sd	s4, 32(sp)
   1738c: 56 ec        	sd	s5, 24(sp)
   1738e: 5a e8        	sd	s6, 16(sp)
   17390: 5e e4        	sd	s7, 8(sp)
   17392: 83 3a 05 01  	ld	s5, 16(a0)
;         while (it) |node| {
   17396: 63 85 0a 06  	beqz	s5, 0x17400 <heap.arena_allocator.ArenaAllocator.deinit+0x82>
   1739a: aa 89        	mv	s3, a0
   1739c: 06 89        	mv	s2, ra
   1739e: 37 55 02 00  	lui	a0, 37
   173a2: 03 3b 05 35  	ld	s6, 848(a0)
   173a6: 3d a0        	j	0x173d4 <heap.arena_allocator.ArenaAllocator.deinit+0x56>
   173a8: 03 ba 09 00  	ld	s4, 0(s3)
   173ac: 83 bb 89 00  	ld	s7, 8(s3)
;     @memset(non_const_ptr, undefined, bytes_len);
   173b0: 93 05 a0 0a  	li	a1, 170
   173b4: 26 85        	mv	a0, s1
   173b6: 22 86        	mv	a2, s0
   173b8: 97 d0 00 00  	auipc	ra, 13
   173bc: e7 80 20 ee  	jalr	-286(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   173c0: 83 b7 0b 01  	ld	a5, 16(s7)
   173c4: 52 85        	mv	a0, s4
   173c6: a6 85        	mv	a1, s1
   173c8: 22 86        	mv	a2, s0
   173ca: 81 46        	li	a3, 0
   173cc: 4a 87        	mv	a4, s2
   173ce: 82 97        	jalr	a5
;         while (it) |node| {
   173d0: 63 88 0a 02  	beqz	s5, 0x17400 <heap.arena_allocator.ArenaAllocator.deinit+0x82>
;             self.child_allocator.free(node.data);
   173d4: 03 b5 0a 01  	ld	a0, 16(s5)
   173d8: 01 44        	li	s0, 0
   173da: da 84        	mv	s1, s6
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   173dc: 01 c5        	beqz	a0, 0x173e4 <heap.arena_allocator.ArenaAllocator.deinit+0x66>
   173de: 83 b4 8a 00  	ld	s1, 8(s5)
   173e2: 2a 84        	mv	s0, a0
   173e4: 83 ba 0a 00  	ld	s5, 0(s5)
;     if (bytes_len == 0) return;
   173e8: 65 d4        	beqz	s0, 0x173d0 <heap.arena_allocator.ArenaAllocator.deinit+0x52>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   173ea: dd fc        	bnez	s1, 0x173a8 <heap.arena_allocator.ArenaAllocator.deinit+0x2a>
   173ec: 37 25 01 00  	lui	a0, 18
   173f0: 13 05 a5 86  	addi	a0, a0, -1942
   173f4: f9 45        	li	a1, 30
   173f6: 81 46        	li	a3, 0
   173f8: 97 c0 00 00  	auipc	ra, 12
   173fc: e7 80 20 f8  	jalr	-126(ra)
;             it = next_it;
   17400: a6 60        	ld	ra, 72(sp)
   17402: 06 64        	ld	s0, 64(sp)
   17404: e2 74        	ld	s1, 56(sp)
   17406: 42 79        	ld	s2, 48(sp)
   17408: a2 79        	ld	s3, 40(sp)
   1740a: 02 7a        	ld	s4, 32(sp)
   1740c: e2 6a        	ld	s5, 24(sp)
   1740e: 42 6b        	ld	s6, 16(sp)
   17410: a2 6b        	ld	s7, 8(sp)
   17412: 61 61        	addi	sp, sp, 80
   17414: 82 80        	ret

0000000000017416 <dwarf.Die.getAttrString>:
;     ) error{ InvalidDebugInfo, MissingDebugInfo }![]const u8 {
   17416: 35 71        	addi	sp, sp, -160
;         for (self.attrs.items) |*attr| {
   17418: 06 ed        	sd	ra, 152(sp)
   1741a: 22 e9        	sd	s0, 144(sp)
   1741c: 26 e5        	sd	s1, 136(sp)
   1741e: 4a e1        	sd	s2, 128(sp)
   17420: 04 7a        	ld	s1, 48(a2)
   17422: 2e 89        	mv	s2, a1
   17424: 2a 84        	mv	s0, a0
   17426: 99 c8        	beqz	s1, 0x1743c <dwarf.Die.getAttrString+0x26>
   17428: 08 76        	ld	a0, 40(a2)
;         for (self.attrs.items) |*attr| {
   1742a: 41 05        	addi	a0, a0, 16
;             if (attr.id == id) return &attr.value;
   1742c: 83 35 05 ff  	ld	a1, -16(a0)
   17430: 63 82 e5 02  	beq	a1, a4, 0x17454 <dwarf.Die.getAttrString+0x3e>
;         for (self.attrs.items) |*attr| {
   17434: fd 14        	addi	s1, s1, -1
   17436: 13 05 05 02  	addi	a0, a0, 32
   1743a: ed f8        	bnez	s1, 0x1742c <dwarf.Die.getAttrString+0x16>
;         const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
   1743c: 4a 85        	mv	a0, s2
   1743e: 97 c0 00 00  	auipc	ra, 12
   17442: e7 80 a0 7b  	jalr	1978(ra)
   17446: 4d 45        	li	a0, 19
;         const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
   17448: 08 e8        	sd	a0, 16(s0)
   1744a: 23 34 04 00  	sd	zero, 8(s0)
   1744e: 23 30 04 00  	sd	zero, 0(s0)
   17452: 8d ac        	j	0x176c4 <dwarf.Die.getAttrString+0x2ae>
;         switch (form_value.*) {
   17454: 83 45 85 00  	lbu	a1, 8(a0)
   17458: 03 37 85 ff  	ld	a4, -8(a0)
   1745c: 29 46        	li	a2, 10
;         switch (form_value.*) {
   1745e: 63 4f b6 04  	blt	a2, a1, 0x174bc <dwarf.Die.getAttrString+0xa6>
   17462: 25 46        	li	a2, 9
;         switch (form_value.*) {
   17464: 63 81 c5 0c  	beq	a1, a2, 0x17526 <dwarf.Die.getAttrString+0x110>
   17468: 29 45        	li	a0, 10
;         switch (form_value.*) {
   1746a: 63 93 a5 26  	bne	a1, a0, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;         return getStringGeneric(di.debug_str, offset);
   1746e: 90 72        	ld	a2, 32(a3)
   17470: 94 76        	ld	a3, 40(a3)
   17472: a8 10        	addi	a0, sp, 104
   17474: ca 85        	mv	a1, s2
   17476: 97 30 00 00  	auipc	ra, 3
   1747a: e7 80 a0 f2  	jalr	-214(ra)
   1747e: 46 75        	ld	a0, 112(sp)
   17480: a6 75        	ld	a1, 104(sp)
   17482: 2a ec        	sd	a0, 24(sp)
   17484: 2e e8        	sd	a1, 16(sp)
   17486: 03 15 e1 07  	lh	a0, 126(sp)
   1748a: 83 15 c1 07  	lh	a1, 124(sp)
   1748e: 03 56 a1 07  	lhu	a2, 122(sp)
   17492: 83 54 81 07  	lhu	s1, 120(sp)
   17496: 23 16 a1 00  	sh	a0, 12(sp)
   1749a: 13 95 05 01  	slli	a0, a1, 16
   1749e: 51 8d        	or	a0, a0, a2
   174a0: 2a c4        	sw	a0, 8(sp)
   174a2: 63 91 04 24  	bnez	s1, 0x176e4 <dwarf.Die.getAttrString+0x2ce>
;             FormValue.StrPtr => |offset| return di.getString(offset),
   174a6: 62 65        	ld	a0, 24(sp)
   174a8: c2 65        	ld	a1, 16(sp)
   174aa: 08 e4        	sd	a0, 8(s0)
   174ac: 03 15 81 00  	lh	a0, 8(sp)
   174b0: 03 16 a1 00  	lh	a2, 10(sp)
   174b4: 0c e0        	sd	a1, 0(s0)
   174b6: 83 15 c1 00  	lh	a1, 12(sp)
   174ba: a9 a8        	j	0x17514 <dwarf.Die.getAttrString+0xfe>
   174bc: 2d 45        	li	a0, 11
;         switch (form_value.*) {
   174be: 63 8a a5 06  	beq	a1, a0, 0x17532 <dwarf.Die.getAttrString+0x11c>
   174c2: 31 45        	li	a0, 12
;         switch (form_value.*) {
   174c4: 63 96 a5 20  	bne	a1, a0, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;         return getStringGeneric(di.debug_line_str, offset);
   174c8: b0 6a        	ld	a2, 80(a3)
   174ca: b4 6e        	ld	a3, 88(a3)
   174cc: a8 10        	addi	a0, sp, 104
   174ce: ca 85        	mv	a1, s2
   174d0: 97 30 00 00  	auipc	ra, 3
   174d4: e7 80 00 ed  	jalr	-304(ra)
   174d8: 46 75        	ld	a0, 112(sp)
   174da: a6 75        	ld	a1, 104(sp)
   174dc: aa f0        	sd	a0, 96(sp)
   174de: ae ec        	sd	a1, 88(sp)
   174e0: 03 15 e1 07  	lh	a0, 126(sp)
   174e4: 83 15 c1 07  	lh	a1, 124(sp)
   174e8: 03 56 a1 07  	lhu	a2, 122(sp)
   174ec: 83 54 81 07  	lhu	s1, 120(sp)
   174f0: 23 1a a1 04  	sh	a0, 84(sp)
   174f4: 13 95 05 01  	slli	a0, a1, 16
   174f8: 51 8d        	or	a0, a0, a2
   174fa: aa c8        	sw	a0, 80(sp)
   174fc: 63 94 04 20  	bnez	s1, 0x17704 <dwarf.Die.getAttrString+0x2ee>
;             FormValue.LineStrPtr => |offset| return di.getLineString(offset),
   17500: 06 75        	ld	a0, 96(sp)
   17502: e6 65        	ld	a1, 88(sp)
   17504: 08 e4        	sd	a0, 8(s0)
   17506: 03 15 01 05  	lh	a0, 80(sp)
   1750a: 03 16 21 05  	lh	a2, 82(sp)
   1750e: 0c e0        	sd	a1, 0(s0)
   17510: 83 15 41 05  	lh	a1, 84(sp)
   17514: 23 19 a4 00  	sh	a0, 18(s0)
   17518: 23 1a c4 00  	sh	a2, 20(s0)
   1751c: 23 18 04 00  	sh	zero, 16(s0)
   17520: 23 1b b4 00  	sh	a1, 22(s0)
   17524: 45 a2        	j	0x176c4 <dwarf.Die.getAttrString+0x2ae>
;         switch (form_value.*) {
   17526: 08 61        	ld	a0, 0(a0)
;             FormValue.String => |value| return value,
   17528: 18 e0        	sd	a4, 0(s0)
   1752a: 08 e4        	sd	a0, 8(s0)
   1752c: 23 18 04 00  	sh	zero, 16(s0)
   17530: 51 aa        	j	0x176c4 <dwarf.Die.getAttrString+0x2ae>
;                 const debug_str_offsets = di.debug_str_offsets orelse return badDwarf();
   17532: 83 b2 06 03  	ld	t0, 48(a3)
   17536: 63 8d 02 18  	beqz	t0, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;                 if (compile_unit.str_offsets_base == 0) return badDwarf();
   1753a: 03 b6 08 02  	ld	a2, 32(a7)
   1753e: 63 09 06 18  	beqz	a2, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;                 if (compile_unit.is_64) {
   17542: 83 c4 28 04  	lbu	s1, 66(a7)
   17546: 8c 7e        	ld	a1, 56(a3)
;                 if (compile_unit.is_64) {
   17548: f9 cc        	beqz	s1, 0x17626 <dwarf.Die.getAttrString+0x210>
;                     const byte_offset = compile_unit.str_offsets_base + 8 * index;
   1754a: 93 14 37 00  	slli	s1, a4, 3
   1754e: 13 d5 34 00  	srli	a0, s1, 3
   17552: 63 1a e5 1e  	bne	a0, a4, 0x17746 <dwarf.Die.getAttrString+0x330>
   17556: 33 07 96 00  	add	a4, a2, s1
   1755a: 63 66 c7 1e  	bltu	a4, a2, 0x17746 <dwarf.Die.getAttrString+0x330>
;                     if (byte_offset + 8 > debug_str_offsets.len) return badDwarf();
   1755e: 13 06 87 00  	addi	a2, a4, 8
   17562: 63 62 e6 1e  	bltu	a2, a4, 0x17746 <dwarf.Die.getAttrString+0x330>
   17566: 63 e5 c5 16  	bltu	a1, a2, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;                     const offset = mem.readInt(u64, debug_str_offsets[byte_offset..][0..8], di.endian);
   1756a: 63 e8 e5 1e  	bltu	a1, a4, 0x1775a <dwarf.Die.getAttrString+0x344>
   1756e: 33 85 e5 40  	sub	a0, a1, a4
   17572: 9d 45        	li	a1, 7
   17574: 63 fe a5 1e  	bgeu	a1, a0, 0x17770 <dwarf.Die.getAttrString+0x35a>
   17578: 16 97        	add	a4, a4, t0
   1757a: 83 42 17 00  	lbu	t0, 1(a4)
   1757e: 83 48 07 00  	lbu	a7, 0(a4)
   17582: 83 43 37 00  	lbu	t2, 3(a4)
   17586: 03 43 27 00  	lbu	t1, 2(a4)
   1758a: 93 94 82 00  	slli	s1, t0, 8
   1758e: b3 e4 14 01  	or	s1, s1, a7
   17592: 93 95 83 00  	slli	a1, t2, 8
   17596: b3 e5 65 00  	or	a1, a1, t1
   1759a: 03 46 57 00  	lbu	a2, 5(a4)
   1759e: c2 05        	slli	a1, a1, 16
   175a0: c5 8d        	or	a1, a1, s1
   175a2: 83 44 47 00  	lbu	s1, 4(a4)
   175a6: 22 06        	slli	a2, a2, 8
   175a8: 03 45 77 00  	lbu	a0, 7(a4)
   175ac: 03 47 67 00  	lbu	a4, 6(a4)
   175b0: 45 8e        	or	a2, a2, s1
;                     const offset = mem.readInt(u64, debug_str_offsets[byte_offset..][0..8], di.endian);
   175b2: 83 c6 86 10  	lbu	a3, 264(a3)
   175b6: 22 05        	slli	a0, a0, 8
   175b8: 59 8d        	or	a0, a0, a4
   175ba: 42 05        	slli	a0, a0, 16
   175bc: 51 8d        	or	a0, a0, a2
   175be: 02 15        	slli	a0, a0, 32
   175c0: 33 67 b5 00  	or	a4, a0, a1
;     if (endian == native_endian) {
   175c4: a1 e6        	bnez	a3, 0x1760c <dwarf.Die.getAttrString+0x1f6>
   175c6: 13 55 87 02  	srli	a0, a4, 40
   175ca: c1 65        	lui	a1, 16
   175cc: 9b 85 05 f0  	addiw	a1, a1, -256
   175d0: 6d 8d        	and	a0, a0, a1
   175d2: 93 55 87 03  	srli	a1, a4, 56
   175d6: 4d 8d        	or	a0, a0, a1
   175d8: 93 55 87 01  	srli	a1, a4, 24
   175dc: 37 06 ff 00  	lui	a2, 4080
   175e0: f1 8d        	and	a1, a1, a2
   175e2: 13 56 87 00  	srli	a2, a4, 8
   175e6: 93 06 f0 0f  	li	a3, 255
   175ea: e2 06        	slli	a3, a3, 24
   175ec: 75 8e        	and	a2, a2, a3
   175ee: d1 8d        	or	a1, a1, a2
   175f0: 4d 8d        	or	a0, a0, a1
   175f2: 93 95 03 02  	slli	a1, t2, 32
   175f6: 13 16 83 02  	slli	a2, t1, 40
   175fa: d1 8d        	or	a1, a1, a2
   175fc: 13 96 02 03  	slli	a2, t0, 48
   17600: 93 96 88 03  	slli	a3, a7, 56
   17604: 55 8e        	or	a2, a2, a3
   17606: d1 8d        	or	a1, a1, a2
   17608: 33 e7 a5 00  	or	a4, a1, a0
;                     return getStringGeneric(opt_str, offset);
   1760c: 08 10        	addi	a0, sp, 32
   1760e: ca 85        	mv	a1, s2
   17610: 3e 86        	mv	a2, a5
   17612: c2 86        	mv	a3, a6
   17614: 97 30 00 00  	auipc	ra, 3
   17618: e7 80 c0 d8  	jalr	-628(ra)
   1761c: 22 75        	ld	a0, 40(sp)
   1761e: c2 75        	ld	a1, 48(sp)
   17620: 08 e4        	sd	a0, 8(s0)
   17622: 02 75        	ld	a0, 32(sp)
   17624: 59 a8        	j	0x176ba <dwarf.Die.getAttrString+0x2a4>
;                     const byte_offset = compile_unit.str_offsets_base + 4 * index;
   17626: 93 14 27 00  	slli	s1, a4, 2
   1762a: 13 d5 24 00  	srli	a0, s1, 2
   1762e: 63 1c e5 10  	bne	a0, a4, 0x17746 <dwarf.Die.getAttrString+0x330>
   17632: 33 07 96 00  	add	a4, a2, s1
   17636: 63 68 c7 10  	bltu	a4, a2, 0x17746 <dwarf.Die.getAttrString+0x330>
;                     if (byte_offset + 4 > debug_str_offsets.len) return badDwarf();
   1763a: 13 06 47 00  	addi	a2, a4, 4
   1763e: 63 64 e6 10  	bltu	a2, a4, 0x17746 <dwarf.Die.getAttrString+0x330>
   17642: 63 e7 c5 08  	bltu	a1, a2, 0x176d0 <dwarf.Die.getAttrString+0x2ba>
;                     const offset = mem.readInt(u32, debug_str_offsets[byte_offset..][0..4], di.endian);
   17646: 63 ea e5 10  	bltu	a1, a4, 0x1775a <dwarf.Die.getAttrString+0x344>
   1764a: 33 85 e5 40  	sub	a0, a1, a4
   1764e: 8d 45        	li	a1, 3
   17650: 63 f0 a5 12  	bgeu	a1, a0, 0x17770 <dwarf.Die.getAttrString+0x35a>
   17654: b3 85 e2 00  	add	a1, t0, a4
   17658: 03 c5 15 00  	lbu	a0, 1(a1)
   1765c: 03 c6 05 00  	lbu	a2, 0(a1)
   17660: 13 17 85 00  	slli	a4, a0, 8
   17664: 83 c4 35 00  	lbu	s1, 3(a1)
   17668: 83 c5 25 00  	lbu	a1, 2(a1)
   1766c: 59 8e        	or	a2, a2, a4
;                     const offset = mem.readInt(u32, debug_str_offsets[byte_offset..][0..4], di.endian);
   1766e: 83 c6 86 10  	lbu	a3, 264(a3)
   17672: 13 97 84 00  	slli	a4, s1, 8
   17676: d9 8d        	or	a1, a1, a4
   17678: c2 05        	slli	a1, a1, 16
   1767a: d1 8d        	or	a1, a1, a2
;     if (endian == native_endian) {
   1767c: 99 ee        	bnez	a3, 0x1769a <dwarf.Die.getAttrString+0x284>
   1767e: 13 d6 85 00  	srli	a2, a1, 8
   17682: c1 66        	lui	a3, 16
   17684: 9b 86 06 f0  	addiw	a3, a3, -256
   17688: 75 8e        	and	a2, a2, a3
   1768a: 93 d6 85 01  	srli	a3, a1, 24
   1768e: 55 8e        	or	a2, a2, a3
   17690: e2 05        	slli	a1, a1, 24
   17692: 42 05        	slli	a0, a0, 16
   17694: 4d 8d        	or	a0, a0, a1
   17696: b3 65 c5 00  	or	a1, a0, a2
;                     return getStringGeneric(opt_str, offset);
   1769a: 13 95 05 02  	slli	a0, a1, 32
   1769e: 13 57 05 02  	srli	a4, a0, 32
   176a2: 28 18        	addi	a0, sp, 56
   176a4: ca 85        	mv	a1, s2
   176a6: 3e 86        	mv	a2, a5
   176a8: c2 86        	mv	a3, a6
   176aa: 97 30 00 00  	auipc	ra, 3
   176ae: e7 80 60 cf  	jalr	-778(ra)
   176b2: 06 65        	ld	a0, 64(sp)
   176b4: a6 65        	ld	a1, 72(sp)
   176b6: 08 e4        	sd	a0, 8(s0)
   176b8: 62 75        	ld	a0, 56(sp)
   176ba: 0c e8        	sd	a1, 16(s0)
   176bc: c2 15        	slli	a1, a1, 48
   176be: c1 91        	srli	a1, a1, 48
   176c0: 08 e0        	sd	a0, 0(s0)
   176c2: a5 e9        	bnez	a1, 0x17732 <dwarf.Die.getAttrString+0x31c>
   176c4: ea 60        	ld	ra, 152(sp)
   176c6: 4a 64        	ld	s0, 144(sp)
   176c8: aa 64        	ld	s1, 136(sp)
   176ca: 0a 69        	ld	s2, 128(sp)
   176cc: 0d 61        	addi	sp, sp, 160
   176ce: 82 80        	ret
   176d0: 4a 85        	mv	a0, s2
   176d2: 97 c0 00 00  	auipc	ra, 12
   176d6: e7 80 60 52  	jalr	1318(ra)
   176da: 13 05 20 03  	li	a0, 50
   176de: 23 18 a4 00  	sh	a0, 16(s0)
   176e2: 81 a8        	j	0x17732 <dwarf.Die.getAttrString+0x31c>
;         return getStringGeneric(di.debug_str, offset);
   176e4: 4a 85        	mv	a0, s2
   176e6: 97 c0 00 00  	auipc	ra, 12
   176ea: e7 80 20 51  	jalr	1298(ra)
;             FormValue.StrPtr => |offset| return di.getString(offset),
   176ee: 62 65        	ld	a0, 24(sp)
   176f0: c2 65        	ld	a1, 16(sp)
   176f2: 08 e4        	sd	a0, 8(s0)
   176f4: 0c e0        	sd	a1, 0(s0)
   176f6: 03 15 81 00  	lh	a0, 8(sp)
   176fa: 83 15 a1 00  	lh	a1, 10(sp)
   176fe: 03 16 c1 00  	lh	a2, 12(sp)
   17702: 05 a0        	j	0x17722 <dwarf.Die.getAttrString+0x30c>
;         return getStringGeneric(di.debug_line_str, offset);
   17704: 4a 85        	mv	a0, s2
   17706: 97 c0 00 00  	auipc	ra, 12
   1770a: e7 80 20 4f  	jalr	1266(ra)
;             FormValue.LineStrPtr => |offset| return di.getLineString(offset),
   1770e: 06 75        	ld	a0, 96(sp)
   17710: e6 65        	ld	a1, 88(sp)
   17712: 08 e4        	sd	a0, 8(s0)
   17714: 0c e0        	sd	a1, 0(s0)
   17716: 03 15 01 05  	lh	a0, 80(sp)
   1771a: 83 15 21 05  	lh	a1, 82(sp)
   1771e: 03 16 41 05  	lh	a2, 84(sp)
   17722: 23 18 94 00  	sh	s1, 16(s0)
   17726: 23 19 a4 00  	sh	a0, 18(s0)
   1772a: 23 1a b4 00  	sh	a1, 20(s0)
   1772e: 23 1b c4 00  	sh	a2, 22(s0)
   17732: 4a 85        	mv	a0, s2
   17734: ea 60        	ld	ra, 152(sp)
   17736: 4a 64        	ld	s0, 144(sp)
   17738: aa 64        	ld	s1, 136(sp)
   1773a: 0a 69        	ld	s2, 128(sp)
   1773c: 0d 61        	addi	sp, sp, 160
   1773e: 17 c3 00 00  	auipc	t1, 12
   17742: 67 00 a3 4b  	jr	1210(t1)
   17746: 37 15 01 00  	lui	a0, 17
   1774a: 13 05 95 5d  	addi	a0, a0, 1497
   1774e: c1 45        	li	a1, 16
   17750: 81 46        	li	a3, 0
   17752: 97 c0 00 00  	auipc	ra, 12
   17756: e7 80 80 c2  	jalr	-984(ra)
   1775a: 37 15 01 00  	lui	a0, 17
   1775e: 13 05 45 5b  	addi	a0, a0, 1460
   17762: 93 05 40 02  	li	a1, 36
   17766: 81 46        	li	a3, 0
   17768: 97 c0 00 00  	auipc	ra, 12
   1776c: e7 80 20 c1  	jalr	-1006(ra)
   17770: 37 15 01 00  	lui	a0, 17
   17774: 13 05 35 6e  	addi	a0, a0, 1763
   17778: cd 45        	li	a1, 19
   1777a: 81 46        	li	a3, 0
   1777c: 97 c0 00 00  	auipc	ra, 12
   17780: e7 80 e0 bf  	jalr	-1026(ra)

0000000000017784 <dwarf.Die.getAttrAddr>:
;     ) error{ InvalidDebugInfo, MissingDebugInfo }!u64 {
   17784: 79 71        	addi	sp, sp, -48
;         for (self.attrs.items) |*attr| {
   17786: 06 f4        	sd	ra, 40(sp)
   17788: 22 f0        	sd	s0, 32(sp)
   1778a: 26 ec        	sd	s1, 24(sp)
   1778c: 4a e8        	sd	s2, 16(sp)
   1778e: 4e e4        	sd	s3, 8(sp)
   17790: 1c 7a        	ld	a5, 48(a2)
   17792: 2e 89        	mv	s2, a1
   17794: aa 89        	mv	s3, a0
   17796: 91 cb        	beqz	a5, 0x177aa <dwarf.Die.getAttrAddr+0x26>
   17798: 08 76        	ld	a0, 40(a2)
   1779a: c5 45        	li	a1, 17
;             if (attr.id == id) return &attr.value;
   1779c: 10 61        	ld	a2, 0(a0)
   1779e: 63 01 b6 02  	beq	a2, a1, 0x177c0 <dwarf.Die.getAttrAddr+0x3c>
;         for (self.attrs.items) |*attr| {
   177a2: fd 17        	addi	a5, a5, -1
   177a4: 13 05 05 02  	addi	a0, a0, 32
   177a8: f5 fb        	bnez	a5, 0x1779c <dwarf.Die.getAttrAddr+0x18>
;         const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
   177aa: 4a 85        	mv	a0, s2
   177ac: 97 c0 00 00  	auipc	ra, 12
   177b0: e7 80 c0 44  	jalr	1100(ra)
   177b4: 4d 45        	li	a0, 19
;         const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
   177b6: 23 b4 a9 00  	sd	a0, 8(s3)
   177ba: 23 b0 09 00  	sd	zero, 0(s3)
   177be: 29 a8        	j	0x177d8 <dwarf.Die.getAttrAddr+0x54>
;         return switch (form_value.*) {
   177c0: 83 45 85 01  	lbu	a1, 24(a0)
   177c4: 1c 65        	ld	a5, 8(a0)
   177c6: 05 45        	li	a0, 1
   177c8: 63 8f a5 00  	beq	a1, a0, 0x177e6 <dwarf.Die.getAttrAddr+0x62>
   177cc: 63 9d 05 20  	bnez	a1, 0x179e6 <dwarf.Die.getAttrAddr+0x262>
   177d0: 23 b0 f9 00  	sd	a5, 0(s3)
   177d4: 23 94 09 00  	sh	zero, 8(s3)
   177d8: a2 70        	ld	ra, 40(sp)
   177da: 02 74        	ld	s0, 32(sp)
   177dc: e2 64        	ld	s1, 24(sp)
   177de: 42 69        	ld	s2, 16(sp)
   177e0: a2 69        	ld	s3, 8(sp)
   177e2: 45 61        	addi	sp, sp, 48
   177e4: 82 80        	ret
;                 const debug_addr = di.debug_addr orelse return badDwarf();
   177e6: cc 6a        	ld	a1, 144(a3)
   177e8: 63 8f 05 16  	beqz	a1, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
;                 if (compile_unit.addr_base < 8) return badDwarf();
   177ec: 18 77        	ld	a4, 40(a4)
   177ee: 1d 45        	li	a0, 7
;                 if (compile_unit.addr_base < 8) return badDwarf();
   177f0: 63 7b e5 16  	bgeu	a0, a4, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
   177f4: d0 6e        	ld	a2, 152(a3)
;                 const version = mem.readInt(u16, debug_addr[compile_unit.addr_base - 4 ..][0..2], di.endian);
   177f6: 13 05 c7 ff  	addi	a0, a4, -4
   177fa: 63 6b a6 22  	bltu	a2, a0, 0x17a30 <dwarf.Die.getAttrAddr+0x2ac>
   177fe: b3 04 a6 40  	sub	s1, a2, a0
   17802: 05 44        	li	s0, 1
   17804: 63 7c 94 20  	bgeu	s0, s1, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   17808: 2e 95        	add	a0, a0, a1
;                 const version = mem.readInt(u16, debug_addr[compile_unit.addr_base - 4 ..][0..2], di.endian);
   1780a: 03 c8 86 10  	lbu	a6, 264(a3)
   1780e: 83 46 15 00  	lbu	a3, 1(a0)
   17812: 03 45 05 00  	lbu	a0, 0(a0)
   17816: a2 06        	slli	a3, a3, 8
   17818: 55 8d        	or	a0, a0, a3
;     if (endian == native_endian) {
   1781a: 63 16 08 00  	bnez	a6, 0x17826 <dwarf.Die.getAttrAddr+0xa2>
   1781e: 93 56 85 00  	srli	a3, a0, 8
   17822: 22 05        	slli	a0, a0, 8
   17824: 55 8d        	or	a0, a0, a3
;     if (endian == native_endian) {
   17826: 42 15        	slli	a0, a0, 48
   17828: 41 91        	srli	a0, a0, 48
   1782a: 95 46        	li	a3, 5
;                 if (version != 5) return badDwarf();
   1782c: 63 1d d5 12  	bne	a0, a3, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
;                 const addr_size = debug_addr[compile_unit.addr_base - 2];
   17830: 13 05 e7 ff  	addi	a0, a4, -2
   17834: 63 74 c5 1e  	bgeu	a0, a2, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
;                 const seg_size = debug_addr[compile_unit.addr_base - 1];
   17838: 93 06 f7 ff  	addi	a3, a4, -1
   1783c: 63 f0 c6 1e  	bgeu	a3, a2, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   17840: 2e 95        	add	a0, a0, a1
   17842: 03 45 05 00  	lbu	a0, 0(a0)
;                 const seg_size = debug_addr[compile_unit.addr_base - 1];
   17846: ae 96        	add	a3, a3, a1
   17848: 83 c6 06 00  	lbu	a3, 0(a3)
;                 const byte_offset = compile_unit.addr_base + (addr_size + seg_size) * index;
   1784c: b3 04 d5 00  	add	s1, a0, a3
   17850: 93 f6 f4 0f  	andi	a3, s1, 255
   17854: 63 9a 96 1a  	bne	a3, s1, 0x17a08 <dwarf.Die.getAttrAddr+0x284>
   17858: b3 b4 f6 02  	mulhu	s1, a3, a5
   1785c: 63 96 04 1a  	bnez	s1, 0x17a08 <dwarf.Die.getAttrAddr+0x284>
   17860: b3 86 f6 02  	mul	a3, a3, a5
;                 const byte_offset = compile_unit.addr_base + (addr_size + seg_size) * index;
   17864: ba 96        	add	a3, a3, a4
   17866: 63 e1 e6 1a  	bltu	a3, a4, 0x17a08 <dwarf.Die.getAttrAddr+0x284>
;                 if (byte_offset + addr_size > debug_addr.len) return badDwarf();
   1786a: 33 87 a6 00  	add	a4, a3, a0
   1786e: 63 6d d7 18  	bltu	a4, a3, 0x17a08 <dwarf.Die.getAttrAddr+0x284>
   17872: 63 6a e6 0e  	bltu	a2, a4, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
   17876: 0d 47        	li	a4, 3
;                 switch (addr_size) {
   17878: 63 42 a7 04  	blt	a4, a0, 0x178bc <dwarf.Die.getAttrAddr+0x138>
   1787c: 05 47        	li	a4, 1
;                 switch (addr_size) {
   1787e: 63 0e e5 0e  	beq	a0, a4, 0x1797a <dwarf.Die.getAttrAddr+0x1f6>
   17882: 09 47        	li	a4, 2
;                 switch (addr_size) {
   17884: 63 11 e5 0e  	bne	a0, a4, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
   17888: 63 64 d6 1a  	bltu	a2, a3, 0x17a30 <dwarf.Die.getAttrAddr+0x2ac>
;                     2 => return mem.readInt(u16, debug_addr[byte_offset..][0..2], di.endian),
   1788c: 33 05 d6 40  	sub	a0, a2, a3
   17890: 05 46        	li	a2, 1
   17892: 63 75 a6 18  	bgeu	a2, a0, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   17896: 33 85 d5 00  	add	a0, a1, a3
   1789a: 83 45 15 00  	lbu	a1, 1(a0)
   1789e: 03 45 05 00  	lbu	a0, 0(a0)
   178a2: a2 05        	slli	a1, a1, 8
   178a4: 4d 8d        	or	a0, a0, a1
   178a6: 63 16 08 00  	bnez	a6, 0x178b2 <dwarf.Die.getAttrAddr+0x12e>
   178aa: 93 55 85 00  	srli	a1, a0, 8
   178ae: 22 05        	slli	a0, a0, 8
   178b0: 4d 8d        	or	a0, a0, a1
;                     2 => return mem.readInt(u16, debug_addr[byte_offset..][0..2], di.endian),
   178b2: 42 15        	slli	a0, a0, 48
   178b4: 41 91        	srli	a0, a0, 48
   178b6: 23 b0 a9 00  	sd	a0, 0(s3)
   178ba: 29 bf        	j	0x177d4 <dwarf.Die.getAttrAddr+0x50>
   178bc: 11 47        	li	a4, 4
;                 switch (addr_size) {
   178be: 63 07 e5 0c  	beq	a0, a4, 0x1798c <dwarf.Die.getAttrAddr+0x208>
   178c2: 21 47        	li	a4, 8
;                 switch (addr_size) {
   178c4: 63 11 e5 0a  	bne	a0, a4, 0x17966 <dwarf.Die.getAttrAddr+0x1e2>
   178c8: 63 64 d6 16  	bltu	a2, a3, 0x17a30 <dwarf.Die.getAttrAddr+0x2ac>
;                     8 => return mem.readInt(u64, debug_addr[byte_offset..][0..8], di.endian),
   178cc: 33 05 d6 40  	sub	a0, a2, a3
   178d0: 1d 46        	li	a2, 7
   178d2: 63 75 a6 14  	bgeu	a2, a0, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   178d6: 33 87 d5 00  	add	a4, a1, a3
   178da: 03 46 17 00  	lbu	a2, 1(a4)
   178de: 83 48 07 00  	lbu	a7, 0(a4)
   178e2: 83 46 37 00  	lbu	a3, 3(a4)
   178e6: 03 45 27 00  	lbu	a0, 2(a4)
   178ea: 93 17 86 00  	slli	a5, a2, 8
   178ee: b3 e7 17 01  	or	a5, a5, a7
   178f2: 93 94 86 00  	slli	s1, a3, 8
   178f6: c9 8c        	or	s1, s1, a0
   178f8: c2 04        	slli	s1, s1, 16
   178fa: c5 8f        	or	a5, a5, s1
   178fc: 83 44 57 00  	lbu	s1, 5(a4)
   17900: 03 44 47 00  	lbu	s0, 4(a4)
   17904: 83 45 77 00  	lbu	a1, 7(a4)
   17908: 03 47 67 00  	lbu	a4, 6(a4)
   1790c: a2 04        	slli	s1, s1, 8
   1790e: c1 8c        	or	s1, s1, s0
   17910: a2 05        	slli	a1, a1, 8
   17912: d9 8d        	or	a1, a1, a4
   17914: c2 05        	slli	a1, a1, 16
   17916: c5 8d        	or	a1, a1, s1
   17918: 82 15        	slli	a1, a1, 32
   1791a: 33 e7 f5 00  	or	a4, a1, a5
   1791e: 63 11 08 04  	bnez	a6, 0x17960 <dwarf.Die.getAttrAddr+0x1dc>
   17922: 93 55 87 02  	srli	a1, a4, 40
   17926: c1 67        	lui	a5, 16
   17928: 9b 87 07 f0  	addiw	a5, a5, -256
   1792c: fd 8d        	and	a1, a1, a5
   1792e: 93 57 87 03  	srli	a5, a4, 56
   17932: dd 8d        	or	a1, a1, a5
   17934: 93 57 87 01  	srli	a5, a4, 24
   17938: b7 04 ff 00  	lui	s1, 4080
   1793c: e5 8f        	and	a5, a5, s1
   1793e: 21 83        	srli	a4, a4, 8
   17940: 93 04 f0 0f  	li	s1, 255
   17944: e2 04        	slli	s1, s1, 24
   17946: 65 8f        	and	a4, a4, s1
   17948: 5d 8f        	or	a4, a4, a5
   1794a: d9 8d        	or	a1, a1, a4
   1794c: 82 16        	slli	a3, a3, 32
   1794e: 22 15        	slli	a0, a0, 40
   17950: 55 8d        	or	a0, a0, a3
   17952: 42 16        	slli	a2, a2, 48
   17954: 93 96 88 03  	slli	a3, a7, 56
   17958: 55 8e        	or	a2, a2, a3
   1795a: 51 8d        	or	a0, a0, a2
   1795c: 33 67 b5 00  	or	a4, a0, a1
;                     8 => return mem.readInt(u64, debug_addr[byte_offset..][0..8], di.endian),
   17960: 23 b0 e9 00  	sd	a4, 0(s3)
   17964: 85 bd        	j	0x177d4 <dwarf.Die.getAttrAddr+0x50>
   17966: 4a 85        	mv	a0, s2
   17968: 97 c0 00 00  	auipc	ra, 12
   1796c: e7 80 00 29  	jalr	656(ra)
   17970: 13 05 20 03  	li	a0, 50
   17974: 23 94 a9 00  	sh	a0, 8(s3)
   17978: ad a8        	j	0x179f2 <dwarf.Die.getAttrAddr+0x26e>
;                     1 => return debug_addr[byte_offset],
   1797a: 63 f1 c6 0a  	bgeu	a3, a2, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   1797e: 33 85 d5 00  	add	a0, a1, a3
   17982: 03 45 05 00  	lbu	a0, 0(a0)
   17986: 23 b0 a9 00  	sd	a0, 0(s3)
   1798a: a9 b5        	j	0x177d4 <dwarf.Die.getAttrAddr+0x50>
;                     4 => return mem.readInt(u32, debug_addr[byte_offset..][0..4], di.endian),
   1798c: 63 62 d6 0a  	bltu	a2, a3, 0x17a30 <dwarf.Die.getAttrAddr+0x2ac>
   17990: 33 05 d6 40  	sub	a0, a2, a3
   17994: 0d 46        	li	a2, 3
   17996: 63 73 a6 08  	bgeu	a2, a0, 0x17a1c <dwarf.Die.getAttrAddr+0x298>
   1799a: b6 95        	add	a1, a1, a3
   1799c: 03 c5 15 00  	lbu	a0, 1(a1)
   179a0: 03 c6 05 00  	lbu	a2, 0(a1)
   179a4: 83 c6 35 00  	lbu	a3, 3(a1)
   179a8: 83 c5 25 00  	lbu	a1, 2(a1)
   179ac: 13 17 85 00  	slli	a4, a0, 8
   179b0: 59 8e        	or	a2, a2, a4
   179b2: a2 06        	slli	a3, a3, 8
   179b4: d5 8d        	or	a1, a1, a3
   179b6: c2 05        	slli	a1, a1, 16
   179b8: d1 8d        	or	a1, a1, a2
;     if (endian == native_endian) {
   179ba: 63 10 08 02  	bnez	a6, 0x179da <dwarf.Die.getAttrAddr+0x256>
   179be: 13 d6 85 00  	srli	a2, a1, 8
   179c2: c1 66        	lui	a3, 16
   179c4: 9b 86 06 f0  	addiw	a3, a3, -256
   179c8: 75 8e        	and	a2, a2, a3
   179ca: 93 d6 85 01  	srli	a3, a1, 24
   179ce: 55 8e        	or	a2, a2, a3
   179d0: e2 05        	slli	a1, a1, 24
   179d2: 42 05        	slli	a0, a0, 16
   179d4: 4d 8d        	or	a0, a0, a1
   179d6: b3 65 c5 00  	or	a1, a0, a2
;                     4 => return mem.readInt(u32, debug_addr[byte_offset..][0..4], di.endian),
   179da: 13 95 05 02  	slli	a0, a1, 32
   179de: 01 91        	srli	a0, a0, 32
   179e0: 23 b0 a9 00  	sd	a0, 0(s3)
   179e4: c5 bb        	j	0x177d4 <dwarf.Die.getAttrAddr+0x50>
   179e6: 13 05 20 03  	li	a0, 50
;         return switch (form_value.*) {
   179ea: 23 b4 a9 00  	sd	a0, 8(s3)
   179ee: 23 b0 09 00  	sd	zero, 0(s3)
   179f2: 4a 85        	mv	a0, s2
   179f4: a2 70        	ld	ra, 40(sp)
   179f6: 02 74        	ld	s0, 32(sp)
   179f8: e2 64        	ld	s1, 24(sp)
   179fa: 42 69        	ld	s2, 16(sp)
   179fc: a2 69        	ld	s3, 8(sp)
   179fe: 45 61        	addi	sp, sp, 48
   17a00: 17 c3 00 00  	auipc	t1, 12
   17a04: 67 00 83 1f  	jr	504(t1)
   17a08: 37 15 01 00  	lui	a0, 17
   17a0c: 13 05 95 5d  	addi	a0, a0, 1497
   17a10: c1 45        	li	a1, 16
   17a12: 81 46        	li	a3, 0
   17a14: 97 c0 00 00  	auipc	ra, 12
   17a18: e7 80 60 96  	jalr	-1690(ra)
   17a1c: 37 15 01 00  	lui	a0, 17
   17a20: 13 05 35 6e  	addi	a0, a0, 1763
   17a24: cd 45        	li	a1, 19
   17a26: 81 46        	li	a3, 0
   17a28: 97 c0 00 00  	auipc	ra, 12
   17a2c: e7 80 20 95  	jalr	-1710(ra)
   17a30: 37 15 01 00  	lui	a0, 17
   17a34: 13 05 45 5b  	addi	a0, a0, 1460
   17a38: 93 05 40 02  	li	a1, 36
   17a3c: 81 46        	li	a3, 0
   17a3e: 97 c0 00 00  	auipc	ra, 12
   17a42: e7 80 c0 93  	jalr	-1732(ra)

0000000000017a46 <dwarf.readUnitLength__anon_5326>:
; fn readUnitLength(in_stream: anytype, endian: std.builtin.Endian, is_64: *bool) !u64 {
   17a46: 59 71        	addi	sp, sp, -112
   17a48: 86 f4        	sd	ra, 104(sp)
   17a4a: a2 f0        	sd	s0, 96(sp)
   17a4c: a6 ec        	sd	s1, 88(sp)
   17a4e: ca e8        	sd	s2, 80(sp)
   17a50: ce e4        	sd	s3, 72(sp)
   17a52: d2 e0        	sd	s4, 64(sp)
   17a54: 56 fc        	sd	s5, 56(sp)
   17a56: 5a f8        	sd	s6, 48(sp)
   17a58: 5e f4        	sd	s7, 40(sp)
   17a5a: 62 f0        	sd	s8, 32(sp)
   17a5c: 3a 8a        	mv	s4, a4
   17a5e: 36 8b        	mv	s6, a3
   17a60: b2 8a        	mv	s5, a2
   17a62: 2e 89        	mv	s2, a1
   17a64: aa 89        	mv	s3, a0
   17a66: 81 44        	li	s1, 0
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17a68: 03 3c 06 00  	ld	s8, 0(a2)
   17a6c: 37 b5 aa aa  	lui	a0, 699051
   17a70: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   17a74: 2a c4        	sw	a0, 8(sp)
   17a76: 93 0b 81 00  	addi	s7, sp, 8
   17a7a: 11 44        	li	s0, 4
;                 const amt = try self.read(buffer[index..]);
   17a7c: 33 86 9b 00  	add	a2, s7, s1
   17a80: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   17a84: 08 08        	addi	a0, sp, 16
   17a86: e2 85        	mv	a1, s8
   17a88: 97 a0 00 00  	auipc	ra, 10
   17a8c: e7 80 00 c3  	jalr	-976(ra)
   17a90: 42 65        	ld	a0, 16(sp)
;                 if (amt == 0) break;
   17a92: 63 09 05 10  	beqz	a0, 0x17ba4 <dwarf.readUnitLength__anon_5326+0x15e>
;                 index += amt;
   17a96: 26 95        	add	a0, a0, s1
   17a98: 63 6a 95 18  	bltu	a0, s1, 0x17c2c <dwarf.readUnitLength__anon_5326+0x1e6>
   17a9c: aa 84        	mv	s1, a0
;             while (index < len) {
   17a9e: e3 6f 85 fc  	bltu	a0, s0, 0x17a7c <dwarf.readUnitLength__anon_5326+0x36>
;             return bytes;
   17aa2: 03 65 81 00  	lwu	a0, 8(sp)
;     if (endian == native_endian) {
   17aa6: 13 7b 1b 00  	andi	s6, s6, 1
   17aaa: 63 14 0b 02  	bnez	s6, 0x17ad2 <dwarf.readUnitLength__anon_5326+0x8c>
   17aae: 93 55 85 00  	srli	a1, a0, 8
   17ab2: 41 66        	lui	a2, 16
   17ab4: 1b 06 06 f0  	addiw	a2, a2, -256
   17ab8: f1 8d        	and	a1, a1, a2
   17aba: 13 56 85 01  	srli	a2, a0, 24
   17abe: d1 8d        	or	a1, a1, a2
   17ac0: 13 16 85 00  	slli	a2, a0, 8
   17ac4: b7 06 ff 00  	lui	a3, 4080
   17ac8: 75 8e        	and	a2, a2, a3
   17aca: 1b 15 85 01  	slliw	a0, a0, 24
   17ace: 51 8d        	or	a0, a0, a2
   17ad0: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   17ad2: 9b 05 05 00  	sext.w	a1, a0
;     is_64.* = (first_32_bits == 0xffffffff);
   17ad6: 13 86 15 00  	addi	a2, a1, 1
   17ada: 13 36 16 00  	seqz	a2, a2
   17ade: fd 56        	li	a3, -1
   17ae0: 23 00 ca 00  	sb	a2, 0(s4)
   17ae4: 63 88 d5 00  	beq	a1, a3, 0x17af4 <dwarf.readUnitLength__anon_5326+0xae>
   17ae8: 3d 56        	li	a2, -17
;         if (first_32_bits >= 0xfffffff0) return badDwarf();
   17aea: 63 66 b6 0e  	bltu	a2, a1, 0x17bd6 <dwarf.readUnitLength__anon_5326+0x190>
;         return @as(u64, first_32_bits);
   17aee: 02 15        	slli	a0, a0, 32
   17af0: 01 91        	srli	a0, a0, 32
   17af2: 49 a8        	j	0x17b84 <dwarf.readUnitLength__anon_5326+0x13e>
   17af4: 37 55 02 00  	lui	a0, 37
   17af8: 03 35 85 35  	ld	a0, 856(a0)
   17afc: 81 44        	li	s1, 0
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17afe: 03 b4 0a 00  	ld	s0, 0(s5)
;             var bytes: [num_bytes]u8 = undefined;
   17b02: 2a e4        	sd	a0, 8(sp)
   17b04: 13 0a 81 00  	addi	s4, sp, 8
   17b08: a1 4a        	li	s5, 8
;                 const amt = try self.read(buffer[index..]);
   17b0a: 33 06 9a 00  	add	a2, s4, s1
   17b0e: b3 86 9a 40  	sub	a3, s5, s1
;             return readFn(self.context, buffer);
   17b12: 08 08        	addi	a0, sp, 16
   17b14: a2 85        	mv	a1, s0
   17b16: 97 a0 00 00  	auipc	ra, 10
   17b1a: e7 80 20 ba  	jalr	-1118(ra)
   17b1e: 42 65        	ld	a0, 16(sp)
   17b20: 79 c1        	beqz	a0, 0x17be6 <dwarf.readUnitLength__anon_5326+0x1a0>
;                 index += amt;
   17b22: 26 95        	add	a0, a0, s1
   17b24: 63 64 95 10  	bltu	a0, s1, 0x17c2c <dwarf.readUnitLength__anon_5326+0x1e6>
   17b28: aa 84        	mv	s1, a0
   17b2a: e3 60 55 ff  	bltu	a0, s5, 0x17b0a <dwarf.readUnitLength__anon_5326+0xc4>
;             return bytes;
   17b2e: 22 65        	ld	a0, 8(sp)
   17b30: 63 1a 0b 04  	bnez	s6, 0x17b84 <dwarf.readUnitLength__anon_5326+0x13e>
   17b34: 93 55 85 01  	srli	a1, a0, 24
   17b38: 37 06 ff 00  	lui	a2, 4080
   17b3c: f1 8d        	and	a1, a1, a2
   17b3e: 13 56 85 00  	srli	a2, a0, 8
   17b42: 93 06 f0 0f  	li	a3, 255
   17b46: 13 97 86 01  	slli	a4, a3, 24
   17b4a: 79 8e        	and	a2, a2, a4
   17b4c: d1 8d        	or	a1, a1, a2
   17b4e: 13 56 85 02  	srli	a2, a0, 40
   17b52: 41 67        	lui	a4, 16
   17b54: 1b 07 07 f0  	addiw	a4, a4, -256
   17b58: 79 8e        	and	a2, a2, a4
   17b5a: 13 57 85 03  	srli	a4, a0, 56
   17b5e: 59 8e        	or	a2, a2, a4
   17b60: d1 8d        	or	a1, a1, a2
   17b62: 13 16 85 01  	slli	a2, a0, 24
   17b66: 13 97 86 02  	slli	a4, a3, 40
   17b6a: 79 8e        	and	a2, a2, a4
   17b6c: 1b 57 85 01  	srliw	a4, a0, 24
   17b70: 02 17        	slli	a4, a4, 32
   17b72: 59 8e        	or	a2, a2, a4
   17b74: 13 17 85 02  	slli	a4, a0, 40
   17b78: c2 16        	slli	a3, a3, 48
   17b7a: f9 8e        	and	a3, a3, a4
   17b7c: 62 15        	slli	a0, a0, 56
   17b7e: 55 8d        	or	a0, a0, a3
   17b80: 51 8d        	or	a0, a0, a2
   17b82: 4d 8d        	or	a0, a0, a1
   17b84: 23 b0 a9 00  	sd	a0, 0(s3)
   17b88: 23 94 09 00  	sh	zero, 8(s3)
   17b8c: a6 70        	ld	ra, 104(sp)
   17b8e: 06 74        	ld	s0, 96(sp)
   17b90: e6 64        	ld	s1, 88(sp)
   17b92: 46 69        	ld	s2, 80(sp)
   17b94: a6 69        	ld	s3, 72(sp)
   17b96: 06 6a        	ld	s4, 64(sp)
   17b98: e2 7a        	ld	s5, 56(sp)
   17b9a: 42 7b        	ld	s6, 48(sp)
   17b9c: a2 7b        	ld	s7, 40(sp)
   17b9e: 02 7c        	ld	s8, 32(sp)
   17ba0: 65 61        	addi	sp, sp, 112
   17ba2: 82 80        	ret
;             if (amt_read < buf.len) return error.EndOfStream;
   17ba4: 4a 85        	mv	a0, s2
   17ba6: 97 c0 00 00  	auipc	ra, 12
   17baa: e7 80 20 05  	jalr	82(ra)
;             try self.readNoEof(&bytes);
   17bae: 4a 85        	mv	a0, s2
   17bb0: 97 c0 00 00  	auipc	ra, 12
   17bb4: e7 80 80 04  	jalr	72(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17bb8: 4a 85        	mv	a0, s2
   17bba: 97 c0 00 00  	auipc	ra, 12
   17bbe: e7 80 e0 03  	jalr	62(ra)
;     const first_32_bits = try in_stream.readInt(u32, endian);
   17bc2: 4a 85        	mv	a0, s2
   17bc4: 97 c0 00 00  	auipc	ra, 12
   17bc8: e7 80 40 03  	jalr	52(ra)
   17bcc: 13 05 10 03  	li	a0, 49
   17bd0: 23 94 a9 00  	sh	a0, 8(s3)
   17bd4: 65 bf        	j	0x17b8c <dwarf.readUnitLength__anon_5326+0x146>
;     return error.InvalidDebugInfo;
   17bd6: 4a 85        	mv	a0, s2
   17bd8: 97 c0 00 00  	auipc	ra, 12
   17bdc: e7 80 00 02  	jalr	32(ra)
   17be0: 13 05 20 03  	li	a0, 50
   17be4: 15 a0        	j	0x17c08 <dwarf.readUnitLength__anon_5326+0x1c2>
;             if (amt_read < buf.len) return error.EndOfStream;
   17be6: 4a 85        	mv	a0, s2
   17be8: 97 c0 00 00  	auipc	ra, 12
   17bec: e7 80 00 01  	jalr	16(ra)
;             try self.readNoEof(&bytes);
   17bf0: 4a 85        	mv	a0, s2
   17bf2: 97 c0 00 00  	auipc	ra, 12
   17bf6: e7 80 60 00  	jalr	6(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17bfa: 4a 85        	mv	a0, s2
   17bfc: 97 c0 00 00  	auipc	ra, 12
   17c00: e7 80 c0 ff  	jalr	-4(ra)
   17c04: 13 05 10 03  	li	a0, 49
   17c08: 23 94 a9 00  	sh	a0, 8(s3)
   17c0c: 4a 85        	mv	a0, s2
   17c0e: a6 70        	ld	ra, 104(sp)
   17c10: 06 74        	ld	s0, 96(sp)
   17c12: e6 64        	ld	s1, 88(sp)
   17c14: 46 69        	ld	s2, 80(sp)
   17c16: a6 69        	ld	s3, 72(sp)
   17c18: 06 6a        	ld	s4, 64(sp)
   17c1a: e2 7a        	ld	s5, 56(sp)
   17c1c: 42 7b        	ld	s6, 48(sp)
   17c1e: a2 7b        	ld	s7, 40(sp)
   17c20: 02 7c        	ld	s8, 32(sp)
   17c22: 65 61        	addi	sp, sp, 112
   17c24: 17 c3 00 00  	auipc	t1, 12
   17c28: 67 00 43 fd  	jr	-44(t1)
   17c2c: 37 15 01 00  	lui	a0, 17
   17c30: 13 05 95 5d  	addi	a0, a0, 1497
   17c34: c1 45        	li	a1, 16
   17c36: 81 46        	li	a3, 0
   17c38: 97 b0 00 00  	auipc	ra, 11
   17c3c: e7 80 20 74  	jalr	1858(ra)

0000000000017c40 <dwarf.parseFormValue__anon_5329>:
; fn parseFormValue(allocator: mem.Allocator, in_stream: anytype, form_id: u64, endian: std.builtin.Endian, is_64: bool) anyerror!FormValue {
   17c40: 0d 71        	addi	sp, sp, -352
;     return switch (form_id) {
   17c42: 86 ee        	sd	ra, 344(sp)
   17c44: a2 ea        	sd	s0, 336(sp)
   17c46: a6 e6        	sd	s1, 328(sp)
   17c48: ca e2        	sd	s2, 320(sp)
   17c4a: 4e fe        	sd	s3, 312(sp)
   17c4c: 52 fa        	sd	s4, 304(sp)
   17c4e: 56 f6        	sd	s5, 296(sp)
   17c50: 5a f2        	sd	s6, 288(sp)
   17c52: 5e ee        	sd	s7, 280(sp)
   17c54: 62 ea        	sd	s8, 272(sp)
   17c56: 93 04 f7 ff  	addi	s1, a4, -1
   17c5a: 13 04 b0 02  	li	s0, 43
   17c5e: 2e 89        	mv	s2, a1
   17c60: aa 89        	mv	s3, a0
;     return switch (form_id) {
   17c62: e3 68 94 68  	bltu	s0, s1, 0x18af2 <.LBB34_210>
   17c66: c2 8b        	mv	s7, a6
   17c68: 3e 8a        	mv	s4, a5
   17c6a: 36 8b        	mv	s6, a3
   17c6c: b2 8a        	mv	s5, a2
   17c6e: 13 95 24 00  	slli	a0, s1, 2
   17c72: b7 05 01 00  	lui	a1, 16
   17c76: 93 85 c5 50  	addi	a1, a1, 1292
   17c7a: 2e 95        	add	a0, a0, a1
   17c7c: 08 41        	lw	a0, 0(a0)
   17c7e: 02 85        	jr	a0

0000000000017c80 <.LBB34_2>:
;             const signed = form_id == FORM.sdata;
   17c80: 13 05 37 ff  	addi	a0, a4, -13
   17c84: 13 35 15 00  	seqz	a0, a0
   17c88: b5 45        	li	a1, 13
;     return FormValue{
   17c8a: 23 00 a1 0e  	sb	a0, 224(sp)
;                     if (signed) {
   17c8e: e3 1f b7 46  	bne	a4, a1, 0x1890c <.LBB34_173+0x84>
;                         const x = try nosuspend leb.readILEB128(i64, in_stream);
   17c92: a8 11        	addi	a0, sp, 232
   17c94: a0 11        	addi	s0, sp, 232
;                         const x = try nosuspend leb.readILEB128(i64, in_stream);
   17c96: ca 85        	mv	a1, s2
   17c98: 5a 86        	mv	a2, s6
   17c9a: 97 d0 ff ff  	auipc	ra, 1048573
   17c9e: e7 80 60 89  	jalr	-1898(ra)
   17ca2: 83 54 01 0f  	lhu	s1, 240(sp)
   17ca6: e3 8f 04 46  	beqz	s1, 0x18924 <.LBB34_173+0x9c>
   17caa: 4a 85        	mv	a0, s2
   17cac: 97 c0 00 00  	auipc	ra, 12
   17cb0: e7 80 c0 f4  	jalr	-180(ra)
;             return parseFormValueConstant(in_stream, signed, endian, -1);
   17cb4: 03 05 01 0e  	lb	a0, 224(sp)
   17cb8: 23 84 a9 00  	sb	a0, 8(s3)
   17cbc: 0d 45        	li	a0, 3
   17cbe: 23 88 a9 00  	sb	a0, 16(s3)
   17cc2: 23 9c 99 00  	sh	s1, 24(s3)
   17cc6: 6f 00 30 7c  	j	0x18c88 <.LBB34_210+0x196>

0000000000017cca <.LBB34_5>:
   17cca: 37 55 02 00  	lui	a0, 37
   17cce: 03 35 05 36  	ld	a0, 864(a0)
   17cd2: 01 44        	li	s0, 0
;     return switch (form_id) {
   17cd4: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17cd8: 03 3b 0b 00  	ld	s6, 0(s6)
;             var bytes: [num_bytes]u8 = undefined;
   17cdc: aa f5        	sd	a0, 232(sp)
   17cde: 93 0a 81 0e  	addi	s5, sp, 232
   17ce2: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   17ce4: 33 86 8a 00  	add	a2, s5, s0
   17ce8: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   17cec: a8 19        	addi	a0, sp, 248
   17cee: da 85        	mv	a1, s6
   17cf0: 97 a0 00 00  	auipc	ra, 10
   17cf4: e7 80 80 9c  	jalr	-1592(ra)
   17cf8: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17cfa: e3 06 05 60  	beqz	a0, 0x18b06 <.LBB34_210+0x14>
;                 index += amt;
   17cfe: 22 95        	add	a0, a0, s0
   17d00: 63 74 85 00  	bgeu	a0, s0, 0x17d08 <.LBB34_5+0x3e>
   17d04: 6f 00 50 7f  	j	0x18cf8 <.LBB34_210+0x206>
   17d08: 2a 84        	mv	s0, a0
;             while (index < len) {
   17d0a: e3 6d 95 fc  	bltu	a0, s1, 0x17ce4 <.LBB34_5+0x1a>
;             return bytes;
   17d0e: 2e 75        	ld	a0, 232(sp)
;     if (endian == native_endian) {
   17d10: 93 75 1a 00  	andi	a1, s4, 1
   17d14: a9 e9        	bnez	a1, 0x17d66 <.LBB34_5+0x9c>
   17d16: 93 55 85 01  	srli	a1, a0, 24
   17d1a: 37 06 ff 00  	lui	a2, 4080
   17d1e: f1 8d        	and	a1, a1, a2
   17d20: 13 56 85 00  	srli	a2, a0, 8
   17d24: 93 06 f0 0f  	li	a3, 255
   17d28: 13 97 86 01  	slli	a4, a3, 24
   17d2c: 79 8e        	and	a2, a2, a4
   17d2e: d1 8d        	or	a1, a1, a2
   17d30: 13 56 85 02  	srli	a2, a0, 40
   17d34: 41 67        	lui	a4, 16
   17d36: 1b 07 07 f0  	addiw	a4, a4, -256
   17d3a: 79 8e        	and	a2, a2, a4
   17d3c: 13 57 85 03  	srli	a4, a0, 56
   17d40: 59 8e        	or	a2, a2, a4
   17d42: d1 8d        	or	a1, a1, a2
   17d44: 13 16 85 01  	slli	a2, a0, 24
   17d48: 13 97 86 02  	slli	a4, a3, 40
   17d4c: 79 8e        	and	a2, a2, a4
   17d4e: 1b 57 85 01  	srliw	a4, a0, 24
   17d52: 02 17        	slli	a4, a4, 32
   17d54: 59 8e        	or	a2, a2, a4
   17d56: 13 17 85 02  	slli	a4, a0, 40
   17d5a: c2 16        	slli	a3, a3, 48
   17d5c: f9 8e        	and	a3, a3, a4
   17d5e: 62 15        	slli	a0, a0, 56
   17d60: 55 8d        	or	a0, a0, a3
   17d62: 51 8d        	or	a0, a0, a2
   17d64: 4d 8d        	or	a0, a0, a1
;         FORM.addr => FormValue{ .Address = try readAddress(in_stream, endian, @sizeOf(usize) == 8) },
   17d66: 23 b0 a9 00  	sd	a0, 0(s3)
   17d6a: 23 88 09 00  	sb	zero, 16(s3)
;     return switch (form_id) {
   17d6e: 03 d5 89 01  	lhu	a0, 24(s3)
   17d72: e3 09 05 4c  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   17d76: 6f 00 30 71  	j	0x18c88 <.LBB34_210+0x196>

0000000000017d7a <.LBB34_12>:
   17d7a: 37 55 02 00  	lui	a0, 37
   17d7e: 03 35 05 36  	ld	a0, 864(a0)
   17d82: 81 44        	li	s1, 0
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   17d84: 03 34 0b 00  	ld	s0, 0(s6)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   17d88: aa f5        	sd	a0, 232(sp)
   17d8a: 93 0b 81 0e  	addi	s7, sp, 232
   17d8e: 09 4c        	li	s8, 2
;                 const amt = try self.read(buffer[index..]);
   17d90: 33 86 9b 00  	add	a2, s7, s1
   17d94: b3 06 9c 40  	sub	a3, s8, s1
;             return readFn(self.context, buffer);
   17d98: a8 19        	addi	a0, sp, 248
   17d9a: a2 85        	mv	a1, s0
   17d9c: 97 a0 00 00  	auipc	ra, 10
   17da0: e7 80 c0 91  	jalr	-1764(ra)
   17da4: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17da6: e3 09 05 50  	beqz	a0, 0x18ab8 <.LBB34_173+0x230>
;                 index += amt;
   17daa: 26 95        	add	a0, a0, s1
   17dac: e3 66 95 74  	bltu	a0, s1, 0x18cf8 <.LBB34_210+0x206>
   17db0: aa 84        	mv	s1, a0
;             while (index < len) {
   17db2: e3 6f 85 fd  	bltu	a0, s8, 0x17d90 <.LBB34_12+0x16>
   17db6: 03 45 81 0e  	lbu	a0, 232(sp)
;     switch (endian) {
   17dba: 93 75 1a 00  	andi	a1, s4, 1
   17dbe: e3 88 05 42  	beqz	a1, 0x189ee <.LBB34_173+0x166>
;             for (bytes) |b, index| {
   17dc2: 83 45 91 0e  	lbu	a1, 233(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   17dc6: a2 05        	slli	a1, a1, 8
   17dc8: 33 e7 a5 00  	or	a4, a1, a0
   17dcc: 6f 00 50 44  	j	0x18a10 <.LBB34_173+0x188>

0000000000017dd0 <.LBB34_18>:
   17dd0: 37 55 02 00  	lui	a0, 37
   17dd4: 03 35 05 36  	ld	a0, 864(a0)
   17dd8: 81 44        	li	s1, 0
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   17dda: 03 34 0b 00  	ld	s0, 0(s6)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   17dde: aa f5        	sd	a0, 232(sp)
   17de0: 93 0b 81 0e  	addi	s7, sp, 232
   17de4: 11 4c        	li	s8, 4
;                 const amt = try self.read(buffer[index..]);
   17de6: 33 86 9b 00  	add	a2, s7, s1
   17dea: b3 06 9c 40  	sub	a3, s8, s1
;             return readFn(self.context, buffer);
   17dee: a8 19        	addi	a0, sp, 248
   17df0: a2 85        	mv	a1, s0
   17df2: 97 a0 00 00  	auipc	ra, 10
   17df6: e7 80 60 8c  	jalr	-1850(ra)
   17dfa: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17dfc: e3 0e 05 4a  	beqz	a0, 0x18ab8 <.LBB34_173+0x230>
;                 index += amt;
   17e00: 26 95        	add	a0, a0, s1
   17e02: e3 6b 95 6e  	bltu	a0, s1, 0x18cf8 <.LBB34_210+0x206>
   17e06: aa 84        	mv	s1, a0
;             while (index < len) {
   17e08: e3 6f 85 fd  	bltu	a0, s8, 0x17de6 <.LBB34_18+0x16>
   17e0c: 03 45 81 0e  	lbu	a0, 232(sp)
   17e10: 83 45 91 0e  	lbu	a1, 233(sp)
;     switch (endian) {
   17e14: 13 76 1a 00  	andi	a2, s4, 1
   17e18: e3 01 06 3e  	beqz	a2, 0x189fa <.LBB34_173+0x172>
;             for (bytes) |b, index| {
   17e1c: 03 46 a1 0e  	lbu	a2, 234(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   17e20: a2 05        	slli	a1, a1, 8
;             for (bytes) |b, index| {
   17e22: 83 46 b1 0e  	lbu	a3, 235(sp)
;                 result = result | (@as(ReturnType, b) << @intCast(ShiftType, index * 8));
   17e26: 4d 8d        	or	a0, a0, a1
   17e28: 93 15 06 01  	slli	a1, a2, 16
   17e2c: 4d 8d        	or	a0, a0, a1
   17e2e: 93 95 86 01  	slli	a1, a3, 24
   17e32: 33 67 b5 00  	or	a4, a0, a1
   17e36: 6f 00 b0 3d  	j	0x18a10 <.LBB34_173+0x188>

0000000000017e3a <.LBB34_24>:
   17e3a: 01 44        	li	s0, 0
;     return FormValue{
   17e3c: 23 08 01 02  	sb	zero, 48(sp)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17e40: 03 3b 0b 00  	ld	s6, 0(s6)
   17e44: 2d 65        	lui	a0, 11
   17e46: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   17e4a: 23 14 a1 0e  	sh	a0, 232(sp)
   17e4e: 93 0a 81 0e  	addi	s5, sp, 232
   17e52: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   17e54: 33 86 8a 00  	add	a2, s5, s0
   17e58: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   17e5c: a8 19        	addi	a0, sp, 248
   17e5e: da 85        	mv	a1, s6
   17e60: 97 a0 00 00  	auipc	ra, 10
   17e64: e7 80 80 85  	jalr	-1960(ra)
   17e68: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17e6a: e3 0c 05 4c  	beqz	a0, 0x18b42 <.LBB34_210+0x50>
;                 index += amt;
   17e6e: 22 95        	add	a0, a0, s0
   17e70: e3 64 85 68  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   17e74: 2a 84        	mv	s0, a0
;             while (index < len) {
   17e76: e3 6f 95 fc  	bltu	a0, s1, 0x17e54 <.LBB34_24+0x1a>
;             return bytes;
   17e7a: 03 55 81 0e  	lhu	a0, 232(sp)
;     if (endian == native_endian) {
   17e7e: 93 75 1a 00  	andi	a1, s4, 1
   17e82: 89 e5        	bnez	a1, 0x17e8c <.LBB34_24+0x52>
   17e84: 93 55 85 00  	srli	a1, a0, 8
   17e88: 22 05        	slli	a0, a0, 8
   17e8a: 4d 8d        	or	a0, a0, a1
   17e8c: 81 45        	li	a1, 0
;                 2 => try nosuspend in_stream.readInt(u16, endian),
   17e8e: 42 15        	slli	a0, a0, 48
   17e90: 41 91        	srli	a0, a0, 48
;         FORM.data2 => parseFormValueConstant(in_stream, false, endian, 2),
   17e92: 03 06 01 03  	lb	a2, 48(sp)
   17e96: 21 aa        	j	0x17fae <.LBB34_39+0x9e>

0000000000017e98 <.LBB34_32>:
   17e98: 01 44        	li	s0, 0
;     return FormValue{
   17e9a: 23 0c 01 02  	sb	zero, 56(sp)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17e9e: 03 3b 0b 00  	ld	s6, 0(s6)
   17ea2: 37 b5 aa aa  	lui	a0, 699051
   17ea6: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   17eaa: aa d5        	sw	a0, 232(sp)
   17eac: 93 0a 81 0e  	addi	s5, sp, 232
   17eb0: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   17eb2: 33 86 8a 00  	add	a2, s5, s0
   17eb6: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   17eba: a8 19        	addi	a0, sp, 248
   17ebc: da 85        	mv	a1, s6
   17ebe: 97 90 00 00  	auipc	ra, 9
   17ec2: e7 80 a0 7f  	jalr	2042(ra)
   17ec6: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17ec8: e3 05 05 4a  	beqz	a0, 0x18b72 <.LBB34_210+0x80>
;                 index += amt;
   17ecc: 22 95        	add	a0, a0, s0
   17ece: e3 65 85 62  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   17ed2: 2a 84        	mv	s0, a0
;             while (index < len) {
   17ed4: e3 6f 95 fc  	bltu	a0, s1, 0x17eb2 <.LBB34_32+0x1a>
;             return bytes;
   17ed8: 03 65 81 0e  	lwu	a0, 232(sp)
;     if (endian == native_endian) {
   17edc: 93 75 1a 00  	andi	a1, s4, 1
   17ee0: 95 e1        	bnez	a1, 0x17f04 <.LBB34_32+0x6c>
   17ee2: 93 55 85 00  	srli	a1, a0, 8
   17ee6: 41 66        	lui	a2, 16
   17ee8: 1b 06 06 f0  	addiw	a2, a2, -256
   17eec: f1 8d        	and	a1, a1, a2
   17eee: 13 56 85 01  	srli	a2, a0, 24
   17ef2: d1 8d        	or	a1, a1, a2
   17ef4: 13 16 85 00  	slli	a2, a0, 8
   17ef8: b7 06 ff 00  	lui	a3, 4080
   17efc: 75 8e        	and	a2, a2, a3
   17efe: 62 05        	slli	a0, a0, 24
   17f00: 51 8d        	or	a0, a0, a2
   17f02: 4d 8d        	or	a0, a0, a1
   17f04: 81 45        	li	a1, 0
;                 4 => try nosuspend in_stream.readInt(u32, endian),
   17f06: 02 15        	slli	a0, a0, 32
   17f08: 01 91        	srli	a0, a0, 32
;         FORM.data4 => parseFormValueConstant(in_stream, false, endian, 4),
   17f0a: 03 06 81 03  	lb	a2, 56(sp)
   17f0e: 45 a0        	j	0x17fae <.LBB34_39+0x9e>

0000000000017f10 <.LBB34_39>:
   17f10: 37 55 02 00  	lui	a0, 37
   17f14: 03 35 05 36  	ld	a0, 864(a0)
   17f18: 01 44        	li	s0, 0
;     return FormValue{
   17f1a: 23 00 01 04  	sb	zero, 64(sp)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   17f1e: 03 3b 0b 00  	ld	s6, 0(s6)
;             var bytes: [num_bytes]u8 = undefined;
   17f22: aa f5        	sd	a0, 232(sp)
   17f24: 93 0a 81 0e  	addi	s5, sp, 232
   17f28: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   17f2a: 33 86 8a 00  	add	a2, s5, s0
   17f2e: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   17f32: a8 19        	addi	a0, sp, 248
   17f34: da 85        	mv	a1, s6
   17f36: 97 90 00 00  	auipc	ra, 9
   17f3a: e7 80 20 78  	jalr	1922(ra)
   17f3e: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   17f40: e3 03 05 46  	beqz	a0, 0x18ba6 <.LBB34_210+0xb4>
;                 index += amt;
   17f44: 22 95        	add	a0, a0, s0
   17f46: e3 69 85 5a  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   17f4a: 2a 84        	mv	s0, a0
;             while (index < len) {
   17f4c: e3 6f 95 fc  	bltu	a0, s1, 0x17f2a <.LBB34_39+0x1a>
;             return bytes;
   17f50: 2e 75        	ld	a0, 232(sp)
;     if (endian == native_endian) {
   17f52: 93 75 1a 00  	andi	a1, s4, 1
   17f56: a9 e9        	bnez	a1, 0x17fa8 <.LBB34_39+0x98>
   17f58: 93 55 85 01  	srli	a1, a0, 24
   17f5c: 37 06 ff 00  	lui	a2, 4080
   17f60: f1 8d        	and	a1, a1, a2
   17f62: 13 56 85 00  	srli	a2, a0, 8
   17f66: 93 06 f0 0f  	li	a3, 255
   17f6a: 13 97 86 01  	slli	a4, a3, 24
   17f6e: 79 8e        	and	a2, a2, a4
   17f70: d1 8d        	or	a1, a1, a2
   17f72: 13 56 85 02  	srli	a2, a0, 40
   17f76: 41 67        	lui	a4, 16
   17f78: 1b 07 07 f0  	addiw	a4, a4, -256
   17f7c: 79 8e        	and	a2, a2, a4
   17f7e: 13 57 85 03  	srli	a4, a0, 56
   17f82: 59 8e        	or	a2, a2, a4
   17f84: d1 8d        	or	a1, a1, a2
   17f86: 13 16 85 01  	slli	a2, a0, 24
   17f8a: 13 97 86 02  	slli	a4, a3, 40
   17f8e: 79 8e        	and	a2, a2, a4
   17f90: 1b 57 85 01  	srliw	a4, a0, 24
   17f94: 02 17        	slli	a4, a4, 32
   17f96: 59 8e        	or	a2, a2, a4
   17f98: 13 17 85 02  	slli	a4, a0, 40
   17f9c: c2 16        	slli	a3, a3, 48
   17f9e: f9 8e        	and	a3, a3, a4
   17fa0: 62 15        	slli	a0, a0, 56
   17fa2: 55 8d        	or	a0, a0, a3
   17fa4: 51 8d        	or	a0, a0, a2
   17fa6: 4d 8d        	or	a0, a0, a1
   17fa8: 81 45        	li	a1, 0
;         FORM.data8 => parseFormValueConstant(in_stream, false, endian, 8),
   17faa: 03 06 01 04  	lb	a2, 64(sp)
   17fae: 23 b0 a9 00  	sd	a0, 0(s3)
   17fb2: 23 84 c9 00  	sb	a2, 8(s3)
   17fb6: 0d 45        	li	a0, 3
   17fb8: 05 a6        	j	0x182d8 <.LBB34_84+0x9c>

0000000000017fba <.LBB34_48>:
;         FORM.ref_sig8 => FormValue{ .Ref = try nosuspend in_stream.readInt(u64, endian) },
   17fba: 23 9c 09 00  	sh	zero, 24(s3)
;         FORM.string => FormValue{ .String = try in_stream.readUntilDelimiterAlloc(allocator, 0, math.maxInt(usize)) },
   17fbe: 03 36 0b 00  	ld	a2, 0(s6)
   17fc2: a8 10        	addi	a0, sp, 104
   17fc4: ca 85        	mv	a1, s2
   17fc6: d6 86        	mv	a3, s5
   17fc8: 97 20 00 00  	auipc	ra, 2
   17fcc: e7 80 60 98  	jalr	-1658(ra)
   17fd0: 03 54 81 07  	lhu	s0, 120(sp)
   17fd4: e3 1a 04 50  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   17fd8: 26 75        	ld	a0, 104(sp)
   17fda: c6 75        	ld	a1, 112(sp)
   17fdc: 23 b0 a9 00  	sd	a0, 0(s3)
   17fe0: 23 b4 b9 00  	sd	a1, 8(s3)
   17fe4: 25 45        	li	a0, 9
   17fe6: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   17fea: 03 d5 89 01  	lhu	a0, 24(s3)
   17fee: e3 0b 05 24  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   17ff2: 6f 00 70 49  	j	0x18c88 <.LBB34_210+0x196>

0000000000017ff6 <.LBB34_50>:
;             const block_len = try nosuspend leb.readULEB128(usize, in_stream);
   17ff6: 28 08        	addi	a0, sp, 24
   17ff8: ca 85        	mv	a1, s2
   17ffa: 5a 86        	mv	a2, s6
   17ffc: 97 20 00 00  	auipc	ra, 2
   18000: e7 80 c0 00  	jalr	12(ra)
   18004: 03 54 01 02  	lhu	s0, 32(sp)
   18008: e3 10 04 4e  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   1800c: 62 67        	ld	a4, 24(sp)
;     const buf = try readAllocBytes(allocator, in_stream, size);
   1800e: a8 19        	addi	a0, sp, 248
   18010: ca 85        	mv	a1, s2
   18012: 56 86        	mv	a2, s5
   18014: da 86        	mv	a3, s6
   18016: 97 a0 00 00  	auipc	ra, 10
   1801a: e7 80 c0 a5  	jalr	-1444(ra)
   1801e: 03 54 81 10  	lhu	s0, 264(sp)
   18022: e3 19 04 44  	bnez	s0, 0x18c74 <.LBB34_210+0x182>
   18026: 6e 75        	ld	a0, 248(sp)
   18028: 92 65        	ld	a1, 256(sp)
;             return parseFormValueBlockLen(allocator, in_stream, block_len);
   1802a: 23 b0 a9 00  	sd	a0, 0(s3)
   1802e: 23 b4 b9 00  	sd	a1, 8(s3)
   18032: 09 45        	li	a0, 2
   18034: 6f 00 10 10  	j	0x18934 <.LBB34_173+0xac>

0000000000018038 <.LBB34_53>:
   18038: 37 55 02 00  	lui	a0, 37
   1803c: 03 35 05 36  	ld	a0, 864(a0)
;     const block_len = try nosuspend in_stream.readVarInt(usize, endian, size);
   18040: 83 35 0b 00  	ld	a1, 0(s6)
;             var bytes_buf: [@sizeOf(ReturnType)]u8 = undefined;
   18044: aa f5        	sd	a0, 232(sp)
;             return readFn(self.context, buffer);
   18046: a8 19        	addi	a0, sp, 248
   18048: b0 11        	addi	a2, sp, 232
   1804a: 85 46        	li	a3, 1
   1804c: 97 90 00 00  	auipc	ra, 9
   18050: e7 80 c0 66  	jalr	1644(ra)
   18054: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18056: e3 01 05 26  	beqz	a0, 0x18ab8 <.LBB34_173+0x230>
   1805a: 03 47 81 0e  	lbu	a4, 232(sp)
   1805e: 6f 00 30 1b  	j	0x18a10 <.LBB34_173+0x188>

0000000000018062 <.LBB34_55>:
;     return FormValue{
   18062: 23 04 01 02  	sb	zero, 40(sp)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18066: 83 35 0b 00  	ld	a1, 0(s6)
   1806a: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   1806e: 23 04 a1 0e  	sb	a0, 232(sp)
;             return readFn(self.context, buffer);
   18072: a8 19        	addi	a0, sp, 248
   18074: b0 11        	addi	a2, sp, 232
   18076: 85 46        	li	a3, 1
   18078: 97 90 00 00  	auipc	ra, 9
   1807c: e7 80 00 64  	jalr	1600(ra)
   18080: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18082: e3 0a 05 36  	beqz	a0, 0x18bf6 <.LBB34_210+0x104>
;             return bytes;
   18086: 83 45 81 0e  	lbu	a1, 232(sp)
   1808a: 01 45        	li	a0, 0
;         FORM.data1 => parseFormValueConstant(in_stream, false, endian, 1),
   1808c: 03 06 81 02  	lb	a2, 40(sp)
   18090: 23 b0 b9 00  	sd	a1, 0(s3)
   18094: 23 84 c9 00  	sb	a2, 8(s3)
   18098: 8d 45        	li	a1, 3
   1809a: e1 a0        	j	0x18162 <.LBB34_66+0x2c>

000000000001809c <.LBB34_58>:
;             return FormValue{ .ExprLoc = buf };
   1809c: 23 9c 09 00  	sh	zero, 24(s3)
   180a0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   180a4: 23 04 a1 0e  	sb	a0, 232(sp)
;             const amt_read = try self.read(result[0..]);
   180a8: 83 35 0b 00  	ld	a1, 0(s6)
;             return readFn(self.context, buffer);
   180ac: a8 19        	addi	a0, sp, 248
   180ae: b0 11        	addi	a2, sp, 232
   180b0: 85 46        	li	a3, 1
   180b2: 97 90 00 00  	auipc	ra, 9
   180b6: e7 80 60 60  	jalr	1542(ra)
   180ba: 6e 75        	ld	a0, 248(sp)
;             if (amt_read < 1) return error.EndOfStream;
   180bc: e3 04 05 26  	beqz	a0, 0x18b24 <.LBB34_210+0x32>
;             return result[0];
   180c0: 03 45 81 0e  	lbu	a0, 232(sp)
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   180c4: 33 35 a0 00  	snez	a0, a0
   180c8: 23 80 a9 00  	sb	a0, 0(s3)
   180cc: 15 45        	li	a0, 5
   180ce: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   180d2: 03 d5 89 01  	lhu	a0, 24(s3)
   180d6: e3 07 05 16  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   180da: 6f 00 f0 3a  	j	0x18c88 <.LBB34_210+0x196>

00000000000180de <.LBB34_60>:
;         FORM.string => FormValue{ .String = try in_stream.readUntilDelimiterAlloc(allocator, 0, math.maxInt(usize)) },
   180de: 23 9c 09 00  	sh	zero, 24(s3)
   180e2: 03 36 0b 00  	ld	a2, 0(s6)
;     return nosuspend if (is_64)
   180e6: 13 f5 1b 00  	andi	a0, s7, 1
   180ea: e3 0a 05 04  	beqz	a0, 0x1893e <.LBB34_173+0xb6>
;         try in_stream.readInt(u64, endian)
   180ee: a8 19        	addi	a0, sp, 248
   180f0: ca 85        	mv	a1, s2
   180f2: d2 86        	mv	a3, s4
   180f4: 97 c0 ff ff  	auipc	ra, 1048572
   180f8: e7 80 40 10  	jalr	260(ra)
   180fc: 03 54 01 10  	lhu	s0, 256(sp)
   18100: e3 1f 04 3c  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   18104: 6e 75        	ld	a0, 248(sp)
   18106: 6f 00 30 05  	j	0x18958 <.LBB34_173+0xd0>

000000000001810a <.LBB34_63>:
;         FORM.ref_udata => parseFormValueRef(in_stream, endian, -1),
   1810a: 23 9c 09 00  	sh	zero, 24(s3)
   1810e: 03 36 0b 00  	ld	a2, 0(s6)
;     return nosuspend if (is_64)
   18112: 13 f5 1b 00  	andi	a0, s7, 1
   18116: e3 0a 05 04  	beqz	a0, 0x1896a <.LBB34_173+0xe2>
;         try in_stream.readInt(u64, endian)
   1811a: a8 19        	addi	a0, sp, 248
   1811c: ca 85        	mv	a1, s2
   1811e: d2 86        	mv	a3, s4
   18120: 97 c0 ff ff  	auipc	ra, 1048572
   18124: e7 80 80 0d  	jalr	216(ra)
   18128: 03 54 01 10  	lhu	s0, 256(sp)
   1812c: e3 19 04 3a  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   18130: 6e 75        	ld	a0, 248(sp)
   18132: 6f 00 30 05  	j	0x18984 <.LBB34_173+0xfc>

0000000000018136 <.LBB34_66>:
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18136: 83 35 0b 00  	ld	a1, 0(s6)
   1813a: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   1813e: 23 04 a1 0e  	sb	a0, 232(sp)
;             return readFn(self.context, buffer);
   18142: a8 19        	addi	a0, sp, 248
   18144: b0 11        	addi	a2, sp, 232
   18146: 85 46        	li	a3, 1
   18148: 97 90 00 00  	auipc	ra, 9
   1814c: e7 80 00 57  	jalr	1392(ra)
   18150: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18152: e3 0a 05 2c  	beqz	a0, 0x18c26 <.LBB34_210+0x134>
;             return bytes;
   18156: 83 45 81 0e  	lbu	a1, 232(sp)
   1815a: 01 45        	li	a0, 0
;         FORM.ref1 => parseFormValueRef(in_stream, endian, 1),
   1815c: 23 b0 b9 00  	sd	a1, 0(s3)
   18160: 9d 45        	li	a1, 7
   18162: 23 88 b9 00  	sb	a1, 16(s3)
   18166: 23 9c a9 00  	sh	a0, 24(s3)
;     return switch (form_id) {
   1816a: 03 d5 89 01  	lhu	a0, 24(s3)
   1816e: e3 0b 05 0c  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   18172: 6f 00 70 31  	j	0x18c88 <.LBB34_210+0x196>

0000000000018176 <.LBB34_70>:
   18176: 01 44        	li	s0, 0
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18178: 03 3b 0b 00  	ld	s6, 0(s6)
   1817c: 2d 65        	lui	a0, 11
   1817e: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   18182: 23 14 a1 0e  	sh	a0, 232(sp)
   18186: 93 0a 81 0e  	addi	s5, sp, 232
   1818a: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   1818c: 33 86 8a 00  	add	a2, s5, s0
   18190: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   18194: a8 19        	addi	a0, sp, 248
   18196: da 85        	mv	a1, s6
   18198: 97 90 00 00  	auipc	ra, 9
   1819c: e7 80 00 52  	jalr	1312(ra)
   181a0: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   181a2: e3 04 05 0e  	beqz	a0, 0x18a8a <.LBB34_173+0x202>
;                 index += amt;
   181a6: 22 95        	add	a0, a0, s0
   181a8: e3 68 85 34  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   181ac: 2a 84        	mv	s0, a0
;             while (index < len) {
   181ae: e3 6f 95 fc  	bltu	a0, s1, 0x1818c <.LBB34_70+0x16>
;             return bytes;
   181b2: 03 55 81 0e  	lhu	a0, 232(sp)
;     if (endian == native_endian) {
   181b6: 93 75 1a 00  	andi	a1, s4, 1
   181ba: 89 e5        	bnez	a1, 0x181c4 <.LBB34_70+0x4e>
   181bc: 93 55 85 00  	srli	a1, a0, 8
   181c0: 22 05        	slli	a0, a0, 8
   181c2: 4d 8d        	or	a0, a0, a1
   181c4: 81 45        	li	a1, 0
;             2 => try nosuspend in_stream.readInt(u16, endian),
   181c6: 42 15        	slli	a0, a0, 48
   181c8: 41 91        	srli	a0, a0, 48
   181ca: 21 a2        	j	0x182d2 <.LBB34_84+0x96>

00000000000181cc <.LBB34_77>:
   181cc: 01 44        	li	s0, 0
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   181ce: 03 3b 0b 00  	ld	s6, 0(s6)
   181d2: 37 b5 aa aa  	lui	a0, 699051
   181d6: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   181da: aa d5        	sw	a0, 232(sp)
   181dc: 93 0a 81 0e  	addi	s5, sp, 232
   181e0: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   181e2: 33 86 8a 00  	add	a2, s5, s0
   181e6: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   181ea: a8 19        	addi	a0, sp, 248
   181ec: da 85        	mv	a1, s6
   181ee: 97 90 00 00  	auipc	ra, 9
   181f2: e7 80 a0 4c  	jalr	1226(ra)
   181f6: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   181f8: e3 09 05 08  	beqz	a0, 0x18a8a <.LBB34_173+0x202>
;                 index += amt;
   181fc: 22 95        	add	a0, a0, s0
   181fe: e3 6d 85 2e  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   18202: 2a 84        	mv	s0, a0
;             while (index < len) {
   18204: e3 6f 95 fc  	bltu	a0, s1, 0x181e2 <.LBB34_77+0x16>
;             return bytes;
   18208: 03 65 81 0e  	lwu	a0, 232(sp)
;     if (endian == native_endian) {
   1820c: 93 75 1a 00  	andi	a1, s4, 1
   18210: 95 e1        	bnez	a1, 0x18234 <.LBB34_77+0x68>
   18212: 93 55 85 00  	srli	a1, a0, 8
   18216: 41 66        	lui	a2, 16
   18218: 1b 06 06 f0  	addiw	a2, a2, -256
   1821c: f1 8d        	and	a1, a1, a2
   1821e: 13 56 85 01  	srli	a2, a0, 24
   18222: d1 8d        	or	a1, a1, a2
   18224: 13 16 85 00  	slli	a2, a0, 8
   18228: b7 06 ff 00  	lui	a3, 4080
   1822c: 75 8e        	and	a2, a2, a3
   1822e: 62 05        	slli	a0, a0, 24
   18230: 51 8d        	or	a0, a0, a2
   18232: 4d 8d        	or	a0, a0, a1
   18234: 81 45        	li	a1, 0
;             4 => try nosuspend in_stream.readInt(u32, endian),
   18236: 02 15        	slli	a0, a0, 32
   18238: 01 91        	srli	a0, a0, 32
   1823a: 61 a8        	j	0x182d2 <.LBB34_84+0x96>

000000000001823c <.LBB34_84>:
   1823c: 37 55 02 00  	lui	a0, 37
   18240: 03 35 05 36  	ld	a0, 864(a0)
   18244: 81 44        	li	s1, 0
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18246: 03 34 0b 00  	ld	s0, 0(s6)
;             var bytes: [num_bytes]u8 = undefined;
   1824a: aa f5        	sd	a0, 232(sp)
   1824c: 93 0a 81 0e  	addi	s5, sp, 232
   18250: 21 4b        	li	s6, 8
;                 const amt = try self.read(buffer[index..]);
   18252: 33 86 9a 00  	add	a2, s5, s1
   18256: b3 06 9b 40  	sub	a3, s6, s1
;             return readFn(self.context, buffer);
   1825a: a8 19        	addi	a0, sp, 248
   1825c: a2 85        	mv	a1, s0
   1825e: 97 90 00 00  	auipc	ra, 9
   18262: e7 80 a0 45  	jalr	1114(ra)
   18266: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18268: e3 01 05 02  	beqz	a0, 0x18a8a <.LBB34_173+0x202>
;                 index += amt;
   1826c: 26 95        	add	a0, a0, s1
   1826e: e3 65 95 28  	bltu	a0, s1, 0x18cf8 <.LBB34_210+0x206>
   18272: aa 84        	mv	s1, a0
;             while (index < len) {
   18274: e3 6f 65 fd  	bltu	a0, s6, 0x18252 <.LBB34_84+0x16>
;             return bytes;
   18278: 2e 75        	ld	a0, 232(sp)
;     if (endian == native_endian) {
   1827a: 93 75 1a 00  	andi	a1, s4, 1
   1827e: a9 e9        	bnez	a1, 0x182d0 <.LBB34_84+0x94>
   18280: 93 55 85 01  	srli	a1, a0, 24
   18284: 37 06 ff 00  	lui	a2, 4080
   18288: f1 8d        	and	a1, a1, a2
   1828a: 13 56 85 00  	srli	a2, a0, 8
   1828e: 93 06 f0 0f  	li	a3, 255
   18292: 13 97 86 01  	slli	a4, a3, 24
   18296: 79 8e        	and	a2, a2, a4
   18298: d1 8d        	or	a1, a1, a2
   1829a: 13 56 85 02  	srli	a2, a0, 40
   1829e: 41 67        	lui	a4, 16
   182a0: 1b 07 07 f0  	addiw	a4, a4, -256
   182a4: 79 8e        	and	a2, a2, a4
   182a6: 13 57 85 03  	srli	a4, a0, 56
   182aa: 59 8e        	or	a2, a2, a4
   182ac: d1 8d        	or	a1, a1, a2
   182ae: 13 16 85 01  	slli	a2, a0, 24
   182b2: 13 97 86 02  	slli	a4, a3, 40
   182b6: 79 8e        	and	a2, a2, a4
   182b8: 1b 57 85 01  	srliw	a4, a0, 24
   182bc: 02 17        	slli	a4, a4, 32
   182be: 59 8e        	or	a2, a2, a4
   182c0: 13 17 85 02  	slli	a4, a0, 40
   182c4: c2 16        	slli	a3, a3, 48
   182c6: f9 8e        	and	a3, a3, a4
   182c8: 62 15        	slli	a0, a0, 56
   182ca: 55 8d        	or	a0, a0, a3
   182cc: 51 8d        	or	a0, a0, a2
   182ce: 4d 8d        	or	a0, a0, a1
   182d0: 81 45        	li	a1, 0
   182d2: 23 b0 a9 00  	sd	a0, 0(s3)
   182d6: 1d 45        	li	a0, 7
   182d8: 23 88 a9 00  	sb	a0, 16(s3)
   182dc: 23 9c b9 00  	sh	a1, 24(s3)
;     return switch (form_id) {
   182e0: 03 d5 89 01  	lhu	a0, 24(s3)
   182e4: 63 00 05 76  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   182e8: 6f 00 10 1a  	j	0x18c88 <.LBB34_210+0x196>

00000000000182ec <.LBB34_93>:
;             -1 => try nosuspend leb.readULEB128(u64, in_stream),
   182ec: a8 19        	addi	a0, sp, 248
   182ee: ca 85        	mv	a1, s2
   182f0: 5a 86        	mv	a2, s6
   182f2: 97 c0 ff ff  	auipc	ra, 1048572
   182f6: e7 80 40 00  	jalr	4(ra)
   182fa: 03 54 01 10  	lhu	s0, 256(sp)
   182fe: e3 1c 04 14  	bnez	s0, 0x18c56 <.LBB34_210+0x164>
   18302: 6e 75        	ld	a0, 248(sp)
;         FORM.ref_udata => parseFormValueRef(in_stream, endian, -1),
   18304: 23 b0 a9 00  	sd	a0, 0(s3)
   18308: 1d 45        	li	a0, 7
   1830a: 2d a7        	j	0x18a34 <.LBB34_173+0x1ac>

000000000001830c <.LBB34_96>:
;             const child_form_id = try nosuspend leb.readULEB128(u64, in_stream);
   1830c: 08 09        	addi	a0, sp, 144
   1830e: ca 85        	mv	a1, s2
   18310: 5a 86        	mv	a2, s6
   18312: 97 c0 ff ff  	auipc	ra, 1048572
   18316: e7 80 40 fe  	jalr	-28(ra)
   1831a: 03 54 81 09  	lhu	s0, 152(sp)
   1831e: e3 15 04 1c  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   18322: 4a 67        	ld	a4, 144(sp)
;                 return parseFormValue(allocator, in_stream, child_form_id, endian, is_64);
   18324: 08 11        	addi	a0, sp, 160
   18326: ca 85        	mv	a1, s2
   18328: 56 86        	mv	a2, s5
   1832a: da 86        	mv	a3, s6
   1832c: d2 87        	mv	a5, s4
   1832e: 5e 88        	mv	a6, s7
   18330: 97 00 00 00  	auipc	ra, 0
   18334: e7 80 00 91  	jalr	-1776(ra)
   18338: 4a 75        	ld	a0, 176(sp)
   1833a: aa 75        	ld	a1, 168(sp)
   1833c: 6a 76        	ld	a2, 184(sp)
   1833e: 23 b8 a9 00  	sd	a0, 16(s3)
   18342: 23 b4 b9 00  	sd	a1, 8(s3)
   18346: 0a 75        	ld	a0, 160(sp)
   18348: 23 bc c9 00  	sd	a2, 24(s3)
   1834c: 93 15 06 03  	slli	a1, a2, 48
   18350: c1 91        	srli	a1, a1, 48
   18352: 23 b0 a9 00  	sd	a0, 0(s3)
   18356: 63 87 05 6e  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   1835a: 4a 85        	mv	a0, s2
   1835c: 97 c0 00 00  	auipc	ra, 12
   18360: e7 80 c0 89  	jalr	-1892(ra)
   18364: c5 a5        	j	0x18a44 <.LBB34_173+0x1bc>

0000000000018366 <.LBB34_99>:
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   18366: 23 9c 09 00  	sh	zero, 24(s3)
   1836a: 03 36 0b 00  	ld	a2, 0(s6)
;     return nosuspend if (is_64)
   1836e: 13 f5 1b 00  	andi	a0, s7, 1
   18372: 63 02 05 62  	beqz	a0, 0x18996 <.LBB34_173+0x10e>
;         try in_stream.readInt(u64, endian)
   18376: a8 19        	addi	a0, sp, 248
   18378: ca 85        	mv	a1, s2
   1837a: d2 86        	mv	a3, s4
   1837c: 97 c0 ff ff  	auipc	ra, 1048572
   18380: e7 80 c0 e7  	jalr	-388(ra)
   18384: 03 54 01 10  	lhu	s0, 256(sp)
   18388: e3 1b 04 14  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   1838c: 6e 75        	ld	a0, 248(sp)
   1838e: 0d a5        	j	0x189b0 <.LBB34_173+0x128>

0000000000018390 <.LBB34_102>:
   18390: 06 8c        	mv	s8, ra
;             const size = try nosuspend leb.readULEB128(usize, in_stream);
   18392: a8 08        	addi	a0, sp, 88
   18394: ca 85        	mv	a1, s2
   18396: 5a 86        	mv	a2, s6
   18398: 97 20 00 00  	auipc	ra, 2
   1839c: e7 80 00 c7  	jalr	-912(ra)
   183a0: 83 54 01 06  	lhu	s1, 96(sp)
   183a4: e3 90 04 0c  	bnez	s1, 0x18c64 <.LBB34_210+0x172>
   183a8: 66 6a        	ld	s4, 88(sp)
;     if (n == 0) {
   183aa: 63 09 0a 6a  	beqz	s4, 0x18a5c <.LBB34_173+0x1d4>
;     const buf = try allocator.alloc(u8, size);
   183ae: 83 b5 8a 00  	ld	a1, 8(s5)
   183b2: 03 b5 0a 00  	ld	a0, 0(s5)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   183b6: 98 61        	ld	a4, 0(a1)
   183b8: d2 85        	mv	a1, s4
   183ba: 01 46        	li	a2, 0
   183bc: e2 86        	mv	a3, s8
   183be: 02 97        	jalr	a4
   183c0: e3 04 05 10  	beqz	a0, 0x18cc8 <.LBB34_210+0x1d6>
   183c4: aa 84        	mv	s1, a0
;     @memset(byte_ptr, undefined, byte_count);
   183c6: 93 05 a0 0a  	li	a1, 170
   183ca: 52 86        	mv	a2, s4
   183cc: 97 c0 00 00  	auipc	ra, 12
   183d0: e7 80 e0 ec  	jalr	-306(ra)
   183d4: 69 a5        	j	0x18a5e <.LBB34_173+0x1d6>

00000000000183d6 <.LBB34_106>:
;         FORM.flag => FormValue{ .Flag = (try nosuspend in_stream.readByte()) != 0 },
   183d6: 37 15 01 00  	lui	a0, 17
   183da: 83 35 85 06  	ld	a1, 104(a0)
   183de: 13 05 85 06  	addi	a0, a0, 104
   183e2: ad aa        	j	0x1855c <.LBB34_126+0xc>

00000000000183e4 <.LBB34_107>:
;         FORM.strx => return FormValue{ .StrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   183e4: 23 9c 09 00  	sh	zero, 24(s3)
   183e8: 08 01        	addi	a0, sp, 128
   183ea: ca 85        	mv	a1, s2
   183ec: 5a 86        	mv	a2, s6
   183ee: 97 20 00 00  	auipc	ra, 2
   183f2: e7 80 a0 c1  	jalr	-998(ra)
   183f6: 03 54 81 08  	lhu	s0, 136(sp)
   183fa: e3 17 04 0e  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   183fe: 0a 65        	ld	a0, 128(sp)
   18400: 09 a4        	j	0x18602 <.LBB34_132+0x28>

0000000000018402 <.LBB34_109>:
;         FORM.addrx => return FormValue{ .AddrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   18402: 23 9c 09 00  	sh	zero, 24(s3)
   18406: 28 00        	addi	a0, sp, 8
   18408: ca 85        	mv	a1, s2
   1840a: 5a 86        	mv	a2, s6
   1840c: 97 20 00 00  	auipc	ra, 2
   18410: e7 80 c0 bf  	jalr	-1028(ra)
   18414: 03 54 01 01  	lhu	s0, 16(sp)
   18418: e3 18 04 0c  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   1841c: 22 65        	ld	a0, 8(sp)
   1841e: 83 d5 89 01  	lhu	a1, 24(s3)
   18422: e9 a9        	j	0x188fc <.LBB34_173+0x74>

0000000000018424 <.LBB34_111>:
   18424: 37 55 02 00  	lui	a0, 37
   18428: 03 35 05 36  	ld	a0, 864(a0)
   1842c: 01 44        	li	s0, 0
;             var buf: [16]u8 = undefined;
   1842e: aa e8        	sd	a0, 80(sp)
   18430: aa e4        	sd	a0, 72(sp)
   18432: 13 0a 81 04  	addi	s4, sp, 72
   18436: c1 44        	li	s1, 16
;                 const amt = try self.read(buffer[index..]);
   18438: 83 35 0b 00  	ld	a1, 0(s6)
   1843c: 33 06 8a 00  	add	a2, s4, s0
   18440: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   18444: a8 19        	addi	a0, sp, 248
   18446: 97 90 00 00  	auipc	ra, 9
   1844a: e7 80 20 27  	jalr	626(ra)
   1844e: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18450: 63 03 05 78  	beqz	a0, 0x18bd6 <.LBB34_210+0xe4>
;                 index += amt;
   18454: 22 95        	add	a0, a0, s0
   18456: e3 61 85 0a  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   1845a: 2a 84        	mv	s0, a0
;             while (index < len) {
   1845c: e3 6e 95 fc  	bltu	a0, s1, 0x18438 <.LBB34_111+0x14>
;             return FormValue{ .data16 = buf };
   18460: 23 9c 09 00  	sh	zero, 24(s3)
   18464: ac 00        	addi	a1, sp, 72
   18466: 41 46        	li	a2, 16
   18468: 4e 85        	mv	a0, s3
   1846a: 97 c0 00 00  	auipc	ra, 12
   1846e: e7 80 a0 e0  	jalr	-502(ra)
   18472: 3d 45        	li	a0, 15
   18474: 23 88 a9 00  	sb	a0, 16(s3)
   18478: f1 a3        	j	0x18a44 <.LBB34_173+0x1bc>

000000000001847a <.LBB34_116>:
;         FORM.strx => return FormValue{ .StrOffset = try nosuspend leb.readULEB128(usize, in_stream) },
   1847a: 23 9c 09 00  	sh	zero, 24(s3)
   1847e: 03 36 0b 00  	ld	a2, 0(s6)
;     return nosuspend if (is_64)
   18482: 13 f5 1b 00  	andi	a0, s7, 1
   18486: 63 0e 05 52  	beqz	a0, 0x189c2 <.LBB34_173+0x13a>
;         try in_stream.readInt(u64, endian)
   1848a: a8 19        	addi	a0, sp, 248
   1848c: ca 85        	mv	a1, s2
   1848e: d2 86        	mv	a3, s4
   18490: 97 c0 ff ff  	auipc	ra, 1048572
   18494: e7 80 80 d6  	jalr	-664(ra)
   18498: 03 54 01 10  	lhu	s0, 256(sp)
   1849c: e3 11 04 04  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   184a0: 6e 75        	ld	a0, 248(sp)
   184a2: 2d ab        	j	0x189dc <.LBB34_173+0x154>

00000000000184a4 <.LBB34_119>:
   184a4: 37 55 02 00  	lui	a0, 37
   184a8: 03 35 05 36  	ld	a0, 864(a0)
   184ac: 01 44        	li	s0, 0
;         FORM.ref_addr => FormValue{ .RefAddr = try readAddress(in_stream, endian, is_64) },
   184ae: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   184b2: 03 3b 0b 00  	ld	s6, 0(s6)
;             var bytes: [num_bytes]u8 = undefined;
   184b6: aa f5        	sd	a0, 232(sp)
   184b8: 93 0a 81 0e  	addi	s5, sp, 232
   184bc: a1 44        	li	s1, 8
;                 const amt = try self.read(buffer[index..]);
   184be: 33 86 8a 00  	add	a2, s5, s0
   184c2: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   184c6: a8 19        	addi	a0, sp, 248
   184c8: da 85        	mv	a1, s6
   184ca: 97 90 00 00  	auipc	ra, 9
   184ce: e7 80 e0 1e  	jalr	494(ra)
   184d2: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   184d4: 63 0e 05 62  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   184d8: 22 95        	add	a0, a0, s0
   184da: e3 6f 85 00  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   184de: 2a 84        	mv	s0, a0
;             while (index < len) {
   184e0: e3 6f 95 fc  	bltu	a0, s1, 0x184be <.LBB34_119+0x1a>
;             return bytes;
   184e4: 2e 75        	ld	a0, 232(sp)
;     if (endian == native_endian) {
   184e6: 93 75 1a 00  	andi	a1, s4, 1
   184ea: a9 e9        	bnez	a1, 0x1853c <.LBB34_119+0x98>
   184ec: 93 55 85 01  	srli	a1, a0, 24
   184f0: 37 06 ff 00  	lui	a2, 4080
   184f4: f1 8d        	and	a1, a1, a2
   184f6: 13 56 85 00  	srli	a2, a0, 8
   184fa: 93 06 f0 0f  	li	a3, 255
   184fe: 13 97 86 01  	slli	a4, a3, 24
   18502: 79 8e        	and	a2, a2, a4
   18504: d1 8d        	or	a1, a1, a2
   18506: 13 56 85 02  	srli	a2, a0, 40
   1850a: 41 67        	lui	a4, 16
   1850c: 1b 07 07 f0  	addiw	a4, a4, -256
   18510: 79 8e        	and	a2, a2, a4
   18512: 13 57 85 03  	srli	a4, a0, 56
   18516: 59 8e        	or	a2, a2, a4
   18518: d1 8d        	or	a1, a1, a2
   1851a: 13 16 85 01  	slli	a2, a0, 24
   1851e: 13 97 86 02  	slli	a4, a3, 40
   18522: 79 8e        	and	a2, a2, a4
   18524: 1b 57 85 01  	srliw	a4, a0, 24
   18528: 02 17        	slli	a4, a4, 32
   1852a: 59 8e        	or	a2, a2, a4
   1852c: 13 17 85 02  	slli	a4, a0, 40
   18530: c2 16        	slli	a3, a3, 48
   18532: f9 8e        	and	a3, a3, a4
   18534: 62 15        	slli	a0, a0, 56
   18536: 55 8d        	or	a0, a0, a3
   18538: 51 8d        	or	a0, a0, a2
   1853a: 4d 8d        	or	a0, a0, a1
;         FORM.ref_sig8 => FormValue{ .Ref = try nosuspend in_stream.readInt(u64, endian) },
   1853c: 23 b0 a9 00  	sd	a0, 0(s3)
   18540: 1d 45        	li	a0, 7
   18542: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   18546: 03 d5 89 01  	lhu	a0, 24(s3)
   1854a: 63 0d 05 4e  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   1854e: 2d af        	j	0x18c88 <.LBB34_210+0x196>

0000000000018550 <.LBB34_126>:
;                 return parseFormValue(allocator, in_stream, child_form_id, endian, is_64);
   18550: 37 15 01 00  	lui	a0, 17
   18554: 83 35 05 08  	ld	a1, 128(a0)
   18558: 13 05 05 08  	addi	a0, a0, 128
   1855c: 10 65        	ld	a2, 8(a0)
   1855e: 08 69        	ld	a0, 16(a0)
   18560: 23 b0 b9 00  	sd	a1, 0(s3)
   18564: 23 9c 09 00  	sh	zero, 24(s3)
   18568: 23 b4 c9 00  	sd	a2, 8(s3)
   1856c: 23 b8 a9 00  	sd	a0, 16(s3)
;     return switch (form_id) {
   18570: 03 d5 89 01  	lhu	a0, 24(s3)
   18574: 63 08 05 4c  	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   18578: 01 af        	j	0x18c88 <.LBB34_210+0x196>

000000000001857a <.LBB34_128>:
;         FORM.loclistx => return FormValue{ .LocListOffset = try nosuspend leb.readULEB128(u64, in_stream) },
   1857a: 23 9c 09 00  	sh	zero, 24(s3)
   1857e: 88 01        	addi	a0, sp, 192
   18580: ca 85        	mv	a1, s2
   18582: 5a 86        	mv	a2, s6
   18584: 97 c0 ff ff  	auipc	ra, 1048572
   18588: e7 80 20 d7  	jalr	-654(ra)
   1858c: 03 54 81 0c  	lhu	s0, 200(sp)
   18590: 63 1c 04 74  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   18594: 0e 65        	ld	a0, 192(sp)
   18596: 83 d5 89 01  	lhu	a1, 24(s3)
   1859a: 23 b0 a9 00  	sd	a0, 0(s3)
   1859e: 35 45        	li	a0, 13
   185a0: 23 88 a9 00  	sb	a0, 16(s3)
   185a4: 63 80 05 4a  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   185a8: c5 a5        	j	0x18c88 <.LBB34_210+0x196>

00000000000185aa <.LBB34_130>:
;         FORM.rnglistx => return FormValue{ .RangeListOffset = try nosuspend leb.readULEB128(u64, in_stream) },
   185aa: 23 9c 09 00  	sh	zero, 24(s3)
   185ae: 88 09        	addi	a0, sp, 208
   185b0: ca 85        	mv	a1, s2
   185b2: 5a 86        	mv	a2, s6
   185b4: 97 c0 ff ff  	auipc	ra, 1048572
   185b8: e7 80 20 d4  	jalr	-702(ra)
   185bc: 03 54 81 0d  	lhu	s0, 216(sp)
   185c0: 63 14 04 72  	bnez	s0, 0x18ce8 <.LBB34_210+0x1f6>
   185c4: 4e 65        	ld	a0, 208(sp)
   185c6: 83 d5 89 01  	lhu	a1, 24(s3)
   185ca: 23 b0 a9 00  	sd	a0, 0(s3)
   185ce: 39 45        	li	a0, 14
   185d0: 23 88 a9 00  	sb	a0, 16(s3)
   185d4: 63 88 05 46  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   185d8: 45 ad        	j	0x18c88 <.LBB34_210+0x196>

00000000000185da <.LBB34_132>:
;         FORM.strx1 => return FormValue{ .StrOffset = try in_stream.readInt(u8, endian) },
   185da: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   185de: 83 35 0b 00  	ld	a1, 0(s6)
   185e2: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   185e6: 23 04 a1 0e  	sb	a0, 232(sp)
;             return readFn(self.context, buffer);
   185ea: a8 19        	addi	a0, sp, 248
   185ec: b0 11        	addi	a2, sp, 232
   185ee: 85 46        	li	a3, 1
   185f0: 97 90 00 00  	auipc	ra, 9
   185f4: e7 80 80 0c  	jalr	200(ra)
   185f8: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   185fa: 63 0b 05 50  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;             return bytes;
   185fe: 03 45 81 0e  	lbu	a0, 232(sp)
   18602: 83 d5 89 01  	lhu	a1, 24(s3)
   18606: 99 aa        	j	0x1875c <.LBB34_149+0x74>

0000000000018608 <.LBB34_135>:
   18608: 01 44        	li	s0, 0
;         FORM.strx2 => return FormValue{ .StrOffset = try in_stream.readInt(u16, endian) },
   1860a: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1860e: 03 3b 0b 00  	ld	s6, 0(s6)
   18612: 2d 65        	lui	a0, 11
   18614: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   18618: 23 14 a1 0e  	sh	a0, 232(sp)
   1861c: 93 0a 81 0e  	addi	s5, sp, 232
   18620: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   18622: 33 86 8a 00  	add	a2, s5, s0
   18626: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1862a: a8 19        	addi	a0, sp, 248
   1862c: da 85        	mv	a1, s6
   1862e: 97 90 00 00  	auipc	ra, 9
   18632: e7 80 a0 08  	jalr	138(ra)
   18636: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18638: 63 0c 05 4c  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   1863c: 22 95        	add	a0, a0, s0
   1863e: 63 6d 85 6a  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   18642: 2a 84        	mv	s0, a0
;             while (index < len) {
   18644: e3 6f 95 fc  	bltu	a0, s1, 0x18622 <.LBB34_135+0x1a>
;             return bytes;
   18648: 03 55 81 0e  	lhu	a0, 232(sp)
;     if (endian == native_endian) {
   1864c: 93 75 1a 00  	andi	a1, s4, 1
   18650: 89 e5        	bnez	a1, 0x1865a <.LBB34_135+0x52>
   18652: 93 55 85 00  	srli	a1, a0, 8
   18656: 22 05        	slli	a0, a0, 8
   18658: 4d 8d        	or	a0, a0, a1
;         FORM.strx2 => return FormValue{ .StrOffset = try in_stream.readInt(u16, endian) },
   1865a: 42 15        	slli	a0, a0, 48
   1865c: 83 d5 89 01  	lhu	a1, 24(s3)
   18660: 41 91        	srli	a0, a0, 48
   18662: ed a8        	j	0x1875c <.LBB34_149+0x74>

0000000000018664 <.LBB34_142>:
   18664: 81 44        	li	s1, 0
;         FORM.strx3 => return FormValue{ .StrOffset = try in_stream.readInt(u24, endian) },
   18666: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1866a: 03 3b 0b 00  	ld	s6, 0(s6)
   1866e: 13 05 a0 fa  	li	a0, -86
;             var bytes: [num_bytes]u8 = undefined;
   18672: 23 05 a1 0e  	sb	a0, 234(sp)
   18676: 6d 75        	lui	a0, 1048571
   18678: 1b 05 a5 aa  	addiw	a0, a0, -1366
   1867c: 23 14 a1 0e  	sh	a0, 232(sp)
   18680: 93 0a 81 0e  	addi	s5, sp, 232
   18684: 0d 44        	li	s0, 3
;                 const amt = try self.read(buffer[index..]);
   18686: 33 86 9a 00  	add	a2, s5, s1
   1868a: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   1868e: a8 19        	addi	a0, sp, 248
   18690: da 85        	mv	a1, s6
   18692: 97 90 00 00  	auipc	ra, 9
   18696: e7 80 60 02  	jalr	38(ra)
   1869a: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   1869c: 63 0a 05 46  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   186a0: 26 95        	add	a0, a0, s1
   186a2: 63 6b 95 64  	bltu	a0, s1, 0x18cf8 <.LBB34_210+0x206>
   186a6: aa 84        	mv	s1, a0
;             while (index < len) {
   186a8: e3 6f 85 fc  	bltu	a0, s0, 0x18686 <.LBB34_142+0x22>
;             return bytes;
   186ac: 03 05 a1 0e  	lb	a0, 234(sp)
   186b0: 83 55 81 0e  	lhu	a1, 232(sp)
   186b4: 42 05        	slli	a0, a0, 16
;     if (endian == native_endian) {
   186b6: 13 76 1a 00  	andi	a2, s4, 1
;             return bytes;
   186ba: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   186bc: 0d e2        	bnez	a2, 0x186de <.LBB34_142+0x7a>
;     return @byteSwap(readIntNative(T, bytes));
   186be: 93 55 85 00  	srli	a1, a0, 8
   186c2: 41 66        	lui	a2, 16
   186c4: 1b 06 06 f0  	addiw	a2, a2, -256
   186c8: f1 8d        	and	a1, a1, a2
   186ca: 13 16 85 00  	slli	a2, a0, 8
   186ce: b7 06 ff 00  	lui	a3, 4080
   186d2: 75 8e        	and	a2, a2, a3
   186d4: 62 05        	slli	a0, a0, 24
   186d6: 51 8d        	or	a0, a0, a2
   186d8: 4d 8d        	or	a0, a0, a1
   186da: 1b 55 85 00  	srliw	a0, a0, 8
;         FORM.strx3 => return FormValue{ .StrOffset = try in_stream.readInt(u24, endian) },
   186de: 22 15        	slli	a0, a0, 40
   186e0: 83 d5 89 01  	lhu	a1, 24(s3)
   186e4: 21 91        	srli	a0, a0, 40
   186e6: 9d a8        	j	0x1875c <.LBB34_149+0x74>

00000000000186e8 <.LBB34_149>:
   186e8: 01 44        	li	s0, 0
;         FORM.strx4 => return FormValue{ .StrOffset = try in_stream.readInt(u32, endian) },
   186ea: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   186ee: 03 3b 0b 00  	ld	s6, 0(s6)
   186f2: 37 b5 aa aa  	lui	a0, 699051
   186f6: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   186fa: aa d5        	sw	a0, 232(sp)
   186fc: 93 0a 81 0e  	addi	s5, sp, 232
   18700: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   18702: 33 86 8a 00  	add	a2, s5, s0
   18706: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1870a: a8 19        	addi	a0, sp, 248
   1870c: da 85        	mv	a1, s6
   1870e: 97 90 00 00  	auipc	ra, 9
   18712: e7 80 a0 fa  	jalr	-86(ra)
   18716: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   18718: 63 0c 05 3e  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   1871c: 22 95        	add	a0, a0, s0
   1871e: 63 6d 85 5c  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   18722: 2a 84        	mv	s0, a0
;             while (index < len) {
   18724: e3 6f 95 fc  	bltu	a0, s1, 0x18702 <.LBB34_149+0x1a>
;             return bytes;
   18728: 03 65 81 0e  	lwu	a0, 232(sp)
;     if (endian == native_endian) {
   1872c: 93 75 1a 00  	andi	a1, s4, 1
   18730: 95 e1        	bnez	a1, 0x18754 <.LBB34_149+0x6c>
   18732: 93 55 85 00  	srli	a1, a0, 8
   18736: 41 66        	lui	a2, 16
   18738: 1b 06 06 f0  	addiw	a2, a2, -256
   1873c: f1 8d        	and	a1, a1, a2
   1873e: 13 56 85 01  	srli	a2, a0, 24
   18742: d1 8d        	or	a1, a1, a2
   18744: 13 16 85 00  	slli	a2, a0, 8
   18748: b7 06 ff 00  	lui	a3, 4080
   1874c: 75 8e        	and	a2, a2, a3
   1874e: 62 05        	slli	a0, a0, 24
   18750: 51 8d        	or	a0, a0, a2
   18752: 4d 8d        	or	a0, a0, a1
;         FORM.strx4 => return FormValue{ .StrOffset = try in_stream.readInt(u32, endian) },
   18754: 02 15        	slli	a0, a0, 32
   18756: 83 d5 89 01  	lhu	a1, 24(s3)
   1875a: 01 91        	srli	a0, a0, 32
   1875c: 23 b0 a9 00  	sd	a0, 0(s3)
   18760: 2d 45        	li	a0, 11
   18762: 23 88 a9 00  	sb	a0, 16(s3)
   18766: 63 8f 05 2c  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   1876a: 39 ab        	j	0x18c88 <.LBB34_210+0x196>

000000000001876c <.LBB34_157>:
;         FORM.addrx1 => return FormValue{ .AddrOffset = try in_stream.readInt(u8, endian) },
   1876c: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18770: 83 35 0b 00  	ld	a1, 0(s6)
   18774: 13 05 a0 0a  	li	a0, 170
;             var bytes: [num_bytes]u8 = undefined;
   18778: 23 04 a1 0e  	sb	a0, 232(sp)
;             return readFn(self.context, buffer);
   1877c: a8 19        	addi	a0, sp, 248
   1877e: b0 11        	addi	a2, sp, 232
   18780: 85 46        	li	a3, 1
   18782: 05 44        	li	s0, 1
   18784: 97 90 00 00  	auipc	ra, 9
   18788: e7 80 40 f3  	jalr	-204(ra)
   1878c: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   1878e: 63 01 05 38  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;             return bytes;
   18792: 03 45 81 0e  	lbu	a0, 232(sp)
;         FORM.addrx1 => return FormValue{ .AddrOffset = try in_stream.readInt(u8, endian) },
   18796: 83 d5 89 01  	lhu	a1, 24(s3)
   1879a: 23 b0 a9 00  	sd	a0, 0(s3)
   1879e: 23 88 89 00  	sb	s0, 16(s3)
   187a2: 63 81 05 2a  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   187a6: cd a1        	j	0x18c88 <.LBB34_210+0x196>

00000000000187a8 <.LBB34_159>:
   187a8: 01 44        	li	s0, 0
;         FORM.addrx2 => return FormValue{ .AddrOffset = try in_stream.readInt(u16, endian) },
   187aa: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   187ae: 03 3b 0b 00  	ld	s6, 0(s6)
   187b2: 2d 65        	lui	a0, 11
   187b4: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   187b8: 23 14 a1 0e  	sh	a0, 232(sp)
   187bc: 93 0a 81 0e  	addi	s5, sp, 232
   187c0: 89 44        	li	s1, 2
;                 const amt = try self.read(buffer[index..]);
   187c2: 33 86 8a 00  	add	a2, s5, s0
   187c6: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   187ca: a8 19        	addi	a0, sp, 248
   187cc: da 85        	mv	a1, s6
   187ce: 97 90 00 00  	auipc	ra, 9
   187d2: e7 80 a0 ee  	jalr	-278(ra)
   187d6: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   187d8: 63 0c 05 32  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   187dc: 22 95        	add	a0, a0, s0
   187de: 63 6d 85 50  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   187e2: 2a 84        	mv	s0, a0
;             while (index < len) {
   187e4: e3 6f 95 fc  	bltu	a0, s1, 0x187c2 <.LBB34_159+0x1a>
;             return bytes;
   187e8: 03 55 81 0e  	lhu	a0, 232(sp)
;     if (endian == native_endian) {
   187ec: 93 75 1a 00  	andi	a1, s4, 1
   187f0: 89 e5        	bnez	a1, 0x187fa <.LBB34_159+0x52>
   187f2: 93 55 85 00  	srli	a1, a0, 8
   187f6: 22 05        	slli	a0, a0, 8
   187f8: 4d 8d        	or	a0, a0, a1
;         FORM.addrx2 => return FormValue{ .AddrOffset = try in_stream.readInt(u16, endian) },
   187fa: 42 15        	slli	a0, a0, 48
   187fc: 83 d5 89 01  	lhu	a1, 24(s3)
   18800: 41 91        	srli	a0, a0, 48
   18802: ed a8        	j	0x188fc <.LBB34_173+0x74>

0000000000018804 <.LBB34_166>:
   18804: 81 44        	li	s1, 0
;         FORM.addrx3 => return FormValue{ .AddrOffset = try in_stream.readInt(u24, endian) },
   18806: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1880a: 03 3b 0b 00  	ld	s6, 0(s6)
   1880e: 13 05 a0 fa  	li	a0, -86
;             var bytes: [num_bytes]u8 = undefined;
   18812: 23 05 a1 0e  	sb	a0, 234(sp)
   18816: 6d 75        	lui	a0, 1048571
   18818: 1b 05 a5 aa  	addiw	a0, a0, -1366
   1881c: 23 14 a1 0e  	sh	a0, 232(sp)
   18820: 93 0a 81 0e  	addi	s5, sp, 232
   18824: 0d 44        	li	s0, 3
;                 const amt = try self.read(buffer[index..]);
   18826: 33 86 9a 00  	add	a2, s5, s1
   1882a: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   1882e: a8 19        	addi	a0, sp, 248
   18830: da 85        	mv	a1, s6
   18832: 97 90 00 00  	auipc	ra, 9
   18836: e7 80 60 e8  	jalr	-378(ra)
   1883a: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   1883c: 63 0a 05 2c  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   18840: 26 95        	add	a0, a0, s1
   18842: 63 6b 95 4a  	bltu	a0, s1, 0x18cf8 <.LBB34_210+0x206>
   18846: aa 84        	mv	s1, a0
;             while (index < len) {
   18848: e3 6f 85 fc  	bltu	a0, s0, 0x18826 <.LBB34_166+0x22>
;             return bytes;
   1884c: 03 05 a1 0e  	lb	a0, 234(sp)
   18850: 83 55 81 0e  	lhu	a1, 232(sp)
   18854: 42 05        	slli	a0, a0, 16
;     if (endian == native_endian) {
   18856: 13 76 1a 00  	andi	a2, s4, 1
;             return bytes;
   1885a: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   1885c: 0d e2        	bnez	a2, 0x1887e <.LBB34_166+0x7a>
;     return @byteSwap(readIntNative(T, bytes));
   1885e: 93 55 85 00  	srli	a1, a0, 8
   18862: 41 66        	lui	a2, 16
   18864: 1b 06 06 f0  	addiw	a2, a2, -256
   18868: f1 8d        	and	a1, a1, a2
   1886a: 13 16 85 00  	slli	a2, a0, 8
   1886e: b7 06 ff 00  	lui	a3, 4080
   18872: 75 8e        	and	a2, a2, a3
   18874: 62 05        	slli	a0, a0, 24
   18876: 51 8d        	or	a0, a0, a2
   18878: 4d 8d        	or	a0, a0, a1
   1887a: 1b 55 85 00  	srliw	a0, a0, 8
;         FORM.addrx3 => return FormValue{ .AddrOffset = try in_stream.readInt(u24, endian) },
   1887e: 22 15        	slli	a0, a0, 40
   18880: 83 d5 89 01  	lhu	a1, 24(s3)
   18884: 21 91        	srli	a0, a0, 40
   18886: 9d a8        	j	0x188fc <.LBB34_173+0x74>

0000000000018888 <.LBB34_173>:
   18888: 01 44        	li	s0, 0
;         FORM.addrx4 => return FormValue{ .AddrOffset = try in_stream.readInt(u32, endian) },
   1888a: 23 9c 09 00  	sh	zero, 24(s3)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1888e: 03 3b 0b 00  	ld	s6, 0(s6)
   18892: 37 b5 aa aa  	lui	a0, 699051
   18896: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   1889a: aa d5        	sw	a0, 232(sp)
   1889c: 93 0a 81 0e  	addi	s5, sp, 232
   188a0: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   188a2: 33 86 8a 00  	add	a2, s5, s0
   188a6: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   188aa: a8 19        	addi	a0, sp, 248
   188ac: da 85        	mv	a1, s6
   188ae: 97 90 00 00  	auipc	ra, 9
   188b2: e7 80 a0 e0  	jalr	-502(ra)
   188b6: 6e 75        	ld	a0, 248(sp)
;                 if (amt == 0) break;
   188b8: 63 0c 05 24  	beqz	a0, 0x18b10 <.LBB34_210+0x1e>
;                 index += amt;
   188bc: 22 95        	add	a0, a0, s0
   188be: 63 6d 85 42  	bltu	a0, s0, 0x18cf8 <.LBB34_210+0x206>
   188c2: 2a 84        	mv	s0, a0
;             while (index < len) {
   188c4: e3 6f 95 fc  	bltu	a0, s1, 0x188a2 <.LBB34_173+0x1a>
;             return bytes;
   188c8: 03 65 81 0e  	lwu	a0, 232(sp)
;     if (endian == native_endian) {
   188cc: 93 75 1a 00  	andi	a1, s4, 1
   188d0: 95 e1        	bnez	a1, 0x188f4 <.LBB34_173+0x6c>
   188d2: 93 55 85 00  	srli	a1, a0, 8
   188d6: 41 66        	lui	a2, 16
   188d8: 1b 06 06 f0  	addiw	a2, a2, -256
   188dc: f1 8d        	and	a1, a1, a2
   188de: 13 56 85 01  	srli	a2, a0, 24
   188e2: d1 8d        	or	a1, a1, a2
   188e4: 13 16 85 00  	slli	a2, a0, 8
   188e8: b7 06 ff 00  	lui	a3, 4080
   188ec: 75 8e        	and	a2, a2, a3
   188ee: 62 05        	slli	a0, a0, 24
   188f0: 51 8d        	or	a0, a0, a2
   188f2: 4d 8d        	or	a0, a0, a1
;         FORM.addrx4 => return FormValue{ .AddrOffset = try in_stream.readInt(u32, endian) },
   188f4: 02 15        	slli	a0, a0, 32
   188f6: 83 d5 89 01  	lhu	a1, 24(s3)
   188fa: 01 91        	srli	a0, a0, 32
   188fc: 23 b0 a9 00  	sd	a0, 0(s3)
   18900: 05 45        	li	a0, 1
   18902: 23 88 a9 00  	sb	a0, 16(s3)
   18906: 63 8f 05 12  	beqz	a1, 0x18a44 <.LBB34_173+0x1bc>
   1890a: bd ae        	j	0x18c88 <.LBB34_210+0x196>
;                         const x = try nosuspend leb.readULEB128(u64, in_stream);
   1890c: a8 19        	addi	a0, sp, 248
   1890e: a0 19        	addi	s0, sp, 248
;                         const x = try nosuspend leb.readULEB128(u64, in_stream);
   18910: ca 85        	mv	a1, s2
   18912: 5a 86        	mv	a2, s6
   18914: 97 c0 ff ff  	auipc	ra, 1048572
   18918: e7 80 20 9e  	jalr	-1566(ra)
   1891c: 83 54 01 10  	lhu	s1, 256(sp)
   18920: 63 95 04 b8  	bnez	s1, 0x17caa <.LBB34_2+0x2a>
   18924: 08 60        	ld	a0, 0(s0)
;             return parseFormValueConstant(in_stream, signed, endian, -1);
   18926: 83 05 01 0e  	lb	a1, 224(sp)
   1892a: 23 b0 a9 00  	sd	a0, 0(s3)
   1892e: 23 84 b9 00  	sb	a1, 8(s3)
   18932: 0d 45        	li	a0, 3
   18934: 23 88 a9 00  	sb	a0, 16(s3)
   18938: 23 9c 09 00  	sh	zero, 24(s3)
   1893c: 21 a2        	j	0x18a44 <.LBB34_173+0x1bc>
;         @as(u64, try in_stream.readInt(u32, endian));
   1893e: a8 11        	addi	a0, sp, 232
   18940: ca 85        	mv	a1, s2
   18942: d2 86        	mv	a3, s4
   18944: 97 b0 ff ff  	auipc	ra, 1048571
   18948: e7 80 20 7e  	jalr	2018(ra)
   1894c: 03 54 c1 0e  	lhu	s0, 236(sp)
   18950: 63 17 04 38  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   18954: 03 65 81 0e  	lwu	a0, 232(sp)
;         FORM.strp => FormValue{ .StrPtr = try readAddress(in_stream, endian, is_64) },
   18958: 23 b0 a9 00  	sd	a0, 0(s3)
   1895c: 29 45        	li	a0, 10
   1895e: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   18962: 03 d5 89 01  	lhu	a0, 24(s3)
   18966: 79 cd        	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   18968: 05 a6        	j	0x18c88 <.LBB34_210+0x196>
;         @as(u64, try in_stream.readInt(u32, endian));
   1896a: a8 11        	addi	a0, sp, 232
   1896c: ca 85        	mv	a1, s2
   1896e: d2 86        	mv	a3, s4
   18970: 97 b0 ff ff  	auipc	ra, 1048571
   18974: e7 80 60 7b  	jalr	1974(ra)
   18978: 03 54 c1 0e  	lhu	s0, 236(sp)
   1897c: 63 11 04 36  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   18980: 03 65 81 0e  	lwu	a0, 232(sp)
;         FORM.ref_addr => FormValue{ .RefAddr = try readAddress(in_stream, endian, is_64) },
   18984: 23 b0 a9 00  	sd	a0, 0(s3)
   18988: 21 45        	li	a0, 8
   1898a: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   1898e: 03 d5 89 01  	lhu	a0, 24(s3)
   18992: 4d c9        	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   18994: d5 ac        	j	0x18c88 <.LBB34_210+0x196>
;         @as(u64, try in_stream.readInt(u32, endian));
   18996: a8 11        	addi	a0, sp, 232
   18998: ca 85        	mv	a1, s2
   1899a: d2 86        	mv	a3, s4
   1899c: 97 b0 ff ff  	auipc	ra, 1048571
   189a0: e7 80 a0 78  	jalr	1930(ra)
   189a4: 03 54 c1 0e  	lhu	s0, 236(sp)
   189a8: 63 1b 04 32  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   189ac: 03 65 81 0e  	lwu	a0, 232(sp)
;         FORM.sec_offset => FormValue{ .SecOffset = try readAddress(in_stream, endian, is_64) },
   189b0: 23 b0 a9 00  	sd	a0, 0(s3)
   189b4: 19 45        	li	a0, 6
   189b6: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   189ba: 03 d5 89 01  	lhu	a0, 24(s3)
   189be: 59 c1        	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   189c0: e1 a4        	j	0x18c88 <.LBB34_210+0x196>
;         @as(u64, try in_stream.readInt(u32, endian));
   189c2: a8 11        	addi	a0, sp, 232
   189c4: ca 85        	mv	a1, s2
   189c6: d2 86        	mv	a3, s4
   189c8: 97 b0 ff ff  	auipc	ra, 1048571
   189cc: e7 80 e0 75  	jalr	1886(ra)
   189d0: 03 54 c1 0e  	lhu	s0, 236(sp)
   189d4: 63 15 04 30  	bnez	s0, 0x18cde <.LBB34_210+0x1ec>
   189d8: 03 65 81 0e  	lwu	a0, 232(sp)
;         FORM.line_strp => FormValue{ .LineStrPtr = try readAddress(in_stream, endian, is_64) },
   189dc: 23 b0 a9 00  	sd	a0, 0(s3)
   189e0: 31 45        	li	a0, 12
   189e2: 23 88 a9 00  	sb	a0, 16(s3)
;     return switch (form_id) {
   189e6: 03 d5 89 01  	lhu	a0, 24(s3)
   189ea: 29 cd        	beqz	a0, 0x18a44 <.LBB34_173+0x1bc>
   189ec: 71 ac        	j	0x18c88 <.LBB34_210+0x196>
;             for (bytes) |b| {
   189ee: 83 45 91 0e  	lbu	a1, 233(sp)
;                 result = (result << 8) | b;
   189f2: 22 05        	slli	a0, a0, 8
   189f4: 33 67 b5 00  	or	a4, a0, a1
   189f8: 21 a8        	j	0x18a10 <.LBB34_173+0x188>
;                 result = (result << 8) | b;
   189fa: 42 05        	slli	a0, a0, 16
;             for (bytes) |b| {
   189fc: 03 46 a1 0e  	lbu	a2, 234(sp)
;                 result = (result << 8) | b;
   18a00: a2 05        	slli	a1, a1, 8
;             for (bytes) |b| {
   18a02: 83 46 b1 0e  	lbu	a3, 235(sp)
;                 result = (result << 8) | b;
   18a06: 4d 8d        	or	a0, a0, a1
   18a08: 51 8d        	or	a0, a0, a2
   18a0a: 22 05        	slli	a0, a0, 8
   18a0c: 33 67 d5 00  	or	a4, a0, a3
   18a10: a8 19        	addi	a0, sp, 248
   18a12: ca 85        	mv	a1, s2
   18a14: 56 86        	mv	a2, s5
   18a16: da 86        	mv	a3, s6
   18a18: 97 90 00 00  	auipc	ra, 9
   18a1c: e7 80 a0 05  	jalr	90(ra)
   18a20: 03 54 81 10  	lhu	s0, 264(sp)
   18a24: 45 ec        	bnez	s0, 0x18adc <.LBB34_173+0x254>
   18a26: ee 75        	ld	a1, 248(sp)
   18a28: 12 65        	ld	a0, 256(sp)
   18a2a: 23 b0 b9 00  	sd	a1, 0(s3)
   18a2e: 23 b4 a9 00  	sd	a0, 8(s3)
   18a32: 09 45        	li	a0, 2
   18a34: 23 88 a9 00  	sb	a0, 16(s3)
   18a38: 23 9c 89 00  	sh	s0, 24(s3)
;     return switch (form_id) {
   18a3c: 03 d5 89 01  	lhu	a0, 24(s3)
   18a40: 63 14 05 24  	bnez	a0, 0x18c88 <.LBB34_210+0x196>
   18a44: f6 60        	ld	ra, 344(sp)
   18a46: 56 64        	ld	s0, 336(sp)
   18a48: b6 64        	ld	s1, 328(sp)
   18a4a: 16 69        	ld	s2, 320(sp)
   18a4c: f2 79        	ld	s3, 312(sp)
   18a4e: 52 7a        	ld	s4, 304(sp)
   18a50: b2 7a        	ld	s5, 296(sp)
   18a52: 12 7b        	ld	s6, 288(sp)
   18a54: f2 6b        	ld	s7, 280(sp)
   18a56: 52 6c        	ld	s8, 272(sp)
   18a58: 35 61        	addi	sp, sp, 352
   18a5a: 82 80        	ret
   18a5c: fd 54        	li	s1, -1
;             return readFn(self.context, buffer);
   18a5e: 83 35 0b 00  	ld	a1, 0(s6)
   18a62: a8 19        	addi	a0, sp, 248
   18a64: 26 86        	mv	a2, s1
   18a66: d2 86        	mv	a3, s4
   18a68: 97 90 00 00  	auipc	ra, 9
   18a6c: e7 80 00 c5  	jalr	-944(ra)
   18a70: 6e 75        	ld	a0, 248(sp)
;     if ((try nosuspend in_stream.read(buf)) < size) return error.EndOfFile;
   18a72: 63 6b 45 23  	bltu	a0, s4, 0x18ca8 <.LBB34_210+0x1b6>
;             return FormValue{ .ExprLoc = buf };
   18a76: 23 9c 09 00  	sh	zero, 24(s3)
   18a7a: 23 b0 99 00  	sd	s1, 0(s3)
   18a7e: 23 b4 49 01  	sd	s4, 8(s3)
   18a82: 11 45        	li	a0, 4
   18a84: 23 88 a9 00  	sb	a0, 16(s3)
   18a88: 75 bf        	j	0x18a44 <.LBB34_173+0x1bc>
   18a8a: 4a 85        	mv	a0, s2
   18a8c: 97 b0 00 00  	auipc	ra, 11
   18a90: e7 80 c0 16  	jalr	364(ra)
   18a94: 4a 85        	mv	a0, s2
   18a96: 97 b0 00 00  	auipc	ra, 11
   18a9a: e7 80 20 16  	jalr	354(ra)
   18a9e: 4a 85        	mv	a0, s2
   18aa0: 97 b0 00 00  	auipc	ra, 11
   18aa4: e7 80 80 15  	jalr	344(ra)
   18aa8: 4a 85        	mv	a0, s2
   18aaa: 97 b0 00 00  	auipc	ra, 11
   18aae: e7 80 e0 14  	jalr	334(ra)
   18ab2: 93 05 10 03  	li	a1, 49
   18ab6: 31 b8        	j	0x182d2 <.LBB34_84+0x96>
   18ab8: 4a 85        	mv	a0, s2
   18aba: 97 b0 00 00  	auipc	ra, 11
   18abe: e7 80 e0 13  	jalr	318(ra)
   18ac2: 4a 85        	mv	a0, s2
   18ac4: 97 b0 00 00  	auipc	ra, 11
   18ac8: e7 80 40 13  	jalr	308(ra)
   18acc: 4a 85        	mv	a0, s2
   18ace: 97 b0 00 00  	auipc	ra, 11
   18ad2: e7 80 a0 12  	jalr	298(ra)
   18ad6: 13 04 10 03  	li	s0, 49
   18ada: 19 a8        	j	0x18af0 <.LBB34_173+0x268>
   18adc: 4a 85        	mv	a0, s2
   18ade: 97 b0 00 00  	auipc	ra, 11
   18ae2: e7 80 a0 11  	jalr	282(ra)
   18ae6: 4a 85        	mv	a0, s2
   18ae8: 97 b0 00 00  	auipc	ra, 11
   18aec: e7 80 00 11  	jalr	272(ra)
   18af0: 2d bf        	j	0x18a2a <.LBB34_173+0x1a2>

0000000000018af2 <.LBB34_210>:
;     return error.InvalidDebugInfo;
   18af2: 4a 85        	mv	a0, s2
   18af4: 97 b0 00 00  	auipc	ra, 11
   18af8: e7 80 40 10  	jalr	260(ra)
   18afc: 13 05 20 03  	li	a0, 50
;             return badDwarf();
   18b00: 23 9c a9 00  	sh	a0, 24(s3)
   18b04: 51 a2        	j	0x18c88 <.LBB34_210+0x196>
;             if (amt_read < buf.len) return error.EndOfStream;
   18b06: 4a 85        	mv	a0, s2
   18b08: 97 b0 00 00  	auipc	ra, 11
   18b0c: e7 80 00 0f  	jalr	240(ra)
   18b10: 4a 85        	mv	a0, s2
   18b12: 97 b0 00 00  	auipc	ra, 11
   18b16: e7 80 60 0e  	jalr	230(ra)
   18b1a: 4a 85        	mv	a0, s2
   18b1c: 97 b0 00 00  	auipc	ra, 11
   18b20: e7 80 c0 0d  	jalr	220(ra)
   18b24: 4a 85        	mv	a0, s2
   18b26: 97 b0 00 00  	auipc	ra, 11
   18b2a: e7 80 20 0d  	jalr	210(ra)
   18b2e: 4a 85        	mv	a0, s2
   18b30: 97 b0 00 00  	auipc	ra, 11
   18b34: e7 80 80 0c  	jalr	200(ra)
   18b38: 13 05 10 03  	li	a0, 49
   18b3c: 23 9c a9 00  	sh	a0, 24(s3)
   18b40: 11 b7        	j	0x18a44 <.LBB34_173+0x1bc>
;             if (amt_read < buf.len) return error.EndOfStream;
   18b42: 4a 85        	mv	a0, s2
   18b44: 97 b0 00 00  	auipc	ra, 11
   18b48: e7 80 40 0b  	jalr	180(ra)
;             try self.readNoEof(&bytes);
   18b4c: 4a 85        	mv	a0, s2
   18b4e: 97 b0 00 00  	auipc	ra, 11
   18b52: e7 80 a0 0a  	jalr	170(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18b56: 4a 85        	mv	a0, s2
   18b58: 97 b0 00 00  	auipc	ra, 11
   18b5c: e7 80 00 0a  	jalr	160(ra)
;                 2 => try nosuspend in_stream.readInt(u16, endian),
   18b60: 4a 85        	mv	a0, s2
   18b62: 97 b0 00 00  	auipc	ra, 11
   18b66: e7 80 60 09  	jalr	150(ra)
   18b6a: 93 05 10 03  	li	a1, 49
   18b6e: 6f f0 4f b2  	j	0x17e92 <.LBB34_24+0x58>
;             if (amt_read < buf.len) return error.EndOfStream;
   18b72: 4a 85        	mv	a0, s2
   18b74: 97 b0 00 00  	auipc	ra, 11
   18b78: e7 80 40 08  	jalr	132(ra)
;             try self.readNoEof(&bytes);
   18b7c: 4a 85        	mv	a0, s2
   18b7e: 97 b0 00 00  	auipc	ra, 11
   18b82: e7 80 a0 07  	jalr	122(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18b86: 4a 85        	mv	a0, s2
   18b88: 97 b0 00 00  	auipc	ra, 11
   18b8c: e7 80 00 07  	jalr	112(ra)
;                 4 => try nosuspend in_stream.readInt(u32, endian),
   18b90: 4a 85        	mv	a0, s2
   18b92: 97 b0 00 00  	auipc	ra, 11
   18b96: e7 80 60 06  	jalr	102(ra)
   18b9a: 93 05 10 03  	li	a1, 49
;         FORM.data4 => parseFormValueConstant(in_stream, false, endian, 4),
   18b9e: 03 06 81 03  	lb	a2, 56(sp)
   18ba2: 6f f0 cf c0  	j	0x17fae <.LBB34_39+0x9e>
;             if (amt_read < buf.len) return error.EndOfStream;
   18ba6: 4a 85        	mv	a0, s2
   18ba8: 97 b0 00 00  	auipc	ra, 11
   18bac: e7 80 00 05  	jalr	80(ra)
;             try self.readNoEof(&bytes);
   18bb0: 4a 85        	mv	a0, s2
   18bb2: 97 b0 00 00  	auipc	ra, 11
   18bb6: e7 80 60 04  	jalr	70(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18bba: 4a 85        	mv	a0, s2
   18bbc: 97 b0 00 00  	auipc	ra, 11
   18bc0: e7 80 c0 03  	jalr	60(ra)
;                 8 => try nosuspend in_stream.readInt(u64, endian),
   18bc4: 4a 85        	mv	a0, s2
   18bc6: 97 b0 00 00  	auipc	ra, 11
   18bca: e7 80 20 03  	jalr	50(ra)
   18bce: 93 05 10 03  	li	a1, 49
   18bd2: 6f f0 8f bd  	j	0x17faa <.LBB34_39+0x9a>
;             if ((try nosuspend in_stream.readAll(&buf)) < 16) return error.EndOfFile;
   18bd6: 4a 85        	mv	a0, s2
   18bd8: 97 b0 00 00  	auipc	ra, 11
   18bdc: e7 80 00 02  	jalr	32(ra)
   18be0: 13 05 60 03  	li	a0, 54
   18be4: 23 bc a9 00  	sd	a0, 24(s3)
   18be8: 23 b8 09 00  	sd	zero, 16(s3)
   18bec: 23 b4 09 00  	sd	zero, 8(s3)
   18bf0: 23 b0 09 00  	sd	zero, 0(s3)
   18bf4: 81 bd        	j	0x18a44 <.LBB34_173+0x1bc>
;             if (amt_read < buf.len) return error.EndOfStream;
   18bf6: 4a 85        	mv	a0, s2
   18bf8: 97 b0 00 00  	auipc	ra, 11
   18bfc: e7 80 00 00  	jalr	ra
;             try self.readNoEof(&bytes);
   18c00: 4a 85        	mv	a0, s2
   18c02: 97 b0 00 00  	auipc	ra, 11
   18c06: e7 80 60 ff  	jalr	-10(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18c0a: 4a 85        	mv	a0, s2
   18c0c: 97 b0 00 00  	auipc	ra, 11
   18c10: e7 80 c0 fe  	jalr	-20(ra)
;                 1 => try nosuspend in_stream.readInt(u8, endian),
   18c14: 4a 85        	mv	a0, s2
   18c16: 97 b0 00 00  	auipc	ra, 11
   18c1a: e7 80 20 fe  	jalr	-30(ra)
   18c1e: 13 05 10 03  	li	a0, 49
   18c22: 6f f0 af c6  	j	0x1808c <.LBB34_55+0x2a>
;             if (amt_read < buf.len) return error.EndOfStream;
   18c26: 4a 85        	mv	a0, s2
   18c28: 97 b0 00 00  	auipc	ra, 11
   18c2c: e7 80 00 fd  	jalr	-48(ra)
;             try self.readNoEof(&bytes);
   18c30: 4a 85        	mv	a0, s2
   18c32: 97 b0 00 00  	auipc	ra, 11
   18c36: e7 80 60 fc  	jalr	-58(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   18c3a: 4a 85        	mv	a0, s2
   18c3c: 97 b0 00 00  	auipc	ra, 11
   18c40: e7 80 c0 fb  	jalr	-68(ra)
;             1 => try nosuspend in_stream.readInt(u8, endian),
   18c44: 4a 85        	mv	a0, s2
   18c46: 97 b0 00 00  	auipc	ra, 11
   18c4a: e7 80 20 fb  	jalr	-78(ra)
   18c4e: 13 05 10 03  	li	a0, 49
   18c52: 6f f0 af d0  	j	0x1815c <.LBB34_66+0x26>
;             -1 => try nosuspend leb.readULEB128(u64, in_stream),
   18c56: 4a 85        	mv	a0, s2
   18c58: 97 b0 00 00  	auipc	ra, 11
   18c5c: e7 80 00 fa  	jalr	-96(ra)
   18c60: 6f f0 4f ea  	j	0x18304 <.LBB34_93+0x18>
;             const size = try nosuspend leb.readULEB128(usize, in_stream);
   18c64: 4a 85        	mv	a0, s2
   18c66: 97 b0 00 00  	auipc	ra, 11
   18c6a: e7 80 20 f9  	jalr	-110(ra)
   18c6e: 23 9c 99 00  	sh	s1, 24(s3)
   18c72: c9 bb        	j	0x18a44 <.LBB34_173+0x1bc>
;     const buf = try readAllocBytes(allocator, in_stream, size);
   18c74: 4a 85        	mv	a0, s2
   18c76: 97 b0 00 00  	auipc	ra, 11
   18c7a: e7 80 20 f8  	jalr	-126(ra)
   18c7e: 09 45        	li	a0, 2
;             return parseFormValueBlockLen(allocator, in_stream, block_len);
   18c80: 23 88 a9 00  	sb	a0, 16(s3)
   18c84: 23 9c 89 00  	sh	s0, 24(s3)
   18c88: 4a 85        	mv	a0, s2
   18c8a: f6 60        	ld	ra, 344(sp)
   18c8c: 56 64        	ld	s0, 336(sp)
   18c8e: b6 64        	ld	s1, 328(sp)
   18c90: 16 69        	ld	s2, 320(sp)
   18c92: f2 79        	ld	s3, 312(sp)
   18c94: 52 7a        	ld	s4, 304(sp)
   18c96: b2 7a        	ld	s5, 296(sp)
   18c98: 12 7b        	ld	s6, 288(sp)
   18c9a: f2 6b        	ld	s7, 280(sp)
   18c9c: 52 6c        	ld	s8, 272(sp)
   18c9e: 35 61        	addi	sp, sp, 352
   18ca0: 17 b3 00 00  	auipc	t1, 11
   18ca4: 67 00 83 f5  	jr	-168(t1)
;     errdefer allocator.free(buf);
   18ca8: 03 b5 8a 00  	ld	a0, 8(s5)
   18cac: aa f9        	sd	a0, 240(sp)
   18cae: 03 b5 0a 00  	ld	a0, 0(s5)
   18cb2: aa f5        	sd	a0, 232(sp)
   18cb4: a8 11        	addi	a0, sp, 232
   18cb6: a6 85        	mv	a1, s1
   18cb8: 52 86        	mv	a2, s4
   18cba: 97 40 00 00  	auipc	ra, 4
   18cbe: e7 80 a0 bc  	jalr	-1078(ra)
   18cc2: 13 04 60 03  	li	s0, 54
   18cc6: 21 a8        	j	0x18cde <.LBB34_210+0x1ec>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   18cc8: 4a 85        	mv	a0, s2
   18cca: 97 b0 00 00  	auipc	ra, 11
   18cce: e7 80 e0 f2  	jalr	-210(ra)
;     return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());
   18cd2: 4a 85        	mv	a0, s2
   18cd4: 97 b0 00 00  	auipc	ra, 11
   18cd8: e7 80 40 f2  	jalr	-220(ra)
   18cdc: 45 44        	li	s0, 17
   18cde: 4a 85        	mv	a0, s2
   18ce0: 97 b0 00 00  	auipc	ra, 11
   18ce4: e7 80 80 f1  	jalr	-232(ra)
   18ce8: 4a 85        	mv	a0, s2
   18cea: 97 b0 00 00  	auipc	ra, 11
   18cee: e7 80 e0 f0  	jalr	-242(ra)
   18cf2: 23 9c 89 00  	sh	s0, 24(s3)
   18cf6: b9 b3        	j	0x18a44 <.LBB34_173+0x1bc>
   18cf8: 37 15 01 00  	lui	a0, 17
   18cfc: 13 05 95 5d  	addi	a0, a0, 1497
   18d00: c1 45        	li	a1, 16
   18d02: 81 46        	li	a3, 0
   18d04: 97 a0 00 00  	auipc	ra, 10
   18d08: e7 80 60 67  	jalr	1654(ra)

0000000000018d0c <debug.printLineInfo__anon_5334>:
; ) !void {
   18d0c: 13 01 01 81  	addi	sp, sp, -2032
   18d10: 23 34 11 7e  	sd	ra, 2024(sp)
   18d14: 23 30 81 7e  	sd	s0, 2016(sp)
   18d18: 23 3c 91 7c  	sd	s1, 2008(sp)
   18d1c: 23 38 21 7d  	sd	s2, 2000(sp)
   18d20: 23 34 31 7d  	sd	s3, 1992(sp)
   18d24: 23 30 41 7d  	sd	s4, 1984(sp)
   18d28: 23 3c 51 7b  	sd	s5, 1976(sp)
   18d2c: 23 38 61 7b  	sd	s6, 1968(sp)
   18d30: 23 34 71 7b  	sd	s7, 1960(sp)
   18d34: 23 30 81 7b  	sd	s8, 1952(sp)
   18d38: 23 3c 91 79  	sd	s9, 1944(sp)
   18d3c: 23 38 a1 79  	sd	s10, 1936(sp)
   18d40: 23 34 b1 79  	sd	s11, 1928(sp)
   18d44: 8d 62        	lui	t0, 3
   18d46: 9b 82 02 8c  	addiw	t0, t0, -1856
   18d4a: 33 01 51 40  	sub	sp, sp, t0
   18d4e: 9e 8d        	mv	s11, t2
;         try tty_config.setColor(out_stream, .Bold);
   18d50: 83 c4 03 00  	lbu	s1, 0(t2)
   18d54: aa 8c        	mv	s9, a0
   18d56: 08 61        	ld	a0, 0(a0)
;             nosuspend switch (conf) {
   18d58: 2a e8        	sd	a0, 16(sp)
   18d5a: 13 f5 34 00  	andi	a0, s1, 3
   18d5e: 46 f0        	sd	a7, 32(sp)
   18d60: 42 ec        	sd	a6, 24(sp)
   18d62: 3e f4        	sd	a5, 40(sp)
   18d64: 3a 8c        	mv	s8, a4
   18d66: 36 8d        	mv	s10, a3
   18d68: 32 8a        	mv	s4, a2
   18d6a: ae 8b        	mv	s7, a1
;             nosuspend switch (conf) {
   18d6c: 25 c1        	beqz	a0, 0x18dcc <debug.printLineInfo__anon_5334+0xc0>
   18d6e: 85 45        	li	a1, 1
;             nosuspend switch (conf) {
   18d70: e3 1e b5 38  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
   18d74: 01 44        	li	s0, 0
;                     try out_stream.writeAll(color_string);
   18d76: 83 a9 0b 00  	lw	s3, 0(s7)
   18d7a: 15 49        	li	s2, 5
   18d7c: 37 25 01 00  	lui	a0, 18
   18d80: 13 0b 85 85  	addi	s6, a0, -1960
   18d84: 91 4a        	li	s5, 4
;                 index += try self.write(bytes[index..]);
   18d86: e3 7e 24 35  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
   18d8a: b3 06 8b 00  	add	a3, s6, s0
   18d8e: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   18d92: 09 65        	lui	a0, 2
   18d94: 1b 05 85 04  	addiw	a0, a0, 72
   18d98: 0a 95        	add	a0, a0, sp
   18d9a: e6 85        	mv	a1, s9
   18d9c: 4e 86        	mv	a2, s3
   18d9e: 97 b0 ff ff  	auipc	ra, 1048571
   18da2: e7 80 e0 0b  	jalr	190(ra)
   18da6: 09 65        	lui	a0, 2
   18da8: 1b 05 05 05  	addiw	a0, a0, 80
   18dac: 0a 95        	add	a0, a0, sp
   18dae: 83 54 05 00  	lhu	s1, 0(a0)
   18db2: e3 9d 04 04  	bnez	s1, 0x1960c <.LBB35_116+0x94>
   18db6: 09 65        	lui	a0, 2
   18db8: 1b 05 85 04  	addiw	a0, a0, 72
   18dbc: 0a 95        	add	a0, a0, sp
   18dbe: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   18dc0: 22 95        	add	a0, a0, s0
   18dc2: e3 6b 85 32  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   18dc6: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   18dc8: e3 1f 55 fb  	bne	a0, s5, 0x18d86 <debug.printLineInfo__anon_5334+0x7a>
;         if (line_info) |*li| {
   18dcc: 03 45 0a 02  	lbu	a0, 32(s4)
   18dd0: 63 04 05 10  	beqz	a0, 0x18ed8 <debug.printLineInfo__anon_5334+0x1cc>
   18dd4: ee 89        	mv	s3, s11
;         if (line_info) |*li| {
   18dd6: 03 36 8a 01  	ld	a2, 24(s4)
   18dda: 83 35 0a 01  	ld	a1, 16(s4)
   18dde: 83 3d 8a 00  	ld	s11, 8(s4)
   18de2: 5e 89        	mv	s2, s7
;             try out_stream.print("{s}:{d}:{d}", .{ li.file_name, li.line, li.column });
   18de4: 83 ab 0b 00  	lw	s7, 0(s7)
;         if (line_info) |*li| {
   18de8: 83 3a 0a 00  	ld	s5, 0(s4)
;             try out_stream.print("{s}:{d}:{d}", .{ li.file_name, li.line, li.column });
   18dec: 5e d8        	sw	s7, 48(sp)
;                             return formatBuf(value, options, writer);
   18dee: 37 15 01 00  	lui	a0, 17
   18df2: 93 06 85 11  	addi	a3, a0, 280
   18df6: 18 18        	addi	a4, sp, 48
   18df8: 66 85        	mv	a0, s9
   18dfa: 97 90 00 00  	auipc	ra, 9
   18dfe: e7 80 60 f3  	jalr	-202(ra)
   18e02: aa 84        	mv	s1, a0
   18e04: 42 15        	slli	a0, a0, 48
   18e06: 41 91        	srli	a0, a0, 48
   18e08: e3 12 05 00  	bnez	a0, 0x1960c <.LBB35_116+0x94>
   18e0c: b7 15 01 00  	lui	a1, 17
   18e10: 13 8b 35 57  	addi	s6, a1, 1395
   18e14: 1d e9        	bnez	a0, 0x18e4a <debug.printLineInfo__anon_5334+0x13e>
;             return writeFn(self.context, bytes);
   18e16: 09 65        	lui	a0, 2
   18e18: 1b 05 85 04  	addiw	a0, a0, 72
   18e1c: 0a 95        	add	a0, a0, sp
   18e1e: 05 47        	li	a4, 1
   18e20: e6 85        	mv	a1, s9
   18e22: 5e 86        	mv	a2, s7
   18e24: da 86        	mv	a3, s6
   18e26: 97 b0 ff ff  	auipc	ra, 1048571
   18e2a: e7 80 60 03  	jalr	54(ra)
   18e2e: 09 65        	lui	a0, 2
   18e30: 1b 05 05 05  	addiw	a0, a0, 80
   18e34: 0a 95        	add	a0, a0, sp
   18e36: 83 54 05 00  	lhu	s1, 0(a0)
   18e3a: 63 94 04 7c  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   18e3e: 09 65        	lui	a0, 2
   18e40: 1b 05 85 04  	addiw	a0, a0, 72
   18e44: 0a 95        	add	a0, a0, sp
   18e46: 08 61        	ld	a0, 0(a0)
   18e48: 79 d5        	beqz	a0, 0x18e16 <debug.printLineInfo__anon_5334+0x10a>
   18e4a: 85 45        	li	a1, 1
   18e4c: e3 1b b5 28  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;             return formatValue(value, actual_fmt, options, writer);
   18e50: 37 15 01 00  	lui	a0, 17
   18e54: 13 06 85 11  	addi	a2, a0, 280
   18e58: 14 18        	addi	a3, sp, 48
   18e5a: 66 85        	mv	a0, s9
   18e5c: d6 85        	mv	a1, s5
   18e5e: 97 a0 00 00  	auipc	ra, 10
   18e62: e7 80 00 e7  	jalr	-400(ra)
   18e66: aa 84        	mv	s1, a0
   18e68: 42 15        	slli	a0, a0, 48
   18e6a: 41 91        	srli	a0, a0, 48
   18e6c: 63 10 05 7a  	bnez	a0, 0x1960c <.LBB35_116+0x94>
   18e70: b7 15 01 00  	lui	a1, 17
   18e74: 13 84 75 57  	addi	s0, a1, 1399
   18e78: 1d e9        	bnez	a0, 0x18eae <debug.printLineInfo__anon_5334+0x1a2>
;             return writeFn(self.context, bytes);
   18e7a: 09 65        	lui	a0, 2
   18e7c: 1b 05 85 04  	addiw	a0, a0, 72
   18e80: 0a 95        	add	a0, a0, sp
   18e82: 05 47        	li	a4, 1
   18e84: e6 85        	mv	a1, s9
   18e86: 5e 86        	mv	a2, s7
   18e88: a2 86        	mv	a3, s0
   18e8a: 97 b0 ff ff  	auipc	ra, 1048571
   18e8e: e7 80 20 fd  	jalr	-46(ra)
   18e92: 09 65        	lui	a0, 2
   18e94: 1b 05 05 05  	addiw	a0, a0, 80
   18e98: 0a 95        	add	a0, a0, sp
   18e9a: 83 54 05 00  	lhu	s1, 0(a0)
   18e9e: 63 92 04 76  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   18ea2: 09 65        	lui	a0, 2
   18ea4: 1b 05 85 04  	addiw	a0, a0, 72
   18ea8: 0a 95        	add	a0, a0, sp
   18eaa: 08 61        	ld	a0, 0(a0)
   18eac: 79 d5        	beqz	a0, 0x18e7a <debug.printLineInfo__anon_5334+0x16e>
   18eae: 85 45        	li	a1, 1
   18eb0: e3 19 b5 22  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;             return formatValue(value, actual_fmt, options, writer);
   18eb4: 37 15 01 00  	lui	a0, 17
   18eb8: 13 06 85 11  	addi	a2, a0, 280
   18ebc: 14 18        	addi	a3, sp, 48
   18ebe: 66 85        	mv	a0, s9
   18ec0: ee 85        	mv	a1, s11
   18ec2: 97 a0 00 00  	auipc	ra, 10
   18ec6: e7 80 c0 e0  	jalr	-500(ra)
   18eca: aa 84        	mv	s1, a0
   18ecc: 42 15        	slli	a0, a0, 48
   18ece: 41 91        	srli	a0, a0, 48
   18ed0: ca 8b        	mv	s7, s2
   18ed2: ce 8d        	mv	s11, s3
   18ed4: 31 cd        	beqz	a0, 0x18f30 <debug.printLineInfo__anon_5334+0x224>
   18ed6: 1d af        	j	0x1960c <.LBB35_116+0x94>
   18ed8: 01 44        	li	s0, 0
;             try out_stream.writeAll("???:?:?");
   18eda: 83 a9 0b 00  	lw	s3, 0(s7)
   18ede: 21 49        	li	s2, 8
   18ee0: 37 25 01 00  	lui	a0, 18
   18ee4: 13 0b a5 bf  	addi	s6, a0, -1030
   18ee8: 9d 4a        	li	s5, 7
;                 index += try self.write(bytes[index..]);
   18eea: e3 7c 24 1f  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
   18eee: b3 06 8b 00  	add	a3, s6, s0
   18ef2: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   18ef6: 09 65        	lui	a0, 2
   18ef8: 1b 05 85 04  	addiw	a0, a0, 72
   18efc: 0a 95        	add	a0, a0, sp
   18efe: e6 85        	mv	a1, s9
   18f00: 4e 86        	mv	a2, s3
   18f02: 97 b0 ff ff  	auipc	ra, 1048571
   18f06: e7 80 a0 f5  	jalr	-166(ra)
   18f0a: 09 65        	lui	a0, 2
   18f0c: 1b 05 05 05  	addiw	a0, a0, 80
   18f10: 0a 95        	add	a0, a0, sp
   18f12: 83 54 05 00  	lhu	s1, 0(a0)
   18f16: 63 90 04 70  	bnez	s1, 0x19616 <.LBB35_116+0x9e>
   18f1a: 09 65        	lui	a0, 2
   18f1c: 1b 05 85 04  	addiw	a0, a0, 72
   18f20: 0a 95        	add	a0, a0, sp
   18f22: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   18f24: 22 95        	add	a0, a0, s0
   18f26: e3 69 85 1c  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   18f2a: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   18f2c: e3 1f 55 fb  	bne	a0, s5, 0x18eea <debug.printLineInfo__anon_5334+0x1de>
;         try tty_config.setColor(out_stream, .Reset);
   18f30: 03 c5 0d 00  	lbu	a0, 0(s11)
;             nosuspend switch (conf) {
   18f34: 0d 89        	andi	a0, a0, 3
   18f36: 25 c1        	beqz	a0, 0x18f96 <debug.printLineInfo__anon_5334+0x28a>
   18f38: 85 45        	li	a1, 1
   18f3a: e3 19 b5 1c  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
   18f3e: 01 44        	li	s0, 0
;                     try out_stream.writeAll(color_string);
   18f40: 83 a9 0b 00  	lw	s3, 0(s7)
   18f44: 15 49        	li	s2, 5
   18f46: 37 25 01 00  	lui	a0, 18
   18f4a: 13 0b 55 86  	addi	s6, a0, -1947
   18f4e: 91 4a        	li	s5, 4
   18f50: e3 79 24 19  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
;                 index += try self.write(bytes[index..]);
   18f54: b3 06 8b 00  	add	a3, s6, s0
   18f58: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   18f5c: 09 65        	lui	a0, 2
   18f5e: 1b 05 85 04  	addiw	a0, a0, 72
   18f62: 0a 95        	add	a0, a0, sp
   18f64: e6 85        	mv	a1, s9
   18f66: 4e 86        	mv	a2, s3
   18f68: 97 b0 ff ff  	auipc	ra, 1048571
   18f6c: e7 80 40 ef  	jalr	-268(ra)
   18f70: 09 65        	lui	a0, 2
   18f72: 1b 05 05 05  	addiw	a0, a0, 80
   18f76: 0a 95        	add	a0, a0, sp
   18f78: 83 54 05 00  	lhu	s1, 0(a0)
   18f7c: 63 98 04 68  	bnez	s1, 0x1960c <.LBB35_116+0x94>
   18f80: 09 65        	lui	a0, 2
   18f82: 1b 05 85 04  	addiw	a0, a0, 72
   18f86: 0a 95        	add	a0, a0, sp
   18f88: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   18f8a: 22 95        	add	a0, a0, s0
   18f8c: e3 66 85 16  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   18f90: 2a 84        	mv	s0, a0
   18f92: e3 1f 55 fb  	bne	a0, s5, 0x18f50 <debug.printLineInfo__anon_5334+0x244>
   18f96: 01 44        	li	s0, 0
;         try out_stream.writeAll(": ");
   18f98: 83 a9 0b 00  	lw	s3, 0(s7)
   18f9c: 0d 49        	li	s2, 3
   18f9e: 37 25 01 00  	lui	a0, 18
   18fa2: 13 0b 95 cf  	addi	s6, a0, -775
   18fa6: 89 4a        	li	s5, 2
   18fa8: e3 7d 24 13  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
;                 index += try self.write(bytes[index..]);
   18fac: b3 06 8b 00  	add	a3, s6, s0
   18fb0: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   18fb4: 09 65        	lui	a0, 2
   18fb6: 1b 05 85 04  	addiw	a0, a0, 72
   18fba: 0a 95        	add	a0, a0, sp
   18fbc: e6 85        	mv	a1, s9
   18fbe: 4e 86        	mv	a2, s3
   18fc0: 97 b0 ff ff  	auipc	ra, 1048571
   18fc4: e7 80 c0 e9  	jalr	-356(ra)
   18fc8: 09 65        	lui	a0, 2
   18fca: 1b 05 05 05  	addiw	a0, a0, 80
   18fce: 0a 95        	add	a0, a0, sp
   18fd0: 83 54 05 00  	lhu	s1, 0(a0)
   18fd4: 63 91 04 64  	bnez	s1, 0x19616 <.LBB35_116+0x9e>
   18fd8: 09 65        	lui	a0, 2
   18fda: 1b 05 85 04  	addiw	a0, a0, 72
   18fde: 0a 95        	add	a0, a0, sp
   18fe0: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   18fe2: 22 95        	add	a0, a0, s0
   18fe4: e3 6a 85 10  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   18fe8: 2a 84        	mv	s0, a0
   18fea: e3 1f 55 fb  	bne	a0, s5, 0x18fa8 <debug.printLineInfo__anon_5334+0x29c>
;         try tty_config.setColor(out_stream, .Dim);
   18fee: 03 c5 0d 00  	lbu	a0, 0(s11)
;             nosuspend switch (conf) {
   18ff2: 0d 89        	andi	a0, a0, 3
   18ff4: 25 c1        	beqz	a0, 0x19054 <debug.printLineInfo__anon_5334+0x348>
   18ff6: 85 45        	li	a1, 1
   18ff8: e3 1a b5 10  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
   18ffc: 01 44        	li	s0, 0
;                     try out_stream.writeAll(color_string);
   18ffe: 83 a9 0b 00  	lw	s3, 0(s7)
   19002: 15 49        	li	s2, 5
   19004: 37 25 01 00  	lui	a0, 18
   19008: 13 0b 35 85  	addi	s6, a0, -1965
   1900c: 91 4a        	li	s5, 4
   1900e: e3 7a 24 0d  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
;                 index += try self.write(bytes[index..]);
   19012: b3 06 8b 00  	add	a3, s6, s0
   19016: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   1901a: 09 65        	lui	a0, 2
   1901c: 1b 05 85 04  	addiw	a0, a0, 72
   19020: 0a 95        	add	a0, a0, sp
   19022: e6 85        	mv	a1, s9
   19024: 4e 86        	mv	a2, s3
   19026: 97 b0 ff ff  	auipc	ra, 1048571
   1902a: e7 80 60 e3  	jalr	-458(ra)
   1902e: 09 65        	lui	a0, 2
   19030: 1b 05 05 05  	addiw	a0, a0, 80
   19034: 0a 95        	add	a0, a0, sp
   19036: 83 54 05 00  	lhu	s1, 0(a0)
   1903a: 63 99 04 5c  	bnez	s1, 0x1960c <.LBB35_116+0x94>
   1903e: 09 65        	lui	a0, 2
   19040: 1b 05 85 04  	addiw	a0, a0, 72
   19044: 0a 95        	add	a0, a0, sp
   19046: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   19048: 22 95        	add	a0, a0, s0
   1904a: e3 67 85 0a  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   1904e: 2a 84        	mv	s0, a0
   19050: e3 1f 55 fb  	bne	a0, s5, 0x1900e <debug.printLineInfo__anon_5334+0x302>
;         try out_stream.print("0x{x} in {s} ({s})", .{ address, symbol_name, compile_unit_name });
   19054: 83 aa 0b 00  	lw	s5, 0(s7)
   19058: 01 44        	li	s0, 0
   1905a: 56 dc        	sw	s5, 56(sp)
   1905c: 0d 49        	li	s2, 3
   1905e: 37 25 01 00  	lui	a0, 18
   19062: 13 0b 75 cd  	addi	s6, a0, -809
   19066: 89 49        	li	s3, 2
   19068: e3 7d 24 07  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
;                 index += try self.write(bytes[index..]);
   1906c: b3 06 8b 00  	add	a3, s6, s0
   19070: 33 87 89 40  	sub	a4, s3, s0
;             return writeFn(self.context, bytes);
   19074: 09 65        	lui	a0, 2
   19076: 1b 05 85 04  	addiw	a0, a0, 72
   1907a: 0a 95        	add	a0, a0, sp
   1907c: e6 85        	mv	a1, s9
   1907e: 56 86        	mv	a2, s5
   19080: 97 b0 ff ff  	auipc	ra, 1048571
   19084: e7 80 c0 dd  	jalr	-548(ra)
   19088: 09 65        	lui	a0, 2
   1908a: 1b 05 05 05  	addiw	a0, a0, 80
   1908e: 0a 95        	add	a0, a0, sp
   19090: 83 54 05 00  	lhu	s1, 0(a0)
   19094: 63 97 04 56  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   19098: 09 65        	lui	a0, 2
   1909a: 1b 05 85 04  	addiw	a0, a0, 72
   1909e: 0a 95        	add	a0, a0, sp
   190a0: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   190a2: 22 95        	add	a0, a0, s0
   190a4: e3 6a 85 04  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   190a8: 2a 84        	mv	s0, a0
   190aa: e3 1f 35 fb  	bne	a0, s3, 0x19068 <debug.printLineInfo__anon_5334+0x35c>
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   190ae: 09 65        	lui	a0, 2
   190b0: 1b 05 85 04  	addiw	a0, a0, 72
   190b4: 0a 95        	add	a0, a0, sp
   190b6: 93 05 a0 0a  	li	a1, 170
   190ba: 13 06 10 04  	li	a2, 65
   190be: 89 66        	lui	a3, 2
   190c0: 9b 86 86 04  	addiw	a3, a3, 72
   190c4: 33 04 d1 00  	add	s0, sp, a3
   190c8: 97 b0 00 00  	auipc	ra, 11
   190cc: e7 80 20 1d  	jalr	466(ra)
   190d0: 01 45        	li	a0, 0
   190d2: a9 45        	li	a1, 10
   190d4: 3d 46        	li	a2, 15
   190d6: 19 a8        	j	0x190ec <debug.printLineInfo__anon_5334+0x3e0>
   190d8: b3 04 a4 00  	add	s1, s0, a0
   190dc: 3d 9f        	addw	a4, a4, a5
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   190de: 23 80 e4 04  	sb	a4, 64(s1)
;             a /= base;
   190e2: 13 dd 46 00  	srli	s10, a3, 4
;             if (a == 0) break;
   190e6: 7d 15        	addi	a0, a0, -1
   190e8: 63 7c d6 00  	bgeu	a2, a3, 0x19100 <debug.printLineInfo__anon_5334+0x3f4>
   190ec: ea 86        	mv	a3, s10
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   190ee: 13 77 fd 00  	andi	a4, s10, 15
   190f2: 93 07 00 03  	li	a5, 48
   190f6: e3 61 b7 fe  	bltu	a4, a1, 0x190d8 <debug.printLineInfo__anon_5334+0x3cc>
   190fa: 93 07 70 05  	li	a5, 87
   190fe: e9 bf        	j	0x190d8 <debug.printLineInfo__anon_5334+0x3cc>
;     return formatBuf(buf[index..], options, writer);
   19100: 33 06 a0 40  	neg	a2, a0
   19104: 89 65        	lui	a1, 2
   19106: 9b 85 85 04  	addiw	a1, a1, 72
   1910a: 8a 95        	add	a1, a1, sp
   1910c: 2e 95        	add	a0, a0, a1
   1910e: 93 05 15 04  	addi	a1, a0, 65
   19112: 37 15 01 00  	lui	a0, 17
   19116: 93 06 85 11  	addi	a3, a0, 280
   1911a: 38 18        	addi	a4, sp, 56
   1911c: 66 85        	mv	a0, s9
   1911e: 97 90 00 00  	auipc	ra, 9
   19122: e7 80 20 c1  	jalr	-1006(ra)
   19126: aa 84        	mv	s1, a0
   19128: 42 15        	slli	a0, a0, 48
   1912a: 41 91        	srli	a0, a0, 48
   1912c: 63 11 05 4c  	bnez	a0, 0x195ee <.LBB35_116+0x76>
   19130: 01 44        	li	s0, 0
   19132: 15 49        	li	s2, 5
   19134: 37 25 01 00  	lui	a0, 18
   19138: 13 0b 75 cd  	addi	s6, a0, -809
   1913c: 91 49        	li	s3, 4
;                 index += try self.write(bytes[index..]);
   1913e: 63 72 24 7b  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
   19142: 33 05 8b 00  	add	a0, s6, s0
   19146: 93 06 55 00  	addi	a3, a0, 5
   1914a: 33 87 89 40  	sub	a4, s3, s0
;             return writeFn(self.context, bytes);
   1914e: 09 65        	lui	a0, 2
   19150: 1b 05 85 04  	addiw	a0, a0, 72
   19154: 0a 95        	add	a0, a0, sp
   19156: e6 85        	mv	a1, s9
   19158: 56 86        	mv	a2, s5
   1915a: 97 b0 ff ff  	auipc	ra, 1048571
   1915e: e7 80 20 d0  	jalr	-766(ra)
   19162: 09 65        	lui	a0, 2
   19164: 1b 05 05 05  	addiw	a0, a0, 80
   19168: 0a 95        	add	a0, a0, sp
   1916a: 83 54 05 00  	lhu	s1, 0(a0)
   1916e: 63 9a 04 48  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   19172: 09 65        	lui	a0, 2
   19174: 1b 05 85 04  	addiw	a0, a0, 72
   19178: 0a 95        	add	a0, a0, sp
   1917a: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   1917c: 22 95        	add	a0, a0, s0
   1917e: 63 6d 85 76  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   19182: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   19184: e3 1d 35 fb  	bne	a0, s3, 0x1913e <debug.printLineInfo__anon_5334+0x432>
;                             return formatBuf(value, options, writer);
   19188: 37 15 01 00  	lui	a0, 17
   1918c: 93 06 85 11  	addi	a3, a0, 280
   19190: 38 18        	addi	a4, sp, 56
   19192: 66 85        	mv	a0, s9
   19194: e2 85        	mv	a1, s8
   19196: 22 76        	ld	a2, 40(sp)
   19198: 97 90 00 00  	auipc	ra, 9
   1919c: e7 80 80 b9  	jalr	-1128(ra)
   191a0: aa 84        	mv	s1, a0
   191a2: 42 15        	slli	a0, a0, 48
   191a4: 41 91        	srli	a0, a0, 48
   191a6: 63 13 05 46  	bnez	a0, 0x1960c <.LBB35_116+0x94>
   191aa: 01 44        	li	s0, 0
   191ac: 0d 49        	li	s2, 3
   191ae: 37 25 01 00  	lui	a0, 18
   191b2: 13 0b 75 cd  	addi	s6, a0, -809
   191b6: 89 49        	li	s3, 2
;                 index += try self.write(bytes[index..]);
   191b8: 63 75 24 73  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
   191bc: 33 05 8b 00  	add	a0, s6, s0
   191c0: 93 06 c5 00  	addi	a3, a0, 12
   191c4: 33 87 89 40  	sub	a4, s3, s0
;             return writeFn(self.context, bytes);
   191c8: 09 65        	lui	a0, 2
   191ca: 1b 05 85 04  	addiw	a0, a0, 72
   191ce: 0a 95        	add	a0, a0, sp
   191d0: e6 85        	mv	a1, s9
   191d2: 56 86        	mv	a2, s5
   191d4: 97 b0 ff ff  	auipc	ra, 1048571
   191d8: e7 80 80 c8  	jalr	-888(ra)
   191dc: 09 65        	lui	a0, 2
   191de: 1b 05 05 05  	addiw	a0, a0, 80
   191e2: 0a 95        	add	a0, a0, sp
   191e4: 83 54 05 00  	lhu	s1, 0(a0)
   191e8: 63 9d 04 40  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   191ec: 09 65        	lui	a0, 2
   191ee: 1b 05 85 04  	addiw	a0, a0, 72
   191f2: 0a 95        	add	a0, a0, sp
   191f4: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   191f6: 22 95        	add	a0, a0, s0
   191f8: 63 60 85 70  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   191fc: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   191fe: e3 1d 35 fb  	bne	a0, s3, 0x191b8 <debug.printLineInfo__anon_5334+0x4ac>
;                             return formatBuf(value, options, writer);
   19202: 37 15 01 00  	lui	a0, 17
   19206: 93 06 85 11  	addi	a3, a0, 280
   1920a: 38 18        	addi	a4, sp, 56
   1920c: 66 85        	mv	a0, s9
   1920e: e2 65        	ld	a1, 24(sp)
   19210: 02 76        	ld	a2, 32(sp)
   19212: 97 90 00 00  	auipc	ra, 9
   19216: e7 80 e0 b1  	jalr	-1250(ra)
   1921a: aa 84        	mv	s1, a0
   1921c: 42 15        	slli	a0, a0, 48
   1921e: 41 91        	srli	a0, a0, 48
   19220: 63 16 05 3e  	bnez	a0, 0x1960c <.LBB35_116+0x94>
   19224: b7 25 01 00  	lui	a1, 18
   19228: 13 84 85 ce  	addi	s0, a1, -792
;             while (index != bytes.len) {
   1922c: 1d e9        	bnez	a0, 0x19262 <debug.printLineInfo__anon_5334+0x556>
;             return writeFn(self.context, bytes);
   1922e: 09 65        	lui	a0, 2
   19230: 1b 05 85 04  	addiw	a0, a0, 72
   19234: 0a 95        	add	a0, a0, sp
   19236: 05 47        	li	a4, 1
   19238: e6 85        	mv	a1, s9
   1923a: 56 86        	mv	a2, s5
   1923c: a2 86        	mv	a3, s0
   1923e: 97 b0 ff ff  	auipc	ra, 1048571
   19242: e7 80 e0 c1  	jalr	-994(ra)
   19246: 09 65        	lui	a0, 2
   19248: 1b 05 05 05  	addiw	a0, a0, 80
   1924c: 0a 95        	add	a0, a0, sp
   1924e: 83 54 05 00  	lhu	s1, 0(a0)
   19252: 63 98 04 3a  	bnez	s1, 0x19602 <.LBB35_116+0x8a>
   19256: 09 65        	lui	a0, 2
   19258: 1b 05 85 04  	addiw	a0, a0, 72
   1925c: 0a 95        	add	a0, a0, sp
   1925e: 08 61        	ld	a0, 0(a0)
;             while (index != bytes.len) {
   19260: 79 d5        	beqz	a0, 0x1922e <debug.printLineInfo__anon_5334+0x522>
   19262: 85 45        	li	a1, 1
;             while (index != bytes.len) {
   19264: 63 1f b5 66  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;         try tty_config.setColor(out_stream, .Reset);
   19268: 03 c5 0d 00  	lbu	a0, 0(s11)
;             nosuspend switch (conf) {
   1926c: 0d 89        	andi	a0, a0, 3
   1926e: 25 c1        	beqz	a0, 0x192ce <debug.printLineInfo__anon_5334+0x5c2>
   19270: 85 45        	li	a1, 1
   19272: 63 1d b5 68  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
   19276: 01 44        	li	s0, 0
;                     try out_stream.writeAll(color_string);
   19278: 83 a9 0b 00  	lw	s3, 0(s7)
   1927c: 15 49        	li	s2, 5
   1927e: 37 25 01 00  	lui	a0, 18
   19282: 13 0b 55 86  	addi	s6, a0, -1947
   19286: 91 4a        	li	s5, 4
   19288: 63 7d 24 65  	bgeu	s0, s2, 0x198e2 <.LBB35_157+0xd6>
;                 index += try self.write(bytes[index..]);
   1928c: b3 06 8b 00  	add	a3, s6, s0
   19290: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   19294: 09 65        	lui	a0, 2
   19296: 1b 05 85 04  	addiw	a0, a0, 72
   1929a: 0a 95        	add	a0, a0, sp
   1929c: e6 85        	mv	a1, s9
   1929e: 4e 86        	mv	a2, s3
   192a0: 97 b0 ff ff  	auipc	ra, 1048571
   192a4: e7 80 c0 bb  	jalr	-1092(ra)
   192a8: 09 65        	lui	a0, 2
   192aa: 1b 05 05 05  	addiw	a0, a0, 80
   192ae: 0a 95        	add	a0, a0, sp
   192b0: 83 54 05 00  	lhu	s1, 0(a0)
   192b4: 63 9c 04 34  	bnez	s1, 0x1960c <.LBB35_116+0x94>
   192b8: 09 65        	lui	a0, 2
   192ba: 1b 05 85 04  	addiw	a0, a0, 72
   192be: 0a 95        	add	a0, a0, sp
   192c0: 08 61        	ld	a0, 0(a0)
;                 index += try self.write(bytes[index..]);
   192c2: 22 95        	add	a0, a0, s0
   192c4: 63 6a 85 62  	bltu	a0, s0, 0x198f8 <.LBB35_157+0xec>
   192c8: 2a 84        	mv	s0, a0
   192ca: e3 1f 55 fb  	bne	a0, s5, 0x19288 <debug.printLineInfo__anon_5334+0x57c>
;         try out_stream.writeAll("\n");
   192ce: 83 aa 0b 00  	lw	s5, 0(s7)
   192d2: 01 45        	li	a0, 0
   192d4: b7 25 01 00  	lui	a1, 18
   192d8: 13 84 35 e2  	addi	s0, a1, -477
   192dc: 1d e9        	bnez	a0, 0x19312 <debug.printLineInfo__anon_5334+0x606>
;             return writeFn(self.context, bytes);
   192de: 09 65        	lui	a0, 2
   192e0: 1b 05 85 04  	addiw	a0, a0, 72
   192e4: 0a 95        	add	a0, a0, sp
   192e6: 05 47        	li	a4, 1
   192e8: e6 85        	mv	a1, s9
   192ea: 56 86        	mv	a2, s5
   192ec: a2 86        	mv	a3, s0
   192ee: 97 b0 ff ff  	auipc	ra, 1048571
   192f2: e7 80 e0 b6  	jalr	-1170(ra)
   192f6: 09 65        	lui	a0, 2
   192f8: 1b 05 05 05  	addiw	a0, a0, 80
   192fc: 0a 95        	add	a0, a0, sp
   192fe: 83 54 05 00  	lhu	s1, 0(a0)
   19302: 63 9a 04 30  	bnez	s1, 0x19616 <.LBB35_116+0x9e>
   19306: 09 65        	lui	a0, 2
   19308: 1b 05 85 04  	addiw	a0, a0, 72
   1930c: 0a 95        	add	a0, a0, sp
   1930e: 08 61        	ld	a0, 0(a0)
   19310: 79 d5        	beqz	a0, 0x192de <debug.printLineInfo__anon_5334+0x5d2>
   19312: 85 45        	li	a1, 1
   19314: 63 17 b5 5c  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;         if (line_info) |li| {
   19318: 03 45 0a 02  	lbu	a0, 32(s4)
   1931c: 63 0c 05 4c  	beqz	a0, 0x197f4 <.LBB35_129+0x1be>
   19320: 03 3c 0a 00  	ld	s8, 0(s4)
   19324: 03 34 8a 01  	ld	s0, 24(s4)
   19328: 03 39 8a 00  	ld	s2, 8(s4)
   1932c: 39 c4        	beqz	s0, 0x1937a <debug.printLineInfo__anon_5334+0x66e>
   1932e: 83 34 0a 01  	ld	s1, 16(s4)
   19332: 01 45        	li	a0, 0
;         if (slice[i] == value) return i;
   19334: b3 85 a4 00  	add	a1, s1, a0
   19338: 83 c5 05 00  	lbu	a1, 0(a1)
   1933c: 63 8b 05 5c  	beqz	a1, 0x19912 <.LBB35_169>
;     while (i < slice.len) : (i += 1) {
   19340: 05 05        	addi	a0, a0, 1
   19342: e3 19 a4 fe  	bne	s0, a0, 0x19334 <debug.printLineInfo__anon_5334+0x628>
;     var path_with_null: [MAX_PATH_BYTES - 1:0]u8 = undefined;
   19346: 09 65        	lui	a0, 2
   19348: 1b 05 85 04  	addiw	a0, a0, 72
   1934c: 0a 95        	add	a0, a0, sp
   1934e: 93 05 a0 0a  	li	a1, 170
   19352: 05 66        	lui	a2, 1
   19354: 97 b0 00 00  	auipc	ra, 11
   19358: e7 80 60 f4  	jalr	-186(ra)
;     if (file_path.len >= MAX_PATH_BYTES) return error.NameTooLong;
   1935c: 13 55 c4 00  	srli	a0, s0, 12
   19360: 63 15 05 56  	bnez	a0, 0x198ca <.LBB35_157+0xbe>
;         dest[i] = s;
   19364: 09 65        	lui	a0, 2
   19366: 1b 05 85 04  	addiw	a0, a0, 72
   1936a: 0a 95        	add	a0, a0, sp
   1936c: a6 85        	mv	a1, s1
   1936e: 22 86        	mv	a2, s0
   19370: 97 b0 00 00  	auipc	ra, 11
   19374: e7 80 40 f0  	jalr	-252(ra)
   19378: 21 a8        	j	0x19390 <debug.printLineInfo__anon_5334+0x684>
;     var path_with_null: [MAX_PATH_BYTES - 1:0]u8 = undefined;
   1937a: 09 65        	lui	a0, 2
   1937c: 1b 05 85 04  	addiw	a0, a0, 72
   19380: 0a 95        	add	a0, a0, sp
   19382: 93 05 a0 0a  	li	a1, 170
   19386: 05 66        	lui	a2, 1
   19388: 97 b0 00 00  	auipc	ra, 11
   1938c: e7 80 20 f1  	jalr	-238(ra)
   19390: 09 65        	lui	a0, 2
   19392: 1b 05 85 04  	addiw	a0, a0, 72
   19396: 0a 95        	add	a0, a0, sp
;     path_with_null[file_path.len] = 0;
   19398: 22 95        	add	a0, a0, s0
   1939a: 23 00 05 00  	sb	zero, 0(a0)
;     return path_with_null;
   1939e: 05 65        	lui	a0, 1
   193a0: 1b 05 05 04  	addiw	a0, a0, 64
   193a4: 0a 95        	add	a0, a0, sp
   193a6: 89 65        	lui	a1, 2
   193a8: 9b 85 85 04  	addiw	a1, a1, 72
   193ac: 8a 95        	add	a1, a1, sp
   193ae: 05 66        	lui	a2, 1
   193b0: 97 b0 00 00  	auipc	ra, 11
   193b4: e7 80 40 ec  	jalr	-316(ra)
;         return self.openFileZ(&path_c, flags);
   193b8: 37 25 01 00  	lui	a0, 18
   193bc: 13 07 c5 e2  	addi	a4, a0, -468
   193c0: 09 65        	lui	a0, 2
   193c2: 1b 05 05 04  	addiw	a0, a0, 64
   193c6: 0a 95        	add	a0, a0, sp
   193c8: 13 06 c0 f9  	li	a2, -100
   193cc: 85 65        	lui	a1, 1
   193ce: 9b 85 05 04  	addiw	a1, a1, 64
   193d2: b3 06 b1 00  	add	a3, sp, a1
   193d6: e6 85        	mv	a1, s9
   193d8: 97 80 00 00  	auipc	ra, 8
   193dc: e7 80 c0 0d  	jalr	220(ra)
   193e0: 09 65        	lui	a0, 2
   193e2: 1b 05 05 04  	addiw	a0, a0, 64
   193e6: 0a 95        	add	a0, a0, sp
   193e8: 00 61        	ld	s0, 0(a0)
   193ea: 93 54 04 02  	srli	s1, s0, 32
   193ee: 13 95 04 03  	slli	a0, s1, 48
   193f2: 41 91        	srli	a0, a0, 48
   193f4: 63 11 05 4e  	bnez	a0, 0x198d6 <.LBB35_157+0xca>
   193f8: 4a ec        	sd	s2, 24(sp)
;     var buf: [mem.page_size]u8 = undefined;
   193fa: 88 00        	addi	a0, sp, 64
   193fc: 93 05 a0 0a  	li	a1, 170
   19400: 05 66        	lui	a2, 1
   19402: 97 b0 00 00  	auipc	ra, 11
   19406: e7 80 80 e9  	jalr	-360(ra)
   1940a: 22 e4        	sd	s0, 8(sp)
   1940c: 9b 0a 04 00  	sext.w	s5, s0
   19410: 7d 75        	lui	a0, 1048575
   19412: 1b 0d 15 00  	addiw	s10, a0, 1
   19416: 11 49        	li	s2, 4
   19418: 85 49        	li	s3, 1
   1941a: 05 4a        	li	s4, 1
;     return asm volatile ("ecall"
   1941c: 93 08 f0 03  	li	a7, 63
   19420: 8c 00        	addi	a1, sp, 64
   19422: 05 66        	lui	a2, 1
   19424: 56 85        	mv	a0, s5
   19426: 73 00 00 00  	ecall	
   1942a: 2a 8b        	mv	s6, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1942c: 63 69 a5 01  	bltu	a0, s10, 0x1943e <debug.printLineInfo__anon_5334+0x732>
   19430: 3b 05 60 41  	negw	a0, s6
   19434: 42 15        	slli	a0, a0, 48
   19436: 41 91        	srli	a0, a0, 48
;         switch (errno(rc)) {
   19438: e3 02 25 ff  	beq	a0, s2, 0x1941c <debug.printLineInfo__anon_5334+0x710>
   1943c: 31 aa        	j	0x19558 <debug.printLineInfo__anon_5334+0x84c>
;         const slice = buf[0..amt_read];
   1943e: 05 65        	lui	a0, 1
   19440: 63 6d 65 4f  	bltu	a0, s6, 0x1993a <.LBB35_169+0x28>
;         for (slice) |byte| {
   19444: 63 0f 0b 0e  	beqz	s6, 0x19542 <debug.printLineInfo__anon_5334+0x836>
   19448: 6e f0        	sd	s11, 32(sp)
   1944a: 5e f4        	sd	s7, 40(sp)
   1944c: 81 4b        	li	s7, 0
   1944e: 11 a8        	j	0x19462 <debug.printLineInfo__anon_5334+0x756>
;             while (index != bytes.len) {
   19450: 85 45        	li	a1, 1
   19452: 63 18 b5 48  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;                 column += 1;
   19456: 85 09        	addi	s3, s3, 1
   19458: 63 80 09 4a  	beqz	s3, 0x198f8 <.LBB35_157+0xec>
   1945c: 85 0b        	addi	s7, s7, 1
;         for (slice) |byte| {
   1945e: 63 8c 6b 0d  	beq	s7, s6, 0x19536 <debug.printLineInfo__anon_5334+0x82a>
   19462: 88 00        	addi	a0, sp, 64
   19464: 5e 95        	add	a0, a0, s7
   19466: 83 4d 05 00  	lbu	s11, 0(a0)
;             if (line == line_info.line) {
   1946a: 63 1f 8a 05  	bne	s4, s8, 0x194c8 <debug.printLineInfo__anon_5334+0x7bc>
   1946e: 22 75        	ld	a0, 40(sp)
   19470: 00 41        	lw	s0, 0(a0)
;                 switch (byte) {
   19472: 25 45        	li	a0, 9
   19474: 63 95 ad 06  	bne	s11, a0, 0x194de <debug.printLineInfo__anon_5334+0x7d2>
   19478: 01 45        	li	a0, 0
;             const array = [1]u8{byte};
   1947a: 93 05 00 02  	li	a1, 32
   1947e: 05 66        	lui	a2, 1
   19480: 1b 06 06 04  	addiw	a2, a2, 64
   19484: 0a 96        	add	a2, a2, sp
   19486: 23 00 b6 00  	sb	a1, 0(a2)
;             while (index != bytes.len) {
   1948a: 79 f1        	bnez	a0, 0x19450 <debug.printLineInfo__anon_5334+0x744>
;             return writeFn(self.context, bytes);
   1948c: 09 65        	lui	a0, 2
   1948e: 1b 05 85 04  	addiw	a0, a0, 72
   19492: 0a 95        	add	a0, a0, sp
   19494: 85 65        	lui	a1, 1
   19496: 9b 85 05 04  	addiw	a1, a1, 64
   1949a: b3 06 b1 00  	add	a3, sp, a1
   1949e: 05 47        	li	a4, 1
   194a0: e6 85        	mv	a1, s9
   194a2: 22 86        	mv	a2, s0
   194a4: 97 b0 ff ff  	auipc	ra, 1048571
   194a8: e7 80 80 9b  	jalr	-1608(ra)
   194ac: 09 65        	lui	a0, 2
   194ae: 1b 05 05 05  	addiw	a0, a0, 80
   194b2: 0a 95        	add	a0, a0, sp
   194b4: 83 54 05 00  	lhu	s1, 0(a0)
   194b8: f1 e0        	bnez	s1, 0x1957c <.LBB35_116+0x4>
   194ba: 09 65        	lui	a0, 2
   194bc: 1b 05 85 04  	addiw	a0, a0, 72
   194c0: 0a 95        	add	a0, a0, sp
   194c2: 08 61        	ld	a0, 0(a0)
;             while (index != bytes.len) {
   194c4: 61 d5        	beqz	a0, 0x1948c <debug.printLineInfo__anon_5334+0x780>
   194c6: 69 b7        	j	0x19450 <debug.printLineInfo__anon_5334+0x744>
;             if (byte == '\n') {
   194c8: 29 45        	li	a0, 10
   194ca: e3 96 ad f8  	bne	s11, a0, 0x19456 <debug.printLineInfo__anon_5334+0x74a>
;                 line += 1;
   194ce: 05 0a        	addi	s4, s4, 1
   194d0: 63 04 0a 42  	beqz	s4, 0x198f8 <.LBB35_157+0xec>
   194d4: 85 49        	li	s3, 1
;                 column += 1;
   194d6: 85 0b        	addi	s7, s7, 1
;         for (slice) |byte| {
   194d8: e3 95 6b f9  	bne	s7, s6, 0x19462 <debug.printLineInfo__anon_5334+0x756>
   194dc: a9 a8        	j	0x19536 <debug.printLineInfo__anon_5334+0x82a>
   194de: 01 45        	li	a0, 0
;             const array = [1]u8{byte};
   194e0: 85 65        	lui	a1, 1
   194e2: 9b 85 05 04  	addiw	a1, a1, 64
   194e6: 8a 95        	add	a1, a1, sp
   194e8: 23 80 b5 01  	sb	s11, 0(a1)
;             while (index != bytes.len) {
   194ec: 15 ed        	bnez	a0, 0x19528 <debug.printLineInfo__anon_5334+0x81c>
;             return writeFn(self.context, bytes);
   194ee: 09 65        	lui	a0, 2
   194f0: 1b 05 85 04  	addiw	a0, a0, 72
   194f4: 0a 95        	add	a0, a0, sp
   194f6: 85 65        	lui	a1, 1
   194f8: 9b 85 05 04  	addiw	a1, a1, 64
   194fc: b3 06 b1 00  	add	a3, sp, a1
   19500: 05 47        	li	a4, 1
   19502: e6 85        	mv	a1, s9
   19504: 22 86        	mv	a2, s0
   19506: 97 b0 ff ff  	auipc	ra, 1048571
   1950a: e7 80 60 95  	jalr	-1706(ra)
   1950e: 09 65        	lui	a0, 2
   19510: 1b 05 05 05  	addiw	a0, a0, 80
   19514: 0a 95        	add	a0, a0, sp
   19516: 83 54 05 00  	lhu	s1, 0(a0)
   1951a: d1 e4        	bnez	s1, 0x195a6 <.LBB35_116+0x2e>
   1951c: 09 65        	lui	a0, 2
   1951e: 1b 05 85 04  	addiw	a0, a0, 72
   19522: 0a 95        	add	a0, a0, sp
   19524: 08 61        	ld	a0, 0(a0)
;             while (index != bytes.len) {
   19526: 61 d5        	beqz	a0, 0x194ee <debug.printLineInfo__anon_5334+0x7e2>
   19528: 85 45        	li	a1, 1
   1952a: 63 1c b5 3a  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;                 if (byte == '\n') {
   1952e: 29 45        	li	a0, 10
   19530: e3 93 ad f2  	bne	s11, a0, 0x19456 <debug.printLineInfo__anon_5334+0x74a>
   19534: 19 a2        	j	0x1963a <.LBB35_129+0x4>
;         if (amt_read < buf.len) return error.EndOfFile;
   19536: 13 55 cb 00  	srli	a0, s6, 12
   1953a: a2 7b        	ld	s7, 40(sp)
   1953c: 82 7d        	ld	s11, 32(sp)
   1953e: e3 1f 05 ec  	bnez	a0, 0x1941c <debug.printLineInfo__anon_5334+0x710>
;     defer f.close();
   19542: 22 65        	ld	a0, 8(sp)
   19544: 97 b0 ff ff  	auipc	ra, 1048571
   19548: e7 80 80 ba  	jalr	-1112(ra)
;         if (amt_read < buf.len) return error.EndOfFile;
   1954c: 66 85        	mv	a0, s9
   1954e: 97 a0 00 00  	auipc	ra, 10
   19552: e7 80 a0 6a  	jalr	1706(ra)
   19556: 25 a6        	j	0x1987e <.LBB35_157+0x72>
   19558: 93 05 70 06  	li	a1, 103
;         switch (errno(rc)) {
   1955c: 63 ca a5 06  	blt	a1, a0, 0x195d0 <.LBB35_116+0x58>
   19560: 6d 15        	addi	a0, a0, -5
   19562: c5 45        	li	a1, 17
   19564: 63 e4 a5 2a  	bltu	a1, a0, 0x1980c <.LBB35_157>
   19568: 0a 05        	slli	a0, a0, 2
   1956a: b7 05 01 00  	lui	a1, 16
   1956e: 93 85 c5 5b  	addi	a1, a1, 1468
   19572: 2e 95        	add	a0, a0, a1
   19574: 08 41        	lw	a0, 0(a0)
   19576: 02 85        	jr	a0

0000000000019578 <.LBB35_116>:
   19578: 8d 44        	li	s1, 3
   1957a: 79 ac        	j	0x19818 <.LBB35_157+0xc>
;             return writeFn(self.context, bytes);
   1957c: 66 85        	mv	a0, s9
   1957e: 97 a0 00 00  	auipc	ra, 10
   19582: e7 80 a0 67  	jalr	1658(ra)
;                 index += try self.write(bytes[index..]);
   19586: 66 85        	mv	a0, s9
   19588: 97 a0 00 00  	auipc	ra, 10
   1958c: e7 80 00 67  	jalr	1648(ra)
;             return self.writeAll(&array);
   19590: 66 85        	mv	a0, s9
   19592: 97 a0 00 00  	auipc	ra, 10
   19596: e7 80 60 66  	jalr	1638(ra)
;     return asm volatile ("ecall"
   1959a: 93 08 90 03  	li	a7, 57
   1959e: 56 85        	mv	a0, s5
   195a0: 73 00 00 00  	ecall	
   195a4: 49 ac        	j	0x19836 <.LBB35_157+0x2a>
;             return writeFn(self.context, bytes);
   195a6: 66 85        	mv	a0, s9
   195a8: 97 a0 00 00  	auipc	ra, 10
   195ac: e7 80 00 65  	jalr	1616(ra)
;                 index += try self.write(bytes[index..]);
   195b0: 66 85        	mv	a0, s9
   195b2: 97 a0 00 00  	auipc	ra, 10
   195b6: e7 80 60 64  	jalr	1606(ra)
;             return self.writeAll(&array);
   195ba: 66 85        	mv	a0, s9
   195bc: 97 a0 00 00  	auipc	ra, 10
   195c0: e7 80 c0 63  	jalr	1596(ra)
;     return asm volatile ("ecall"
   195c4: 93 08 90 03  	li	a7, 57
   195c8: 56 85        	mv	a0, s5
   195ca: 73 00 00 00  	ecall	
   195ce: a5 a4        	j	0x19836 <.LBB35_157+0x2a>
   195d0: 93 05 80 06  	li	a1, 104
;         switch (errno(rc)) {
   195d4: 63 0a b5 22  	beq	a0, a1, 0x19808 <.LBB35_155+0x6>
   195d8: 93 05 90 06  	li	a1, 105
;         switch (errno(rc)) {
   195dc: 63 0d b5 04  	beq	a0, a1, 0x19636 <.LBB35_129>
   195e0: 93 05 e0 06  	li	a1, 110
;         switch (errno(rc)) {
   195e4: 63 14 b5 22  	bne	a0, a1, 0x1980c <.LBB35_157>
   195e8: 93 04 30 03  	li	s1, 51
   195ec: 35 a4        	j	0x19818 <.LBB35_157+0xc>
;     return formatBuf(buf[index..], options, writer);
   195ee: 66 85        	mv	a0, s9
   195f0: 97 a0 00 00  	auipc	ra, 10
   195f4: e7 80 80 60  	jalr	1544(ra)
;     return formatInt(int_value, radix, case, options, writer);
   195f8: 66 85        	mv	a0, s9
   195fa: 97 a0 00 00  	auipc	ra, 10
   195fe: e7 80 e0 5f  	jalr	1534(ra)
   19602: 66 85        	mv	a0, s9
   19604: 97 a0 00 00  	auipc	ra, 10
   19608: e7 80 40 5f  	jalr	1524(ra)
   1960c: 66 85        	mv	a0, s9
   1960e: 97 a0 00 00  	auipc	ra, 10
   19612: e7 80 a0 5e  	jalr	1514(ra)
   19616: 66 85        	mv	a0, s9
   19618: 97 a0 00 00  	auipc	ra, 10
   1961c: e7 80 00 5e  	jalr	1504(ra)
   19620: 66 85        	mv	a0, s9
   19622: 97 a0 00 00  	auipc	ra, 10
   19626: e7 80 60 5d  	jalr	1494(ra)
   1962a: 66 85        	mv	a0, s9
   1962c: 97 a0 00 00  	auipc	ra, 10
   19630: e7 80 c0 5c  	jalr	1484(ra)
   19634: 89 ac        	j	0x19886 <.LBB35_157+0x7a>

0000000000019636 <.LBB35_129>:
   19636: 9d 44        	li	s1, 7
   19638: c5 a2        	j	0x19818 <.LBB35_157+0xc>
;     return asm volatile ("ecall"
   1963a: 93 08 90 03  	li	a7, 57
   1963e: 56 85        	mv	a0, s5
   19640: 73 00 00 00  	ecall	
   19644: fd 75        	lui	a1, 1048575
   19646: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   19648: b3 35 b5 00  	sltu	a1, a0, a1
   1964c: 42 15        	slli	a0, a0, 48
   1964e: 41 91        	srli	a0, a0, 48
   19650: 41 66        	lui	a2, 16
   19652: 5d 36        	addiw	a2, a2, -9
   19654: 31 8d        	xor	a0, a0, a2
   19656: 33 35 a0 00  	snez	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1965a: 4d 8d        	or	a0, a0, a1
   1965c: 63 0b 05 2a  	beqz	a0, 0x19912 <.LBB35_169>
   19660: a2 7a        	ld	s5, 40(sp)
   19662: 02 7b        	ld	s6, 32(sp)
   19664: 62 65        	ld	a0, 24(sp)
;                 if (li.column > 0) {
   19666: 63 02 05 14  	beqz	a0, 0x197aa <.LBB35_129+0x174>
;                     try out_stream.writeByteNTimes(' ', space_needed);
   1966a: 03 a9 0a 00  	lw	s2, 0(s5)
;                     const space_needed = @intCast(usize, li.column - 1);
   1966e: 13 04 f5 ff  	addi	s0, a0, -1
;         d.* = value;
   19672: 09 65        	lui	a0, 2
   19674: 1b 05 85 04  	addiw	a0, a0, 72
   19678: 0a 95        	add	a0, a0, sp
   1967a: 93 05 00 02  	li	a1, 32
   1967e: 13 06 00 10  	li	a2, 256
   19682: 97 b0 00 00  	auipc	ra, 11
   19686: e7 80 80 c1  	jalr	-1000(ra)
   1968a: 21 c8        	beqz	s0, 0x196da <.LBB35_129+0xa4>
   1968c: 13 05 00 10  	li	a0, 256
   19690: a2 89        	mv	s3, s0
   19692: 63 64 a4 00  	bltu	s0, a0, 0x1969a <.LBB35_129+0x64>
   19696: 93 09 00 10  	li	s3, 256
;                 try self.writeAll(bytes[0..to_write]);
   1969a: 05 65        	lui	a0, 1
   1969c: 1b 05 05 04  	addiw	a0, a0, 64
   196a0: 0a 95        	add	a0, a0, sp
   196a2: 23 20 25 01  	sw	s2, 0(a0)
   196a6: 05 65        	lui	a0, 1
   196a8: 1b 05 05 04  	addiw	a0, a0, 64
   196ac: b3 05 a1 00  	add	a1, sp, a0
   196b0: 09 65        	lui	a0, 2
   196b2: 1b 05 85 04  	addiw	a0, a0, 72
   196b6: 33 06 a1 00  	add	a2, sp, a0
   196ba: 66 85        	mv	a0, s9
   196bc: ce 86        	mv	a3, s3
   196be: 97 a0 ff ff  	auipc	ra, 1048570
   196c2: e7 80 a0 92  	jalr	-1750(ra)
   196c6: aa 84        	mv	s1, a0
   196c8: 42 15        	slli	a0, a0, 48
   196ca: 41 91        	srli	a0, a0, 48
   196cc: 31 f9        	bnez	a0, 0x19620 <.LBB35_116+0xa8>
;                 remaining -= to_write;
   196ce: 33 05 34 41  	sub	a0, s0, s3
   196d2: 63 63 a4 22  	bltu	s0, a0, 0x198f8 <.LBB35_157+0xec>
   196d6: 2a 84        	mv	s0, a0
;             while (remaining > 0) {
   196d8: 55 f9        	bnez	a0, 0x1968c <.LBB35_129+0x56>
;                     try tty_config.setColor(out_stream, .Green);
   196da: 03 45 0b 00  	lbu	a0, 0(s6)
;             nosuspend switch (conf) {
   196de: 0d 89        	andi	a0, a0, 3
   196e0: 15 cd        	beqz	a0, 0x1971c <.LBB35_129+0xe6>
   196e2: 85 45        	li	a1, 1
;             nosuspend switch (conf) {
   196e4: 63 14 b5 22  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
;                     try out_stream.writeAll(color_string);
   196e8: 03 a5 0a 00  	lw	a0, 0(s5)
   196ec: 89 65        	lui	a1, 2
   196ee: 9b 85 85 04  	addiw	a1, a1, 72
   196f2: 8a 95        	add	a1, a1, sp
   196f4: 88 c1        	sw	a0, 0(a1)
   196f6: 37 25 01 00  	lui	a0, 18
   196fa: 13 06 d5 85  	addi	a2, a0, -1955
   196fe: 09 65        	lui	a0, 2
   19700: 1b 05 85 04  	addiw	a0, a0, 72
   19704: b3 05 a1 00  	add	a1, sp, a0
   19708: 9d 46        	li	a3, 7
   1970a: 66 85        	mv	a0, s9
   1970c: 97 a0 ff ff  	auipc	ra, 1048570
   19710: e7 80 c0 8d  	jalr	-1828(ra)
   19714: aa 84        	mv	s1, a0
   19716: 42 15        	slli	a0, a0, 48
   19718: 41 91        	srli	a0, a0, 48
   1971a: 19 f1        	bnez	a0, 0x19620 <.LBB35_116+0xa8>
;                     try out_stream.writeAll("^");
   1971c: 03 aa 0a 00  	lw	s4, 0(s5)
   19720: 01 45        	li	a0, 0
   19722: b7 25 01 00  	lui	a1, 18
   19726: 13 84 e5 bb  	addi	s0, a1, -1090
;             while (index != bytes.len) {
   1972a: 1d e9        	bnez	a0, 0x19760 <.LBB35_129+0x12a>
;             return writeFn(self.context, bytes);
   1972c: 09 65        	lui	a0, 2
   1972e: 1b 05 85 04  	addiw	a0, a0, 72
   19732: 0a 95        	add	a0, a0, sp
   19734: 05 47        	li	a4, 1
   19736: e6 85        	mv	a1, s9
   19738: 52 86        	mv	a2, s4
   1973a: a2 86        	mv	a3, s0
   1973c: 97 a0 ff ff  	auipc	ra, 1048570
   19740: e7 80 00 72  	jalr	1824(ra)
   19744: 09 65        	lui	a0, 2
   19746: 1b 05 05 05  	addiw	a0, a0, 80
   1974a: 0a 95        	add	a0, a0, sp
   1974c: 83 54 05 00  	lhu	s1, 0(a0)
   19750: e3 93 04 ec  	bnez	s1, 0x19616 <.LBB35_116+0x9e>
   19754: 09 65        	lui	a0, 2
   19756: 1b 05 85 04  	addiw	a0, a0, 72
   1975a: 0a 95        	add	a0, a0, sp
   1975c: 08 61        	ld	a0, 0(a0)
;             while (index != bytes.len) {
   1975e: 79 d5        	beqz	a0, 0x1972c <.LBB35_129+0xf6>
   19760: 85 45        	li	a1, 1
;             while (index != bytes.len) {
   19762: 63 10 b5 18  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
;                     try tty_config.setColor(out_stream, .Reset);
   19766: 03 45 0b 00  	lbu	a0, 0(s6)
;             nosuspend switch (conf) {
   1976a: 0d 89        	andi	a0, a0, 3
   1976c: 1d cd        	beqz	a0, 0x197aa <.LBB35_129+0x174>
   1976e: 85 45        	li	a1, 1
   19770: 63 1e b5 18  	bne	a0, a1, 0x1990c <.LBB35_157+0x100>
;                     try out_stream.writeAll(color_string);
   19774: 03 a5 0a 00  	lw	a0, 0(s5)
   19778: 89 65        	lui	a1, 2
   1977a: 9b 85 85 04  	addiw	a1, a1, 72
   1977e: 8a 95        	add	a1, a1, sp
   19780: 88 c1        	sw	a0, 0(a1)
   19782: 37 25 01 00  	lui	a0, 18
   19786: 13 06 55 86  	addi	a2, a0, -1947
   1978a: 09 65        	lui	a0, 2
   1978c: 1b 05 85 04  	addiw	a0, a0, 72
   19790: b3 05 a1 00  	add	a1, sp, a0
   19794: 91 46        	li	a3, 4
   19796: 66 85        	mv	a0, s9
   19798: 97 a0 ff ff  	auipc	ra, 1048570
   1979c: e7 80 00 85  	jalr	-1968(ra)
   197a0: aa 84        	mv	s1, a0
   197a2: 42 15        	slli	a0, a0, 48
   197a4: 41 91        	srli	a0, a0, 48
   197a6: e3 1d 05 e6  	bnez	a0, 0x19620 <.LBB35_116+0xa8>
;                 try out_stream.writeAll("\n");
   197aa: 03 a9 0a 00  	lw	s2, 0(s5)
   197ae: 01 45        	li	a0, 0
   197b0: b7 25 01 00  	lui	a1, 18
   197b4: 13 84 35 e2  	addi	s0, a1, -477
   197b8: 1d e9        	bnez	a0, 0x197ee <.LBB35_129+0x1b8>
;             return writeFn(self.context, bytes);
   197ba: 09 65        	lui	a0, 2
   197bc: 1b 05 85 04  	addiw	a0, a0, 72
   197c0: 0a 95        	add	a0, a0, sp
   197c2: 05 47        	li	a4, 1
   197c4: e6 85        	mv	a1, s9
   197c6: 4a 86        	mv	a2, s2
   197c8: a2 86        	mv	a3, s0
   197ca: 97 a0 ff ff  	auipc	ra, 1048570
   197ce: e7 80 20 69  	jalr	1682(ra)
   197d2: 09 65        	lui	a0, 2
   197d4: 1b 05 05 05  	addiw	a0, a0, 80
   197d8: 0a 95        	add	a0, a0, sp
   197da: 83 54 05 00  	lhu	s1, 0(a0)
   197de: e3 9c 04 e2  	bnez	s1, 0x19616 <.LBB35_116+0x9e>
   197e2: 09 65        	lui	a0, 2
   197e4: 1b 05 85 04  	addiw	a0, a0, 72
   197e8: 0a 95        	add	a0, a0, sp
   197ea: 08 61        	ld	a0, 0(a0)
   197ec: 79 d5        	beqz	a0, 0x197ba <.LBB35_129+0x184>
   197ee: 85 45        	li	a1, 1
;             while (index != bytes.len) {
   197f0: 63 19 b5 0e  	bne	a0, a1, 0x198e2 <.LBB35_157+0xd6>
   197f4: 81 44        	li	s1, 0
   197f6: 41 a8        	j	0x19886 <.LBB35_157+0x7a>

00000000000197f8 <.LBB35_153>:
   197f8: 93 04 40 03  	li	s1, 52
   197fc: 31 a8        	j	0x19818 <.LBB35_157+0xc>

00000000000197fe <.LBB35_154>:
   197fe: ad 44        	li	s1, 11
   19800: 21 a8        	j	0x19818 <.LBB35_157+0xc>

0000000000019802 <.LBB35_155>:
   19802: 93 04 20 02  	li	s1, 34
   19806: 09 a8        	j	0x19818 <.LBB35_157+0xc>
   19808: b1 44        	li	s1, 12
   1980a: 39 a0        	j	0x19818 <.LBB35_157+0xc>

000000000001980c <.LBB35_157>:
;     return error.Unexpected;
   1980c: 66 85        	mv	a0, s9
   1980e: 97 a0 00 00  	auipc	ra, 10
   19812: e7 80 a0 3e  	jalr	1002(ra)
   19816: b5 44        	li	s1, 13
   19818: 66 85        	mv	a0, s9
   1981a: 97 a0 00 00  	auipc	ra, 10
   1981e: e7 80 e0 3d  	jalr	990(ra)
;             return os.read(self.handle, buffer);
   19822: 66 85        	mv	a0, s9
   19824: 97 a0 00 00  	auipc	ra, 10
   19828: e7 80 40 3d  	jalr	980(ra)
;     return asm volatile ("ecall"
   1982c: 93 08 90 03  	li	a7, 57
   19830: 56 85        	mv	a0, s5
   19832: 73 00 00 00  	ecall	
   19836: fd 75        	lui	a1, 1048575
   19838: 85 25        	addiw	a1, a1, 1
   1983a: b3 35 b5 00  	sltu	a1, a0, a1
   1983e: 42 15        	slli	a0, a0, 48
   19840: 41 91        	srli	a0, a0, 48
   19842: 41 66        	lui	a2, 16
   19844: 5d 36        	addiw	a2, a2, -9
   19846: 31 8d        	xor	a0, a0, a2
   19848: 33 35 a0 00  	snez	a0, a0
   1984c: 4d 8d        	or	a0, a0, a1
   1984e: 71 c1        	beqz	a0, 0x19912 <.LBB35_169>
   19850: 66 85        	mv	a0, s9
   19852: 97 a0 00 00  	auipc	ra, 10
   19856: e7 80 60 3a  	jalr	934(ra)
;             if (printLineFromFile(out_stream, li)) {
   1985a: 13 95 04 03  	slli	a0, s1, 48
   1985e: 41 91        	srli	a0, a0, 48
   19860: 93 05 60 03  	li	a1, 54
   19864: e3 e3 a5 dc  	bltu	a1, a0, 0x1962a <.LBB35_116+0xb2>
   19868: b7 05 00 40  	lui	a1, 262144
   1986c: c5 25        	addiw	a1, a1, 17
   1986e: e2 05        	slli	a1, a1, 24
   19870: 93 85 05 02  	addi	a1, a1, 32
   19874: 33 d5 a5 00  	srl	a0, a1, a0
   19878: 05 89        	andi	a0, a0, 1
   1987a: e3 08 05 da  	beqz	a0, 0x1962a <.LBB35_116+0xb2>
   1987e: 81 44        	li	s1, 0
;                 else => return err,
   19880: 42 65        	ld	a0, 16(sp)
   19882: 23 b0 ac 00  	sd	a0, 0(s9)
   19886: 26 85        	mv	a0, s1
   19888: 8d 65        	lui	a1, 3
   1988a: 9b 85 05 8c  	addiw	a1, a1, -1856
   1988e: 2e 91        	add	sp, sp, a1
   19890: 83 30 81 7e  	ld	ra, 2024(sp)
   19894: 03 34 01 7e  	ld	s0, 2016(sp)
   19898: 83 34 81 7d  	ld	s1, 2008(sp)
   1989c: 03 39 01 7d  	ld	s2, 2000(sp)
   198a0: 83 39 81 7c  	ld	s3, 1992(sp)
   198a4: 03 3a 01 7c  	ld	s4, 1984(sp)
   198a8: 83 3a 81 7b  	ld	s5, 1976(sp)
   198ac: 03 3b 01 7b  	ld	s6, 1968(sp)
   198b0: 83 3b 81 7a  	ld	s7, 1960(sp)
   198b4: 03 3c 01 7a  	ld	s8, 1952(sp)
   198b8: 83 3c 81 79  	ld	s9, 1944(sp)
   198bc: 03 3d 01 79  	ld	s10, 1936(sp)
   198c0: 83 3d 81 78  	ld	s11, 1928(sp)
   198c4: 13 01 01 7f  	addi	sp, sp, 2032
   198c8: 82 80        	ret
;     if (file_path.len >= MAX_PATH_BYTES) return error.NameTooLong;
   198ca: 66 85        	mv	a0, s9
   198cc: 97 a0 00 00  	auipc	ra, 10
   198d0: e7 80 c0 32  	jalr	812(ra)
   198d4: e9 44        	li	s1, 26
   198d6: 66 85        	mv	a0, s9
   198d8: 97 a0 00 00  	auipc	ra, 10
   198dc: e7 80 00 32  	jalr	800(ra)
   198e0: 85 bf        	j	0x19850 <.LBB35_157+0x44>
   198e2: 37 15 01 00  	lui	a0, 17
   198e6: 13 05 45 5b  	addi	a0, a0, 1460
   198ea: 93 05 40 02  	li	a1, 36
   198ee: 81 46        	li	a3, 0
   198f0: 97 a0 00 00  	auipc	ra, 10
   198f4: e7 80 a0 a8  	jalr	-1398(ra)
   198f8: 37 15 01 00  	lui	a0, 17
   198fc: 13 05 95 5d  	addi	a0, a0, 1497
   19900: c1 45        	li	a1, 16
   19902: 81 46        	li	a3, 0
   19904: 97 a0 00 00  	auipc	ra, 10
   19908: e7 80 60 a7  	jalr	-1418(ra)
   1990c: 89 45        	li	a1, 2
   1990e: 63 1c b5 00  	bne	a0, a1, 0x19926 <.LBB35_169+0x14>

0000000000019912 <.LBB35_169>:
   19912: 37 25 01 00  	lui	a0, 18
   19916: 13 05 b5 a7  	addi	a0, a0, -1413
   1991a: e1 45        	li	a1, 24
   1991c: 81 46        	li	a3, 0
   1991e: 97 a0 00 00  	auipc	ra, 10
   19922: e7 80 c0 a5  	jalr	-1444(ra)
   19926: 37 25 01 00  	lui	a0, 18
   1992a: 13 05 a5 99  	addi	a0, a0, -1638
   1992e: dd 45        	li	a1, 23
   19930: 81 46        	li	a3, 0
   19932: 97 a0 00 00  	auipc	ra, 10
   19936: e7 80 80 a4  	jalr	-1464(ra)
;         const slice = buf[0..amt_read];
   1993a: 37 15 01 00  	lui	a0, 17
   1993e: 13 05 35 6e  	addi	a0, a0, 1763
   19942: cd 45        	li	a1, 19
   19944: 81 46        	li	a3, 0
   19946: 97 a0 00 00  	auipc	ra, 10
   1994a: e7 80 40 a3  	jalr	-1484(ra)

000000000001994e <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc>:
;         ) ![]u8 {
   1994e: 71 71        	addi	sp, sp, -176
;             return Self{
   19950: 06 f5        	sd	ra, 168(sp)
   19952: 22 f1        	sd	s0, 160(sp)
   19954: 26 ed        	sd	s1, 152(sp)
   19956: 4a e9        	sd	s2, 144(sp)
   19958: 4e e5        	sd	s3, 136(sp)
   1995a: 52 e1        	sd	s4, 128(sp)
   1995c: d6 fc        	sd	s5, 120(sp)
   1995e: da f8        	sd	s6, 112(sp)
   19960: de f4        	sd	s7, 104(sp)
   19962: e2 f0        	sd	s8, 96(sp)
   19964: e6 ec        	sd	s9, 88(sp)
   19966: ea e8        	sd	s10, 80(sp)
   19968: ee e4        	sd	s11, 72(sp)
   1996a: 98 62        	ld	a4, 0(a3)
   1996c: 3a f4        	sd	a4, 40(sp)
   1996e: 37 57 02 00  	lui	a4, 37
   19972: 83 3c 87 36  	ld	s9, 872(a4)
;             return Self{
   19976: 94 66        	ld	a3, 8(a3)
   19978: 36 f0        	sd	a3, 32(sp)
   1997a: 86 89        	mv	s3, ra
   1997c: b2 8b        	mv	s7, a2
   1997e: 2e e4        	sd	a1, 8(sp)
   19980: 2a e8        	sd	a0, 16(sp)
   19982: 81 44        	li	s1, 0
   19984: 01 4c        	li	s8, 0
   19986: 13 0a a0 0a  	li	s4, 170
   1998a: fd 5a        	li	s5, -1
   1998c: 66 8b        	mv	s6, s9
   1998e: 66 ec        	sd	s9, 24(sp)
;             var result: [1]u8 = undefined;
   19990: a3 0b 41 03  	sb	s4, 55(sp)
;             return readFn(self.context, buffer);
   19994: 28 18        	addi	a0, sp, 56
   19996: 13 06 71 03  	addi	a2, sp, 55
   1999a: 85 46        	li	a3, 1
   1999c: de 85        	mv	a1, s7
   1999e: 97 80 00 00  	auipc	ra, 8
   199a2: e7 80 a0 d1  	jalr	-742(ra)
   199a6: 62 75        	ld	a0, 56(sp)
;             if (amt_read < 1) return error.EndOfStream;
   199a8: 63 06 05 24  	beqz	a0, 0x19bf4 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2a6>
;             return result[0];
   199ac: 03 49 71 03  	lbu	s2, 55(sp)
;                 if (byte == delimiter) {
   199b0: 63 07 09 0e  	beqz	s2, 0x19a9e <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x150>
;             if (self.capacity >= new_capacity) return;
   199b4: 63 ef 84 0b  	bltu	s1, s8, 0x19a72 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x124>
   199b8: 62 84        	mv	s0, s8
   199ba: 19 a0        	j	0x199c0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x72>
;                 if (better_capacity >= new_capacity) break;
   199bc: 63 ec 84 00  	bltu	s1, s0, 0x199d4 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x86>
   199c0: a2 85        	mv	a1, s0
;                 better_capacity +|= better_capacity / 2 + 8;
   199c2: 13 55 14 00  	srli	a0, s0, 1
   199c6: 22 95        	add	a0, a0, s0
   199c8: 21 05        	addi	a0, a0, 8
   199ca: 7d 54        	li	s0, -1
   199cc: e3 68 b5 fe  	bltu	a0, a1, 0x199bc <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x6e>
   199d0: 2a 84        	mv	s0, a0
   199d2: ed b7        	j	0x199bc <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x6e>
;             if (self.capacity >= new_capacity) return;
   199d4: 63 7f 8c 08  	bgeu	s8, s0, 0x19a72 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x124>
;     if (old_mem.len == 0) {
   199d8: 63 00 0c 02  	beqz	s8, 0x199f8 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0xaa>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   199dc: 02 75        	ld	a0, 32(sp)
   199de: 03 38 85 00  	ld	a6, 8(a0)
   199e2: 22 75        	ld	a0, 40(sp)
   199e4: e6 85        	mv	a1, s9
   199e6: 62 86        	mv	a2, s8
   199e8: 81 46        	li	a3, 0
   199ea: 22 87        	mv	a4, s0
   199ec: ce 87        	mv	a5, s3
   199ee: 02 98        	jalr	a6
   199f0: 05 89        	andi	a0, a0, 1
;             if (self.allocator.resize(old_memory, new_capacity)) {
   199f2: 19 c1        	beqz	a0, 0x199f8 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0xaa>
   199f4: 22 8c        	mv	s8, s0
   199f6: b5 a8        	j	0x19a72 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x124>
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   199f8: 02 75        	ld	a0, 32(sp)
   199fa: 18 61        	ld	a4, 0(a0)
   199fc: 22 75        	ld	a0, 40(sp)
   199fe: a2 85        	mv	a1, s0
   19a00: 01 46        	li	a2, 0
   19a02: ce 86        	mv	a3, s3
   19a04: 02 97        	jalr	a4
   19a06: 63 0d 05 28  	beqz	a0, 0x19ca0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x352>
   19a0a: 2a 8d        	mv	s10, a0
;     @memset(byte_ptr, undefined, byte_count);
   19a0c: 93 05 a0 0a  	li	a1, 170
   19a10: 22 86        	mv	a2, s0
   19a12: 97 b0 00 00  	auipc	ra, 11
   19a16: e7 80 80 88  	jalr	-1912(ra)
;     if (!ok) unreachable; // assertion failure
   19a1a: 63 6b 94 2c  	bltu	s0, s1, 0x19cf0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3a2>
;     for (source) |s, i|
   19a1e: 89 cc        	beqz	s1, 0x19a38 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0xea>
   19a20: 01 45        	li	a0, 0
;     for (source) |s, i|
   19a22: b3 85 ac 00  	add	a1, s9, a0
   19a26: 83 85 05 00  	lb	a1, 0(a1)
;         dest[i] = s;
   19a2a: 33 06 ad 00  	add	a2, s10, a0
   19a2e: 05 05        	addi	a0, a0, 1
   19a30: 23 00 b6 00  	sb	a1, 0(a2)
;     for (source) |s, i|
   19a34: e3 97 a4 fe  	bne	s1, a0, 0x19a22 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0xd4>
   19a38: 01 4b        	li	s6, 0
   19a3a: e2 6d        	ld	s11, 24(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19a3c: 63 04 0c 00  	beqz	s8, 0x19a44 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0xf6>
   19a40: e6 8d        	mv	s11, s9
   19a42: 62 8b        	mv	s6, s8
;     if (bytes_len == 0) return;
   19a44: 63 04 0b 02  	beqz	s6, 0x19a6c <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x11e>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   19a48: 63 8e 0d 2a  	beqz	s11, 0x19d04 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3b6>
;     @memset(non_const_ptr, undefined, bytes_len);
   19a4c: 93 05 a0 0a  	li	a1, 170
   19a50: 6e 85        	mv	a0, s11
   19a52: 5a 86        	mv	a2, s6
   19a54: 97 b0 00 00  	auipc	ra, 11
   19a58: e7 80 60 84  	jalr	-1978(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   19a5c: 02 75        	ld	a0, 32(sp)
   19a5e: 1c 69        	ld	a5, 16(a0)
   19a60: 22 75        	ld	a0, 40(sp)
   19a62: ee 85        	mv	a1, s11
   19a64: 5a 86        	mv	a2, s6
   19a66: 81 46        	li	a3, 0
   19a68: 4e 87        	mv	a4, s3
   19a6a: 82 97        	jalr	a5
   19a6c: 22 8c        	mv	s8, s0
   19a6e: 6a 8b        	mv	s6, s10
   19a70: ea 8c        	mv	s9, s10
;     if (!ok) unreachable; // assertion failure
   19a72: 63 ff 84 27  	bgeu	s1, s8, 0x19cf0 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3a2>
;             self.items.len += 1;
   19a76: 13 85 14 00  	addi	a0, s1, 1
;             return &self.items[self.items.len - 1];
   19a7a: b3 85 9c 00  	add	a1, s9, s1
;             new_item_ptr.* = item;
   19a7e: 23 80 25 01  	sb	s2, 0(a1)
   19a82: aa 84        	mv	s1, a0
;                 if (array_list.items.len == max_size) {
   19a84: e3 16 55 f1  	bne	a0, s5, 0x19990 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x42>
   19a88: 13 04 70 03  	li	s0, 55
   19a8c: a2 64        	ld	s1, 8(sp)
   19a8e: 26 85        	mv	a0, s1
   19a90: 97 a0 00 00  	auipc	ra, 10
   19a94: e7 80 80 16  	jalr	360(ra)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19a98: 63 0d 0c 16  	beqz	s8, 0x19c12 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2c4>
   19a9c: bd aa        	j	0x19c1a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2cc>
;     if (new_n == 0) {
   19a9e: ad c8        	beqz	s1, 0x19b10 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x1c2>
;     if (old_mem.len == 0) {
   19aa0: 63 0d 0c 00  	beqz	s8, 0x19aba <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x16c>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   19aa4: 02 75        	ld	a0, 32(sp)
   19aa6: 00 65        	ld	s0, 8(a0)
   19aa8: 22 75        	ld	a0, 40(sp)
   19aaa: da 85        	mv	a1, s6
   19aac: 62 86        	mv	a2, s8
   19aae: 81 46        	li	a3, 0
   19ab0: 26 87        	mv	a4, s1
   19ab2: ce 87        	mv	a5, s3
   19ab4: 02 94        	jalr	s0
   19ab6: 05 89        	andi	a0, a0, 1
;             if (allocator.resize(old_memory, self.items.len)) {
   19ab8: 49 e9        	bnez	a0, 0x19b4a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x1fc>
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   19aba: 02 75        	ld	a0, 32(sp)
   19abc: 18 61        	ld	a4, 0(a0)
   19abe: 22 75        	ld	a0, 40(sp)
   19ac0: a6 85        	mv	a1, s1
   19ac2: 01 46        	li	a2, 0
   19ac4: ce 86        	mv	a3, s3
   19ac6: 02 97        	jalr	a4
   19ac8: 63 09 05 1a  	beqz	a0, 0x19c7a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x32c>
   19acc: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   19ace: 93 05 a0 0a  	li	a1, 170
   19ad2: 26 86        	mv	a2, s1
   19ad4: 97 a0 00 00  	auipc	ra, 10
   19ad8: e7 80 60 7c  	jalr	1990(ra)
   19adc: 01 45        	li	a0, 0
;     for (source) |s, i|
   19ade: b3 05 ab 00  	add	a1, s6, a0
   19ae2: 83 85 05 00  	lb	a1, 0(a1)
;         dest[i] = s;
   19ae6: 33 06 a4 00  	add	a2, s0, a0
   19aea: 05 05        	addi	a0, a0, 1
   19aec: 23 00 b6 00  	sb	a1, 0(a2)
;     for (source) |s, i|
   19af0: e3 97 a4 fe  	bne	s1, a0, 0x19ade <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x190>
;             @memset(@ptrCast([*]u8, self.items.ptr), undefined, self.items.len * @sizeOf(T));
   19af4: 93 05 a0 0a  	li	a1, 170
   19af8: 5a 85        	mv	a0, s6
   19afa: 26 86        	mv	a2, s1
   19afc: 97 a0 00 00  	auipc	ra, 10
   19b00: e7 80 e0 79  	jalr	1950(ra)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19b04: 63 0a 0c 04  	beqz	s8, 0x19b58 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x20a>
   19b08: da 8b        	mv	s7, s6
;     if (bytes_len == 0) return;
   19b0a: 63 1d 0c 04  	bnez	s8, 0x19b64 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x216>
   19b0e: b5 a8        	j	0x19b8a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x23c>
   19b10: 37 55 02 00  	lui	a0, 37
   19b14: 83 3b 85 36  	ld	s7, 872(a0)
   19b18: 01 44        	li	s0, 0
   19b1a: de 8c        	mv	s9, s7
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19b1c: 63 04 0c 00  	beqz	s8, 0x19b24 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x1d6>
   19b20: da 8c        	mv	s9, s6
   19b22: 62 84        	mv	s0, s8
;     if (bytes_len == 0) return;
   19b24: 1d c4        	beqz	s0, 0x19b52 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x204>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   19b26: 63 8f 0c 1c  	beqz	s9, 0x19d04 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3b6>
;     @memset(non_const_ptr, undefined, bytes_len);
   19b2a: 93 05 a0 0a  	li	a1, 170
   19b2e: 66 85        	mv	a0, s9
   19b30: 22 86        	mv	a2, s0
   19b32: 97 a0 00 00  	auipc	ra, 10
   19b36: e7 80 80 76  	jalr	1896(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   19b3a: 02 75        	ld	a0, 32(sp)
   19b3c: 1c 69        	ld	a5, 16(a0)
   19b3e: 22 75        	ld	a0, 40(sp)
   19b40: e6 85        	mv	a1, s9
   19b42: 22 86        	mv	a2, s0
   19b44: 81 46        	li	a3, 0
   19b46: 4e 87        	mv	a4, s3
   19b48: 82 97        	jalr	a5
   19b4a: 37 55 02 00  	lui	a0, 37
   19b4e: 83 3b 85 36  	ld	s7, 872(a0)
   19b52: 01 4c        	li	s8, 0
   19b54: 01 45        	li	a0, 0
   19b56: 2d a8        	j	0x19b90 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x242>
   19b58: 37 55 02 00  	lui	a0, 37
   19b5c: 83 3b 85 36  	ld	s7, 872(a0)
;     if (bytes_len == 0) return;
   19b60: 63 05 0c 02  	beqz	s8, 0x19b8a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x23c>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   19b64: 63 80 0b 1a  	beqz	s7, 0x19d04 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3b6>
;     @memset(non_const_ptr, undefined, bytes_len);
   19b68: 93 05 a0 0a  	li	a1, 170
   19b6c: 5e 85        	mv	a0, s7
   19b6e: 62 86        	mv	a2, s8
   19b70: 97 a0 00 00  	auipc	ra, 10
   19b74: e7 80 a0 72  	jalr	1834(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   19b78: 02 75        	ld	a0, 32(sp)
   19b7a: 1c 69        	ld	a5, 16(a0)
   19b7c: 22 75        	ld	a0, 40(sp)
   19b7e: de 85        	mv	a1, s7
   19b80: 62 86        	mv	a2, s8
   19b82: 81 46        	li	a3, 0
   19b84: 4e 87        	mv	a4, s3
   19b86: 82 97        	jalr	a5
   19b88: 01 4c        	li	s8, 0
   19b8a: 01 45        	li	a0, 0
   19b8c: da 8b        	mv	s7, s6
   19b8e: 22 8b        	mv	s6, s0
   19b90: 42 64        	ld	s0, 16(sp)
;             return array_list.toOwnedSlice();
   19b92: 23 30 64 01  	sd	s6, 0(s0)
   19b96: 04 e4        	sd	s1, 8(s0)
   19b98: 23 18 a4 00  	sh	a0, 16(s0)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19b9c: 63 16 0c 00  	bnez	s8, 0x19ba8 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x25a>
   19ba0: b7 55 02 00  	lui	a1, 37
   19ba4: 83 bb 85 36  	ld	s7, 872(a1)
;     if (bytes_len == 0) return;
   19ba8: 63 06 0c 02  	beqz	s8, 0x19bd4 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x286>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   19bac: 63 8c 0b 14  	beqz	s7, 0x19d04 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3b6>
;     @memset(non_const_ptr, undefined, bytes_len);
   19bb0: 93 05 a0 0a  	li	a1, 170
   19bb4: 5e 85        	mv	a0, s7
   19bb6: 62 86        	mv	a2, s8
   19bb8: 97 a0 00 00  	auipc	ra, 10
   19bbc: e7 80 20 6e  	jalr	1762(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   19bc0: 02 75        	ld	a0, 32(sp)
   19bc2: 1c 69        	ld	a5, 16(a0)
   19bc4: 22 75        	ld	a0, 40(sp)
   19bc6: de 85        	mv	a1, s7
   19bc8: 62 86        	mv	a2, s8
   19bca: 81 46        	li	a3, 0
   19bcc: 4e 87        	mv	a4, s3
   19bce: 82 97        	jalr	a5
;             return array_list.toOwnedSlice();
   19bd0: 03 55 04 01  	lhu	a0, 16(s0)
   19bd4: 41 e1        	bnez	a0, 0x19c54 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x306>
   19bd6: aa 70        	ld	ra, 168(sp)
   19bd8: 0a 74        	ld	s0, 160(sp)
   19bda: ea 64        	ld	s1, 152(sp)
   19bdc: 4a 69        	ld	s2, 144(sp)
   19bde: aa 69        	ld	s3, 136(sp)
   19be0: 0a 6a        	ld	s4, 128(sp)
   19be2: e6 7a        	ld	s5, 120(sp)
   19be4: 46 7b        	ld	s6, 112(sp)
   19be6: a6 7b        	ld	s7, 104(sp)
   19be8: 06 7c        	ld	s8, 96(sp)
   19bea: e6 6c        	ld	s9, 88(sp)
   19bec: 46 6d        	ld	s10, 80(sp)
   19bee: a6 6d        	ld	s11, 72(sp)
   19bf0: 4d 61        	addi	sp, sp, 176
   19bf2: 82 80        	ret
   19bf4: a2 64        	ld	s1, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19bf6: 26 85        	mv	a0, s1
   19bf8: 97 a0 00 00  	auipc	ra, 10
   19bfc: e7 80 00 00  	jalr	ra
   19c00: 13 04 10 03  	li	s0, 49
   19c04: 26 85        	mv	a0, s1
   19c06: 97 a0 00 00  	auipc	ra, 10
   19c0a: e7 80 20 ff  	jalr	-14(ra)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19c0e: 63 16 0c 00  	bnez	s8, 0x19c1a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2cc>
   19c12: 37 55 02 00  	lui	a0, 37
   19c16: 03 3b 85 36  	ld	s6, 872(a0)
;     if (bytes_len == 0) return;
   19c1a: 63 04 0c 02  	beqz	s8, 0x19c42 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2f4>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   19c1e: 63 03 0b 0e  	beqz	s6, 0x19d04 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x3b6>
;     @memset(non_const_ptr, undefined, bytes_len);
   19c22: 93 05 a0 0a  	li	a1, 170
   19c26: 5a 85        	mv	a0, s6
   19c28: 62 86        	mv	a2, s8
   19c2a: 97 a0 00 00  	auipc	ra, 10
   19c2e: e7 80 00 67  	jalr	1648(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   19c32: 02 75        	ld	a0, 32(sp)
   19c34: 1c 69        	ld	a5, 16(a0)
   19c36: 22 75        	ld	a0, 40(sp)
   19c38: da 85        	mv	a1, s6
   19c3a: 62 86        	mv	a2, s8
   19c3c: 81 46        	li	a3, 0
   19c3e: 4e 87        	mv	a4, s3
   19c40: 82 97        	jalr	a5
;             try self.readUntilDelimiterArrayList(&array_list, delimiter, max_size);
   19c42: 26 85        	mv	a0, s1
   19c44: 97 a0 00 00  	auipc	ra, 10
   19c48: e7 80 40 fb  	jalr	-76(ra)
   19c4c: 42 65        	ld	a0, 16(sp)
   19c4e: 23 18 85 00  	sh	s0, 16(a0)
   19c52: 51 b7        	j	0x19bd6 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x288>
;             return array_list.toOwnedSlice();
   19c54: 22 65        	ld	a0, 8(sp)
   19c56: aa 70        	ld	ra, 168(sp)
   19c58: 0a 74        	ld	s0, 160(sp)
   19c5a: ea 64        	ld	s1, 152(sp)
   19c5c: 4a 69        	ld	s2, 144(sp)
   19c5e: aa 69        	ld	s3, 136(sp)
   19c60: 0a 6a        	ld	s4, 128(sp)
   19c62: e6 7a        	ld	s5, 120(sp)
   19c64: 46 7b        	ld	s6, 112(sp)
   19c66: a6 7b        	ld	s7, 104(sp)
   19c68: 06 7c        	ld	s8, 96(sp)
   19c6a: e6 6c        	ld	s9, 88(sp)
   19c6c: 46 6d        	ld	s10, 80(sp)
   19c6e: a6 6d        	ld	s11, 72(sp)
   19c70: 4d 61        	addi	sp, sp, 176
   19c72: 17 a3 00 00  	auipc	t1, 10
   19c76: 67 00 63 f8  	jr	-122(t1)
   19c7a: 22 64        	ld	s0, 8(sp)
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   19c7c: 22 85        	mv	a0, s0
   19c7e: 97 a0 00 00  	auipc	ra, 10
   19c82: e7 80 a0 f7  	jalr	-134(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   19c86: 22 85        	mv	a0, s0
   19c88: 97 a0 00 00  	auipc	ra, 10
   19c8c: e7 80 00 f7  	jalr	-144(ra)
;             const new_memory = try allocator.alignedAlloc(T, alignment, self.items.len);
   19c90: 22 85        	mv	a0, s0
   19c92: 97 a0 00 00  	auipc	ra, 10
   19c96: e7 80 60 f6  	jalr	-154(ra)
   19c9a: 45 45        	li	a0, 17
   19c9c: da 8b        	mv	s7, s6
   19c9e: cd bd        	j	0x19b90 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x242>
   19ca0: a2 64        	ld	s1, 8(sp)
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   19ca2: 26 85        	mv	a0, s1
   19ca4: 97 a0 00 00  	auipc	ra, 10
   19ca8: e7 80 40 f5  	jalr	-172(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   19cac: 26 85        	mv	a0, s1
   19cae: 97 a0 00 00  	auipc	ra, 10
   19cb2: e7 80 a0 f4  	jalr	-182(ra)
;                 const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
   19cb6: 26 85        	mv	a0, s1
   19cb8: 97 a0 00 00  	auipc	ra, 10
   19cbc: e7 80 00 f4  	jalr	-192(ra)
;             return self.ensureTotalCapacityPrecise(better_capacity);
   19cc0: 26 85        	mv	a0, s1
   19cc2: 97 a0 00 00  	auipc	ra, 10
   19cc6: e7 80 60 f3  	jalr	-202(ra)
;             try self.ensureTotalCapacity(self.items.len + 1);
   19cca: 26 85        	mv	a0, s1
   19ccc: 97 a0 00 00  	auipc	ra, 10
   19cd0: e7 80 c0 f2  	jalr	-212(ra)
;             const new_item_ptr = try self.addOne();
   19cd4: 26 85        	mv	a0, s1
   19cd6: 97 a0 00 00  	auipc	ra, 10
   19cda: e7 80 20 f2  	jalr	-222(ra)
   19cde: 45 44        	li	s0, 17
   19ce0: 26 85        	mv	a0, s1
   19ce2: 97 a0 00 00  	auipc	ra, 10
   19ce6: e7 80 60 f1  	jalr	-234(ra)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   19cea: e3 04 0c f2  	beqz	s8, 0x19c12 <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2c4>
   19cee: 35 b7        	j	0x19c1a <io.reader.Reader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).readUntilDelimiterAlloc+0x2cc>
   19cf0: 37 25 01 00  	lui	a0, 18
   19cf4: 13 05 b5 a7  	addi	a0, a0, -1413
   19cf8: e1 45        	li	a1, 24
   19cfa: 81 46        	li	a3, 0
   19cfc: 97 90 00 00  	auipc	ra, 9
   19d00: e7 80 e0 67  	jalr	1662(ra)
   19d04: 37 25 01 00  	lui	a0, 18
   19d08: 13 05 a5 86  	addi	a0, a0, -1942
   19d0c: f9 45        	li	a1, 30
   19d0e: 81 46        	li	a3, 0
   19d10: 97 90 00 00  	auipc	ra, 9
   19d14: e7 80 a0 66  	jalr	1642(ra)

0000000000019d18 <leb128.readULEB128__anon_5465>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   19d18: 39 71        	addi	sp, sp, -64
   19d1a: 06 fc        	sd	ra, 56(sp)
   19d1c: 22 f8        	sd	s0, 48(sp)
   19d1e: 26 f4        	sd	s1, 40(sp)
   19d20: 4a f0        	sd	s2, 32(sp)
   19d22: 4e ec        	sd	s3, 24(sp)
   19d24: b2 84        	mv	s1, a2
   19d26: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   19d2a: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19d2e: 98 60        	ld	a4, 0(s1)
   19d30: 2e 89        	mv	s2, a1
   19d32: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   19d34: 28 00        	addi	a0, sp, 8
   19d36: 13 06 71 00  	addi	a2, sp, 7
   19d3a: 85 46        	li	a3, 1
   19d3c: ba 85        	mv	a1, a4
   19d3e: 97 80 00 00  	auipc	ra, 8
   19d42: e7 80 a0 97  	jalr	-1670(ra)
   19d46: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19d48: 75 c1        	beqz	a0, 0x19e2c <leb128.readULEB128__anon_5465+0x114>
;             return result[0];
   19d4a: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19d4e: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   19d52: 63 52 05 0c  	bgez	a0, 0x19e16 <leb128.readULEB128__anon_5465+0xfe>
   19d56: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19d5a: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19d5e: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19d60: 28 00        	addi	a0, sp, 8
   19d62: 13 06 71 00  	addi	a2, sp, 7
   19d66: 85 46        	li	a3, 1
   19d68: 97 80 00 00  	auipc	ra, 8
   19d6c: e7 80 00 95  	jalr	-1712(ra)
   19d70: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19d72: 4d cd        	beqz	a0, 0x19e2c <leb128.readULEB128__anon_5465+0x114>
;             return result[0];
   19d74: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19d78: 93 75 f5 07  	andi	a1, a0, 127
   19d7c: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   19d7e: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   19d80: 63 5b 05 08  	bgez	a0, 0x19e16 <leb128.readULEB128__anon_5465+0xfe>
   19d84: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19d88: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19d8c: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19d8e: 28 00        	addi	a0, sp, 8
   19d90: 13 06 71 00  	addi	a2, sp, 7
   19d94: 85 46        	li	a3, 1
   19d96: 97 80 00 00  	auipc	ra, 8
   19d9a: e7 80 20 92  	jalr	-1758(ra)
   19d9e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19da0: 51 c5        	beqz	a0, 0x19e2c <leb128.readULEB128__anon_5465+0x114>
;             return result[0];
   19da2: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19da6: 93 75 f5 07  	andi	a1, a0, 127
   19daa: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   19dac: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   19dae: 63 54 05 06  	bgez	a0, 0x19e16 <leb128.readULEB128__anon_5465+0xfe>
   19db2: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19db6: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19dba: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19dbc: 28 00        	addi	a0, sp, 8
   19dbe: 13 06 71 00  	addi	a2, sp, 7
   19dc2: 85 46        	li	a3, 1
   19dc4: 97 80 00 00  	auipc	ra, 8
   19dc8: e7 80 40 8f  	jalr	-1804(ra)
   19dcc: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19dce: 39 cd        	beqz	a0, 0x19e2c <leb128.readULEB128__anon_5465+0x114>
;             return result[0];
   19dd0: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19dd4: 93 75 f5 07  	andi	a1, a0, 127
   19dd8: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   19dda: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   19ddc: 63 5d 05 02  	bgez	a0, 0x19e16 <leb128.readULEB128__anon_5465+0xfe>
   19de0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19de4: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19de8: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19dea: 28 00        	addi	a0, sp, 8
   19dec: 13 06 71 00  	addi	a2, sp, 7
   19df0: 85 46        	li	a3, 1
   19df2: 97 80 00 00  	auipc	ra, 8
   19df6: e7 80 60 8c  	jalr	-1850(ra)
   19dfa: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19dfc: 05 c9        	beqz	a0, 0x19e2c <leb128.readULEB128__anon_5465+0x114>
;             return result[0];
   19dfe: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19e02: 93 75 05 07  	andi	a1, a0, 112
;         if (ov[1] != 0) return error.Overflow;
   19e06: b1 e1        	bnez	a1, 0x19e4a <leb128.readULEB128__anon_5465+0x132>
   19e08: 62 15        	slli	a0, a0, 56
   19e0a: 61 95        	srai	a0, a0, 56
;         if (byte & 0x80 == 0) break;
   19e0c: 63 4f 05 02  	bltz	a0, 0x19e4a <leb128.readULEB128__anon_5465+0x132>
   19e10: 1b 15 c5 01  	slliw	a0, a0, 28
   19e14: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   19e16: 23 a0 89 00  	sw	s0, 0(s3)
   19e1a: 23 92 09 00  	sh	zero, 4(s3)
   19e1e: e2 70        	ld	ra, 56(sp)
   19e20: 42 74        	ld	s0, 48(sp)
   19e22: a2 74        	ld	s1, 40(sp)
   19e24: 02 79        	ld	s2, 32(sp)
   19e26: e2 69        	ld	s3, 24(sp)
   19e28: 21 61        	addi	sp, sp, 64
   19e2a: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   19e2c: 4a 85        	mv	a0, s2
   19e2e: 97 a0 00 00  	auipc	ra, 10
   19e32: e7 80 a0 dc  	jalr	-566(ra)
;         const byte = try reader.readByte();
   19e36: 4a 85        	mv	a0, s2
   19e38: 97 a0 00 00  	auipc	ra, 10
   19e3c: e7 80 00 dc  	jalr	-576(ra)
   19e40: 13 05 10 03  	li	a0, 49
   19e44: 23 92 a9 00  	sh	a0, 4(s3)
   19e48: d9 bf        	j	0x19e1e <leb128.readULEB128__anon_5465+0x106>
   19e4a: 4a 85        	mv	a0, s2
   19e4c: 97 a0 00 00  	auipc	ra, 10
   19e50: e7 80 c0 da  	jalr	-596(ra)
   19e54: 13 05 00 03  	li	a0, 48
   19e58: 23 a2 a9 00  	sw	a0, 4(s3)
   19e5c: 23 a0 09 00  	sw	zero, 0(s3)
   19e60: 7d bf        	j	0x19e1e <leb128.readULEB128__anon_5465+0x106>

0000000000019e62 <leb128.readULEB128__anon_5470>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   19e62: 39 71        	addi	sp, sp, -64
   19e64: 06 fc        	sd	ra, 56(sp)
   19e66: 22 f8        	sd	s0, 48(sp)
   19e68: 26 f4        	sd	s1, 40(sp)
   19e6a: 4a f0        	sd	s2, 32(sp)
   19e6c: 4e ec        	sd	s3, 24(sp)
   19e6e: b2 84        	mv	s1, a2
   19e70: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   19e74: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19e78: 98 60        	ld	a4, 0(s1)
   19e7a: 2e 89        	mv	s2, a1
   19e7c: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   19e7e: 28 00        	addi	a0, sp, 8
   19e80: 13 06 71 00  	addi	a2, sp, 7
   19e84: 85 46        	li	a3, 1
   19e86: ba 85        	mv	a1, a4
   19e88: 97 80 00 00  	auipc	ra, 8
   19e8c: e7 80 00 83  	jalr	-2000(ra)
   19e90: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19e92: 21 cd        	beqz	a0, 0x19eea <leb128.readULEB128__anon_5470+0x88>
;             return result[0];
   19e94: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19e98: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   19e9c: 63 5c 05 02  	bgez	a0, 0x19ed4 <leb128.readULEB128__anon_5470+0x72>
   19ea0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19ea4: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19ea8: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19eaa: 28 00        	addi	a0, sp, 8
   19eac: 13 06 71 00  	addi	a2, sp, 7
   19eb0: 85 46        	li	a3, 1
   19eb2: 97 80 00 00  	auipc	ra, 8
   19eb6: e7 80 60 80  	jalr	-2042(ra)
   19eba: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19ebc: 1d c5        	beqz	a0, 0x19eea <leb128.readULEB128__anon_5470+0x88>
;             return result[0];
   19ebe: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19ec2: 93 75 e5 07  	andi	a1, a0, 126
;         if (ov[1] != 0) return error.Overflow;
   19ec6: 9d ed        	bnez	a1, 0x19f04 <leb128.readULEB128__anon_5470+0xa2>
   19ec8: 62 15        	slli	a0, a0, 56
   19eca: 61 95        	srai	a0, a0, 56
;         if (byte & 0x80 == 0) break;
   19ecc: 63 4c 05 02  	bltz	a0, 0x19f04 <leb128.readULEB128__anon_5470+0xa2>
   19ed0: 1e 05        	slli	a0, a0, 7
   19ed2: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   19ed4: 23 90 09 00  	sh	zero, 0(s3)
   19ed8: 23 81 89 00  	sb	s0, 2(s3)
   19edc: e2 70        	ld	ra, 56(sp)
   19ede: 42 74        	ld	s0, 48(sp)
   19ee0: a2 74        	ld	s1, 40(sp)
   19ee2: 02 79        	ld	s2, 32(sp)
   19ee4: e2 69        	ld	s3, 24(sp)
   19ee6: 21 61        	addi	sp, sp, 64
   19ee8: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   19eea: 4a 85        	mv	a0, s2
   19eec: 97 a0 00 00  	auipc	ra, 10
   19ef0: e7 80 c0 d0  	jalr	-756(ra)
;         const byte = try reader.readByte();
   19ef4: 4a 85        	mv	a0, s2
   19ef6: 97 a0 00 00  	auipc	ra, 10
   19efa: e7 80 20 d0  	jalr	-766(ra)
   19efe: 13 05 10 03  	li	a0, 49
   19f02: 11 a8        	j	0x19f16 <leb128.readULEB128__anon_5470+0xb4>
   19f04: 4a 85        	mv	a0, s2
   19f06: 97 a0 00 00  	auipc	ra, 10
   19f0a: e7 80 20 cf  	jalr	-782(ra)
   19f0e: 23 91 09 00  	sh	zero, 2(s3)
   19f12: 13 05 00 03  	li	a0, 48
   19f16: 23 90 a9 00  	sh	a0, 0(s3)
   19f1a: c9 b7        	j	0x19edc <leb128.readULEB128__anon_5470+0x7a>

0000000000019f1c <leb128.readULEB128__anon_5474>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   19f1c: 39 71        	addi	sp, sp, -64
   19f1e: 06 fc        	sd	ra, 56(sp)
   19f20: 22 f8        	sd	s0, 48(sp)
   19f22: 26 f4        	sd	s1, 40(sp)
   19f24: 4a f0        	sd	s2, 32(sp)
   19f26: 4e ec        	sd	s3, 24(sp)
   19f28: b2 84        	mv	s1, a2
   19f2a: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   19f2e: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19f32: 98 60        	ld	a4, 0(s1)
   19f34: 2e 89        	mv	s2, a1
   19f36: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   19f38: 28 00        	addi	a0, sp, 8
   19f3a: 13 06 71 00  	addi	a2, sp, 7
   19f3e: 85 46        	li	a3, 1
   19f40: ba 85        	mv	a1, a4
   19f42: 97 70 00 00  	auipc	ra, 7
   19f46: e7 80 60 77  	jalr	1910(ra)
   19f4a: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19f4c: 59 c1        	beqz	a0, 0x19fd2 <leb128.readULEB128__anon_5474+0xb6>
;             return result[0];
   19f4e: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19f52: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   19f56: 63 53 05 06  	bgez	a0, 0x19fbc <leb128.readULEB128__anon_5474+0xa0>
   19f5a: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19f5e: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19f62: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19f64: 28 00        	addi	a0, sp, 8
   19f66: 13 06 71 00  	addi	a2, sp, 7
   19f6a: 85 46        	li	a3, 1
   19f6c: 97 70 00 00  	auipc	ra, 7
   19f70: e7 80 c0 74  	jalr	1868(ra)
   19f74: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19f76: 31 cd        	beqz	a0, 0x19fd2 <leb128.readULEB128__anon_5474+0xb6>
;             return result[0];
   19f78: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19f7c: 93 75 f5 07  	andi	a1, a0, 127
   19f80: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   19f82: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   19f84: 63 5c 05 02  	bgez	a0, 0x19fbc <leb128.readULEB128__anon_5474+0xa0>
   19f88: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   19f8c: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   19f90: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   19f92: 28 00        	addi	a0, sp, 8
   19f94: 13 06 71 00  	addi	a2, sp, 7
   19f98: 85 46        	li	a3, 1
   19f9a: 97 70 00 00  	auipc	ra, 7
   19f9e: e7 80 e0 71  	jalr	1822(ra)
   19fa2: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   19fa4: 1d c5        	beqz	a0, 0x19fd2 <leb128.readULEB128__anon_5474+0xb6>
;             return result[0];
   19fa6: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   19faa: 93 75 c5 07  	andi	a1, a0, 124
;         if (ov[1] != 0) return error.Overflow;
   19fae: a9 e1        	bnez	a1, 0x19ff0 <leb128.readULEB128__anon_5474+0xd4>
   19fb0: 62 15        	slli	a0, a0, 56
   19fb2: 61 95        	srai	a0, a0, 56
;         if (byte & 0x80 == 0) break;
   19fb4: 63 4e 05 02  	bltz	a0, 0x19ff0 <leb128.readULEB128__anon_5474+0xd4>
   19fb8: 3a 05        	slli	a0, a0, 14
   19fba: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   19fbc: 23 90 89 00  	sh	s0, 0(s3)
   19fc0: 23 91 09 00  	sh	zero, 2(s3)
   19fc4: e2 70        	ld	ra, 56(sp)
   19fc6: 42 74        	ld	s0, 48(sp)
   19fc8: a2 74        	ld	s1, 40(sp)
   19fca: 02 79        	ld	s2, 32(sp)
   19fcc: e2 69        	ld	s3, 24(sp)
   19fce: 21 61        	addi	sp, sp, 64
   19fd0: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   19fd2: 4a 85        	mv	a0, s2
   19fd4: 97 a0 00 00  	auipc	ra, 10
   19fd8: e7 80 40 c2  	jalr	-988(ra)
;         const byte = try reader.readByte();
   19fdc: 4a 85        	mv	a0, s2
   19fde: 97 a0 00 00  	auipc	ra, 10
   19fe2: e7 80 a0 c1  	jalr	-998(ra)
   19fe6: 13 05 10 03  	li	a0, 49
   19fea: 23 91 a9 00  	sh	a0, 2(s3)
   19fee: d9 bf        	j	0x19fc4 <leb128.readULEB128__anon_5474+0xa8>
   19ff0: 4a 85        	mv	a0, s2
   19ff2: 97 a0 00 00  	auipc	ra, 10
   19ff6: e7 80 60 c0  	jalr	-1018(ra)
   19ffa: 13 05 00 03  	li	a0, 48
   19ffe: 23 91 a9 00  	sh	a0, 2(s3)
   1a002: 23 90 09 00  	sh	zero, 0(s3)
   1a006: 7d bf        	j	0x19fc4 <leb128.readULEB128__anon_5474+0xa8>

000000000001a008 <leb128.readULEB128__anon_5478>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   1a008: 39 71        	addi	sp, sp, -64
   1a00a: 06 fc        	sd	ra, 56(sp)
   1a00c: 22 f8        	sd	s0, 48(sp)
   1a00e: 26 f4        	sd	s1, 40(sp)
   1a010: 4a f0        	sd	s2, 32(sp)
   1a012: 4e ec        	sd	s3, 24(sp)
   1a014: b2 84        	mv	s1, a2
   1a016: 13 06 a0 0a  	li	a2, 170
;             var result: [1]u8 = undefined;
   1a01a: a3 03 c1 00  	sb	a2, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a01e: 98 60        	ld	a4, 0(s1)
   1a020: 2e 89        	mv	s2, a1
   1a022: aa 89        	mv	s3, a0
;             return readFn(self.context, buffer);
   1a024: 28 00        	addi	a0, sp, 8
   1a026: 13 06 71 00  	addi	a2, sp, 7
   1a02a: 85 46        	li	a3, 1
   1a02c: ba 85        	mv	a1, a4
   1a02e: 97 70 00 00  	auipc	ra, 7
   1a032: e7 80 a0 68  	jalr	1674(ra)
   1a036: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a038: 63 0a 05 1c  	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a03c: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a040: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   1a044: 63 59 05 1a  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a048: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a04c: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a050: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a052: 28 00        	addi	a0, sp, 8
   1a054: 13 06 71 00  	addi	a2, sp, 7
   1a058: 85 46        	li	a3, 1
   1a05a: 97 70 00 00  	auipc	ra, 7
   1a05e: e7 80 e0 65  	jalr	1630(ra)
   1a062: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a064: 63 04 05 1a  	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a068: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a06c: 93 75 f5 07  	andi	a1, a0, 127
   1a070: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   1a072: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a074: 63 51 05 18  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a078: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a07c: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a080: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a082: 28 00        	addi	a0, sp, 8
   1a084: 13 06 71 00  	addi	a2, sp, 7
   1a088: 85 46        	li	a3, 1
   1a08a: 97 70 00 00  	auipc	ra, 7
   1a08e: e7 80 e0 62  	jalr	1582(ra)
   1a092: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a094: 63 0c 05 16  	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a098: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a09c: 93 75 f5 07  	andi	a1, a0, 127
   1a0a0: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   1a0a2: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a0a4: 63 59 05 14  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a0a8: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a0ac: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a0b0: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a0b2: 28 00        	addi	a0, sp, 8
   1a0b4: 13 06 71 00  	addi	a2, sp, 7
   1a0b8: 85 46        	li	a3, 1
   1a0ba: 97 70 00 00  	auipc	ra, 7
   1a0be: e7 80 e0 5f  	jalr	1534(ra)
   1a0c2: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a0c4: 63 04 05 14  	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a0c8: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a0cc: 93 75 f5 07  	andi	a1, a0, 127
   1a0d0: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   1a0d2: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a0d4: 63 51 05 12  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a0d8: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a0dc: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a0e0: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a0e2: 28 00        	addi	a0, sp, 8
   1a0e4: 13 06 71 00  	addi	a2, sp, 7
   1a0e8: 85 46        	li	a3, 1
   1a0ea: 97 70 00 00  	auipc	ra, 7
   1a0ee: e7 80 e0 5c  	jalr	1486(ra)
   1a0f2: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a0f4: 63 0c 05 10  	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a0f8: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a0fc: 93 75 f5 07  	andi	a1, a0, 127
   1a100: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   1a102: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a104: 63 59 05 0e  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a108: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a10c: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a110: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a112: 28 00        	addi	a0, sp, 8
   1a114: 13 06 71 00  	addi	a2, sp, 7
   1a118: 85 46        	li	a3, 1
   1a11a: 97 70 00 00  	auipc	ra, 7
   1a11e: e7 80 e0 59  	jalr	1438(ra)
   1a122: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a124: 65 c5        	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a126: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a12a: 93 75 f5 07  	andi	a1, a0, 127
   1a12e: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   1a130: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a132: 63 52 05 0c  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a136: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a13a: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a13e: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a140: 28 00        	addi	a0, sp, 8
   1a142: 13 06 71 00  	addi	a2, sp, 7
   1a146: 85 46        	li	a3, 1
   1a148: 97 70 00 00  	auipc	ra, 7
   1a14c: e7 80 00 57  	jalr	1392(ra)
   1a150: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a152: 4d cd        	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a154: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a158: 93 75 f5 07  	andi	a1, a0, 127
   1a15c: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   1a15e: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a160: 63 5b 05 08  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a164: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a168: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a16c: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a16e: 28 00        	addi	a0, sp, 8
   1a170: 13 06 71 00  	addi	a2, sp, 7
   1a174: 85 46        	li	a3, 1
   1a176: 97 70 00 00  	auipc	ra, 7
   1a17a: e7 80 20 54  	jalr	1346(ra)
   1a17e: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a180: 51 c5        	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a182: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a186: 93 75 f5 07  	andi	a1, a0, 127
   1a18a: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   1a18c: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a18e: 63 54 05 06  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a192: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a196: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a19a: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a19c: 28 00        	addi	a0, sp, 8
   1a19e: 13 06 71 00  	addi	a2, sp, 7
   1a1a2: 85 46        	li	a3, 1
   1a1a4: 97 70 00 00  	auipc	ra, 7
   1a1a8: e7 80 40 51  	jalr	1300(ra)
   1a1ac: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a1ae: 39 cd        	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a1b0: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a1b4: 93 75 f5 07  	andi	a1, a0, 127
   1a1b8: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   1a1ba: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   1a1bc: 63 5d 05 02  	bgez	a0, 0x1a1f6 <leb128.readULEB128__anon_5478+0x1ee>
   1a1c0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1a1c4: a3 03 a1 00  	sb	a0, 7(sp)
;             const amt_read = try self.read(result[0..]);
   1a1c8: 8c 60        	ld	a1, 0(s1)
;             return readFn(self.context, buffer);
   1a1ca: 28 00        	addi	a0, sp, 8
   1a1cc: 13 06 71 00  	addi	a2, sp, 7
   1a1d0: 85 46        	li	a3, 1
   1a1d2: 97 70 00 00  	auipc	ra, 7
   1a1d6: e7 80 60 4e  	jalr	1254(ra)
   1a1da: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1a1dc: 05 c9        	beqz	a0, 0x1a20c <leb128.readULEB128__anon_5478+0x204>
;             return result[0];
   1a1de: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   1a1e2: 93 75 e5 07  	andi	a1, a0, 126
;         if (ov[1] != 0) return error.Overflow;
   1a1e6: b1 e1        	bnez	a1, 0x1a22a <leb128.readULEB128__anon_5478+0x222>
   1a1e8: 93 15 85 03  	slli	a1, a0, 56
   1a1ec: e1 95        	srai	a1, a1, 56
;         if (byte & 0x80 == 0) break;
   1a1ee: 63 ce 05 02  	bltz	a1, 0x1a22a <leb128.readULEB128__anon_5478+0x222>
   1a1f2: 7e 15        	slli	a0, a0, 63
   1a1f4: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   1a1f6: 23 b0 89 00  	sd	s0, 0(s3)
   1a1fa: 23 94 09 00  	sh	zero, 8(s3)
   1a1fe: e2 70        	ld	ra, 56(sp)
   1a200: 42 74        	ld	s0, 48(sp)
   1a202: a2 74        	ld	s1, 40(sp)
   1a204: 02 79        	ld	s2, 32(sp)
   1a206: e2 69        	ld	s3, 24(sp)
   1a208: 21 61        	addi	sp, sp, 64
   1a20a: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   1a20c: 4a 85        	mv	a0, s2
   1a20e: 97 a0 00 00  	auipc	ra, 10
   1a212: e7 80 a0 9e  	jalr	-1558(ra)
;         const byte = try reader.readByte();
   1a216: 4a 85        	mv	a0, s2
   1a218: 97 a0 00 00  	auipc	ra, 10
   1a21c: e7 80 00 9e  	jalr	-1568(ra)
   1a220: 13 05 10 03  	li	a0, 49
   1a224: 23 94 a9 00  	sh	a0, 8(s3)
   1a228: d9 bf        	j	0x1a1fe <leb128.readULEB128__anon_5478+0x1f6>
   1a22a: 4a 85        	mv	a0, s2
   1a22c: 97 a0 00 00  	auipc	ra, 10
   1a230: e7 80 c0 9c  	jalr	-1588(ra)
   1a234: 13 05 00 03  	li	a0, 48
   1a238: 23 b4 a9 00  	sd	a0, 8(s3)
   1a23c: 23 b0 09 00  	sd	zero, 0(s3)
   1a240: 7d bf        	j	0x1a1fe <leb128.readULEB128__anon_5478+0x1f6>

000000000001a242 <dwarf.FormValue.getString>:
;     fn getString(fv: FormValue, di: DwarfInfo) ![]const u8 {
   1a242: 59 71        	addi	sp, sp, -112
;         switch (fv) {
   1a244: 86 f4        	sd	ra, 104(sp)
   1a246: a2 f0        	sd	s0, 96(sp)
   1a248: a6 ec        	sd	s1, 88(sp)
   1a24a: ca e8        	sd	s2, 80(sp)
   1a24c: 03 47 06 01  	lbu	a4, 16(a2)
   1a250: a5 47        	li	a5, 9
   1a252: 2a 84        	mv	s0, a0
   1a254: 63 00 f7 06  	beq	a4, a5, 0x1a2b4 <dwarf.FormValue.getString+0x72>
   1a258: 2e 89        	mv	s2, a1
   1a25a: 29 45        	li	a0, 10
;         switch (fv) {
   1a25c: 63 03 a7 06  	beq	a4, a0, 0x1a2c2 <dwarf.FormValue.getString+0x80>
   1a260: 31 45        	li	a0, 12
;         switch (fv) {
   1a262: 63 14 a7 0c  	bne	a4, a0, 0x1a32a <dwarf.FormValue.getString+0xe8>
;             .StrPtr => |off| return di.getString(off),
   1a266: 18 62        	ld	a4, 0(a2)
;             .LineStrPtr => |off| return di.getLineString(off),
   1a268: b0 6a        	ld	a2, 80(a3)
   1a26a: b4 6e        	ld	a3, 88(a3)
;         return getStringGeneric(di.debug_line_str, offset);
   1a26c: 28 18        	addi	a0, sp, 56
   1a26e: ca 85        	mv	a1, s2
   1a270: 97 00 00 00  	auipc	ra, 0
   1a274: e7 80 00 13  	jalr	304(ra)
   1a278: 06 65        	ld	a0, 64(sp)
   1a27a: e2 75        	ld	a1, 56(sp)
   1a27c: 2a f8        	sd	a0, 48(sp)
   1a27e: 2e f4        	sd	a1, 40(sp)
   1a280: 03 15 e1 04  	lh	a0, 78(sp)
   1a284: 83 15 c1 04  	lh	a1, 76(sp)
   1a288: 03 56 a1 04  	lhu	a2, 74(sp)
   1a28c: 83 54 81 04  	lhu	s1, 72(sp)
   1a290: 23 12 a1 02  	sh	a0, 36(sp)
   1a294: 13 95 05 01  	slli	a0, a1, 16
   1a298: 51 8d        	or	a0, a0, a2
   1a29a: 2a d0        	sw	a0, 32(sp)
   1a29c: cd e0        	bnez	s1, 0x1a33e <dwarf.FormValue.getString+0xfc>
;             .LineStrPtr => |off| return di.getLineString(off),
   1a29e: 42 75        	ld	a0, 48(sp)
   1a2a0: a2 75        	ld	a1, 40(sp)
   1a2a2: 08 e4        	sd	a0, 8(s0)
   1a2a4: 03 15 01 02  	lh	a0, 32(sp)
   1a2a8: 03 16 21 02  	lh	a2, 34(sp)
   1a2ac: 0c e0        	sd	a1, 0(s0)
   1a2ae: 83 15 41 02  	lh	a1, 36(sp)
   1a2b2: b1 a8        	j	0x1a30e <dwarf.FormValue.getString+0xcc>
;         switch (fv) {
   1a2b4: 08 62        	ld	a0, 0(a2)
   1a2b6: 0c 66        	ld	a1, 8(a2)
;             .String => |s| return s,
   1a2b8: 08 e0        	sd	a0, 0(s0)
   1a2ba: 0c e4        	sd	a1, 8(s0)
   1a2bc: 23 18 04 00  	sh	zero, 16(s0)
   1a2c0: b9 a8        	j	0x1a31e <dwarf.FormValue.getString+0xdc>
   1a2c2: 18 62        	ld	a4, 0(a2)
;             .StrPtr => |off| return di.getString(off),
   1a2c4: 90 72        	ld	a2, 32(a3)
   1a2c6: 94 76        	ld	a3, 40(a3)
;         return getStringGeneric(di.debug_str, offset);
   1a2c8: 28 18        	addi	a0, sp, 56
   1a2ca: ca 85        	mv	a1, s2
   1a2cc: 97 00 00 00  	auipc	ra, 0
   1a2d0: e7 80 40 0d  	jalr	212(ra)
   1a2d4: 06 65        	ld	a0, 64(sp)
   1a2d6: e2 75        	ld	a1, 56(sp)
   1a2d8: 2a ec        	sd	a0, 24(sp)
   1a2da: 2e e8        	sd	a1, 16(sp)
   1a2dc: 03 15 e1 04  	lh	a0, 78(sp)
   1a2e0: 83 15 c1 04  	lh	a1, 76(sp)
   1a2e4: 03 56 a1 04  	lhu	a2, 74(sp)
   1a2e8: 83 54 81 04  	lhu	s1, 72(sp)
   1a2ec: 23 16 a1 00  	sh	a0, 12(sp)
   1a2f0: 13 95 05 01  	slli	a0, a1, 16
   1a2f4: 51 8d        	or	a0, a0, a2
   1a2f6: 2a c4        	sw	a0, 8(sp)
   1a2f8: bd e0        	bnez	s1, 0x1a35e <dwarf.FormValue.getString+0x11c>
;             .StrPtr => |off| return di.getString(off),
   1a2fa: 62 65        	ld	a0, 24(sp)
   1a2fc: c2 65        	ld	a1, 16(sp)
   1a2fe: 08 e4        	sd	a0, 8(s0)
   1a300: 03 15 81 00  	lh	a0, 8(sp)
   1a304: 03 16 a1 00  	lh	a2, 10(sp)
   1a308: 0c e0        	sd	a1, 0(s0)
   1a30a: 83 15 c1 00  	lh	a1, 12(sp)
   1a30e: 23 19 a4 00  	sh	a0, 18(s0)
   1a312: 23 1a c4 00  	sh	a2, 20(s0)
   1a316: 23 18 04 00  	sh	zero, 16(s0)
   1a31a: 23 1b b4 00  	sh	a1, 22(s0)
   1a31e: a6 70        	ld	ra, 104(sp)
   1a320: 06 74        	ld	s0, 96(sp)
   1a322: e6 64        	ld	s1, 88(sp)
   1a324: 46 69        	ld	s2, 80(sp)
   1a326: 65 61        	addi	sp, sp, 112
   1a328: 82 80        	ret
;     return error.InvalidDebugInfo;
   1a32a: 4a 85        	mv	a0, s2
   1a32c: 97 a0 00 00  	auipc	ra, 10
   1a330: e7 80 c0 8c  	jalr	-1844(ra)
   1a334: 13 05 20 03  	li	a0, 50
;             else => return badDwarf(),
   1a338: 23 18 a4 00  	sh	a0, 16(s0)
   1a33c: 81 a8        	j	0x1a38c <dwarf.FormValue.getString+0x14a>
;         return getStringGeneric(di.debug_line_str, offset);
   1a33e: 4a 85        	mv	a0, s2
   1a340: 97 a0 00 00  	auipc	ra, 10
   1a344: e7 80 80 8b  	jalr	-1864(ra)
;             .LineStrPtr => |off| return di.getLineString(off),
   1a348: 42 75        	ld	a0, 48(sp)
   1a34a: a2 75        	ld	a1, 40(sp)
   1a34c: 08 e4        	sd	a0, 8(s0)
   1a34e: 0c e0        	sd	a1, 0(s0)
   1a350: 03 15 01 02  	lh	a0, 32(sp)
   1a354: 83 15 21 02  	lh	a1, 34(sp)
   1a358: 03 16 41 02  	lh	a2, 36(sp)
   1a35c: 05 a0        	j	0x1a37c <dwarf.FormValue.getString+0x13a>
;         return getStringGeneric(di.debug_str, offset);
   1a35e: 4a 85        	mv	a0, s2
   1a360: 97 a0 00 00  	auipc	ra, 10
   1a364: e7 80 80 89  	jalr	-1896(ra)
;             .StrPtr => |off| return di.getString(off),
   1a368: 62 65        	ld	a0, 24(sp)
   1a36a: c2 65        	ld	a1, 16(sp)
   1a36c: 08 e4        	sd	a0, 8(s0)
   1a36e: 0c e0        	sd	a1, 0(s0)
   1a370: 03 15 81 00  	lh	a0, 8(sp)
   1a374: 83 15 a1 00  	lh	a1, 10(sp)
   1a378: 03 16 c1 00  	lh	a2, 12(sp)
   1a37c: 23 18 94 00  	sh	s1, 16(s0)
   1a380: 23 19 a4 00  	sh	a0, 18(s0)
   1a384: 23 1a b4 00  	sh	a1, 20(s0)
   1a388: 23 1b c4 00  	sh	a2, 22(s0)
   1a38c: 4a 85        	mv	a0, s2
   1a38e: a6 70        	ld	ra, 104(sp)
   1a390: 06 74        	ld	s0, 96(sp)
   1a392: e6 64        	ld	s1, 88(sp)
   1a394: 46 69        	ld	s2, 80(sp)
   1a396: 65 61        	addi	sp, sp, 112
   1a398: 17 a3 00 00  	auipc	t1, 10
   1a39c: 67 00 03 86  	jr	-1952(t1)

000000000001a3a0 <dwarf.getStringGeneric>:
; fn getStringGeneric(opt_str: ?[]const u8, offset: u64) ![:0]const u8 {
   1a3a0: 01 11        	addi	sp, sp, -32
   1a3a2: 06 ec        	sd	ra, 24(sp)
   1a3a4: 22 e8        	sd	s0, 16(sp)
   1a3a6: 26 e4        	sd	s1, 8(sp)
   1a3a8: ae 84        	mv	s1, a1
   1a3aa: 2a 84        	mv	s0, a0
;     const str = opt_str orelse return badDwarf();
   1a3ac: 1d c2        	beqz	a2, 0x1a3d2 <dwarf.getStringGeneric+0x32>
;     if (offset > str.len) return badDwarf();
   1a3ae: 63 e2 e6 02  	bltu	a3, a4, 0x1a3d2 <dwarf.getStringGeneric+0x32>
;     while (i < slice.len) : (i += 1) {
   1a3b2: 63 70 d7 02  	bgeu	a4, a3, 0x1a3d2 <dwarf.getStringGeneric+0x32>
   1a3b6: 01 45        	li	a0, 0
;         if (slice[i] == value) return i;
   1a3b8: b3 05 e6 00  	add	a1, a2, a4
;     while (i < slice.len) : (i += 1) {
   1a3bc: 33 06 d7 40  	sub	a2, a4, a3
;         if (slice[i] == value) return i;
   1a3c0: b3 87 a5 00  	add	a5, a1, a0
   1a3c4: 83 c7 07 00  	lbu	a5, 0(a5)
   1a3c8: 9d c7        	beqz	a5, 0x1a3f6 <dwarf.getStringGeneric+0x56>
;     while (i < slice.len) : (i += 1) {
   1a3ca: 05 05        	addi	a0, a0, 1
   1a3cc: b3 07 a6 00  	add	a5, a2, a0
   1a3d0: e5 fb        	bnez	a5, 0x1a3c0 <dwarf.getStringGeneric+0x20>
   1a3d2: 26 85        	mv	a0, s1
   1a3d4: 97 a0 00 00  	auipc	ra, 10
   1a3d8: e7 80 40 82  	jalr	-2012(ra)
   1a3dc: 13 05 20 03  	li	a0, 50
   1a3e0: 23 18 a4 00  	sh	a0, 16(s0)
   1a3e4: 26 85        	mv	a0, s1
   1a3e6: e2 60        	ld	ra, 24(sp)
   1a3e8: 42 64        	ld	s0, 16(sp)
   1a3ea: a2 64        	ld	s1, 8(sp)
   1a3ec: 05 61        	addi	sp, sp, 32
   1a3ee: 17 a3 00 00  	auipc	t1, 10
   1a3f2: 67 00 a3 80  	jr	-2038(t1)
;     return str[casted_offset..last :0];
   1a3f6: 33 06 a7 00  	add	a2, a4, a0
   1a3fa: 63 6d e6 00  	bltu	a2, a4, 0x1a414 <dwarf.getStringGeneric+0x74>
   1a3fe: 63 76 d6 02  	bgeu	a2, a3, 0x1a42a <dwarf.getStringGeneric+0x8a>
   1a402: 0c e0        	sd	a1, 0(s0)
   1a404: 08 e4        	sd	a0, 8(s0)
   1a406: 23 18 04 00  	sh	zero, 16(s0)
   1a40a: e2 60        	ld	ra, 24(sp)
   1a40c: 42 64        	ld	s0, 16(sp)
   1a40e: a2 64        	ld	s1, 8(sp)
   1a410: 05 61        	addi	sp, sp, 32
   1a412: 82 80        	ret
;     return str[casted_offset..last :0];
   1a414: 37 15 01 00  	lui	a0, 17
   1a418: 13 05 45 5b  	addi	a0, a0, 1460
   1a41c: 93 05 40 02  	li	a1, 36
   1a420: 81 46        	li	a3, 0
   1a422: 97 90 00 00  	auipc	ra, 9
   1a426: e7 80 80 f5  	jalr	-168(ra)
   1a42a: 37 15 01 00  	lui	a0, 17
   1a42e: 13 05 35 6e  	addi	a0, a0, 1763
   1a432: cd 45        	li	a1, 19
   1a434: 81 46        	li	a3, 0
   1a436: 97 90 00 00  	auipc	ra, 9
   1a43a: e7 80 40 f4  	jalr	-188(ra)

000000000001a43e <dwarf.FormValue.getUInt__anon_5490>:
;     fn getUInt(fv: FormValue, comptime U: type) !U {
   1a43e: 01 11        	addi	sp, sp, -32
;         switch (fv) {
   1a440: 06 ec        	sd	ra, 24(sp)
   1a442: 22 e8        	sd	s0, 16(sp)
   1a444: 26 e4        	sd	s1, 8(sp)
   1a446: 83 46 06 01  	lbu	a3, 16(a2)
   1a44a: 19 47        	li	a4, 6
   1a44c: ae 84        	mv	s1, a1
   1a44e: 2a 84        	mv	s0, a0
   1a450: 63 88 e6 00  	beq	a3, a4, 0x1a460 <dwarf.FormValue.getUInt__anon_5490+0x22>
   1a454: 0d 45        	li	a0, 3
;         switch (fv) {
   1a456: 63 91 a6 02  	bne	a3, a0, 0x1a478 <dwarf.FormValue.getUInt__anon_5490+0x3a>
   1a45a: 03 45 86 00  	lbu	a0, 8(a2)
;         if (self.signed) return badDwarf();
   1a45e: 1d ed        	bnez	a0, 0x1a49c <dwarf.FormValue.getUInt__anon_5490+0x5e>
   1a460: 08 62        	ld	a0, 0(a2)
   1a462: 93 55 05 02  	srli	a1, a0, 32
   1a466: 89 e9        	bnez	a1, 0x1a478 <dwarf.FormValue.getUInt__anon_5490+0x3a>
   1a468: 08 c0        	sw	a0, 0(s0)
   1a46a: 23 12 04 00  	sh	zero, 4(s0)
   1a46e: e2 60        	ld	ra, 24(sp)
   1a470: 42 64        	ld	s0, 16(sp)
   1a472: a2 64        	ld	s1, 8(sp)
   1a474: 05 61        	addi	sp, sp, 32
   1a476: 82 80        	ret
   1a478: 26 85        	mv	a0, s1
   1a47a: 97 90 00 00  	auipc	ra, 9
   1a47e: e7 80 e0 77  	jalr	1918(ra)
   1a482: 13 05 20 03  	li	a0, 50
   1a486: 23 12 a4 00  	sh	a0, 4(s0)
   1a48a: 26 85        	mv	a0, s1
   1a48c: e2 60        	ld	ra, 24(sp)
   1a48e: 42 64        	ld	s0, 16(sp)
   1a490: a2 64        	ld	s1, 8(sp)
   1a492: 05 61        	addi	sp, sp, 32
   1a494: 17 93 00 00  	auipc	t1, 9
   1a498: 67 00 43 76  	jr	1892(t1)
;     return error.InvalidDebugInfo;
   1a49c: 26 85        	mv	a0, s1
   1a49e: 97 90 00 00  	auipc	ra, 9
   1a4a2: e7 80 a0 75  	jalr	1882(ra)
;         if (self.signed) return badDwarf();
   1a4a6: 26 85        	mv	a0, s1
   1a4a8: 97 90 00 00  	auipc	ra, 9
   1a4ac: e7 80 00 75  	jalr	1872(ra)
;                 const int = try c.asUnsignedLe();
   1a4b0: 26 85        	mv	a0, s1
   1a4b2: 97 90 00 00  	auipc	ra, 9
   1a4b6: e7 80 60 74  	jalr	1862(ra)
   1a4ba: 13 05 20 03  	li	a0, 50
   1a4be: 23 12 a4 00  	sh	a0, 4(s0)
   1a4c2: 75 b7        	j	0x1a46e <dwarf.FormValue.getUInt__anon_5490+0x30>

000000000001a4c4 <dwarf.LineNumberProgram.checkLineMatch>:
;     ) !?debug.LineInfo {
   1a4c4: 19 71        	addi	sp, sp, -128
   1a4c6: 86 fc        	sd	ra, 120(sp)
   1a4c8: a2 f8        	sd	s0, 112(sp)
   1a4ca: a6 f4        	sd	s1, 104(sp)
   1a4cc: ca f0        	sd	s2, 96(sp)
   1a4ce: ce ec        	sd	s3, 88(sp)
   1a4d0: d2 e8        	sd	s4, 80(sp)
   1a4d2: d6 e4        	sd	s5, 72(sp)
   1a4d4: da e0        	sd	s6, 64(sp)
   1a4d6: 5e fc        	sd	s7, 56(sp)
   1a4d8: 62 f8        	sd	s8, 48(sp)
   1a4da: 66 f4        	sd	s9, 40(sp)
   1a4dc: b2 84        	mv	s1, a2
;         if (self.prev_valid and
   1a4de: 03 46 e6 05  	lbu	a2, 94(a2)
   1a4e2: aa 8c        	mv	s9, a0
   1a4e4: 55 ca        	beqz	a2, 0x1a598 <dwarf.LineNumberProgram.checkLineMatch+0xd4>
   1a4e6: ae 89        	mv	s3, a1
;             self.target_address >= self.prev_address and
   1a4e8: 88 70        	ld	a0, 32(s1)
   1a4ea: 8c 7c        	ld	a1, 56(s1)
   1a4ec: 63 66 b5 0a  	bltu	a0, a1, 0x1a598 <dwarf.LineNumberProgram.checkLineMatch+0xd4>
;             self.target_address < self.address)
   1a4f0: 8c 60        	ld	a1, 0(s1)
   1a4f2: 63 73 b5 0a  	bgeu	a0, a1, 0x1a598 <dwarf.LineNumberProgram.checkLineMatch+0xd4>
;             const file_index = if (self.version >= 5) self.prev_file else i: {
   1a4f6: 83 d5 84 05  	lhu	a1, 88(s1)
   1a4fa: a8 60        	ld	a0, 64(s1)
   1a4fc: 11 46        	li	a2, 4
;             const file_index = if (self.version >= 5) self.prev_file else i: {
   1a4fe: 63 65 b6 00  	bltu	a2, a1, 0x1a508 <dwarf.LineNumberProgram.checkLineMatch+0x44>
;                 if (self.prev_file == 0) return missingDwarf();
   1a502: 63 04 05 26  	beqz	a0, 0x1a76a <dwarf.LineNumberProgram.checkLineMatch+0x2a6>
;                 break :i self.prev_file - 1;
   1a506: 7d 15        	addi	a0, a0, -1
;             if (file_index >= file_entries.len) return badDwarf();
   1a508: 63 7c f5 20  	bgeu	a0, a5, 0x1a720 <dwarf.LineNumberProgram.checkLineMatch+0x25c>
   1a50c: 13 06 80 03  	li	a2, 56
;             if (file_entry.dir_index >= self.include_dirs.len) return badDwarf();
   1a510: 33 05 c5 02  	mul	a0, a0, a2
   1a514: b3 05 a7 00  	add	a1, a4, a0
   1a518: 03 e5 05 02  	lwu	a0, 32(a1)
   1a51c: 98 78        	ld	a4, 48(s1)
   1a51e: 63 71 e5 20  	bgeu	a0, a4, 0x1a720 <dwarf.LineNumberProgram.checkLineMatch+0x25c>
   1a522: 98 74        	ld	a4, 40(s1)
;             const dir_name = self.include_dirs[file_entry.dir_index].path;
   1a524: 33 05 c5 02  	mul	a0, a0, a2
   1a528: 33 06 a7 00  	add	a2, a4, a0
   1a52c: 08 62        	ld	a0, 0(a2)
   1a52e: 83 3a 86 00  	ld	s5, 8(a2)
;                 dir_name, file_entry.path,
   1a532: 03 bc 05 00  	ld	s8, 0(a1)
   1a536: 03 b9 85 00  	ld	s2, 8(a1)
   1a53a: 2a e4        	sd	a0, 8(sp)
   1a53c: 56 e8        	sd	s5, 16(sp)
   1a53e: 62 ec        	sd	s8, 24(sp)
   1a540: 4a f0        	sd	s2, 32(sp)
;             if (path.len == 0) continue else break :blk index;
   1a542: 63 8f 0a 0a  	beqz	s5, 0x1a600 <dwarf.LineNumberProgram.checkLineMatch+0x13c>
   1a546: 13 0b 01 01  	addi	s6, sp, 16
;             if (this_path.len == 0) continue;
   1a54a: 63 02 09 0c  	beqz	s2, 0x1a60e <dwarf.LineNumberProgram.checkLineMatch+0x14a>
;             const prev_sep = sepPredicate(prev_path[prev_path.len - 1]);
   1a54e: b3 85 aa 00  	add	a1, s5, a0
   1a552: 83 c5 f5 ff  	lbu	a1, -1(a1)
;             const this_sep = sepPredicate(this_path[0]);
   1a556: 03 47 0c 00  	lbu	a4, 0(s8)
;             const prev_sep = sepPredicate(prev_path[prev_path.len - 1]);
   1a55a: 13 86 15 fd  	addi	a2, a1, -47
   1a55e: 33 36 c0 00  	snez	a2, a2
;             const this_sep = sepPredicate(this_path[0]);
   1a562: 93 07 17 fd  	addi	a5, a4, -47
   1a566: b3 37 f0 00  	snez	a5, a5
;             sum += @boolToInt(!prev_sep and !this_sep);
   1a56a: 7d 8e        	and	a2, a2, a5
   1a56c: 56 96        	add	a2, a2, s5
   1a56e: 63 68 56 17  	bltu	a2, s5, 0x1a6de <dwarf.LineNumberProgram.checkLineMatch+0x21a>
;     return switch (native_os) {
   1a572: 13 47 f7 02  	xori	a4, a4, 47
   1a576: 93 c5 f5 02  	xori	a1, a1, 47
   1a57a: d9 8d        	or	a1, a1, a4
   1a57c: 93 b5 15 00  	seqz	a1, a1
;             sum += if (prev_sep and this_sep) this_path.len - 1 else this_path.len;
   1a580: b3 05 b9 40  	sub	a1, s2, a1
   1a584: 33 09 b6 00  	add	s2, a2, a1
   1a588: 63 6b c9 14  	bltu	s2, a2, 0x1a6de <dwarf.LineNumberProgram.checkLineMatch+0x21a>
   1a58c: 85 4b        	li	s7, 1
;     if (n == 0) {
   1a58e: 63 12 09 08  	bnez	s2, 0x1a612 <dwarf.LineNumberProgram.checkLineMatch+0x14e>
   1a592: 7d 5a        	li	s4, -1
   1a594: 56 84        	mv	s0, s5
   1a596: 55 a0        	j	0x1a63a <dwarf.LineNumberProgram.checkLineMatch+0x176>
;         self.prev_address = self.address;
   1a598: 88 60        	ld	a0, 0(s1)
   1a59a: 85 45        	li	a1, 1
;         self.prev_valid = true;
   1a59c: 23 8f b4 04  	sb	a1, 94(s1)
;         self.prev_file = self.file;
   1a5a0: 8c 64        	ld	a1, 8(s1)
;         self.prev_address = self.address;
   1a5a2: 88 fc        	sd	a0, 56(s1)
;         self.prev_line = self.line;
   1a5a4: 88 68        	ld	a0, 16(s1)
;         self.prev_column = self.column;
   1a5a6: 90 6c        	ld	a2, 24(s1)
;         self.prev_file = self.file;
   1a5a8: ac e0        	sd	a1, 64(s1)
;         self.prev_is_stmt = self.is_stmt;
   1a5aa: 83 c5 a4 05  	lbu	a1, 90(s1)
;         self.prev_line = self.line;
   1a5ae: a8 e4        	sd	a0, 72(s1)
;         self.prev_column = self.column;
   1a5b0: b0 e8        	sd	a2, 80(s1)
;         self.prev_basic_block = self.basic_block;
   1a5b2: 03 c5 b4 05  	lbu	a0, 91(s1)
;         self.prev_is_stmt = self.is_stmt;
   1a5b6: 85 89        	andi	a1, a1, 1
;         self.prev_end_sequence = self.end_sequence;
   1a5b8: 03 c6 c4 05  	lbu	a2, 92(s1)
;         self.prev_is_stmt = self.is_stmt;
   1a5bc: a3 8f b4 04  	sb	a1, 95(s1)
;         self.prev_basic_block = self.basic_block;
   1a5c0: 05 89        	andi	a0, a0, 1
   1a5c2: 23 80 a4 06  	sb	a0, 96(s1)
;         self.prev_end_sequence = self.end_sequence;
   1a5c6: 13 75 16 00  	andi	a0, a2, 1
   1a5ca: a3 80 a4 06  	sb	a0, 97(s1)
;         return null;
   1a5ce: 23 b4 0c 02  	sd	zero, 40(s9)
   1a5d2: 23 b0 0c 02  	sd	zero, 32(s9)
   1a5d6: 23 bc 0c 00  	sd	zero, 24(s9)
   1a5da: 23 b8 0c 00  	sd	zero, 16(s9)
   1a5de: 23 b4 0c 00  	sd	zero, 8(s9)
   1a5e2: 23 b0 0c 00  	sd	zero, 0(s9)
   1a5e6: e6 70        	ld	ra, 120(sp)
   1a5e8: 46 74        	ld	s0, 112(sp)
   1a5ea: a6 74        	ld	s1, 104(sp)
   1a5ec: 06 79        	ld	s2, 96(sp)
   1a5ee: e6 69        	ld	s3, 88(sp)
   1a5f0: 46 6a        	ld	s4, 80(sp)
   1a5f2: a6 6a        	ld	s5, 72(sp)
   1a5f4: 06 6b        	ld	s6, 64(sp)
   1a5f6: e2 7b        	ld	s7, 56(sp)
   1a5f8: 42 7c        	ld	s8, 48(sp)
   1a5fa: a2 7c        	ld	s9, 40(sp)
   1a5fc: 09 61        	addi	sp, sp, 128
   1a5fe: 82 80        	ret
;             if (path.len == 0) continue else break :blk index;
   1a600: 63 09 09 0e  	beqz	s2, 0x1a6f2 <dwarf.LineNumberProgram.checkLineMatch+0x22e>
   1a604: 13 0b 01 02  	addi	s6, sp, 32
   1a608: 89 4b        	li	s7, 2
   1a60a: 4a 84        	mv	s0, s2
   1a60c: 29 a0        	j	0x1a616 <dwarf.LineNumberProgram.checkLineMatch+0x152>
   1a60e: 85 4b        	li	s7, 1
   1a610: 56 89        	mv	s2, s5
   1a612: 2a 8c        	mv	s8, a0
   1a614: 56 84        	mv	s0, s5
;     const buf = try allocator.alloc(u8, total_len);
   1a616: 8c 66        	ld	a1, 8(a3)
   1a618: 88 62        	ld	a0, 0(a3)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1a61a: 98 61        	ld	a4, 0(a1)
   1a61c: ca 85        	mv	a1, s2
   1a61e: 01 46        	li	a2, 0
   1a620: 86 86        	mv	a3, ra
   1a622: 02 97        	jalr	a4
   1a624: 63 06 05 10  	beqz	a0, 0x1a730 <dwarf.LineNumberProgram.checkLineMatch+0x26c>
   1a628: 2a 8a        	mv	s4, a0
;     @memset(byte_ptr, undefined, byte_count);
   1a62a: 93 05 a0 0a  	li	a1, 170
   1a62e: 4a 86        	mv	a2, s2
   1a630: 97 a0 00 00  	auipc	ra, 10
   1a634: e7 80 a0 c6  	jalr	-918(ra)
   1a638: 62 85        	mv	a0, s8
;     if (!ok) unreachable; // assertion failure
   1a63a: 63 61 89 16  	bltu	s2, s0, 0x1a79c <dwarf.LineNumberProgram.checkLineMatch+0x2d8>
   1a63e: 81 45        	li	a1, 0
;     for (source) |s, i|
   1a640: 33 06 b5 00  	add	a2, a0, a1
   1a644: 03 06 06 00  	lb	a2, 0(a2)
;         dest[i] = s;
   1a648: b3 06 ba 00  	add	a3, s4, a1
   1a64c: 85 05        	addi	a1, a1, 1
   1a64e: 23 80 c6 00  	sb	a2, 0(a3)
;     for (source) |s, i|
   1a652: e3 17 b4 fe  	bne	s0, a1, 0x1a640 <dwarf.LineNumberProgram.checkLineMatch+0x17c>
;     var buf_index: usize = paths[first_path_index].len;
   1a656: 83 35 0b 00  	ld	a1, 0(s6)
;     if (!ok) unreachable; // assertion failure
   1a65a: 63 81 05 14  	beqz	a1, 0x1a79c <dwarf.LineNumberProgram.checkLineMatch+0x2d8>
;     while (i < paths.len) : (i += 1) {
   1a65e: 63 8e 0a 08  	beqz	s5, 0x1a6fa <dwarf.LineNumberProgram.checkLineMatch+0x236>
;         const this_path = paths[i];
   1a662: 13 96 4b 00  	slli	a2, s7, 4
   1a666: 34 00        	addi	a3, sp, 8
   1a668: 36 96        	add	a2, a2, a3
   1a66a: 14 66        	ld	a3, 8(a2)
;         if (this_path.len == 0) continue;
   1a66c: d9 c6        	beqz	a3, 0x1a6fa <dwarf.LineNumberProgram.checkLineMatch+0x236>
   1a66e: 10 62        	ld	a2, 0(a2)
;         const prev_sep = sepPredicate(prev_path[prev_path.len - 1]);
   1a670: 2e 95        	add	a0, a0, a1
   1a672: 03 45 f5 ff  	lbu	a0, -1(a0)
;         const this_sep = sepPredicate(this_path[0]);
   1a676: 03 47 06 00  	lbu	a4, 0(a2)
;         const prev_sep = sepPredicate(prev_path[prev_path.len - 1]);
   1a67a: 93 07 15 fd  	addi	a5, a0, -47
   1a67e: 93 b7 17 00  	seqz	a5, a5
;         const this_sep = sepPredicate(this_path[0]);
   1a682: 13 04 17 fd  	addi	s0, a4, -47
   1a686: 13 34 14 00  	seqz	s0, s0
;         if (!prev_sep and !this_sep) {
   1a68a: c1 8f        	or	a5, a5, s0
   1a68c: 91 eb        	bnez	a5, 0x1a6a0 <dwarf.LineNumberProgram.checkLineMatch+0x1dc>
;             buf[buf_index] = separator;
   1a68e: 63 fc 25 13  	bgeu	a1, s2, 0x1a7c6 <dwarf.LineNumberProgram.checkLineMatch+0x302>
   1a692: b3 07 ba 00  	add	a5, s4, a1
   1a696: 13 04 f0 02  	li	s0, 47
   1a69a: 23 80 87 00  	sb	s0, 0(a5)
;             buf_index += 1;
   1a69e: 85 05        	addi	a1, a1, 1
;         mem.copy(u8, buf[buf_index..], adjusted_path);
   1a6a0: 63 68 b9 10  	bltu	s2, a1, 0x1a7b0 <dwarf.LineNumberProgram.checkLineMatch+0x2ec>
   1a6a4: 13 47 f7 02  	xori	a4, a4, 47
   1a6a8: 13 45 f5 02  	xori	a0, a0, 47
   1a6ac: 59 8d        	or	a0, a0, a4
   1a6ae: 13 37 15 00  	seqz	a4, a0
   1a6b2: 33 85 e6 40  	sub	a0, a3, a4
;         mem.copy(u8, buf[buf_index..], adjusted_path);
   1a6b6: b3 06 b9 40  	sub	a3, s2, a1
;     if (!ok) unreachable; // assertion failure
   1a6ba: 63 e1 a6 0e  	bltu	a3, a0, 0x1a79c <dwarf.LineNumberProgram.checkLineMatch+0x2d8>
;     for (source) |s, i|
   1a6be: 09 cd        	beqz	a0, 0x1a6d8 <dwarf.LineNumberProgram.checkLineMatch+0x214>
   1a6c0: 3a 96        	add	a2, a2, a4
   1a6c2: b3 06 ba 00  	add	a3, s4, a1
   1a6c6: 2a 87        	mv	a4, a0
;     for (source) |s, i|
   1a6c8: 83 07 06 00  	lb	a5, 0(a2)
;         dest[i] = s;
   1a6cc: 23 80 f6 00  	sb	a5, 0(a3)
;     for (source) |s, i|
   1a6d0: 05 06        	addi	a2, a2, 1
   1a6d2: 7d 17        	addi	a4, a4, -1
   1a6d4: 85 06        	addi	a3, a3, 1
   1a6d6: 6d fb        	bnez	a4, 0x1a6c8 <dwarf.LineNumberProgram.checkLineMatch+0x204>
;         buf_index += adjusted_path.len;
   1a6d8: 2e 95        	add	a0, a0, a1
   1a6da: 63 70 b5 02  	bgeu	a0, a1, 0x1a6fa <dwarf.LineNumberProgram.checkLineMatch+0x236>
   1a6de: 37 15 01 00  	lui	a0, 17
   1a6e2: 13 05 95 5d  	addi	a0, a0, 1497
   1a6e6: c1 45        	li	a1, 16
   1a6e8: 81 46        	li	a3, 0
   1a6ea: 97 90 00 00  	auipc	ra, 9
   1a6ee: e7 80 00 c9  	jalr	-880(ra)
   1a6f2: 37 55 02 00  	lui	a0, 37
   1a6f6: 03 3a 05 37  	ld	s4, 880(a0)
;             return debug.LineInfo{
   1a6fa: 23 94 0c 02  	sh	zero, 40(s9)
   1a6fe: 05 45        	li	a0, 1
   1a700: 23 80 ac 02  	sb	a0, 32(s9)
;                 .line = if (self.prev_line >= 0) @intCast(u64, self.prev_line) else 0,
   1a704: a8 64        	ld	a0, 72(s1)
   1a706: 63 43 a0 00  	bgtz	a0, 0x1a70c <dwarf.LineNumberProgram.checkLineMatch+0x248>
   1a70a: 01 45        	li	a0, 0
   1a70c: 23 b0 ac 00  	sd	a0, 0(s9)
;                 .column = self.prev_column,
   1a710: a8 68        	ld	a0, 80(s1)
   1a712: 23 b4 ac 00  	sd	a0, 8(s9)
   1a716: 23 b8 4c 01  	sd	s4, 16(s9)
   1a71a: 23 bc 2c 01  	sd	s2, 24(s9)
   1a71e: e1 b5        	j	0x1a5e6 <dwarf.LineNumberProgram.checkLineMatch+0x122>
   1a720: 4e 85        	mv	a0, s3
   1a722: 97 90 00 00  	auipc	ra, 9
   1a726: e7 80 60 4d  	jalr	1238(ra)
   1a72a: 13 05 20 03  	li	a0, 50
   1a72e: a1 a0        	j	0x1a776 <dwarf.LineNumberProgram.checkLineMatch+0x2b2>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   1a730: 4e 85        	mv	a0, s3
   1a732: 97 90 00 00  	auipc	ra, 9
   1a736: e7 80 60 4c  	jalr	1222(ra)
;     return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());
   1a73a: 4e 85        	mv	a0, s3
   1a73c: 97 90 00 00  	auipc	ra, 9
   1a740: e7 80 c0 4b  	jalr	1212(ra)
;     const buf = try allocator.alloc(u8, total_len);
   1a744: 4e 85        	mv	a0, s3
   1a746: 97 90 00 00  	auipc	ra, 9
   1a74a: e7 80 20 4b  	jalr	1202(ra)
;     return joinSepMaybeZ(allocator, sep, isSep, paths, false);
   1a74e: 4e 85        	mv	a0, s3
   1a750: 97 90 00 00  	auipc	ra, 9
   1a754: e7 80 80 4a  	jalr	1192(ra)
;             const file_name = try fs.path.join(allocator, &[_][]const u8{
   1a758: 4e 85        	mv	a0, s3
   1a75a: 97 90 00 00  	auipc	ra, 9
   1a75e: e7 80 e0 49  	jalr	1182(ra)
   1a762: 45 45        	li	a0, 17
   1a764: 23 94 ac 02  	sh	a0, 40(s9)
   1a768: bd bd        	j	0x1a5e6 <dwarf.LineNumberProgram.checkLineMatch+0x122>
;     return error.MissingDebugInfo;
   1a76a: 4e 85        	mv	a0, s3
   1a76c: 97 90 00 00  	auipc	ra, 9
   1a770: e7 80 c0 48  	jalr	1164(ra)
   1a774: 4d 45        	li	a0, 19
   1a776: 23 94 ac 02  	sh	a0, 40(s9)
   1a77a: 4e 85        	mv	a0, s3
   1a77c: e6 70        	ld	ra, 120(sp)
   1a77e: 46 74        	ld	s0, 112(sp)
   1a780: a6 74        	ld	s1, 104(sp)
   1a782: 06 79        	ld	s2, 96(sp)
   1a784: e6 69        	ld	s3, 88(sp)
   1a786: 46 6a        	ld	s4, 80(sp)
   1a788: a6 6a        	ld	s5, 72(sp)
   1a78a: 06 6b        	ld	s6, 64(sp)
   1a78c: e2 7b        	ld	s7, 56(sp)
   1a78e: 42 7c        	ld	s8, 48(sp)
   1a790: a2 7c        	ld	s9, 40(sp)
   1a792: 09 61        	addi	sp, sp, 128
   1a794: 17 93 00 00  	auipc	t1, 9
   1a798: 67 00 43 46  	jr	1124(t1)
   1a79c: 37 25 01 00  	lui	a0, 18
   1a7a0: 13 05 b5 a7  	addi	a0, a0, -1413
   1a7a4: e1 45        	li	a1, 24
   1a7a6: 81 46        	li	a3, 0
   1a7a8: 97 90 00 00  	auipc	ra, 9
   1a7ac: e7 80 20 bd  	jalr	-1070(ra)
;         mem.copy(u8, buf[buf_index..], adjusted_path);
   1a7b0: 37 15 01 00  	lui	a0, 17
   1a7b4: 13 05 45 5b  	addi	a0, a0, 1460
   1a7b8: 93 05 40 02  	li	a1, 36
   1a7bc: 81 46        	li	a3, 0
   1a7be: 97 90 00 00  	auipc	ra, 9
   1a7c2: e7 80 c0 bb  	jalr	-1092(ra)
;             buf[buf_index] = separator;
   1a7c6: 37 15 01 00  	lui	a0, 17
   1a7ca: 13 05 35 6e  	addi	a0, a0, 1763
   1a7ce: cd 45        	li	a1, 19
   1a7d0: 81 46        	li	a3, 0
   1a7d2: 97 90 00 00  	auipc	ra, 9
   1a7d6: e7 80 80 ba  	jalr	-1112(ra)

000000000001a7da <dwarf.DwarfInfo.getLineNumberInfo>:
;     ) !debug.LineInfo {
   1a7da: 13 01 01 81  	addi	sp, sp, -2032
   1a7de: 23 34 11 7e  	sd	ra, 2024(sp)
   1a7e2: 23 30 81 7e  	sd	s0, 2016(sp)
   1a7e6: 23 3c 91 7c  	sd	s1, 2008(sp)
   1a7ea: 23 38 21 7d  	sd	s2, 2000(sp)
   1a7ee: 23 34 31 7d  	sd	s3, 1992(sp)
   1a7f2: 23 30 41 7d  	sd	s4, 1984(sp)
   1a7f6: 23 3c 51 7b  	sd	s5, 1976(sp)
   1a7fa: 23 38 61 7b  	sd	s6, 1968(sp)
   1a7fe: 23 34 71 7b  	sd	s7, 1960(sp)
   1a802: 23 30 81 7b  	sd	s8, 1952(sp)
   1a806: 23 3c 91 79  	sd	s9, 1944(sp)
   1a80a: 23 38 a1 79  	sd	s10, 1936(sp)
   1a80e: 23 34 b1 79  	sd	s11, 1928(sp)
   1a812: 6d 71        	addi	sp, sp, -272
   1a814: b2 84        	mv	s1, a2
;         var stream = io.fixedBufferStream(di.debug_line);
   1a816: 30 62        	ld	a2, 64(a2)
   1a818: 03 b8 84 04  	ld	a6, 72(s1)
   1a81c: 3a 84        	mv	s0, a4
   1a81e: b2 f1        	sd	a2, 224(sp)
   1a820: c2 f5        	sd	a6, 232(sp)
   1a822: 82 f9        	sd	zero, 240(sp)
   1a824: 90 11        	addi	a2, sp, 224
;         const in = &stream.reader();
   1a826: b2 fd        	sd	a2, 248(sp)
;         const compile_unit_cwd = try compile_unit.die.getAttrString(di, AT.comp_dir, di.debug_line_str, compile_unit);
   1a828: 10 63        	ld	a2, 0(a4)
   1a82a: 83 b8 04 05  	ld	a7, 80(s1)
   1a82e: 03 b8 84 05  	ld	a6, 88(s1)
   1a832: 06 89        	mv	s2, ra
   1a834: be 8a        	mv	s5, a5
   1a836: 36 8c        	mv	s8, a3
   1a838: 2e 8d        	mv	s10, a1
   1a83a: 2a 8b        	mv	s6, a0
;         const compile_unit_cwd = try compile_unit.die.getAttrString(di, AT.comp_dir, di.debug_line_str, compile_unit);
   1a83c: 08 02        	addi	a0, sp, 256
   1a83e: 6d 47        	li	a4, 27
   1a840: a6 ed        	sd	s1, 216(sp)
   1a842: a6 86        	mv	a3, s1
   1a844: c6 87        	mv	a5, a7
   1a846: a2 88        	mv	a7, s0
   1a848: 97 d0 ff ff  	auipc	ra, 1048573
   1a84c: e7 80 e0 bc  	jalr	-1074(ra)
   1a850: 83 54 01 11  	lhu	s1, 272(sp)
   1a854: 99 c0        	beqz	s1, 0x1a85a <dwarf.DwarfInfo.getLineNumberInfo+0x80>
   1a856: 6f 10 50 07  	j	0x1c0ca <.LBB45_239+0x56a>
;         const line_info_offset = try compile_unit.die.getAttrSecOffset(AT.stmt_list);
   1a85a: 08 60        	ld	a0, 0(s0)
;         for (self.attrs.items) |*attr| {
   1a85c: 0c 79        	ld	a1, 48(a0)
   1a85e: 4d 44        	li	s0, 19
   1a860: 99 e1        	bnez	a1, 0x1a866 <dwarf.DwarfInfo.getLineNumberInfo+0x8c>
   1a862: 6f 10 40 3c  	j	0x1bc26 <.LBB45_239+0xc6>
   1a866: 4a e9        	sd	s2, 144(sp)
   1a868: 08 75        	ld	a0, 40(a0)
   1a86a: 12 69        	ld	s2, 256(sp)
   1a86c: b2 6c        	ld	s9, 264(sp)
;         for (self.attrs.items) |*attr| {
   1a86e: 41 05        	addi	a0, a0, 16
   1a870: 41 46        	li	a2, 16
;             if (attr.id == id) return &attr.value;
   1a872: 83 36 05 ff  	ld	a3, -16(a0)
   1a876: 63 88 c6 00  	beq	a3, a2, 0x1a886 <dwarf.DwarfInfo.getLineNumberInfo+0xac>
;         for (self.attrs.items) |*attr| {
   1a87a: fd 15        	addi	a1, a1, -1
   1a87c: 13 05 05 02  	addi	a0, a0, 32
   1a880: ed f9        	bnez	a1, 0x1a872 <dwarf.DwarfInfo.getLineNumberInfo+0x98>
   1a882: 6f 10 40 3a  	j	0x1bc26 <.LBB45_239+0xc6>
;         switch (fv) {
   1a886: 83 45 85 00  	lbu	a1, 8(a0)
   1a88a: 19 46        	li	a2, 6
   1a88c: 63 8c c5 00  	beq	a1, a2, 0x1a8a4 <dwarf.DwarfInfo.getLineNumberInfo+0xca>
   1a890: 0d 46        	li	a2, 3
;         switch (fv) {
   1a892: 63 84 c5 00  	beq	a1, a2, 0x1a89a <dwarf.DwarfInfo.getLineNumberInfo+0xc0>
   1a896: 6f 10 80 37  	j	0x1bc0e <.LBB45_239+0xae>
   1a89a: 83 45 05 00  	lbu	a1, 0(a0)
;         if (self.signed) return badDwarf();
   1a89e: 99 c1        	beqz	a1, 0x1a8a4 <dwarf.DwarfInfo.getLineNumberInfo+0xca>
   1a8a0: 6f 10 40 36  	j	0x1bc04 <.LBB45_239+0xa4>
   1a8a4: 83 35 85 ff  	ld	a1, -8(a0)
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1a8a8: 2e 75        	ld	a0, 232(sp)
   1a8aa: 63 63 b5 00  	bltu	a0, a1, 0x1a8b0 <dwarf.DwarfInfo.getLineNumberInfo+0xd6>
   1a8ae: 2e 85        	mv	a0, a1
   1a8b0: ae fc        	sd	a1, 120(sp)
   1a8b2: aa f9        	sd	a0, 240(sp)
   1a8b4: 13 05 a0 0a  	li	a0, 170
;         var is_64: bool = undefined;
   1a8b8: a3 0f a1 10  	sb	a0, 287(sp)
;         const unit_length = try readUnitLength(in, di.endian, &is_64);
   1a8bc: 6e 65        	ld	a0, 216(sp)
   1a8be: 83 06 85 10  	lb	a3, 264(a0)
   1a8c2: 08 12        	addi	a0, sp, 288
   1a8c4: b0 19        	addi	a2, sp, 248
   1a8c6: 13 07 f1 11  	addi	a4, sp, 287
   1a8ca: ea 85        	mv	a1, s10
   1a8cc: 97 d0 ff ff  	auipc	ra, 1048573
   1a8d0: e7 80 a0 17  	jalr	378(ra)
   1a8d4: 03 54 81 12  	lhu	s0, 296(sp)
   1a8d8: 19 c0        	beqz	s0, 0x1a8de <dwarf.DwarfInfo.getLineNumberInfo+0x104>
   1a8da: 6f 10 30 25  	j	0x1c32c <.LBB45_239+0x7cc>
   1a8de: 12 75        	ld	a0, 288(sp)
;         if (unit_length == 0) {
   1a8e0: 19 e1        	bnez	a0, 0x1a8e6 <dwarf.DwarfInfo.getLineNumberInfo+0x10c>
   1a8e2: 6f 10 20 0a  	j	0x1b984 <.LBB45_180+0x1aa>
;         const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1a8e6: 03 46 f1 11  	lbu	a2, 287(sp)
   1a8ea: b1 45        	li	a1, 12
   1a8ec: b2 e9        	sd	a2, 208(sp)
   1a8ee: 11 e2        	bnez	a2, 0x1a8f2 <dwarf.DwarfInfo.getLineNumberInfo+0x118>
   1a8f0: 91 45        	li	a1, 4
;         const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1a8f2: aa 95        	add	a1, a1, a0
   1a8f4: ae ec        	sd	a1, 88(sp)
   1a8f6: 63 f4 a5 00  	bgeu	a1, a0, 0x1a8fe <dwarf.DwarfInfo.getLineNumberInfo+0x124>
   1a8fa: 6f 10 30 76  	j	0x1c85c <.LBB45_239+0xcfc>
   1a8fe: 81 44        	li	s1, 0
;         const version = try in.readInt(u16, di.endian);
   1a900: 6e 65        	ld	a0, 216(sp)
   1a902: 83 09 85 10  	lb	s3, 264(a0)
   1a906: 2d 65        	lui	a0, 11
   1a908: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   1a90c: 85 65        	lui	a1, 1
   1a90e: 9b 85 05 88  	addiw	a1, a1, -1920
   1a912: 8a 95        	add	a1, a1, sp
   1a914: 23 90 a5 00  	sh	a0, 0(a1)
   1a918: 05 65        	lui	a0, 1
   1a91a: 1b 05 05 88  	addiw	a0, a0, -1920
   1a91e: 33 0a a1 00  	add	s4, sp, a0
   1a922: 09 44        	li	s0, 2
;                 const amt = try self.read(buffer[index..]);
   1a924: 33 06 9a 00  	add	a2, s4, s1
   1a928: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   1a92c: 05 65        	lui	a0, 1
   1a92e: 1b 05 85 88  	addiw	a0, a0, -1912
   1a932: 0a 95        	add	a0, a0, sp
   1a934: 8c 11        	addi	a1, sp, 224
   1a936: 97 70 00 00  	auipc	ra, 7
   1a93a: e7 80 20 d8  	jalr	-638(ra)
   1a93e: 05 65        	lui	a0, 1
   1a940: 1b 05 85 88  	addiw	a0, a0, -1912
   1a944: 0a 95        	add	a0, a0, sp
   1a946: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1a948: e3 0b 05 70  	beqz	a0, 0x1b85e <.LBB45_180+0x84>
;                 index += amt;
   1a94c: 26 95        	add	a0, a0, s1
   1a94e: 63 74 95 00  	bgeu	a0, s1, 0x1a956 <dwarf.DwarfInfo.getLineNumberInfo+0x17c>
   1a952: 6f 10 b0 70  	j	0x1c85c <.LBB45_239+0xcfc>
   1a956: aa 84        	mv	s1, a0
;             while (index < len) {
   1a958: e3 66 85 fc  	bltu	a0, s0, 0x1a924 <dwarf.DwarfInfo.getLineNumberInfo+0x14a>
;             return bytes;
   1a95c: 05 65        	lui	a0, 1
   1a95e: 1b 05 05 88  	addiw	a0, a0, -1920
   1a962: 0a 95        	add	a0, a0, sp
   1a964: 03 54 05 00  	lhu	s0, 0(a0)
;     if (endian == native_endian) {
   1a968: 13 f5 19 00  	andi	a0, s3, 1
   1a96c: 19 e5        	bnez	a0, 0x1a97a <dwarf.DwarfInfo.getLineNumberInfo+0x1a0>
   1a96e: 13 55 84 00  	srli	a0, s0, 8
   1a972: 93 15 84 00  	slli	a1, s0, 8
   1a976: 33 e4 a5 00  	or	s0, a1, a0
;     if (endian == native_endian) {
   1a97a: 13 15 04 03  	slli	a0, s0, 48
   1a97e: 93 59 05 03  	srli	s3, a0, 48
   1a982: 05 45        	li	a0, 1
;         if (version < 2) return badDwarf();
   1a984: 63 78 35 6b  	bgeu	a0, s3, 0x1b034 <dwarf.DwarfInfo.getLineNumberInfo+0x85a>
   1a988: 15 45        	li	a0, 5
;         if (version >= 5) {
   1a98a: 63 ec a9 04  	bltu	s3, a0, 0x1a9e2 <dwarf.DwarfInfo.getLineNumberInfo+0x208>
;             return readFn(self.context, buffer);
   1a98e: 05 65        	lui	a0, 1
   1a990: 1b 05 85 88  	addiw	a0, a0, -1912
   1a994: 0a 95        	add	a0, a0, sp
   1a996: 8c 11        	addi	a1, sp, 224
   1a998: 05 66        	lui	a2, 1
   1a99a: 1b 06 06 88  	addiw	a2, a2, -1920
   1a99e: 0a 96        	add	a2, a2, sp
   1a9a0: 85 46        	li	a3, 1
   1a9a2: 97 70 00 00  	auipc	ra, 7
   1a9a6: e7 80 60 d1  	jalr	-746(ra)
   1a9aa: 05 65        	lui	a0, 1
   1a9ac: 1b 05 85 88  	addiw	a0, a0, -1912
   1a9b0: 0a 95        	add	a0, a0, sp
   1a9b2: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1a9b4: e3 0f 05 6a  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
;             return readFn(self.context, buffer);
   1a9b8: 05 65        	lui	a0, 1
   1a9ba: 1b 05 85 88  	addiw	a0, a0, -1912
   1a9be: 0a 95        	add	a0, a0, sp
   1a9c0: 8c 11        	addi	a1, sp, 224
   1a9c2: 05 66        	lui	a2, 1
   1a9c4: 1b 06 06 88  	addiw	a2, a2, -1920
   1a9c8: 0a 96        	add	a2, a2, sp
   1a9ca: 85 46        	li	a3, 1
   1a9cc: 97 70 00 00  	auipc	ra, 7
   1a9d0: e7 80 c0 ce  	jalr	-788(ra)
   1a9d4: 05 65        	lui	a0, 1
   1a9d6: 1b 05 85 88  	addiw	a0, a0, -1912
   1a9da: 0a 95        	add	a0, a0, sp
   1a9dc: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1a9de: e3 0a 05 68  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
   1a9e2: a2 e0        	sd	s0, 64(sp)
   1a9e4: d6 e4        	sd	s5, 72(sp)
   1a9e6: 6e 65        	ld	a0, 216(sp)
   1a9e8: 03 0a 85 10  	lb	s4, 264(a0)
;         const prologue_length = if (is_64) try in.readInt(u64, di.endian) else try in.readInt(u32, di.endian);
   1a9ec: 4e 65        	ld	a0, 208(sp)
   1a9ee: 55 cd        	beqz	a0, 0x1aaaa <dwarf.DwarfInfo.getLineNumberInfo+0x2d0>
   1a9f0: 37 55 02 00  	lui	a0, 37
   1a9f4: 03 35 85 37  	ld	a0, 888(a0)
   1a9f8: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1a9fa: 85 65        	lui	a1, 1
   1a9fc: 9b 85 05 88  	addiw	a1, a1, -1920
   1aa00: 8a 95        	add	a1, a1, sp
   1aa02: 88 e1        	sd	a0, 0(a1)
   1aa04: 05 65        	lui	a0, 1
   1aa06: 1b 05 05 88  	addiw	a0, a0, -1920
   1aa0a: b3 0a a1 00  	add	s5, sp, a0
   1aa0e: 21 44        	li	s0, 8
;                 const amt = try self.read(buffer[index..]);
   1aa10: 33 86 9a 00  	add	a2, s5, s1
   1aa14: b3 06 94 40  	sub	a3, s0, s1
;             return readFn(self.context, buffer);
   1aa18: 05 65        	lui	a0, 1
   1aa1a: 1b 05 85 88  	addiw	a0, a0, -1912
   1aa1e: 0a 95        	add	a0, a0, sp
   1aa20: 8c 11        	addi	a1, sp, 224
   1aa22: 97 70 00 00  	auipc	ra, 7
   1aa26: e7 80 60 c9  	jalr	-874(ra)
   1aa2a: 05 65        	lui	a0, 1
   1aa2c: 1b 05 85 88  	addiw	a0, a0, -1912
   1aa30: 0a 95        	add	a0, a0, sp
   1aa32: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1aa34: e3 05 05 62  	beqz	a0, 0x1b85e <.LBB45_180+0x84>
;                 index += amt;
   1aa38: 26 95        	add	a0, a0, s1
   1aa3a: 63 74 95 00  	bgeu	a0, s1, 0x1aa42 <dwarf.DwarfInfo.getLineNumberInfo+0x268>
   1aa3e: 6f 10 f0 61  	j	0x1c85c <.LBB45_239+0xcfc>
   1aa42: aa 84        	mv	s1, a0
;             while (index < len) {
   1aa44: e3 66 85 fc  	bltu	a0, s0, 0x1aa10 <dwarf.DwarfInfo.getLineNumberInfo+0x236>
;             return bytes;
   1aa48: 05 65        	lui	a0, 1
   1aa4a: 1b 05 05 88  	addiw	a0, a0, -1920
   1aa4e: 0a 95        	add	a0, a0, sp
   1aa50: 08 61        	ld	a0, 0(a0)
;     if (endian == native_endian) {
   1aa52: 93 75 1a 00  	andi	a1, s4, 1
   1aa56: f5 e1        	bnez	a1, 0x1ab3a <dwarf.DwarfInfo.getLineNumberInfo+0x360>
   1aa58: 93 55 85 01  	srli	a1, a0, 24
   1aa5c: 37 06 ff 00  	lui	a2, 4080
   1aa60: f1 8d        	and	a1, a1, a2
   1aa62: 13 56 85 00  	srli	a2, a0, 8
   1aa66: 93 06 f0 0f  	li	a3, 255
   1aa6a: 13 97 86 01  	slli	a4, a3, 24
   1aa6e: 79 8e        	and	a2, a2, a4
   1aa70: d1 8d        	or	a1, a1, a2
   1aa72: 13 56 85 02  	srli	a2, a0, 40
   1aa76: 41 67        	lui	a4, 16
   1aa78: 1b 07 07 f0  	addiw	a4, a4, -256
   1aa7c: 79 8e        	and	a2, a2, a4
   1aa7e: 13 57 85 03  	srli	a4, a0, 56
   1aa82: 59 8e        	or	a2, a2, a4
   1aa84: d1 8d        	or	a1, a1, a2
   1aa86: 13 16 85 01  	slli	a2, a0, 24
   1aa8a: 13 97 86 02  	slli	a4, a3, 40
   1aa8e: 79 8e        	and	a2, a2, a4
   1aa90: 1b 57 85 01  	srliw	a4, a0, 24
   1aa94: 02 17        	slli	a4, a4, 32
   1aa96: 59 8e        	or	a2, a2, a4
   1aa98: 13 17 85 02  	slli	a4, a0, 40
   1aa9c: c2 16        	slli	a3, a3, 48
   1aa9e: f9 8e        	and	a3, a3, a4
   1aaa0: 62 15        	slli	a0, a0, 56
   1aaa2: 55 8d        	or	a0, a0, a3
   1aaa4: 51 8d        	or	a0, a0, a2
   1aaa6: 4d 8d        	or	a0, a0, a1
   1aaa8: 49 a8        	j	0x1ab3a <dwarf.DwarfInfo.getLineNumberInfo+0x360>
   1aaaa: 01 44        	li	s0, 0
   1aaac: 37 b5 aa aa  	lui	a0, 699051
   1aab0: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   1aab4: 85 65        	lui	a1, 1
   1aab6: 9b 85 05 88  	addiw	a1, a1, -1920
   1aaba: 8a 95        	add	a1, a1, sp
   1aabc: 88 c1        	sw	a0, 0(a1)
   1aabe: 05 65        	lui	a0, 1
   1aac0: 1b 05 05 88  	addiw	a0, a0, -1920
   1aac4: b3 0a a1 00  	add	s5, sp, a0
   1aac8: 91 44        	li	s1, 4
;                 const amt = try self.read(buffer[index..]);
   1aaca: 33 86 8a 00  	add	a2, s5, s0
   1aace: b3 86 84 40  	sub	a3, s1, s0
;             return readFn(self.context, buffer);
   1aad2: 05 65        	lui	a0, 1
   1aad4: 1b 05 85 88  	addiw	a0, a0, -1912
   1aad8: 0a 95        	add	a0, a0, sp
   1aada: 8c 11        	addi	a1, sp, 224
   1aadc: 97 70 00 00  	auipc	ra, 7
   1aae0: e7 80 c0 bd  	jalr	-1060(ra)
   1aae4: 05 65        	lui	a0, 1
   1aae6: 1b 05 85 88  	addiw	a0, a0, -1912
   1aaea: 0a 95        	add	a0, a0, sp
   1aaec: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1aaee: e3 08 05 56  	beqz	a0, 0x1b85e <.LBB45_180+0x84>
;                 index += amt;
   1aaf2: 22 95        	add	a0, a0, s0
   1aaf4: 63 74 85 00  	bgeu	a0, s0, 0x1aafc <dwarf.DwarfInfo.getLineNumberInfo+0x322>
   1aaf8: 6f 10 50 56  	j	0x1c85c <.LBB45_239+0xcfc>
   1aafc: 2a 84        	mv	s0, a0
;             while (index < len) {
   1aafe: e3 66 95 fc  	bltu	a0, s1, 0x1aaca <dwarf.DwarfInfo.getLineNumberInfo+0x2f0>
;             return bytes;
   1ab02: 05 65        	lui	a0, 1
   1ab04: 1b 05 05 88  	addiw	a0, a0, -1920
   1ab08: 0a 95        	add	a0, a0, sp
   1ab0a: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1ab0e: 93 75 1a 00  	andi	a1, s4, 1
   1ab12: 95 e1        	bnez	a1, 0x1ab36 <dwarf.DwarfInfo.getLineNumberInfo+0x35c>
   1ab14: 93 55 85 00  	srli	a1, a0, 8
   1ab18: 41 66        	lui	a2, 16
   1ab1a: 1b 06 06 f0  	addiw	a2, a2, -256
   1ab1e: f1 8d        	and	a1, a1, a2
   1ab20: 13 56 85 01  	srli	a2, a0, 24
   1ab24: d1 8d        	or	a1, a1, a2
   1ab26: 13 16 85 00  	slli	a2, a0, 8
   1ab2a: b7 06 ff 00  	lui	a3, 4080
   1ab2e: 75 8e        	and	a2, a2, a3
   1ab30: 62 05        	slli	a0, a0, 24
   1ab32: 51 8d        	or	a0, a0, a2
   1ab34: 4d 8d        	or	a0, a0, a1
;         const prologue_length = if (is_64) try in.readInt(u64, di.endian) else try in.readInt(u32, di.endian);
   1ab36: 02 15        	slli	a0, a0, 32
   1ab38: 01 91        	srli	a0, a0, 32
;         const prog_start_offset = (try seekable.getPos()) + prologue_length;
   1ab3a: ce 75        	ld	a1, 240(sp)
   1ab3c: b3 84 a5 00  	add	s1, a1, a0
   1ab40: 63 f4 b4 00  	bgeu	s1, a1, 0x1ab48 <dwarf.DwarfInfo.getLineNumberInfo+0x36e>
   1ab44: 6f 10 90 51  	j	0x1c85c <.LBB45_239+0xcfc>
   1ab48: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1ab4c: 85 65        	lui	a1, 1
   1ab4e: 9b 85 05 88  	addiw	a1, a1, -1920
   1ab52: 8a 95        	add	a1, a1, sp
   1ab54: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1ab58: 05 65        	lui	a0, 1
   1ab5a: 1b 05 85 88  	addiw	a0, a0, -1912
   1ab5e: 0a 95        	add	a0, a0, sp
   1ab60: 8c 11        	addi	a1, sp, 224
   1ab62: 05 66        	lui	a2, 1
   1ab64: 1b 06 06 88  	addiw	a2, a2, -1920
   1ab68: 0a 96        	add	a2, a2, sp
   1ab6a: 85 46        	li	a3, 1
   1ab6c: 97 70 00 00  	auipc	ra, 7
   1ab70: e7 80 c0 b4  	jalr	-1204(ra)
   1ab74: 05 65        	lui	a0, 1
   1ab76: 1b 05 85 88  	addiw	a0, a0, -1912
   1ab7a: 0a 95        	add	a0, a0, sp
   1ab7c: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1ab7e: e3 0a 05 4e  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
;             return result[0];
   1ab82: 05 65        	lui	a0, 1
   1ab84: 1b 05 05 88  	addiw	a0, a0, -1920
   1ab88: 0a 95        	add	a0, a0, sp
   1ab8a: 03 45 05 00  	lbu	a0, 0(a0)
   1ab8e: 2a e1        	sd	a0, 128(sp)
;         if (minimum_instruction_length == 0) return badDwarf();
   1ab90: 63 02 05 4a  	beqz	a0, 0x1b034 <dwarf.DwarfInfo.getLineNumberInfo+0x85a>
   1ab94: 11 45        	li	a0, 4
;         if (version >= 4) {
   1ab96: 63 e7 a9 02  	bltu	s3, a0, 0x1abc4 <dwarf.DwarfInfo.getLineNumberInfo+0x3ea>
;             return readFn(self.context, buffer);
   1ab9a: 05 65        	lui	a0, 1
   1ab9c: 1b 05 85 88  	addiw	a0, a0, -1912
   1aba0: 0a 95        	add	a0, a0, sp
   1aba2: 8c 11        	addi	a1, sp, 224
   1aba4: 05 66        	lui	a2, 1
   1aba6: 1b 06 06 88  	addiw	a2, a2, -1920
   1abaa: 0a 96        	add	a2, a2, sp
   1abac: 85 46        	li	a3, 1
   1abae: 97 70 00 00  	auipc	ra, 7
   1abb2: e7 80 a0 b0  	jalr	-1270(ra)
   1abb6: 05 65        	lui	a0, 1
   1abb8: 1b 05 85 88  	addiw	a0, a0, -1912
   1abbc: 0a 95        	add	a0, a0, sp
   1abbe: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1abc0: e3 09 05 4a  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
   1abc4: 13 04 a0 0a  	li	s0, 170
;             var result: [1]u8 = undefined;
   1abc8: 05 65        	lui	a0, 1
   1abca: 1b 05 05 88  	addiw	a0, a0, -1920
   1abce: 0a 95        	add	a0, a0, sp
   1abd0: 23 00 85 00  	sb	s0, 0(a0)
;             return readFn(self.context, buffer);
   1abd4: 05 65        	lui	a0, 1
   1abd6: 1b 05 85 88  	addiw	a0, a0, -1912
   1abda: 0a 95        	add	a0, a0, sp
   1abdc: 8c 11        	addi	a1, sp, 224
   1abde: 05 66        	lui	a2, 1
   1abe0: 1b 06 06 88  	addiw	a2, a2, -1920
   1abe4: 0a 96        	add	a2, a2, sp
   1abe6: 85 46        	li	a3, 1
   1abe8: 97 70 00 00  	auipc	ra, 7
   1abec: e7 80 00 ad  	jalr	-1328(ra)
   1abf0: 05 65        	lui	a0, 1
   1abf2: 1b 05 85 88  	addiw	a0, a0, -1912
   1abf6: 0a 95        	add	a0, a0, sp
   1abf8: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1abfa: e3 0c 05 46  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
;             return result[0];
   1abfe: 05 65        	lui	a0, 1
   1ac00: 1b 05 05 88  	addiw	a0, a0, -1920
   1ac04: 0a 95        	add	a0, a0, sp
   1ac06: 83 4a 05 00  	lbu	s5, 0(a0)
;             var result: [1]u8 = undefined;
   1ac0a: 05 65        	lui	a0, 1
   1ac0c: 1b 05 05 88  	addiw	a0, a0, -1920
   1ac10: 0a 95        	add	a0, a0, sp
   1ac12: 23 00 85 00  	sb	s0, 0(a0)
;             return readFn(self.context, buffer);
   1ac16: 05 65        	lui	a0, 1
   1ac18: 1b 05 85 88  	addiw	a0, a0, -1912
   1ac1c: 0a 95        	add	a0, a0, sp
   1ac1e: 8c 11        	addi	a1, sp, 224
   1ac20: 05 66        	lui	a2, 1
   1ac22: 1b 06 06 88  	addiw	a2, a2, -1920
   1ac26: 0a 96        	add	a2, a2, sp
   1ac28: 85 46        	li	a3, 1
   1ac2a: 97 70 00 00  	auipc	ra, 7
   1ac2e: e7 80 e0 a8  	jalr	-1394(ra)
   1ac32: 05 65        	lui	a0, 1
   1ac34: 1b 05 85 88  	addiw	a0, a0, -1912
   1ac38: 0a 95        	add	a0, a0, sp
   1ac3a: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1ac3c: e3 06 05 42  	beqz	a0, 0x1b868 <.LBB45_180+0x8e>
;             return result[0];
   1ac40: 05 65        	lui	a0, 1
   1ac42: 1b 05 05 88  	addiw	a0, a0, -1920
   1ac46: 0a 95        	add	a0, a0, sp
   1ac48: 03 05 05 00  	lb	a0, 0(a0)
   1ac4c: 2a f9        	sd	a0, 176(sp)
   1ac4e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1ac52: 85 65        	lui	a1, 1
   1ac54: 9b 85 05 88  	addiw	a1, a1, -1920
   1ac58: 8a 95        	add	a1, a1, sp
   1ac5a: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1ac5e: 05 65        	lui	a0, 1
   1ac60: 1b 05 85 88  	addiw	a0, a0, -1912
   1ac64: 0a 95        	add	a0, a0, sp
   1ac66: 8c 11        	addi	a1, sp, 224
   1ac68: 05 66        	lui	a2, 1
   1ac6a: 1b 06 06 88  	addiw	a2, a2, -1920
   1ac6e: 0a 96        	add	a2, a2, sp
   1ac70: 85 46        	li	a3, 1
   1ac72: 97 70 00 00  	auipc	ra, 7
   1ac76: e7 80 60 a4  	jalr	-1466(ra)
   1ac7a: 05 65        	lui	a0, 1
   1ac7c: 1b 05 85 88  	addiw	a0, a0, -1912
   1ac80: 0a 95        	add	a0, a0, sp
   1ac82: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1ac84: e3 07 05 3e  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
;             return result[0];
   1ac88: 05 65        	lui	a0, 1
   1ac8a: 1b 05 05 88  	addiw	a0, a0, -1920
   1ac8e: 0a 95        	add	a0, a0, sp
   1ac90: 03 4a 05 00  	lbu	s4, 0(a0)
;         if (line_range == 0) return badDwarf();
   1ac94: 63 00 0a 3a  	beqz	s4, 0x1b034 <dwarf.DwarfInfo.getLineNumberInfo+0x85a>
   1ac98: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1ac9c: 85 65        	lui	a1, 1
   1ac9e: 9b 85 05 88  	addiw	a1, a1, -1920
   1aca2: 8a 95        	add	a1, a1, sp
   1aca4: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1aca8: 05 65        	lui	a0, 1
   1acaa: 1b 05 85 88  	addiw	a0, a0, -1912
   1acae: 0a 95        	add	a0, a0, sp
   1acb0: 8c 11        	addi	a1, sp, 224
   1acb2: 05 66        	lui	a2, 1
   1acb4: 1b 06 06 88  	addiw	a2, a2, -1920
   1acb8: 0a 96        	add	a2, a2, sp
   1acba: 85 46        	li	a3, 1
   1acbc: 97 70 00 00  	auipc	ra, 7
   1acc0: e7 80 c0 9f  	jalr	-1540(ra)
   1acc4: 05 65        	lui	a0, 1
   1acc6: 1b 05 85 88  	addiw	a0, a0, -1912
   1acca: 0a 95        	add	a0, a0, sp
   1accc: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1acce: e3 02 05 3a  	beqz	a0, 0x1b872 <.LBB45_180+0x98>
   1acd2: 56 f4        	sd	s5, 40(sp)
   1acd4: 26 f8        	sd	s1, 48(sp)
;             return result[0];
   1acd6: 05 65        	lui	a0, 1
   1acd8: 1b 05 05 88  	addiw	a0, a0, -1920
   1acdc: 0a 95        	add	a0, a0, sp
   1acde: 83 45 05 00  	lbu	a1, 0(a0)
;         const standard_opcode_lengths = try allocator.alloc(u8, opcode_base - 1);
   1ace2: 13 85 f5 ff  	addi	a0, a1, -1
   1ace6: 93 7b f5 0f  	andi	s7, a0, 255
   1acea: 2a fc        	sd	a0, 56(sp)
   1acec: 63 84 ab 00  	beq	s7, a0, 0x1acf4 <dwarf.DwarfInfo.getLineNumberInfo+0x51a>
   1acf0: 6f 10 d0 36  	j	0x1c85c <.LBB45_239+0xcfc>
   1acf4: 2e fd        	sd	a1, 184(sp)
;     if (n == 0) {
   1acf6: 63 83 0b 08  	beqz	s7, 0x1ad7c <dwarf.DwarfInfo.getLineNumberInfo+0x5a2>
   1acfa: 83 35 8c 00  	ld	a1, 8(s8)
   1acfe: 03 35 0c 00  	ld	a0, 0(s8)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1ad02: 98 61        	ld	a4, 0(a1)
   1ad04: de 85        	mv	a1, s7
   1ad06: 01 46        	li	a2, 0
   1ad08: ca 66        	ld	a3, 144(sp)
   1ad0a: 02 97        	jalr	a4
   1ad0c: 19 e1        	bnez	a0, 0x1ad12 <dwarf.DwarfInfo.getLineNumberInfo+0x538>
   1ad0e: 6f 10 a0 0b  	j	0x1bdc8 <.LBB45_239+0x268>
;     @memset(byte_ptr, undefined, byte_count);
   1ad12: 93 05 a0 0a  	li	a1, 170
   1ad16: 13 04 a0 0a  	li	s0, 170
   1ad1a: aa e5        	sd	a0, 200(sp)
   1ad1c: 5e 86        	mv	a2, s7
   1ad1e: 97 90 00 00  	auipc	ra, 9
   1ad22: e7 80 c0 57  	jalr	1404(ra)
   1ad26: 81 44        	li	s1, 0
;             var result: [1]u8 = undefined;
   1ad28: 05 65        	lui	a0, 1
   1ad2a: 1b 05 05 88  	addiw	a0, a0, -1920
   1ad2e: 0a 95        	add	a0, a0, sp
   1ad30: 23 00 85 00  	sb	s0, 0(a0)
;             return readFn(self.context, buffer);
   1ad34: 05 65        	lui	a0, 1
   1ad36: 1b 05 85 88  	addiw	a0, a0, -1912
   1ad3a: 0a 95        	add	a0, a0, sp
   1ad3c: 8c 11        	addi	a1, sp, 224
   1ad3e: 05 66        	lui	a2, 1
   1ad40: 1b 06 06 88  	addiw	a2, a2, -1920
   1ad44: 0a 96        	add	a2, a2, sp
   1ad46: 85 46        	li	a3, 1
   1ad48: 97 70 00 00  	auipc	ra, 7
   1ad4c: e7 80 00 97  	jalr	-1680(ra)
   1ad50: 05 65        	lui	a0, 1
   1ad52: 1b 05 85 88  	addiw	a0, a0, -1912
   1ad56: 0a 95        	add	a0, a0, sp
   1ad58: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1ad5a: 19 e1        	bnez	a0, 0x1ad60 <dwarf.DwarfInfo.getLineNumberInfo+0x586>
   1ad5c: 6f 10 20 09  	j	0x1bdee <.LBB45_239+0x28e>
;             return result[0];
   1ad60: 05 65        	lui	a0, 1
   1ad62: 1b 05 05 88  	addiw	a0, a0, -1920
   1ad66: 0a 95        	add	a0, a0, sp
   1ad68: 03 05 05 00  	lb	a0, 0(a0)
;                 standard_opcode_lengths[i] = try in.readByte();
   1ad6c: ae 65        	ld	a1, 200(sp)
   1ad6e: a6 95        	add	a1, a1, s1
;             while (i < opcode_base - 1) : (i += 1) {
   1ad70: 85 04        	addi	s1, s1, 1
;                 standard_opcode_lengths[i] = try in.readByte();
   1ad72: 23 80 a5 00  	sb	a0, 0(a1)
;             while (i < opcode_base - 1) : (i += 1) {
   1ad76: e3 99 9b fa  	bne	s7, s1, 0x1ad28 <dwarf.DwarfInfo.getLineNumberInfo+0x54e>
   1ad7a: 19 a0        	j	0x1ad80 <dwarf.DwarfInfo.getLineNumberInfo+0x5a6>
   1ad7c: 7d 55        	li	a0, -1
   1ad7e: aa e5        	sd	a0, 200(sp)
;             return .{
   1ad80: 03 35 0c 00  	ld	a0, 0(s8)
   1ad84: 83 35 8c 00  	ld	a1, 8(s8)
;         return (State{}).promote(child_allocator);
   1ad88: 2a fa        	sd	a0, 304(sp)
   1ad8a: 2e fe        	sd	a1, 312(sp)
   1ad8c: 82 e2        	sd	zero, 320(sp)
   1ad8e: 82 e6        	sd	zero, 328(sp)
   1ad90: 0c 1a        	addi	a1, sp, 304
;         return .{
   1ad92: ae ea        	sd	a1, 336(sp)
   1ad94: 37 15 01 00  	lui	a0, 17
   1ad98: 13 06 05 02  	addi	a2, a0, 32
   1ad9c: b2 ee        	sd	a2, 344(sp)
;             return Self{
   1ad9e: 82 f6        	sd	zero, 360(sp)
   1ada0: 37 55 02 00  	lui	a0, 37
   1ada4: 03 35 85 37  	ld	a0, 888(a0)
   1ada8: 82 fa        	sd	zero, 368(sp)
   1adaa: ae fe        	sd	a1, 376(sp)
   1adac: 32 e3        	sd	a2, 384(sp)
;         var include_directories = std.ArrayList(FileEntry).init(arena);
   1adae: aa f2        	sd	a0, 352(sp)
;             return Self{
   1adb0: 02 ef        	sd	zero, 408(sp)
   1adb2: 02 eb        	sd	zero, 400(sp)
   1adb4: 32 f7        	sd	a2, 424(sp)
   1adb6: 2e f3        	sd	a1, 416(sp)
   1adb8: 91 45        	li	a1, 4
;         var file_entries = std.ArrayList(FileEntry).init(arena);
   1adba: 2a e7        	sd	a0, 392(sp)
   1adbc: 5a e5        	sd	s6, 136(sp)
   1adbe: 62 ed        	sd	s8, 152(sp)
;         if (version < 5) {
   1adc0: 63 e4 35 0b  	bltu	a1, s3, 0x1ae68 <dwarf.DwarfInfo.getLineNumberInfo+0x68e>
;             const new_item_ptr = try self.addOne();
   1adc4: 05 65        	lui	a0, 1
   1adc6: 1b 05 85 88  	addiw	a0, a0, -1912
   1adca: 0a 95        	add	a0, a0, sp
   1adcc: 90 12        	addi	a2, sp, 352
   1adce: ea 85        	mv	a1, s10
   1add0: 97 70 00 00  	auipc	ra, 7
   1add4: e7 80 c0 d8  	jalr	-628(ra)
   1add8: 05 65        	lui	a0, 1
   1adda: 1b 05 05 89  	addiw	a0, a0, -1904
   1adde: 0a 95        	add	a0, a0, sp
   1ade0: 03 54 05 00  	lhu	s0, 0(a0)
   1ade4: 19 c0        	beqz	s0, 0x1adea <dwarf.DwarfInfo.getLineNumberInfo+0x610>
   1ade6: 6f 10 a0 14  	j	0x1bf30 <.LBB45_239+0x3d0>
   1adea: 05 65        	lui	a0, 1
   1adec: 1b 05 85 88  	addiw	a0, a0, -1912
   1adf0: 0a 95        	add	a0, a0, sp
   1adf2: 08 61        	ld	a0, 0(a0)
;             new_item_ptr.* = item;
   1adf4: 23 30 25 01  	sd	s2, 0(a0)
   1adf8: 23 34 95 01  	sd	s9, 8(a0)
   1adfc: 23 38 05 00  	sd	zero, 16(a0)
   1ae00: 23 3c 05 00  	sd	zero, 24(a0)
   1ae04: 23 30 05 02  	sd	zero, 32(a0)
   1ae08: 23 34 05 02  	sd	zero, 40(a0)
   1ae0c: 23 28 05 02  	sw	zero, 48(a0)
;                 const dir = try in.readUntilDelimiterAlloc(arena, 0, math.maxInt(usize));
   1ae10: 88 03        	addi	a0, sp, 448
   1ae12: 90 11        	addi	a2, sp, 224
   1ae14: 94 0a        	addi	a3, sp, 336
   1ae16: ea 85        	mv	a1, s10
   1ae18: 97 f0 ff ff  	auipc	ra, 1048575
   1ae1c: e7 80 60 b3  	jalr	-1226(ra)
   1ae20: 03 54 01 1d  	lhu	s0, 464(sp)
   1ae24: e3 16 04 68  	bnez	s0, 0x1bcb0 <.LBB45_239+0x150>
   1ae28: be 64        	ld	s1, 456(sp)
;                 if (dir.len == 0) break;
   1ae2a: 63 8f 04 12  	beqz	s1, 0x1af68 <dwarf.DwarfInfo.getLineNumberInfo+0x78e>
;                 const dir = try in.readUntilDelimiterAlloc(arena, 0, math.maxInt(usize));
   1ae2e: 1e 64        	ld	s0, 448(sp)
;             const new_item_ptr = try self.addOne();
   1ae30: 05 65        	lui	a0, 1
   1ae32: 1b 05 85 88  	addiw	a0, a0, -1912
   1ae36: 0a 95        	add	a0, a0, sp
   1ae38: 90 12        	addi	a2, sp, 352
   1ae3a: ea 85        	mv	a1, s10
   1ae3c: 97 70 00 00  	auipc	ra, 7
   1ae40: e7 80 00 d2  	jalr	-736(ra)
   1ae44: 05 65        	lui	a0, 1
   1ae46: 1b 05 05 89  	addiw	a0, a0, -1904
   1ae4a: 0a 95        	add	a0, a0, sp
   1ae4c: 03 59 05 00  	lhu	s2, 0(a0)
   1ae50: 63 04 09 00  	beqz	s2, 0x1ae58 <dwarf.DwarfInfo.getLineNumberInfo+0x67e>
   1ae54: 6f 10 80 15  	j	0x1bfac <.LBB45_239+0x44c>
   1ae58: 05 65        	lui	a0, 1
   1ae5a: 1b 05 85 88  	addiw	a0, a0, -1912
   1ae5e: 0a 95        	add	a0, a0, sp
   1ae60: 08 61        	ld	a0, 0(a0)
;             new_item_ptr.* = item;
   1ae62: 00 e1        	sd	s0, 0(a0)
   1ae64: 04 e5        	sd	s1, 8(a0)
   1ae66: 59 bf        	j	0x1adfc <dwarf.DwarfInfo.getLineNumberInfo+0x622>
;                 var dir_ent_fmt_buf: [10]FileEntFmt = undefined;
   1ae68: 23 34 a1 2a  	sd	a0, 680(sp)
   1ae6c: 23 30 a1 2a  	sd	a0, 672(sp)
   1ae70: 23 3c a1 28  	sd	a0, 664(sp)
   1ae74: 23 38 a1 28  	sd	a0, 656(sp)
   1ae78: 23 34 a1 28  	sd	a0, 648(sp)
   1ae7c: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1ae80: 85 65        	lui	a1, 1
   1ae82: 9b 85 05 88  	addiw	a1, a1, -1920
   1ae86: 8a 95        	add	a1, a1, sp
   1ae88: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1ae8c: 05 65        	lui	a0, 1
   1ae8e: 1b 05 85 88  	addiw	a0, a0, -1912
   1ae92: 0a 95        	add	a0, a0, sp
   1ae94: 8c 11        	addi	a1, sp, 224
   1ae96: 05 66        	lui	a2, 1
   1ae98: 1b 06 06 88  	addiw	a2, a2, -1920
   1ae9c: 0a 96        	add	a2, a2, sp
   1ae9e: 85 46        	li	a3, 1
   1aea0: 97 70 00 00  	auipc	ra, 7
   1aea4: e7 80 80 81  	jalr	-2024(ra)
   1aea8: 05 65        	lui	a0, 1
   1aeaa: 1b 05 85 88  	addiw	a0, a0, -1912
   1aeae: 0a 95        	add	a0, a0, sp
   1aeb0: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1aeb2: 19 e1        	bnez	a0, 0x1aeb8 <dwarf.DwarfInfo.getLineNumberInfo+0x6de>
   1aeb4: 6f 10 00 0a  	j	0x1bf54 <.LBB45_239+0x3f4>
;             return result[0];
   1aeb8: 05 65        	lui	a0, 1
   1aeba: 1b 05 05 88  	addiw	a0, a0, -1920
   1aebe: 0a 95        	add	a0, a0, sp
   1aec0: 83 49 05 00  	lbu	s3, 0(a0)
   1aec4: 2d 45        	li	a0, 11
;                 if (directory_entry_format_count > dir_ent_fmt_buf.len) return badDwarf();
   1aec6: 63 e4 a9 00  	bltu	s3, a0, 0x1aece <dwarf.DwarfInfo.getLineNumberInfo+0x6f4>
   1aeca: 6f 10 20 0b  	j	0x1bf7c <.LBB45_239+0x41c>
;                 for (dir_ent_fmt_buf[0..directory_entry_format_count]) |*ent_fmt| {
   1aece: 63 8a 09 04  	beqz	s3, 0x1af22 <dwarf.DwarfInfo.getLineNumberInfo+0x748>
   1aed2: 13 04 a1 28  	addi	s0, sp, 650
   1aed6: ce 84        	mv	s1, s3
;                         .content_type_code = try leb.readULEB128(u8, in),
   1aed8: 88 0d        	addi	a0, sp, 720
   1aeda: b0 19        	addi	a2, sp, 248
   1aedc: ea 85        	mv	a1, s10
   1aede: 97 f0 ff ff  	auipc	ra, 1048575
   1aee2: e7 80 40 f8  	jalr	-124(ra)
   1aee6: 03 59 01 2d  	lhu	s2, 720(sp)
   1aeea: 63 04 09 00  	beqz	s2, 0x1aef2 <dwarf.DwarfInfo.getLineNumberInfo+0x718>
   1aeee: 6f 10 e0 22  	j	0x1c11c <.LBB45_239+0x5bc>
   1aef2: 03 05 21 2d  	lb	a0, 722(sp)
   1aef6: 23 00 a4 00  	sb	a0, 0(s0)
;                         .form_code = try leb.readULEB128(u16, in),
   1aefa: a8 15        	addi	a0, sp, 744
   1aefc: b0 19        	addi	a2, sp, 248
   1aefe: ea 85        	mv	a1, s10
   1af00: 97 f0 ff ff  	auipc	ra, 1048575
   1af04: e7 80 c0 01  	jalr	28(ra)
   1af08: 03 59 a1 2e  	lhu	s2, 746(sp)
   1af0c: 63 04 09 00  	beqz	s2, 0x1af14 <dwarf.DwarfInfo.getLineNumberInfo+0x73a>
   1af10: 6f 10 a0 22  	j	0x1c13a <.LBB45_239+0x5da>
   1af14: 03 15 81 2e  	lh	a0, 744(sp)
   1af18: 23 1f a4 fe  	sh	a0, -2(s0)
;                 for (dir_ent_fmt_buf[0..directory_entry_format_count]) |*ent_fmt| {
   1af1c: fd 14        	addi	s1, s1, -1
   1af1e: 11 04        	addi	s0, s0, 4
   1af20: c5 fc        	bnez	s1, 0x1aed8 <dwarf.DwarfInfo.getLineNumberInfo+0x6fe>
;                 const directories_count = try leb.readULEB128(usize, in);
   1af22: 08 06        	addi	a0, sp, 768
   1af24: b0 19        	addi	a2, sp, 248
   1af26: ea 85        	mv	a1, s10
   1af28: 97 f0 ff ff  	auipc	ra, 1048575
   1af2c: e7 80 00 0e  	jalr	224(ra)
   1af30: 03 54 81 30  	lhu	s0, 776(sp)
   1af34: 19 c0        	beqz	s0, 0x1af3a <dwarf.DwarfInfo.getLineNumberInfo+0x760>
   1af36: 6f 10 a0 09  	j	0x1bfd0 <.LBB45_239+0x470>
   1af3a: 83 34 01 30  	ld	s1, 768(sp)
   1af3e: 37 55 02 00  	lui	a0, 37
   1af42: 03 34 85 37  	ld	s0, 888(a0)
;             if (self.capacity >= new_capacity) return;
   1af46: 52 f5        	sd	s4, 168(sp)
   1af48: e3 85 04 14  	beqz	s1, 0x1b892 <.LBB45_180+0xb8>
   1af4c: 01 46        	li	a2, 0
   1af4e: 19 a0        	j	0x1af54 <dwarf.DwarfInfo.getLineNumberInfo+0x77a>
;                 if (better_capacity >= new_capacity) break;
   1af50: 63 7c 96 74  	bgeu	a2, s1, 0x1b6a8 <.LBB45_150+0x86>
   1af54: b2 85        	mv	a1, a2
;                 better_capacity +|= better_capacity / 2 + 8;
   1af56: 13 55 16 00  	srli	a0, a2, 1
   1af5a: 32 95        	add	a0, a0, a2
   1af5c: 21 05        	addi	a0, a0, 8
   1af5e: 7d 56        	li	a2, -1
   1af60: e3 68 b5 fe  	bltu	a0, a1, 0x1af50 <dwarf.DwarfInfo.getLineNumberInfo+0x776>
   1af64: 2a 86        	mv	a2, a0
   1af66: ed b7        	j	0x1af50 <dwarf.DwarfInfo.getLineNumberInfo+0x776>
   1af68: 52 f5        	sd	s4, 168(sp)
;                 const file_name = try in.readUntilDelimiterAlloc(arena, 0, math.maxInt(usize));
   1af6a: a8 1b        	addi	a0, sp, 504
   1af6c: 90 11        	addi	a2, sp, 224
   1af6e: 94 0a        	addi	a3, sp, 336
   1af70: ea 85        	mv	a1, s10
   1af72: 97 f0 ff ff  	auipc	ra, 1048575
   1af76: e7 80 c0 9d  	jalr	-1572(ra)
   1af7a: 03 54 81 20  	lhu	s0, 520(sp)
   1af7e: e3 16 04 62  	bnez	s0, 0x1bdaa <.LBB45_239+0x24a>
   1af82: 03 3a 01 20  	ld	s4, 512(sp)
;                 if (file_name.len == 0) break;
   1af86: 63 00 0a 0c  	beqz	s4, 0x1b046 <dwarf.DwarfInfo.getLineNumberInfo+0x86c>
   1af8a: 7e 79        	ld	s2, 504(sp)
;                 const dir_index = try leb.readULEB128(u32, in);
   1af8c: 08 14        	addi	a0, sp, 544
   1af8e: b0 19        	addi	a2, sp, 248
   1af90: ea 85        	mv	a1, s10
   1af92: 97 f0 ff ff  	auipc	ra, 1048575
   1af96: e7 80 60 d8  	jalr	-634(ra)
   1af9a: 03 54 41 22  	lhu	s0, 548(sp)
   1af9e: 19 c0        	beqz	s0, 0x1afa4 <dwarf.DwarfInfo.getLineNumberInfo+0x7ca>
   1afa0: 6f 10 60 0c  	j	0x1c066 <.LBB45_239+0x506>
   1afa4: 83 29 01 22  	lw	s3, 544(sp)
;                 const mtime = try leb.readULEB128(u64, in);
   1afa8: 28 1c        	addi	a0, sp, 568
   1afaa: b0 19        	addi	a2, sp, 248
   1afac: ea 85        	mv	a1, s10
   1afae: 97 90 ff ff  	auipc	ra, 1048569
   1afb2: e7 80 80 34  	jalr	840(ra)
   1afb6: 03 54 01 24  	lhu	s0, 576(sp)
   1afba: 19 c0        	beqz	s0, 0x1afc0 <dwarf.DwarfInfo.getLineNumberInfo+0x7e6>
   1afbc: 6f 10 80 0c  	j	0x1c084 <.LBB45_239+0x524>
   1afc0: 03 34 81 23  	ld	s0, 568(sp)
;                 const size = try leb.readULEB128(u64, in);
   1afc4: a8 0c        	addi	a0, sp, 600
   1afc6: b0 19        	addi	a2, sp, 248
   1afc8: ea 85        	mv	a1, s10
   1afca: 97 90 ff ff  	auipc	ra, 1048569
   1afce: e7 80 c0 32  	jalr	812(ra)
   1afd2: 83 54 01 26  	lhu	s1, 608(sp)
   1afd6: 99 c0        	beqz	s1, 0x1afdc <dwarf.DwarfInfo.getLineNumberInfo+0x802>
   1afd8: 6f 10 a0 0c  	j	0x1c0a2 <.LBB45_239+0x542>
   1afdc: 83 34 81 25  	ld	s1, 600(sp)
;             const new_item_ptr = try self.addOne();
   1afe0: 05 65        	lui	a0, 1
   1afe2: 1b 05 85 88  	addiw	a0, a0, -1912
   1afe6: 0a 95        	add	a0, a0, sp
   1afe8: 30 03        	addi	a2, sp, 392
   1afea: ea 85        	mv	a1, s10
   1afec: 97 70 00 00  	auipc	ra, 7
   1aff0: e7 80 00 b7  	jalr	-1168(ra)
   1aff4: 05 65        	lui	a0, 1
   1aff6: 1b 05 05 89  	addiw	a0, a0, -1904
   1affa: 0a 95        	add	a0, a0, sp
   1affc: 83 5a 05 00  	lhu	s5, 0(a0)
   1b000: 63 84 0a 00  	beqz	s5, 0x1b008 <dwarf.DwarfInfo.getLineNumberInfo+0x82e>
   1b004: 6f 10 60 0d  	j	0x1c0da <.LBB45_239+0x57a>
   1b008: 05 65        	lui	a0, 1
   1b00a: 1b 05 85 88  	addiw	a0, a0, -1912
   1b00e: 0a 95        	add	a0, a0, sp
   1b010: 08 61        	ld	a0, 0(a0)
;             new_item_ptr.* = item;
   1b012: 23 30 25 01  	sd	s2, 0(a0)
   1b016: 23 34 45 01  	sd	s4, 8(a0)
   1b01a: 00 e9        	sd	s0, 16(a0)
   1b01c: 04 ed        	sd	s1, 24(a0)
   1b01e: 23 20 35 03  	sw	s3, 32(a0)
   1b022: 23 22 05 02  	sw	zero, 36(a0)
   1b026: 23 24 05 02  	sw	zero, 40(a0)
   1b02a: 23 26 05 02  	sw	zero, 44(a0)
   1b02e: 23 28 05 02  	sw	zero, 48(a0)
   1b032: 25 bf        	j	0x1af6a <dwarf.DwarfInfo.getLineNumberInfo+0x790>
   1b034: 6a 85        	mv	a0, s10
   1b036: 97 90 00 00  	auipc	ra, 9
   1b03a: e7 80 20 bc  	jalr	-1086(ra)
   1b03e: 13 05 20 03  	li	a0, 50
   1b042: 6f 00 f0 14  	j	0x1b990 <.LBB45_180+0x1b6>
;             include_directories.items,
   1b046: 96 79        	ld	s3, 352(sp)
   1b048: b6 7c        	ld	s9, 360(sp)
   1b04a: 0a 69        	ld	s2, 128(sp)
   1b04c: 5e f0        	sd	s7, 32(sp)
   1b04e: 37 55 02 00  	lui	a0, 37
   1b052: 03 35 85 37  	ld	a0, 888(a0)
;         const default_is_stmt = (try in.readByte()) != 0;
   1b056: a2 75        	ld	a1, 40(sp)
   1b058: b3 35 b0 00  	snez	a1, a1
;         return LineNumberProgram{
   1b05c: 23 34 a1 5a  	sd	a0, 1448(sp)
   1b060: 23 30 a1 5a  	sd	a0, 1440(sp)
   1b064: 23 3c a1 58  	sd	a0, 1432(sp)
;             include_directories.items,
   1b068: 23 3c 01 54  	sd	zero, 1368(sp)
   1b06c: 05 45        	li	a0, 1
   1b06e: 23 30 a1 56  	sd	a0, 1376(sp)
   1b072: 23 34 a1 56  	sd	a0, 1384(sp)
   1b076: 23 38 01 56  	sd	zero, 1392(sp)
   1b07a: 26 65        	ld	a0, 72(sp)
   1b07c: 23 3c a1 56  	sd	a0, 1400(sp)
   1b080: 23 30 31 59  	sd	s3, 1408(sp)
   1b084: 23 34 91 59  	sd	s9, 1416(sp)
   1b088: 23 38 01 58  	sd	zero, 1424(sp)
   1b08c: 06 65        	ld	a0, 64(sp)
   1b08e: 23 18 a1 5a  	sh	a0, 1456(sp)
   1b092: 23 09 b1 5a  	sb	a1, 1458(sp)
   1b096: a3 09 01 5a  	sb	zero, 1459(sp)
   1b09a: 23 0a 01 5a  	sb	zero, 1460(sp)
   1b09e: a3 0a b1 5a  	sb	a1, 1461(sp)
   1b0a2: ad 65        	lui	a1, 11
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1b0a4: 2e 75        	ld	a0, 232(sp)
   1b0a6: 1b 86 05 a0  	addiw	a2, a1, -1536
;             include_directories.items,
   1b0aa: 23 1b c1 5a  	sh	a2, 1462(sp)
   1b0ae: 9b 85 a5 aa  	addiw	a1, a1, -1366
   1b0b2: 23 1c b1 5a  	sh	a1, 1464(sp)
   1b0b6: c2 75        	ld	a1, 48(sp)
   1b0b8: 63 63 b5 00  	bltu	a0, a1, 0x1b0be <dwarf.DwarfInfo.getLineNumberInfo+0x8e4>
   1b0bc: 2e 85        	mv	a0, a1
   1b0be: e6 75        	ld	a1, 120(sp)
;         const next_unit_pos = line_info_offset + next_offset;
   1b0c0: 66 66        	ld	a2, 88(sp)
   1b0c2: 33 8a c5 00  	add	s4, a1, a2
   1b0c6: aa f9        	sd	a0, 240(sp)
;         const next_unit_pos = line_info_offset + next_offset;
   1b0c8: 63 74 ba 00  	bgeu	s4, a1, 0x1b0d0 <dwarf.DwarfInfo.getLineNumberInfo+0x8f6>
   1b0cc: 6f 10 00 79  	j	0x1c85c <.LBB45_239+0xcfc>
;         while ((try seekable.getPos()) < next_unit_pos) {
   1b0d0: e3 7d 45 3f  	bgeu	a0, s4, 0x1bcca <.LBB45_239+0x16a>
   1b0d4: 6a 75        	ld	a0, 184(sp)
   1b0d6: 13 45 f5 ff  	not	a0, a0
   1b0da: 93 0c a0 0a  	li	s9, 170
   1b0de: 85 65        	lui	a1, 1
   1b0e0: 9b 85 05 88  	addiw	a1, a1, -1920
   1b0e4: b3 0a b1 00  	add	s5, sp, a1
   1b0e8: 85 4b        	li	s7, 1
   1b0ea: 89 49        	li	s3, 2
   1b0ec: b7 55 02 00  	lui	a1, 37
   1b0f0: 83 b5 85 37  	ld	a1, 888(a1)
   1b0f4: 2e f1        	sd	a1, 160(sp)
   1b0f6: a1 4d        	li	s11, 8
   1b0f8: 93 05 f0 0f  	li	a1, 255
   1b0fc: 13 96 85 01  	slli	a2, a1, 24
   1b100: b2 f8        	sd	a2, 112(sp)
   1b102: 41 66        	lui	a2, 16
   1b104: 1b 06 06 f0  	addiw	a2, a2, -256
   1b108: b2 f4        	sd	a2, 104(sp)
   1b10a: 13 96 85 02  	slli	a2, a1, 40
   1b10e: b2 f0        	sd	a2, 96(sp)
   1b110: c2 15        	slli	a1, a1, 48
   1b112: ae ec        	sd	a1, 88(sp)
   1b114: ad 65        	lui	a1, 11
   1b116: 9b 85 05 a0  	addiw	a1, a1, -1536
   1b11a: ae fc        	sd	a1, 120(sp)
   1b11c: b7 05 01 00  	lui	a1, 16
   1b120: 93 85 c5 62  	addi	a1, a1, 1580
   1b124: ae e9        	sd	a1, 208(sp)
   1b126: 13 75 f5 0f  	andi	a0, a0, 255
   1b12a: aa 75        	ld	a1, 168(sp)
   1b12c: 3b 55 b5 02  	divuw	a0, a0, a1
   1b130: b3 04 a9 02  	mul	s1, s2, a0
   1b134: a6 e1        	sd	s1, 192(sp)
   1b136: 29 a0        	j	0x1b140 <.LBB45_93+0x6>
   1b138: ae f9        	sd	a1, 240(sp)

000000000001b13a <.LBB45_93>:
;         while ((try seekable.getPos()) < next_unit_pos) {
   1b13a: 4e 75        	ld	a0, 240(sp)
   1b13c: e3 77 45 39  	bgeu	a0, s4, 0x1bcca <.LBB45_239+0x16a>
;             var result: [1]u8 = undefined;
   1b140: 05 65        	lui	a0, 1
   1b142: 1b 05 05 88  	addiw	a0, a0, -1920
   1b146: 0a 95        	add	a0, a0, sp
   1b148: 23 00 95 01  	sb	s9, 0(a0)
;             return readFn(self.context, buffer);
   1b14c: 05 65        	lui	a0, 1
   1b14e: 1b 05 85 88  	addiw	a0, a0, -1912
   1b152: 0a 95        	add	a0, a0, sp
   1b154: 8c 11        	addi	a1, sp, 224
   1b156: 05 66        	lui	a2, 1
   1b158: 1b 06 06 88  	addiw	a2, a2, -1920
   1b15c: 0a 96        	add	a2, a2, sp
   1b15e: 85 46        	li	a3, 1
   1b160: 97 60 00 00  	auipc	ra, 6
   1b164: e7 80 80 55  	jalr	1368(ra)
   1b168: 05 65        	lui	a0, 1
   1b16a: 1b 05 85 88  	addiw	a0, a0, -1912
   1b16e: 0a 95        	add	a0, a0, sp
   1b170: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1b172: e3 0e 05 66  	beqz	a0, 0x1bfee <.LBB45_239+0x48e>
;             return result[0];
   1b176: 05 65        	lui	a0, 1
   1b178: 1b 05 05 88  	addiw	a0, a0, -1920
   1b17c: 0a 95        	add	a0, a0, sp
   1b17e: 03 45 05 00  	lbu	a0, 0(a0)
;             if (opcode == LNS.extended_op) {
   1b182: 21 c5        	beqz	a0, 0x1b1ca <.LBB45_99+0x2e>
   1b184: ea 75        	ld	a1, 184(sp)
;             } else if (opcode >= opcode_base) {
   1b186: 63 76 b5 12  	bgeu	a0, a1, 0x1b2b2 <.LBB45_99+0x116>
;                 switch (opcode) {
   1b18a: 7d 15        	addi	a0, a0, -1
   1b18c: a5 45        	li	a1, 9
   1b18e: 63 eb a5 34  	bltu	a1, a0, 0x1b4e4 <.LBB45_99+0x348>
   1b192: 0a 05        	slli	a0, a0, 2
   1b194: ce 65        	ld	a1, 208(sp)
   1b196: 2e 95        	add	a0, a0, a1
   1b198: 08 41        	lw	a0, 0(a0)
   1b19a: 02 85        	jr	a0

000000000001b19c <.LBB45_99>:
;                         if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b19c: 3a 67        	ld	a4, 392(sp)
   1b19e: da 67        	ld	a5, 400(sp)
   1b1a0: 13 05 01 76  	addi	a0, sp, 1888
   1b1a4: 13 06 81 55  	addi	a2, sp, 1368
   1b1a8: ea 85        	mv	a1, s10
   1b1aa: e2 86        	mv	a3, s8
   1b1ac: 97 f0 ff ff  	auipc	ra, 1048575
   1b1b0: e7 80 80 31  	jalr	792(ra)
   1b1b4: 03 54 81 78  	lhu	s0, 1928(sp)
   1b1b8: 19 c0        	beqz	s0, 0x1b1be <.LBB45_99+0x22>
   1b1ba: 6f 10 e0 59  	j	0x1c758 <.LBB45_239+0xbf8>
   1b1be: 03 45 01 78  	lbu	a0, 1920(sp)
   1b1c2: 63 0d 05 16  	beqz	a0, 0x1b33c <.LBB45_99+0x1a0>
   1b1c6: 6f 10 c0 0e  	j	0x1c2b2 <.LBB45_239+0x752>
;                 const op_size = try leb.readULEB128(u64, in);
   1b1ca: 13 05 01 5d  	addi	a0, sp, 1488
   1b1ce: b0 19        	addi	a2, sp, 248
   1b1d0: ea 85        	mv	a1, s10
   1b1d2: 97 90 ff ff  	auipc	ra, 1048569
   1b1d6: e7 80 40 12  	jalr	292(ra)
   1b1da: 03 54 81 5d  	lhu	s0, 1496(sp)
   1b1de: 19 c0        	beqz	s0, 0x1b1e4 <.LBB45_99+0x48>
   1b1e0: 6f 10 60 19  	j	0x1c376 <.LBB45_239+0x816>
   1b1e4: 03 34 01 5d  	ld	s0, 1488(sp)
;                 if (op_size < 1) return badDwarf();
   1b1e8: 19 e0        	bnez	s0, 0x1b1ee <.LBB45_99+0x52>
   1b1ea: 6f 10 c0 1a  	j	0x1c396 <.LBB45_239+0x836>
;             var result: [1]u8 = undefined;
   1b1ee: 05 65        	lui	a0, 1
   1b1f0: 1b 05 05 88  	addiw	a0, a0, -1920
   1b1f4: 0a 95        	add	a0, a0, sp
   1b1f6: 23 00 95 01  	sb	s9, 0(a0)
;             return readFn(self.context, buffer);
   1b1fa: 05 65        	lui	a0, 1
   1b1fc: 1b 05 85 88  	addiw	a0, a0, -1912
   1b200: 0a 95        	add	a0, a0, sp
   1b202: 8c 11        	addi	a1, sp, 224
   1b204: 05 66        	lui	a2, 1
   1b206: 1b 06 06 88  	addiw	a2, a2, -1920
   1b20a: 0a 96        	add	a2, a2, sp
   1b20c: 85 46        	li	a3, 1
   1b20e: 97 60 00 00  	auipc	ra, 6
   1b212: e7 80 a0 4a  	jalr	1194(ra)
   1b216: 05 65        	lui	a0, 1
   1b218: 1b 05 85 88  	addiw	a0, a0, -1912
   1b21c: 0a 95        	add	a0, a0, sp
   1b21e: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1b220: 19 e1        	bnez	a0, 0x1b226 <.LBB45_99+0x8a>
   1b222: 6f 10 60 1a  	j	0x1c3c8 <.LBB45_239+0x868>
;             return result[0];
   1b226: 05 65        	lui	a0, 1
   1b228: 1b 05 05 88  	addiw	a0, a0, -1920
   1b22c: 0a 95        	add	a0, a0, sp
   1b22e: 03 45 05 00  	lbu	a0, 0(a0)
;                 switch (sub_op) {
   1b232: 8d 45        	li	a1, 3
   1b234: 63 07 b5 10  	beq	a0, a1, 0x1b342 <.LBB45_99+0x1a6>
   1b238: 63 03 35 1f  	beq	a0, s3, 0x1b41e <.LBB45_99+0x282>
   1b23c: 63 15 75 29  	bne	a0, s7, 0x1b4c6 <.LBB45_99+0x32a>
;                         if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b240: 3a 67        	ld	a4, 392(sp)
   1b242: da 67        	ld	a5, 400(sp)
;                         prog.end_sequence = true;
   1b244: 23 0a 71 5b  	sb	s7, 1460(sp)
;                         if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b248: 13 05 01 61  	addi	a0, sp, 1552
   1b24c: 13 06 81 55  	addi	a2, sp, 1368
   1b250: ea 85        	mv	a1, s10
   1b252: e2 86        	mv	a3, s8
   1b254: 97 f0 ff ff  	auipc	ra, 1048575
   1b258: e7 80 00 27  	jalr	624(ra)
   1b25c: 03 54 81 63  	lhu	s0, 1592(sp)
   1b260: 19 c0        	beqz	s0, 0x1b266 <.LBB45_99+0xca>
   1b262: 6f 10 a0 3f  	j	0x1c65c <.LBB45_239+0xafc>
   1b266: 03 45 01 63  	lbu	a0, 1584(sp)
   1b26a: e3 1a 05 3e  	bnez	a0, 0x1be5e <.LBB45_239+0x2fe>
;         self.address = 0;
   1b26e: 23 3c 01 54  	sd	zero, 1368(sp)
;         self.file = 1;
   1b272: 23 30 71 57  	sd	s7, 1376(sp)
;         self.line = 1;
   1b276: 23 34 71 57  	sd	s7, 1384(sp)
;         self.column = 0;
   1b27a: 23 38 01 56  	sd	zero, 1392(sp)
;         self.is_stmt = self.default_is_stmt;
   1b27e: 03 45 51 5b  	lbu	a0, 1461(sp)
   1b282: 05 89        	andi	a0, a0, 1
   1b284: 23 09 a1 5a  	sb	a0, 1458(sp)
;         self.basic_block = false;
   1b288: a3 09 01 5a  	sb	zero, 1459(sp)
;         self.end_sequence = false;
   1b28c: 23 0a 01 5a  	sb	zero, 1460(sp)
;         self.prev_valid = false;
   1b290: 66 75        	ld	a0, 120(sp)
   1b292: 23 1b a1 5a  	sh	a0, 1462(sp)
;         self.prev_address = 0;
   1b296: 23 38 01 58  	sd	zero, 1424(sp)
   1b29a: 2d 65        	lui	a0, 11
   1b29c: 1b 05 a5 aa  	addiw	a0, a0, -1366
;         self.prev_basic_block = undefined;
   1b2a0: 23 1c a1 5a  	sh	a0, 1464(sp)
   1b2a4: 13 05 81 59  	addi	a0, sp, 1432
   1b2a8: 8a 75        	ld	a1, 160(sp)
;         self.prev_line = undefined;
   1b2aa: 0c e5        	sd	a1, 8(a0)
   1b2ac: 0c e9        	sd	a1, 16(a0)
   1b2ae: 0c e1        	sd	a1, 0(a0)
   1b2b0: 69 b5        	j	0x1b13a <.LBB45_93>
;                 const adjusted_opcode = opcode - opcode_base;
   1b2b2: b3 05 b5 40  	sub	a1, a0, a1
;                 const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
   1b2b6: 13 f5 f5 0f  	andi	a0, a1, 255
   1b2ba: 2a 77        	ld	a4, 168(sp)
   1b2bc: 13 76 f7 0f  	andi	a2, a4, 255
   1b2c0: 3b 56 c5 02  	divuw	a2, a0, a2
   1b2c4: 33 05 c9 02  	mul	a0, s2, a2
   1b2c8: 93 56 85 00  	srli	a3, a0, 8
   1b2cc: 99 c2        	beqz	a3, 0x1b2d2 <.LBB45_99+0x136>
   1b2ce: 6f 10 e0 58  	j	0x1c85c <.LBB45_239+0xcfc>
   1b2d2: 3b 06 e6 02  	mulw	a2, a2, a4
;                 prog.line += inc_line;
   1b2d6: 83 36 81 56  	ld	a3, 1384(sp)
   1b2da: 91 9d        	subw	a1, a1, a2
;                 const inc_line = @as(i32, line_base) + @as(i32, adjusted_opcode % line_range);
   1b2dc: 93 f5 f5 0f  	andi	a1, a1, 255
   1b2e0: 4a 76        	ld	a2, 176(sp)
   1b2e2: 2e 96        	add	a2, a2, a1
;                 prog.line += inc_line;
   1b2e4: b3 85 c6 00  	add	a1, a3, a2
   1b2e8: b3 a6 d5 00  	slt	a3, a1, a3
   1b2ec: 13 26 06 00  	slti	a2, a2, 0
   1b2f0: 63 04 d6 00  	beq	a2, a3, 0x1b2f8 <.LBB45_99+0x15c>
   1b2f4: 6f 10 80 56  	j	0x1c85c <.LBB45_239+0xcfc>
   1b2f8: 23 34 b1 56  	sd	a1, 1384(sp)
;                 prog.address += inc_addr;
   1b2fc: 83 35 81 55  	ld	a1, 1368(sp)
   1b300: 13 75 f5 0f  	andi	a0, a0, 255
   1b304: 2e 95        	add	a0, a0, a1
   1b306: 63 74 b5 00  	bgeu	a0, a1, 0x1b30e <.LBB45_99+0x172>
   1b30a: 6f 10 20 55  	j	0x1c85c <.LBB45_239+0xcfc>
;                 if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b30e: 3a 67        	ld	a4, 392(sp)
   1b310: da 67        	ld	a5, 400(sp)
;                 prog.address += inc_addr;
   1b312: 23 3c a1 54  	sd	a0, 1368(sp)
;                 if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b316: 13 05 01 70  	addi	a0, sp, 1792
   1b31a: 13 06 81 55  	addi	a2, sp, 1368
   1b31e: ea 85        	mv	a1, s10
   1b320: e2 86        	mv	a3, s8
   1b322: 97 f0 ff ff  	auipc	ra, 1048575
   1b326: e7 80 20 1a  	jalr	418(ra)
   1b32a: 03 54 81 72  	lhu	s0, 1832(sp)
   1b32e: 19 c0        	beqz	s0, 0x1b334 <.LBB45_99+0x198>
   1b330: 6f 10 00 0d  	j	0x1c400 <.LBB45_239+0x8a0>
   1b334: 03 45 01 72  	lbu	a0, 1824(sp)
   1b338: 63 15 05 66  	bnez	a0, 0x1b9a2 <.LBB45_180+0x1c8>
   1b33c: a3 09 01 5a  	sb	zero, 1459(sp)
   1b340: ed bb        	j	0x1b13a <.LBB45_93>
;                         const path = try in.readUntilDelimiterAlloc(arena, 0, math.maxInt(usize));
   1b342: 13 05 01 66  	addi	a0, sp, 1632
   1b346: 90 11        	addi	a2, sp, 224
   1b348: 94 0a        	addi	a3, sp, 336
   1b34a: ea 85        	mv	a1, s10
   1b34c: 97 e0 ff ff  	auipc	ra, 1048574
   1b350: e7 80 20 60  	jalr	1538(ra)
   1b354: 03 54 01 67  	lhu	s0, 1648(sp)
   1b358: 19 c0        	beqz	s0, 0x1b35e <.LBB45_99+0x1c2>
   1b35a: 6f 10 20 32  	j	0x1c67c <.LBB45_239+0xb1c>
   1b35e: 03 3b 01 66  	ld	s6, 1632(sp)
   1b362: 83 3b 81 66  	ld	s7, 1640(sp)
;                         const dir_index = try leb.readULEB128(u32, in);
   1b366: 13 05 81 68  	addi	a0, sp, 1672
   1b36a: b0 19        	addi	a2, sp, 248
   1b36c: ea 85        	mv	a1, s10
   1b36e: 97 f0 ff ff  	auipc	ra, 1048575
   1b372: e7 80 a0 9a  	jalr	-1622(ra)
   1b376: 03 54 c1 68  	lhu	s0, 1676(sp)
   1b37a: 19 c0        	beqz	s0, 0x1b380 <.LBB45_99+0x1e4>
   1b37c: 6f 10 40 35  	j	0x1c6d0 <.LBB45_239+0xb70>
   1b380: 03 2c 81 68  	lw	s8, 1672(sp)
;                         const mtime = try leb.readULEB128(u64, in);
   1b384: 13 05 01 6a  	addi	a0, sp, 1696
   1b388: b0 19        	addi	a2, sp, 248
   1b38a: ea 85        	mv	a1, s10
   1b38c: 97 90 ff ff  	auipc	ra, 1048569
   1b390: e7 80 a0 f6  	jalr	-150(ra)
   1b394: 03 54 81 6a  	lhu	s0, 1704(sp)
   1b398: 19 c0        	beqz	s0, 0x1b39e <.LBB45_99+0x202>
   1b39a: 6f 10 60 35  	j	0x1c6f0 <.LBB45_239+0xb90>
   1b39e: 03 34 01 6a  	ld	s0, 1696(sp)
;                         const size = try leb.readULEB128(u64, in);
   1b3a2: 13 05 01 6c  	addi	a0, sp, 1728
   1b3a6: b0 19        	addi	a2, sp, 248
   1b3a8: ea 85        	mv	a1, s10
   1b3aa: 97 90 ff ff  	auipc	ra, 1048569
   1b3ae: e7 80 c0 f4  	jalr	-180(ra)
   1b3b2: 83 54 81 6c  	lhu	s1, 1736(sp)
   1b3b6: 99 c0        	beqz	s1, 0x1b3bc <.LBB45_99+0x220>
   1b3b8: 6f 10 60 35  	j	0x1c70e <.LBB45_239+0xbae>
   1b3bc: 03 39 01 6c  	ld	s2, 1728(sp)
;             const new_item_ptr = try self.addOne();
   1b3c0: 05 65        	lui	a0, 1
   1b3c2: 1b 05 85 88  	addiw	a0, a0, -1912
   1b3c6: 0a 95        	add	a0, a0, sp
   1b3c8: 30 03        	addi	a2, sp, 392
   1b3ca: ea 85        	mv	a1, s10
   1b3cc: 97 60 00 00  	auipc	ra, 6
   1b3d0: e7 80 00 79  	jalr	1936(ra)
   1b3d4: 05 65        	lui	a0, 1
   1b3d6: 1b 05 05 89  	addiw	a0, a0, -1904
   1b3da: 0a 95        	add	a0, a0, sp
   1b3dc: 83 54 05 00  	lhu	s1, 0(a0)
   1b3e0: 99 c0        	beqz	s1, 0x1b3e6 <.LBB45_99+0x24a>
   1b3e2: 6f 10 c0 34  	j	0x1c72e <.LBB45_239+0xbce>
   1b3e6: 05 65        	lui	a0, 1
   1b3e8: 1b 05 85 88  	addiw	a0, a0, -1912
   1b3ec: 0a 95        	add	a0, a0, sp
   1b3ee: 08 61        	ld	a0, 0(a0)
;             new_item_ptr.* = item;
   1b3f0: 23 30 65 01  	sd	s6, 0(a0)
   1b3f4: 23 34 75 01  	sd	s7, 8(a0)
   1b3f8: 00 e9        	sd	s0, 16(a0)
   1b3fa: 23 3c 25 01  	sd	s2, 24(a0)
   1b3fe: 23 20 85 03  	sw	s8, 32(a0)
   1b402: 23 22 05 02  	sw	zero, 36(a0)
   1b406: 23 24 05 02  	sw	zero, 40(a0)
   1b40a: 23 26 05 02  	sw	zero, 44(a0)
   1b40e: 23 28 05 02  	sw	zero, 48(a0)
   1b412: 2a 6b        	ld	s6, 136(sp)
   1b414: 6a 6c        	ld	s8, 152(sp)
   1b416: 0a 69        	ld	s2, 128(sp)
   1b418: 85 4b        	li	s7, 1
   1b41a: 8e 64        	ld	s1, 192(sp)
   1b41c: 39 bb        	j	0x1b13a <.LBB45_93>
;                         const addr = try in.readInt(usize, di.endian);
   1b41e: 6e 65        	ld	a0, 216(sp)
   1b420: 03 04 85 10  	lb	s0, 264(a0)
   1b424: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1b426: 0a 75        	ld	a0, 160(sp)
   1b428: 85 65        	lui	a1, 1
   1b42a: 9b 85 05 88  	addiw	a1, a1, -1920
   1b42e: 8a 95        	add	a1, a1, sp
   1b430: 88 e1        	sd	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1b432: 33 86 9a 00  	add	a2, s5, s1
   1b436: b3 86 9d 40  	sub	a3, s11, s1
;             return readFn(self.context, buffer);
   1b43a: 05 65        	lui	a0, 1
   1b43c: 1b 05 85 88  	addiw	a0, a0, -1912
   1b440: 0a 95        	add	a0, a0, sp
   1b442: 8c 11        	addi	a1, sp, 224
   1b444: 97 60 00 00  	auipc	ra, 6
   1b448: e7 80 40 27  	jalr	628(ra)
   1b44c: 05 65        	lui	a0, 1
   1b44e: 1b 05 85 88  	addiw	a0, a0, -1912
   1b452: 0a 95        	add	a0, a0, sp
   1b454: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1b456: 63 0e 05 7c  	beqz	a0, 0x1bc32 <.LBB45_239+0xd2>
;                 index += amt;
   1b45a: 26 95        	add	a0, a0, s1
   1b45c: 63 74 95 00  	bgeu	a0, s1, 0x1b464 <.LBB45_99+0x2c8>
   1b460: 6f 10 c0 3f  	j	0x1c85c <.LBB45_239+0xcfc>
   1b464: aa 84        	mv	s1, a0
;             while (index < len) {
   1b466: e3 66 b5 fd  	bltu	a0, s11, 0x1b432 <.LBB45_99+0x296>
;             return bytes;
   1b46a: 05 65        	lui	a0, 1
   1b46c: 1b 05 05 88  	addiw	a0, a0, -1920
   1b470: 0a 95        	add	a0, a0, sp
   1b472: 08 61        	ld	a0, 0(a0)
;     if (endian == native_endian) {
   1b474: 93 75 14 00  	andi	a1, s0, 1
   1b478: b9 e1        	bnez	a1, 0x1b4be <.LBB45_99+0x322>
   1b47a: 93 55 85 01  	srli	a1, a0, 24
   1b47e: 37 06 ff 00  	lui	a2, 4080
   1b482: f1 8d        	and	a1, a1, a2
   1b484: 13 56 85 00  	srli	a2, a0, 8
   1b488: c6 76        	ld	a3, 112(sp)
   1b48a: 75 8e        	and	a2, a2, a3
   1b48c: d1 8d        	or	a1, a1, a2
   1b48e: 13 56 85 02  	srli	a2, a0, 40
   1b492: a6 76        	ld	a3, 104(sp)
   1b494: 75 8e        	and	a2, a2, a3
   1b496: 93 56 85 03  	srli	a3, a0, 56
   1b49a: 55 8e        	or	a2, a2, a3
   1b49c: d1 8d        	or	a1, a1, a2
   1b49e: 13 16 85 01  	slli	a2, a0, 24
   1b4a2: 86 76        	ld	a3, 96(sp)
   1b4a4: 75 8e        	and	a2, a2, a3
   1b4a6: 9b 56 85 01  	srliw	a3, a0, 24
   1b4aa: 82 16        	slli	a3, a3, 32
   1b4ac: 55 8e        	or	a2, a2, a3
   1b4ae: 93 16 85 02  	slli	a3, a0, 40
   1b4b2: 66 67        	ld	a4, 88(sp)
   1b4b4: f9 8e        	and	a3, a3, a4
   1b4b6: 62 15        	slli	a0, a0, 56
   1b4b8: 55 8d        	or	a0, a0, a3
   1b4ba: 51 8d        	or	a0, a0, a2
   1b4bc: 4d 8d        	or	a0, a0, a1
   1b4be: 8e 64        	ld	s1, 192(sp)
;                         prog.address = addr;
   1b4c0: 23 3c a1 54  	sd	a0, 1368(sp)
   1b4c4: 9d b9        	j	0x1b13a <.LBB45_93>
;                         const fwd_amt = math.cast(isize, op_size - 1) orelse return badDwarf();
   1b4c6: 13 05 f4 ff  	addi	a0, s0, -1
;     if ((is_comptime or maxInt(@TypeOf(x)) > maxInt(T)) and x > maxInt(T)) {
   1b4ca: 63 54 05 00  	bgez	a0, 0x1b4d2 <.LBB45_99+0x336>
   1b4ce: 6f 10 e0 1c  	j	0x1c69c <.LBB45_239+0xb3c>
   1b4d2: ce 75        	ld	a1, 240(sp)
   1b4d4: 2e 95        	add	a0, a0, a1
   1b4d6: 63 67 b5 02  	bltu	a0, a1, 0x1b504 <.LBB45_99+0x368>
   1b4da: ae 75        	ld	a1, 232(sp)
   1b4dc: e3 ee a5 c4  	bltu	a1, a0, 0x1b138 <dwarf.DwarfInfo.getLineNumberInfo+0x95e>
   1b4e0: aa 85        	mv	a1, a0
   1b4e2: 99 b9        	j	0x1b138 <dwarf.DwarfInfo.getLineNumberInfo+0x95e>
;                         if (opcode - 1 >= standard_opcode_lengths.len) return badDwarf();
   1b4e4: 13 75 f5 0f  	andi	a0, a0, 255
   1b4e8: 83 45 81 03  	lbu	a1, 56(sp)
   1b4ec: 63 64 b5 00  	bltu	a0, a1, 0x1b4f4 <.LBB45_99+0x358>
   1b4f0: 6f 10 80 28  	j	0x1c778 <.LBB45_239+0xc18>
;                         const len_bytes = standard_opcode_lengths[opcode - 1];
   1b4f4: ae 65        	ld	a1, 200(sp)
   1b4f6: 2e 95        	add	a0, a0, a1
   1b4f8: 03 45 05 00  	lbu	a0, 0(a0)
   1b4fc: ce 75        	ld	a1, 240(sp)
   1b4fe: 2e 95        	add	a0, a0, a1
   1b500: e3 7d b5 fc  	bgeu	a0, a1, 0x1b4da <.LBB45_99+0x33e>
   1b504: 03 34 0d 00  	ld	s0, 0(s10)
   1b508: 6a 85        	mv	a0, s10
   1b50a: 97 80 00 00  	auipc	ra, 8
   1b50e: e7 80 e0 6e  	jalr	1774(ra)
   1b512: 23 30 8d 00  	sd	s0, 0(s10)
   1b516: 7d 55        	li	a0, -1
   1b518: ae 75        	ld	a1, 232(sp)
   1b51a: e3 ef a5 c0  	bltu	a1, a0, 0x1b138 <dwarf.DwarfInfo.getLineNumberInfo+0x95e>
   1b51e: c9 b7        	j	0x1b4e0 <.LBB45_99+0x344>

000000000001b520 <.LBB45_136>:
;                         const arg = try leb.readULEB128(usize, in);
   1b520: 13 05 01 7b  	addi	a0, sp, 1968
   1b524: b0 19        	addi	a2, sp, 248
   1b526: ea 85        	mv	a1, s10
   1b528: 97 f0 ff ff  	auipc	ra, 1048575
   1b52c: e7 80 00 ae  	jalr	-1312(ra)
   1b530: 03 54 81 7b  	lhu	s0, 1976(sp)
   1b534: 19 c0        	beqz	s0, 0x1b53a <.LBB45_136+0x1a>
   1b536: 6f 10 40 28  	j	0x1c7ba <.LBB45_239+0xc5a>
   1b53a: 03 35 01 7b  	ld	a0, 1968(sp)
;                         prog.address += arg * minimum_instruction_length;
   1b53e: b3 35 25 03  	mulhu	a1, a0, s2
   1b542: 99 c1        	beqz	a1, 0x1b548 <.LBB45_136+0x28>
   1b544: 6f 10 80 31  	j	0x1c85c <.LBB45_239+0xcfc>
   1b548: 83 35 81 55  	ld	a1, 1368(sp)
   1b54c: 33 05 25 03  	mul	a0, a0, s2
;                         prog.address += arg * minimum_instruction_length;
   1b550: 2e 95        	add	a0, a0, a1
   1b552: 63 78 b5 14  	bgeu	a0, a1, 0x1b6a2 <.LBB45_150+0x80>
   1b556: 6f 10 60 30  	j	0x1c85c <.LBB45_239+0xcfc>

000000000001b55a <.LBB45_139>:
;                         const arg = try leb.readILEB128(i64, in);
   1b55a: 13 05 01 7d  	addi	a0, sp, 2000
   1b55e: b0 19        	addi	a2, sp, 248
   1b560: ea 85        	mv	a1, s10
   1b562: 97 90 ff ff  	auipc	ra, 1048569
   1b566: e7 80 e0 fc  	jalr	-50(ra)
   1b56a: 03 54 81 7d  	lhu	s0, 2008(sp)
   1b56e: 19 c0        	beqz	s0, 0x1b574 <.LBB45_139+0x1a>
   1b570: 6f 10 a0 26  	j	0x1c7da <.LBB45_239+0xc7a>
   1b574: 83 35 01 7d  	ld	a1, 2000(sp)
;                         prog.line += arg;
   1b578: 03 36 81 56  	ld	a2, 1384(sp)
   1b57c: 33 05 b6 00  	add	a0, a2, a1
   1b580: 33 26 c5 00  	slt	a2, a0, a2
   1b584: 93 a5 05 00  	slti	a1, a1, 0
   1b588: 63 84 c5 00  	beq	a1, a2, 0x1b590 <.LBB45_139+0x36>
   1b58c: 6f 10 00 2d  	j	0x1c85c <.LBB45_239+0xcfc>
   1b590: 23 34 a1 56  	sd	a0, 1384(sp)
   1b594: 5d b6        	j	0x1b13a <.LBB45_93>

000000000001b596 <.LBB45_142>:
;                         const arg = try leb.readULEB128(usize, in);
   1b596: 13 05 01 7f  	addi	a0, sp, 2032
   1b59a: b0 19        	addi	a2, sp, 248
   1b59c: ea 85        	mv	a1, s10
   1b59e: 97 f0 ff ff  	auipc	ra, 1048575
   1b5a2: e7 80 a0 a6  	jalr	-1430(ra)
   1b5a6: 03 54 81 7f  	lhu	s0, 2040(sp)
   1b5aa: 19 c0        	beqz	s0, 0x1b5b0 <.LBB45_142+0x1a>
   1b5ac: 6f 10 e0 24  	j	0x1c7fa <.LBB45_239+0xc9a>
   1b5b0: 03 35 01 7f  	ld	a0, 2032(sp)
;                         prog.file = arg;
   1b5b4: 23 30 a1 56  	sd	a0, 1376(sp)
   1b5b8: 49 b6        	j	0x1b13a <.LBB45_93>

000000000001b5ba <.LBB45_144>:
;                         const arg = try leb.readULEB128(u64, in);
   1b5ba: 05 65        	lui	a0, 1
   1b5bc: 1b 05 05 81  	addiw	a0, a0, -2032
   1b5c0: 0a 95        	add	a0, a0, sp
   1b5c2: b0 19        	addi	a2, sp, 248
   1b5c4: ea 85        	mv	a1, s10
   1b5c6: 97 90 ff ff  	auipc	ra, 1048569
   1b5ca: e7 80 00 d3  	jalr	-720(ra)
   1b5ce: 05 65        	lui	a0, 1
   1b5d0: 1b 05 85 81  	addiw	a0, a0, -2024
   1b5d4: 0a 95        	add	a0, a0, sp
   1b5d6: 03 54 05 00  	lhu	s0, 0(a0)
   1b5da: 19 c0        	beqz	s0, 0x1b5e0 <.LBB45_144+0x26>
   1b5dc: 6f 10 c0 24  	j	0x1c828 <.LBB45_239+0xcc8>
   1b5e0: 05 65        	lui	a0, 1
   1b5e2: 1b 05 05 81  	addiw	a0, a0, -2032
   1b5e6: 0a 95        	add	a0, a0, sp
   1b5e8: 08 61        	ld	a0, 0(a0)
;                         prog.column = arg;
   1b5ea: 23 38 a1 56  	sd	a0, 1392(sp)
   1b5ee: b1 b6        	j	0x1b13a <.LBB45_93>

000000000001b5f0 <.LBB45_146>:
;                         prog.is_stmt = !prog.is_stmt;
   1b5f0: 03 05 21 5b  	lb	a0, 1458(sp)
   1b5f4: 13 45 f5 ff  	not	a0, a0
   1b5f8: 05 89        	andi	a0, a0, 1
   1b5fa: 23 09 a1 5a  	sb	a0, 1458(sp)
   1b5fe: 35 be        	j	0x1b13a <.LBB45_93>

000000000001b600 <.LBB45_147>:
;                         prog.basic_block = true;
   1b600: a3 09 71 5b  	sb	s7, 1459(sp)
   1b604: 1d be        	j	0x1b13a <.LBB45_93>

000000000001b606 <.LBB45_148>:
;                         const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
   1b606: 13 d5 84 00  	srli	a0, s1, 8
   1b60a: 19 c1        	beqz	a0, 0x1b610 <.LBB45_148+0xa>
   1b60c: 6f 10 00 25  	j	0x1c85c <.LBB45_239+0xcfc>
;                         prog.address += inc_addr;
   1b610: 83 35 81 55  	ld	a1, 1368(sp)
   1b614: 13 f5 f4 0f  	andi	a0, s1, 255
   1b618: 2e 95        	add	a0, a0, a1
   1b61a: 63 74 b5 08  	bgeu	a0, a1, 0x1b6a2 <.LBB45_150+0x80>
   1b61e: 6f 10 e0 23  	j	0x1c85c <.LBB45_239+0xcfc>

000000000001b622 <.LBB45_150>:
;                         const arg = try in.readInt(u16, di.endian);
   1b622: 6e 65        	ld	a0, 216(sp)
   1b624: 03 04 85 10  	lb	s0, 264(a0)
   1b628: 81 44        	li	s1, 0
   1b62a: 2d 65        	lui	a0, 11
   1b62c: 1b 05 a5 aa  	addiw	a0, a0, -1366
;             var bytes: [num_bytes]u8 = undefined;
   1b630: 85 65        	lui	a1, 1
   1b632: 9b 85 05 88  	addiw	a1, a1, -1920
   1b636: 8a 95        	add	a1, a1, sp
   1b638: 23 90 a5 00  	sh	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1b63c: 33 86 9a 00  	add	a2, s5, s1
   1b640: b3 86 99 40  	sub	a3, s3, s1
;             return readFn(self.context, buffer);
   1b644: 05 65        	lui	a0, 1
   1b646: 1b 05 85 88  	addiw	a0, a0, -1912
   1b64a: 0a 95        	add	a0, a0, sp
   1b64c: 8c 11        	addi	a1, sp, 224
   1b64e: 97 60 00 00  	auipc	ra, 6
   1b652: e7 80 a0 06  	jalr	106(ra)
   1b656: 05 65        	lui	a0, 1
   1b658: 1b 05 85 88  	addiw	a0, a0, -1912
   1b65c: 0a 95        	add	a0, a0, sp
   1b65e: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1b660: e3 0c 05 1a  	beqz	a0, 0x1c018 <.LBB45_239+0x4b8>
;                 index += amt;
   1b664: 26 95        	add	a0, a0, s1
   1b666: 63 74 95 00  	bgeu	a0, s1, 0x1b66e <.LBB45_150+0x4c>
   1b66a: 6f 10 20 1f  	j	0x1c85c <.LBB45_239+0xcfc>
   1b66e: aa 84        	mv	s1, a0
;             while (index < len) {
   1b670: e3 66 35 fd  	bltu	a0, s3, 0x1b63c <.LBB45_150+0x1a>
;             return bytes;
   1b674: 05 65        	lui	a0, 1
   1b676: 1b 05 05 88  	addiw	a0, a0, -1920
   1b67a: 0a 95        	add	a0, a0, sp
   1b67c: 03 55 05 00  	lhu	a0, 0(a0)
;     if (endian == native_endian) {
   1b680: 93 75 14 00  	andi	a1, s0, 1
   1b684: 89 e5        	bnez	a1, 0x1b68e <.LBB45_150+0x6c>
   1b686: 93 55 85 00  	srli	a1, a0, 8
   1b68a: 22 05        	slli	a0, a0, 8
   1b68c: 4d 8d        	or	a0, a0, a1
   1b68e: 8e 64        	ld	s1, 192(sp)
;                         prog.address += arg;
   1b690: 83 35 81 55  	ld	a1, 1368(sp)
   1b694: 42 15        	slli	a0, a0, 48
   1b696: 41 91        	srli	a0, a0, 48
   1b698: 2e 95        	add	a0, a0, a1
   1b69a: 63 74 b5 00  	bgeu	a0, a1, 0x1b6a2 <.LBB45_150+0x80>
   1b69e: 6f 10 e0 1b  	j	0x1c85c <.LBB45_239+0xcfc>
   1b6a2: 23 3c a1 54  	sd	a0, 1368(sp)
   1b6a6: 51 bc        	j	0x1b13a <.LBB45_93>
   1b6a8: ce f4        	sd	s3, 104(sp)
;             return self.ensureTotalCapacityPrecise(better_capacity);
   1b6aa: 8c 12        	addi	a1, sp, 352
   1b6ac: 6a 85        	mv	a0, s10
   1b6ae: 97 70 00 00  	auipc	ra, 7
   1b6b2: e7 80 80 7a  	jalr	1960(ra)
   1b6b6: aa 8c        	mv	s9, a0
   1b6b8: 42 15        	slli	a0, a0, 48
   1b6ba: 41 91        	srli	a0, a0, 48
   1b6bc: e3 16 05 32  	bnez	a0, 0x1c1e8 <.LBB45_239+0x688>
   1b6c0: 22 ec        	sd	s0, 24(sp)
   1b6c2: 5e f0        	sd	s7, 32(sp)
   1b6c4: 36 76        	ld	a2, 360(sp)
   1b6c6: d6 75        	ld	a1, 368(sp)
;                     while (i < directories_count) : (i += 1) {
   1b6c8: 33 85 c5 40  	sub	a0, a1, a2
   1b6cc: 82 f0        	sd	zero, 96(sp)
   1b6ce: 63 e3 a5 00  	bltu	a1, a0, 0x1b6d4 <.LBB45_150+0xb2>
   1b6d2: aa f0        	sd	a0, 96(sp)
   1b6d4: 81 4b        	li	s7, 0
   1b6d6: 16 75        	ld	a0, 352(sp)
;                     while (i < directories_count) : (i += 1) {
   1b6d8: aa f8        	sd	a0, 112(sp)
   1b6da: 11 4a        	li	s4, 4
   1b6dc: 37 05 01 00  	lui	a0, 16
   1b6e0: 93 0a 45 60  	addi	s5, a0, 1540
   1b6e4: a6 e8        	sd	s1, 80(sp)
   1b6e6: 32 f1        	sd	a2, 160(sp)
;                         var e: FileEntry = .{ .path = &.{} };
   1b6e8: 23 3c 01 32  	sd	zero, 824(sp)
   1b6ec: 23 38 01 32  	sd	zero, 816(sp)
   1b6f0: a6 7c        	ld	s9, 104(sp)
;                         for (dir_ent_fmt_buf[0..directory_entry_format_count]) |ent_fmt| {
   1b6f2: 63 82 0c 10  	beqz	s9, 0x1b7f6 <.LBB45_180+0x1c>
   1b6f6: 81 49        	li	s3, 0
   1b6f8: 01 49        	li	s2, 0
   1b6fa: 81 44        	li	s1, 0
   1b6fc: 01 4b        	li	s6, 0
   1b6fe: 82 e1        	sd	zero, 192(sp)
   1b700: 13 0c a1 28  	addi	s8, sp, 650
   1b704: 39 a0        	j	0x1b712 <.LBB45_150+0xf0>
   1b706: 03 3b 01 36  	ld	s6, 864(sp)
;                         for (dir_ent_fmt_buf[0..directory_entry_format_count]) |ent_fmt| {
   1b70a: fd 1c        	addi	s9, s9, -1
   1b70c: 11 0c        	addi	s8, s8, 4
   1b70e: 63 89 0c 0e  	beqz	s9, 0x1b800 <.LBB45_180+0x26>
   1b712: 03 57 ec ff  	lhu	a4, -2(s8)
   1b716: 03 44 0c 00  	lbu	s0, 0(s8)
;                                 di.endian,
   1b71a: 6e 65        	ld	a0, 216(sp)
   1b71c: 83 07 85 10  	lb	a5, 264(a0)
   1b720: 88 06        	addi	a0, sp, 832
   1b722: 90 0a        	addi	a2, sp, 336
   1b724: b4 19        	addi	a3, sp, 248
   1b726: ea 85        	mv	a1, s10
   1b728: 4e 68        	ld	a6, 208(sp)
   1b72a: 97 c0 ff ff  	auipc	ra, 1048572
   1b72e: e7 80 60 51  	jalr	1302(ra)
   1b732: 83 5d 81 35  	lhu	s11, 856(sp)
   1b736: 63 99 0d 4a  	bnez	s11, 0x1bbe8 <.LBB45_239+0x88>
;                             const form_value = try parseFormValue(
   1b73a: 03 35 01 35  	ld	a0, 848(sp)
   1b73e: 83 35 81 34  	ld	a1, 840(sp)
   1b742: 03 36 01 34  	ld	a2, 832(sp)
   1b746: 23 38 a1 36  	sd	a0, 880(sp)
   1b74a: 23 34 b1 36  	sd	a1, 872(sp)
;                             switch (ent_fmt.content_type_code) {
   1b74e: 13 05 f4 ff  	addi	a0, s0, -1
;                             const form_value = try parseFormValue(
   1b752: 23 30 c1 36  	sd	a2, 864(sp)
;                             switch (ent_fmt.content_type_code) {
   1b756: e3 6a aa fa  	bltu	s4, a0, 0x1b70a <.LBB45_150+0xe8>
   1b75a: 0a 05        	slli	a0, a0, 2
   1b75c: 56 95        	add	a0, a0, s5
   1b75e: 08 41        	lw	a0, 0(a0)
   1b760: 02 85        	jr	a0

000000000001b762 <.LBB45_169>:
;                                 LNCT.path => e.path = try form_value.getString(di.*),
   1b762: a8 1e        	addi	a0, sp, 888
   1b764: 90 16        	addi	a2, sp, 864
   1b766: ea 85        	mv	a1, s10
   1b768: ee 66        	ld	a3, 216(sp)
   1b76a: 97 f0 ff ff  	auipc	ra, 1048575
   1b76e: e7 80 80 ad  	jalr	-1320(ra)
   1b772: 03 54 81 38  	lhu	s0, 904(sp)
   1b776: e3 11 04 1e  	bnez	s0, 0x1c158 <.LBB45_239+0x5f8>
   1b77a: 83 39 81 37  	ld	s3, 888(sp)
   1b77e: 03 39 01 38  	ld	s2, 896(sp)
   1b782: 61 b7        	j	0x1b70a <.LBB45_150+0xe8>

000000000001b784 <.LBB45_171>:
;                                 LNCT.directory_index => e.dir_index = try form_value.getUInt(u32),
   1b784: 08 17        	addi	a0, sp, 928
   1b786: 90 16        	addi	a2, sp, 864
   1b788: ea 85        	mv	a1, s10
   1b78a: 97 f0 ff ff  	auipc	ra, 1048575
   1b78e: e7 80 40 cb  	jalr	-844(ra)
   1b792: 03 54 41 3a  	lhu	s0, 932(sp)
   1b796: e3 11 04 1e  	bnez	s0, 0x1c178 <.LBB45_239+0x618>
   1b79a: 03 25 01 3a  	lw	a0, 928(sp)
   1b79e: aa e1        	sd	a0, 192(sp)
   1b7a0: ad b7        	j	0x1b70a <.LBB45_150+0xe8>

000000000001b7a2 <.LBB45_173>:
;         switch (fv) {
   1b7a2: 03 45 01 37  	lbu	a0, 880(sp)
   1b7a6: 99 45        	li	a1, 6
   1b7a8: 63 09 b5 00  	beq	a0, a1, 0x1b7ba <.LBB45_173+0x18>
   1b7ac: 8d 45        	li	a1, 3
   1b7ae: e3 19 b5 46  	bne	a0, a1, 0x1c420 <.LBB45_239+0x8c0>
   1b7b2: 03 45 81 36  	lbu	a0, 872(sp)
;         if (self.signed) return badDwarf();
   1b7b6: e3 1b 05 46  	bnez	a0, 0x1c42c <.LBB45_239+0x8cc>
   1b7ba: 83 34 01 36  	ld	s1, 864(sp)
   1b7be: b1 b7        	j	0x1b70a <.LBB45_150+0xe8>

000000000001b7c0 <.LBB45_177>:
;         switch (fv) {
   1b7c0: 03 45 01 37  	lbu	a0, 880(sp)
   1b7c4: 99 45        	li	a1, 6
   1b7c6: e3 00 b5 f4  	beq	a0, a1, 0x1b706 <.LBB45_150+0xe4>
   1b7ca: 8d 45        	li	a1, 3
   1b7cc: e3 1d b5 44  	bne	a0, a1, 0x1c426 <.LBB45_239+0x8c6>
   1b7d0: 03 45 81 36  	lbu	a0, 872(sp)
;         if (self.signed) return badDwarf();
   1b7d4: 0d d9        	beqz	a0, 0x1b706 <.LBB45_150+0xe4>
   1b7d6: 6f 00 50 49  	j	0x1c46a <.LBB45_239+0x90a>

000000000001b7da <.LBB45_180>:
;         switch (fv) {
   1b7da: 03 45 01 37  	lbu	a0, 880(sp)
   1b7de: bd 45        	li	a1, 15
   1b7e0: e3 1a b5 1c  	bne	a0, a1, 0x1c1b4 <.LBB45_239+0x654>
;             .data16 => |d| return d,
   1b7e4: 03 35 81 34  	ld	a0, 840(sp)
   1b7e8: 83 35 01 34  	ld	a1, 832(sp)
   1b7ec: 23 3c a1 32  	sd	a0, 824(sp)
   1b7f0: 23 38 b1 32  	sd	a1, 816(sp)
   1b7f4: 19 bf        	j	0x1b70a <.LBB45_150+0xe8>
   1b7f6: 82 e1        	sd	zero, 192(sp)
   1b7f8: 01 4b        	li	s6, 0
   1b7fa: 81 44        	li	s1, 0
   1b7fc: 01 49        	li	s2, 0
   1b7fe: 81 49        	li	s3, 0
   1b800: 6a 6c        	ld	s8, 152(sp)
;     if (!ok) unreachable; // assertion failure
   1b802: 06 75        	ld	a0, 96(sp)
   1b804: 63 94 ab 00  	bne	s7, a0, 0x1b80c <.LBB45_180+0x32>
   1b808: 6f 10 80 06  	j	0x1c870 <.LBB45_239+0xd10>
   1b80c: 0a 76        	ld	a2, 160(sp)
;             return &self.items[self.items.len - 1];
   1b80e: 13 05 80 03  	li	a0, 56
   1b812: 33 05 a6 02  	mul	a0, a2, a0
   1b816: c6 75        	ld	a1, 112(sp)
   1b818: 2e 95        	add	a0, a0, a1
;             new_item_ptr.* = item;
   1b81a: 23 30 35 01  	sd	s3, 0(a0)
   1b81e: 23 34 25 01  	sd	s2, 8(a0)
   1b822: 04 e9        	sd	s1, 16(a0)
   1b824: 23 3c 65 01  	sd	s6, 24(a0)
   1b828: 8e 65        	ld	a1, 192(sp)
   1b82a: 0c d1        	sw	a1, 32(a0)
   1b82c: 83 25 01 33  	lw	a1, 816(sp)
   1b830: 4c d1        	sw	a1, 36(a0)
   1b832: 83 25 41 33  	lw	a1, 820(sp)
   1b836: 0c d5        	sw	a1, 40(a0)
   1b838: 83 25 81 33  	lw	a1, 824(sp)
   1b83c: 4c d5        	sw	a1, 44(a0)
   1b83e: 83 25 c1 33  	lw	a1, 828(sp)
;             self.items.len += 1;
   1b842: 93 0c 16 00  	addi	s9, a2, 1
   1b846: 85 0b        	addi	s7, s7, 1
;             new_item_ptr.* = item;
   1b848: 0c d9        	sw	a1, 48(a0)
   1b84a: 66 86        	mv	a2, s9
   1b84c: c6 64        	ld	s1, 80(sp)
;                     while (i < directories_count) : (i += 1) {
   1b84e: e3 9c 9b e8  	bne	s7, s1, 0x1b6e6 <.LBB45_150+0xc4>
   1b852: e6 f6        	sd	s9, 360(sp)
   1b854: 2a 6b        	ld	s6, 136(sp)
   1b856: 82 7b        	ld	s7, 32(sp)
   1b858: c6 79        	ld	s3, 112(sp)
   1b85a: 62 64        	ld	s0, 24(sp)
   1b85c: 2d a8        	j	0x1b896 <.LBB45_180+0xbc>
   1b85e: 6a 85        	mv	a0, s10
   1b860: 97 80 00 00  	auipc	ra, 8
   1b864: e7 80 80 39  	jalr	920(ra)
   1b868: 6a 85        	mv	a0, s10
   1b86a: 97 80 00 00  	auipc	ra, 8
   1b86e: e7 80 e0 38  	jalr	910(ra)
   1b872: 6a 85        	mv	a0, s10
   1b874: 97 80 00 00  	auipc	ra, 8
   1b878: e7 80 40 38  	jalr	900(ra)
   1b87c: 6a 85        	mv	a0, s10
   1b87e: 97 80 00 00  	auipc	ra, 8
   1b882: e7 80 a0 37  	jalr	890(ra)
   1b886: 13 05 10 03  	li	a0, 49
   1b88a: 23 10 ab 02  	sh	a0, 32(s6)
   1b88e: 6f 00 d0 2a  	j	0x1c33a <.LBB45_239+0x7da>
   1b892: 81 4c        	li	s9, 0
   1b894: a2 89        	mv	s3, s0
;             var file_ent_fmt_buf: [10]FileEntFmt = undefined;
   1b896: 23 34 81 40  	sd	s0, 1032(sp)
   1b89a: 23 30 81 40  	sd	s0, 1024(sp)
   1b89e: 23 3c 81 3e  	sd	s0, 1016(sp)
   1b8a2: 23 38 81 3e  	sd	s0, 1008(sp)
   1b8a6: 23 34 81 3e  	sd	s0, 1000(sp)
   1b8aa: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   1b8ae: 85 65        	lui	a1, 1
   1b8b0: 9b 85 05 88  	addiw	a1, a1, -1920
   1b8b4: 8a 95        	add	a1, a1, sp
   1b8b6: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1b8ba: 05 65        	lui	a0, 1
   1b8bc: 1b 05 85 88  	addiw	a0, a0, -1912
   1b8c0: 0a 95        	add	a0, a0, sp
   1b8c2: 8c 11        	addi	a1, sp, 224
   1b8c4: 05 66        	lui	a2, 1
   1b8c6: 1b 06 06 88  	addiw	a2, a2, -1920
   1b8ca: 0a 96        	add	a2, a2, sp
   1b8cc: 85 46        	li	a3, 1
   1b8ce: 97 60 00 00  	auipc	ra, 6
   1b8d2: e7 80 a0 de  	jalr	-534(ra)
   1b8d6: 05 65        	lui	a0, 1
   1b8d8: 1b 05 85 88  	addiw	a0, a0, -1912
   1b8dc: 0a 95        	add	a0, a0, sp
   1b8de: 08 61        	ld	a0, 0(a0)
;             if (amt_read < 1) return error.EndOfStream;
   1b8e0: e3 0a 05 14  	beqz	a0, 0x1c234 <.LBB45_239+0x6d4>
;             return result[0];
   1b8e4: 05 65        	lui	a0, 1
   1b8e6: 1b 05 05 88  	addiw	a0, a0, -1920
   1b8ea: 0a 95        	add	a0, a0, sp
   1b8ec: 83 45 05 00  	lbu	a1, 0(a0)
   1b8f0: 2d 45        	li	a0, 11
;             if (file_name_entry_format_count > file_ent_fmt_buf.len) return badDwarf();
   1b8f2: e3 fd a5 16  	bgeu	a1, a0, 0x1c26c <.LBB45_239+0x70c>
   1b8f6: ae f4        	sd	a1, 104(sp)
;             for (file_ent_fmt_buf[0..file_name_entry_format_count]) |*ent_fmt| {
   1b8f8: b9 c5        	beqz	a1, 0x1b946 <.LBB45_180+0x16c>
   1b8fa: 13 04 a1 3e  	addi	s0, sp, 1002
   1b8fe: a6 74        	ld	s1, 104(sp)
;                     .content_type_code = try leb.readULEB128(u8, in),
   1b900: 13 05 01 43  	addi	a0, sp, 1072
   1b904: b0 19        	addi	a2, sp, 248
   1b906: ea 85        	mv	a1, s10
   1b908: 97 e0 ff ff  	auipc	ra, 1048574
   1b90c: e7 80 a0 55  	jalr	1370(ra)
   1b910: 03 59 01 43  	lhu	s2, 1072(sp)
   1b914: e3 1a 09 38  	bnez	s2, 0x1c4a8 <.LBB45_239+0x948>
   1b918: 03 05 21 43  	lb	a0, 1074(sp)
   1b91c: 23 00 a4 00  	sb	a0, 0(s0)
;                     .form_code = try leb.readULEB128(u16, in),
   1b920: 13 05 81 44  	addi	a0, sp, 1096
   1b924: b0 19        	addi	a2, sp, 248
   1b926: ea 85        	mv	a1, s10
   1b928: 97 e0 ff ff  	auipc	ra, 1048574
   1b92c: e7 80 40 5f  	jalr	1524(ra)
   1b930: 03 59 a1 44  	lhu	s2, 1098(sp)
   1b934: e3 1a 09 38  	bnez	s2, 0x1c4c8 <.LBB45_239+0x968>
   1b938: 03 15 81 44  	lh	a0, 1096(sp)
   1b93c: 23 1f a4 fe  	sh	a0, -2(s0)
;             for (file_ent_fmt_buf[0..file_name_entry_format_count]) |*ent_fmt| {
   1b940: fd 14        	addi	s1, s1, -1
   1b942: 11 04        	addi	s0, s0, 4
   1b944: d5 fc        	bnez	s1, 0x1b900 <.LBB45_180+0x126>
;             const file_names_count = try leb.readULEB128(usize, in);
   1b946: 13 05 01 46  	addi	a0, sp, 1120
   1b94a: b0 19        	addi	a2, sp, 248
   1b94c: ea 85        	mv	a1, s10
   1b94e: 97 e0 ff ff  	auipc	ra, 1048574
   1b952: e7 80 a0 6b  	jalr	1722(ra)
   1b956: 03 54 81 46  	lhu	s0, 1128(sp)
   1b95a: e3 14 04 1a  	bnez	s0, 0x1c302 <.LBB45_239+0x7a2>
   1b95e: 83 34 01 46  	ld	s1, 1120(sp)
;             if (self.capacity >= new_capacity) return;
   1b962: 63 84 04 ee  	beqz	s1, 0x1b04a <dwarf.DwarfInfo.getLineNumberInfo+0x870>
   1b966: 01 46        	li	a2, 0
   1b968: 26 74        	ld	s0, 104(sp)
   1b96a: 19 a0        	j	0x1b970 <.LBB45_180+0x196>
;                 if (better_capacity >= new_capacity) break;
   1b96c: 63 7c 96 0a  	bgeu	a2, s1, 0x1ba24 <.LBB45_180+0x24a>
   1b970: b2 85        	mv	a1, a2
;                 better_capacity +|= better_capacity / 2 + 8;
   1b972: 13 55 16 00  	srli	a0, a2, 1
   1b976: 32 95        	add	a0, a0, a2
   1b978: 21 05        	addi	a0, a0, 8
   1b97a: 7d 56        	li	a2, -1
   1b97c: e3 68 b5 fe  	bltu	a0, a1, 0x1b96c <.LBB45_180+0x192>
   1b980: 2a 86        	mv	a2, a0
   1b982: ed b7        	j	0x1b96c <.LBB45_180+0x192>
;     return error.MissingDebugInfo;
   1b984: 6a 85        	mv	a0, s10
   1b986: 97 80 00 00  	auipc	ra, 8
   1b98a: e7 80 20 27  	jalr	626(ra)
   1b98e: 4d 45        	li	a0, 19
   1b990: 23 10 ab 02  	sh	a0, 32(s6)
   1b994: 6a 85        	mv	a0, s10
   1b996: 97 80 00 00  	auipc	ra, 8
   1b99a: e7 80 20 26  	jalr	610(ra)
   1b99e: 6f 00 d0 19  	j	0x1c33a <.LBB45_239+0x7da>
;                 if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b9a2: 03 35 81 71  	ld	a0, 1816(sp)
   1b9a6: 83 35 01 71  	ld	a1, 1808(sp)
   1b9aa: 03 36 81 70  	ld	a2, 1800(sp)
   1b9ae: 83 36 01 70  	ld	a3, 1792(sp)
;         var it = self.state.buffer_list.first;
   1b9b2: 16 69        	ld	s2, 320(sp)
;                 if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1b9b4: 23 3c a1 74  	sd	a0, 1880(sp)
   1b9b8: 23 38 b1 74  	sd	a1, 1872(sp)
   1b9bc: 23 34 c1 74  	sd	a2, 1864(sp)
   1b9c0: 23 30 d1 74  	sd	a3, 1856(sp)
   1b9c4: 82 7a        	ld	s5, 32(sp)
   1b9c6: ca 6c        	ld	s9, 144(sp)
;         while (it) |node| {
   1b9c8: 63 08 09 04  	beqz	s2, 0x1ba18 <.LBB45_180+0x23e>
   1b9cc: 37 55 02 00  	lui	a0, 37
   1b9d0: 83 39 85 37  	ld	s3, 888(a0)
   1b9d4: 2d a0        	j	0x1b9fe <.LBB45_180+0x224>
   1b9d6: d2 7b        	ld	s7, 304(sp)
   1b9d8: 72 7a        	ld	s4, 312(sp)
;     @memset(non_const_ptr, undefined, bytes_len);
   1b9da: 93 05 a0 0a  	li	a1, 170
   1b9de: 22 85        	mv	a0, s0
   1b9e0: 26 86        	mv	a2, s1
   1b9e2: 97 90 00 00  	auipc	ra, 9
   1b9e6: e7 80 80 8b  	jalr	-1864(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1b9ea: 83 37 0a 01  	ld	a5, 16(s4)
   1b9ee: 5e 85        	mv	a0, s7
   1b9f0: a2 85        	mv	a1, s0
   1b9f2: 26 86        	mv	a2, s1
   1b9f4: 81 46        	li	a3, 0
   1b9f6: 66 87        	mv	a4, s9
   1b9f8: 82 97        	jalr	a5
;         while (it) |node| {
   1b9fa: 63 0f 09 00  	beqz	s2, 0x1ba18 <.LBB45_180+0x23e>
;             self.child_allocator.free(node.data);
   1b9fe: 03 35 09 01  	ld	a0, 16(s2)
   1ba02: 81 44        	li	s1, 0
   1ba04: 4e 84        	mv	s0, s3
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1ba06: 01 c5        	beqz	a0, 0x1ba0e <.LBB45_180+0x234>
   1ba08: 03 34 89 00  	ld	s0, 8(s2)
   1ba0c: aa 84        	mv	s1, a0
   1ba0e: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1ba12: e5 d4        	beqz	s1, 0x1b9fa <.LBB45_180+0x220>
   1ba14: 69 f0        	bnez	s0, 0x1b9d6 <.LBB45_180+0x1fc>
   1ba16: f9 a1        	j	0x1bee4 <.LBB45_239+0x384>
;     if (n == 0) {
   1ba18: 03 45 81 03  	lbu	a0, 56(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1ba1c: 63 05 05 24  	beqz	a0, 0x1bc66 <.LBB45_239+0x106>
   1ba20: 2e 64        	ld	s0, 200(sp)
   1ba22: b9 a4        	j	0x1bc70 <.LBB45_239+0x110>
;             return self.ensureTotalCapacityPrecise(better_capacity);
   1ba24: 2c 03        	addi	a1, sp, 392
   1ba26: 6a 85        	mv	a0, s10
   1ba28: 97 70 00 00  	auipc	ra, 7
   1ba2c: e7 80 e0 42  	jalr	1070(ra)
   1ba30: 2a 89        	mv	s2, a0
   1ba32: 42 15        	slli	a0, a0, 48
   1ba34: 41 91        	srli	a0, a0, 48
   1ba36: e3 16 05 32  	bnez	a0, 0x1c562 <.LBB45_239+0xa02>
   1ba3a: 66 e8        	sd	s9, 16(sp)
   1ba3c: ce f8        	sd	s3, 112(sp)
   1ba3e: 5e f0        	sd	s7, 32(sp)
   1ba40: 5a 66        	ld	a2, 400(sp)
   1ba42: fa 65        	ld	a1, 408(sp)
;                 while (i < file_names_count) : (i += 1) {
   1ba44: 33 85 c5 40  	sub	a0, a1, a2
   1ba48: 82 f0        	sd	zero, 96(sp)
   1ba4a: 63 e3 a5 00  	bltu	a1, a0, 0x1ba50 <.LBB45_180+0x276>
   1ba4e: aa f0        	sd	a0, 96(sp)
   1ba50: 01 4a        	li	s4, 0
   1ba52: 3a 65        	ld	a0, 392(sp)
;                 while (i < file_names_count) : (i += 1) {
   1ba54: 2a ec        	sd	a0, 24(sp)
   1ba56: 91 4a        	li	s5, 4
   1ba58: 37 05 01 00  	lui	a0, 16
   1ba5c: 93 0d 85 61  	addi	s11, a0, 1560
   1ba60: a6 e8        	sd	s1, 80(sp)
   1ba62: 32 f1        	sd	a2, 160(sp)
;                     var e: FileEntry = .{ .path = &.{} };
   1ba64: 23 3c 01 48  	sd	zero, 1176(sp)
   1ba68: 23 38 01 48  	sd	zero, 1168(sp)
;                     for (file_ent_fmt_buf[0..file_name_entry_format_count]) |ent_fmt| {
   1ba6c: 63 08 04 10  	beqz	s0, 0x1bb7c <.LBB45_239+0x1c>
   1ba70: 82 e1        	sd	zero, 192(sp)
   1ba72: 01 4c        	li	s8, 0
   1ba74: 81 49        	li	s3, 0
   1ba76: 01 49        	li	s2, 0
   1ba78: 81 4b        	li	s7, 0
   1ba7a: 22 8b        	mv	s6, s0
   1ba7c: 13 04 a1 3e  	addi	s0, sp, 1002
   1ba80: 39 a0        	j	0x1ba8e <.LBB45_180+0x2b4>
   1ba82: 03 3c 01 4d  	ld	s8, 1232(sp)
;                     for (file_ent_fmt_buf[0..file_name_entry_format_count]) |ent_fmt| {
   1ba86: 7d 1b        	addi	s6, s6, -1
   1ba88: 11 04        	addi	s0, s0, 4
   1ba8a: 63 0e 0b 0e  	beqz	s6, 0x1bb86 <.LBB45_239+0x26>
   1ba8e: 03 57 e4 ff  	lhu	a4, -2(s0)
   1ba92: 83 4c 04 00  	lbu	s9, 0(s0)
;                             di.endian,
   1ba96: 6e 65        	ld	a0, 216(sp)
   1ba98: 83 07 85 10  	lb	a5, 264(a0)
   1ba9c: 13 05 01 4a  	addi	a0, sp, 1184
   1baa0: 90 0a        	addi	a2, sp, 336
   1baa2: b4 19        	addi	a3, sp, 248
   1baa4: ea 85        	mv	a1, s10
   1baa6: 4e 68        	ld	a6, 208(sp)
   1baa8: 97 c0 ff ff  	auipc	ra, 1048572
   1baac: e7 80 80 19  	jalr	408(ra)
   1bab0: 83 54 81 4b  	lhu	s1, 1208(sp)
   1bab4: 63 96 04 36  	bnez	s1, 0x1be20 <.LBB45_239+0x2c0>
;                         const form_value = try parseFormValue(
   1bab8: 03 35 01 4b  	ld	a0, 1200(sp)
   1babc: 83 35 81 4a  	ld	a1, 1192(sp)
   1bac0: 03 36 01 4a  	ld	a2, 1184(sp)
   1bac4: 23 30 a1 4e  	sd	a0, 1248(sp)
   1bac8: 23 3c b1 4c  	sd	a1, 1240(sp)
;                         switch (ent_fmt.content_type_code) {
   1bacc: 13 85 fc ff  	addi	a0, s9, -1
;                         const form_value = try parseFormValue(
   1bad0: 23 38 c1 4c  	sd	a2, 1232(sp)
;                         switch (ent_fmt.content_type_code) {
   1bad4: e3 e9 aa fa  	bltu	s5, a0, 0x1ba86 <.LBB45_180+0x2ac>
   1bad8: 0a 05        	slli	a0, a0, 2
   1bada: 6e 95        	add	a0, a0, s11
   1badc: 08 41        	lw	a0, 0(a0)
   1bade: 02 85        	jr	a0

000000000001bae0 <.LBB45_228>:
;                             LNCT.path => e.path = try form_value.getString(di.*),
   1bae0: 13 05 81 4e  	addi	a0, sp, 1256
   1bae4: 13 06 01 4d  	addi	a2, sp, 1232
   1bae8: ea 85        	mv	a1, s10
   1baea: ee 66        	ld	a3, 216(sp)
   1baec: 97 e0 ff ff  	auipc	ra, 1048574
   1baf0: e7 80 60 75  	jalr	1878(ra)
   1baf4: 83 54 81 4f  	lhu	s1, 1272(sp)
   1baf8: e3 98 04 1e  	bnez	s1, 0x1c4e8 <.LBB45_239+0x988>
   1bafc: 83 3b 81 4e  	ld	s7, 1256(sp)
   1bb00: 03 39 01 4f  	ld	s2, 1264(sp)
   1bb04: 49 b7        	j	0x1ba86 <.LBB45_180+0x2ac>

000000000001bb06 <.LBB45_230>:
;                             LNCT.directory_index => e.dir_index = try form_value.getUInt(u32),
   1bb06: 13 05 01 51  	addi	a0, sp, 1296
   1bb0a: 13 06 01 4d  	addi	a2, sp, 1232
   1bb0e: ea 85        	mv	a1, s10
   1bb10: 97 f0 ff ff  	auipc	ra, 1048575
   1bb14: e7 80 e0 92  	jalr	-1746(ra)
   1bb18: 83 54 41 51  	lhu	s1, 1300(sp)
   1bb1c: e3 97 04 1e  	bnez	s1, 0x1c50a <.LBB45_239+0x9aa>
   1bb20: 03 25 01 51  	lw	a0, 1296(sp)
   1bb24: aa e1        	sd	a0, 192(sp)
   1bb26: 85 b7        	j	0x1ba86 <.LBB45_180+0x2ac>

000000000001bb28 <.LBB45_232>:
;         switch (fv) {
   1bb28: 03 45 01 4e  	lbu	a0, 1248(sp)
   1bb2c: 99 45        	li	a1, 6
   1bb2e: 63 09 b5 00  	beq	a0, a1, 0x1bb40 <.LBB45_232+0x18>
   1bb32: 8d 45        	li	a1, 3
   1bb34: e3 1e b5 26  	bne	a0, a1, 0x1c5b0 <.LBB45_239+0xa50>
   1bb38: 03 45 81 4d  	lbu	a0, 1240(sp)
;         if (self.signed) return badDwarf();
   1bb3c: e3 10 05 28  	bnez	a0, 0x1c5bc <.LBB45_239+0xa5c>
   1bb40: 83 39 01 4d  	ld	s3, 1232(sp)
   1bb44: 89 b7        	j	0x1ba86 <.LBB45_180+0x2ac>

000000000001bb46 <.LBB45_236>:
;         switch (fv) {
   1bb46: 03 45 01 4e  	lbu	a0, 1248(sp)
   1bb4a: 99 45        	li	a1, 6
   1bb4c: e3 0b b5 f2  	beq	a0, a1, 0x1ba82 <.LBB45_180+0x2a8>
   1bb50: 8d 45        	li	a1, 3
   1bb52: e3 12 b5 26  	bne	a0, a1, 0x1c5b6 <.LBB45_239+0xa56>
   1bb56: 03 45 81 4d  	lbu	a0, 1240(sp)
;         if (self.signed) return badDwarf();
   1bb5a: 05 d5        	beqz	a0, 0x1ba82 <.LBB45_180+0x2a8>
   1bb5c: 6f 00 10 2a  	j	0x1c5fc <.LBB45_239+0xa9c>

000000000001bb60 <.LBB45_239>:
;         switch (fv) {
   1bb60: 03 45 01 4e  	lbu	a0, 1248(sp)
   1bb64: bd 45        	li	a1, 15
   1bb66: e3 13 b5 1c  	bne	a0, a1, 0x1c52c <.LBB45_239+0x9cc>
;             .data16 => |d| return d,
   1bb6a: 03 35 81 4a  	ld	a0, 1192(sp)
   1bb6e: 83 35 01 4a  	ld	a1, 1184(sp)
   1bb72: 23 3c a1 48  	sd	a0, 1176(sp)
   1bb76: 23 38 b1 48  	sd	a1, 1168(sp)
   1bb7a: 31 b7        	j	0x1ba86 <.LBB45_180+0x2ac>
   1bb7c: 81 4b        	li	s7, 0
   1bb7e: 01 49        	li	s2, 0
   1bb80: 81 49        	li	s3, 0
   1bb82: 01 4c        	li	s8, 0
   1bb84: 82 e1        	sd	zero, 192(sp)
;     if (!ok) unreachable; // assertion failure
   1bb86: 06 75        	ld	a0, 96(sp)
   1bb88: e3 04 aa 4e  	beq	s4, a0, 0x1c870 <.LBB45_239+0xd10>
   1bb8c: 8a 76        	ld	a3, 160(sp)
;             return &self.items[self.items.len - 1];
   1bb8e: 13 05 80 03  	li	a0, 56
   1bb92: 33 85 a6 02  	mul	a0, a3, a0
   1bb96: e2 65        	ld	a1, 24(sp)
   1bb98: aa 95        	add	a1, a1, a0
;             new_item_ptr.* = item;
   1bb9a: 23 b0 75 01  	sd	s7, 0(a1)
   1bb9e: 23 b4 25 01  	sd	s2, 8(a1)
   1bba2: 23 b8 35 01  	sd	s3, 16(a1)
   1bba6: 23 bc 85 01  	sd	s8, 24(a1)
   1bbaa: 0e 65        	ld	a0, 192(sp)
   1bbac: 88 d1        	sw	a0, 32(a1)
   1bbae: 03 25 01 49  	lw	a0, 1168(sp)
   1bbb2: c8 d1        	sw	a0, 36(a1)
   1bbb4: 03 25 41 49  	lw	a0, 1172(sp)
   1bbb8: 88 d5        	sw	a0, 40(a1)
   1bbba: 03 25 81 49  	lw	a0, 1176(sp)
   1bbbe: c8 d5        	sw	a0, 44(a1)
   1bbc0: 03 26 c1 49  	lw	a2, 1180(sp)
;             self.items.len += 1;
   1bbc4: 13 85 16 00  	addi	a0, a3, 1
   1bbc8: 05 0a        	addi	s4, s4, 1
;             new_item_ptr.* = item;
   1bbca: 90 d9        	sw	a2, 48(a1)
   1bbcc: 2a 86        	mv	a2, a0
   1bbce: 2a 6b        	ld	s6, 136(sp)
   1bbd0: 26 74        	ld	s0, 104(sp)
   1bbd2: c6 64        	ld	s1, 80(sp)
;                 while (i < file_names_count) : (i += 1) {
   1bbd4: e3 17 9a e8  	bne	s4, s1, 0x1ba62 <.LBB45_180+0x288>
   1bbd8: 2a eb        	sd	a0, 400(sp)
   1bbda: 6a 6c        	ld	s8, 152(sp)
   1bbdc: 82 7b        	ld	s7, 32(sp)
   1bbde: 0a 69        	ld	s2, 128(sp)
   1bbe0: c6 79        	ld	s3, 112(sp)
   1bbe2: c2 6c        	ld	s9, 16(sp)
   1bbe4: 6f f0 8f c6  	j	0x1b04c <dwarf.DwarfInfo.getLineNumberInfo+0x872>
;         var it = self.state.buffer_list.first;
   1bbe8: 16 69        	ld	s2, 320(sp)
   1bbea: 0a 75        	ld	a0, 160(sp)
   1bbec: aa f6        	sd	a0, 360(sp)
   1bbee: aa 6a        	ld	s5, 136(sp)
   1bbf0: 6a 6b        	ld	s6, 152(sp)
   1bbf2: 4a 6c        	ld	s8, 144(sp)
;         while (it) |node| {
   1bbf4: 63 1d 09 10  	bnez	s2, 0x1bd0e <.LBB45_239+0x1ae>
;     if (n == 0) {
   1bbf8: 03 45 81 03  	lbu	a0, 56(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1bbfc: 63 00 05 16  	beqz	a0, 0x1bd5c <.LBB45_239+0x1fc>
   1bc00: 02 75        	ld	a0, 32(sp)
   1bc02: 9d a2        	j	0x1bd68 <.LBB45_239+0x208>
;     return error.InvalidDebugInfo;
   1bc04: 6a 85        	mv	a0, s10
   1bc06: 97 80 00 00  	auipc	ra, 8
   1bc0a: e7 80 20 ff  	jalr	-14(ra)
   1bc0e: 6a 85        	mv	a0, s10
   1bc10: 97 80 00 00  	auipc	ra, 8
   1bc14: e7 80 80 fe  	jalr	-24(ra)
   1bc18: 6a 85        	mv	a0, s10
   1bc1a: 97 80 00 00  	auipc	ra, 8
   1bc1e: e7 80 e0 fd  	jalr	-34(ra)
   1bc22: 13 04 20 03  	li	s0, 50
   1bc26: 6a 85        	mv	a0, s10
   1bc28: 97 80 00 00  	auipc	ra, 8
   1bc2c: e7 80 00 fd  	jalr	-48(ra)
   1bc30: f5 ad        	j	0x1c32c <.LBB45_239+0x7cc>
;             if (amt_read < buf.len) return error.EndOfStream;
   1bc32: 6a 85        	mv	a0, s10
   1bc34: 97 80 00 00  	auipc	ra, 8
   1bc38: e7 80 40 fc  	jalr	-60(ra)
;             try self.readNoEof(&bytes);
   1bc3c: 6a 85        	mv	a0, s10
   1bc3e: 97 80 00 00  	auipc	ra, 8
   1bc42: e7 80 a0 fb  	jalr	-70(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1bc46: 6a 85        	mv	a0, s10
   1bc48: 97 80 00 00  	auipc	ra, 8
   1bc4c: e7 80 00 fb  	jalr	-80(ra)
;         var it = self.state.buffer_list.first;
   1bc50: 16 69        	ld	s2, 320(sp)
   1bc52: 82 7a        	ld	s5, 32(sp)
   1bc54: ca 6c        	ld	s9, 144(sp)
;         while (it) |node| {
   1bc56: 63 12 09 24  	bnez	s2, 0x1be9a <.LBB45_239+0x33a>
;     if (n == 0) {
   1bc5a: 03 45 81 03  	lbu	a0, 56(sp)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1bc5e: 63 0d 05 28  	beqz	a0, 0x1bef8 <.LBB45_239+0x398>
   1bc62: 2e 64        	ld	s0, 200(sp)
   1bc64: 79 ac        	j	0x1bf02 <.LBB45_239+0x3a2>
   1bc66: 37 55 02 00  	lui	a0, 37
   1bc6a: 03 34 85 37  	ld	s0, 888(a0)
   1bc6e: 81 4a        	li	s5, 0
;     if (bytes_len == 0) return;
   1bc70: 63 87 0a 02  	beqz	s5, 0x1bc9e <.LBB45_239+0x13e>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1bc74: 63 08 04 26  	beqz	s0, 0x1bee4 <.LBB45_239+0x384>
   1bc78: 03 39 0c 00  	ld	s2, 0(s8)
   1bc7c: 83 34 8c 00  	ld	s1, 8(s8)
;     @memset(non_const_ptr, undefined, bytes_len);
   1bc80: 93 05 a0 0a  	li	a1, 170
   1bc84: 22 85        	mv	a0, s0
   1bc86: 56 86        	mv	a2, s5
   1bc88: 97 80 00 00  	auipc	ra, 8
   1bc8c: e7 80 20 61  	jalr	1554(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1bc90: 9c 68        	ld	a5, 16(s1)
   1bc92: 4a 85        	mv	a0, s2
   1bc94: a2 85        	mv	a1, s0
   1bc96: 56 86        	mv	a2, s5
   1bc98: 81 46        	li	a3, 0
   1bc9a: 66 87        	mv	a4, s9
   1bc9c: 82 97        	jalr	a5
;                 if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1bc9e: 03 35 81 75  	ld	a0, 1880(sp)
   1bca2: 83 35 01 75  	ld	a1, 1872(sp)
   1bca6: 03 36 81 74  	ld	a2, 1864(sp)
   1bcaa: 83 36 01 74  	ld	a3, 1856(sp)
   1bcae: 3d ad        	j	0x1c2ec <.LBB45_239+0x78c>
;         defer tmp_arena.deinit();
   1bcb0: 08 1a        	addi	a0, sp, 304
   1bcb2: 97 b0 ff ff  	auipc	ra, 1048571
   1bcb6: e7 80 c0 6c  	jalr	1740(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bcba: 03 35 8c 00  	ld	a0, 8(s8)
   1bcbe: aa f3        	sd	a0, 480(sp)
   1bcc0: 03 35 0c 00  	ld	a0, 0(s8)
   1bcc4: aa ef        	sd	a0, 472(sp)
   1bcc6: a8 0b        	addi	a0, sp, 472
   1bcc8: a1 ad        	j	0x1c320 <.LBB45_239+0x7c0>
;     return error.MissingDebugInfo;
   1bcca: 6a 85        	mv	a0, s10
   1bccc: 97 80 00 00  	auipc	ra, 8
   1bcd0: e7 80 c0 f2  	jalr	-212(ra)
   1bcd4: 4d 45        	li	a0, 19
;         return missingDwarf();
   1bcd6: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1bcda: 08 1a        	addi	a0, sp, 304
   1bcdc: 97 b0 ff ff  	auipc	ra, 1048571
   1bce0: e7 80 20 6a  	jalr	1698(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bce4: 03 35 8c 00  	ld	a0, 8(s8)
   1bce8: 85 65        	lui	a1, 1
   1bcea: 9b 85 85 85  	addiw	a1, a1, -1960
   1bcee: 8a 95        	add	a1, a1, sp
   1bcf0: 88 e1        	sd	a0, 0(a1)
   1bcf2: 03 35 0c 00  	ld	a0, 0(s8)
   1bcf6: 85 65        	lui	a1, 1
   1bcf8: 9b 85 05 85  	addiw	a1, a1, -1968
   1bcfc: 8a 95        	add	a1, a1, sp
   1bcfe: 88 e1        	sd	a0, 0(a1)
   1bd00: 05 65        	lui	a0, 1
   1bd02: 1b 05 05 85  	addiw	a0, a0, -1968
   1bd06: 0a 95        	add	a0, a0, sp
   1bd08: ae 65        	ld	a1, 200(sp)
   1bd0a: 02 76        	ld	a2, 32(sp)
   1bd0c: 51 ab        	j	0x1c2a0 <.LBB45_239+0x740>
   1bd0e: 37 55 02 00  	lui	a0, 37
   1bd12: 83 39 85 37  	ld	s3, 888(a0)
   1bd16: 19 a0        	j	0x1bd1c <.LBB45_239+0x1bc>
;         while (it) |node| {
   1bd18: e3 00 09 ee  	beqz	s2, 0x1bbf8 <.LBB45_239+0x98>
;             self.child_allocator.free(node.data);
   1bd1c: 03 35 09 01  	ld	a0, 16(s2)
   1bd20: 81 44        	li	s1, 0
   1bd22: 4e 84        	mv	s0, s3
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1bd24: 01 c5        	beqz	a0, 0x1bd2c <.LBB45_239+0x1cc>
   1bd26: 03 34 89 00  	ld	s0, 8(s2)
   1bd2a: aa 84        	mv	s1, a0
   1bd2c: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1bd30: e5 d4        	beqz	s1, 0x1bd18 <.LBB45_239+0x1b8>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1bd32: 63 09 04 1a  	beqz	s0, 0x1bee4 <.LBB45_239+0x384>
   1bd36: d2 7b        	ld	s7, 304(sp)
   1bd38: 72 7a        	ld	s4, 312(sp)
;     @memset(non_const_ptr, undefined, bytes_len);
   1bd3a: 93 05 a0 0a  	li	a1, 170
   1bd3e: 22 85        	mv	a0, s0
   1bd40: 26 86        	mv	a2, s1
   1bd42: 97 80 00 00  	auipc	ra, 8
   1bd46: e7 80 80 55  	jalr	1368(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1bd4a: 83 37 0a 01  	ld	a5, 16(s4)
   1bd4e: 5e 85        	mv	a0, s7
   1bd50: a2 85        	mv	a1, s0
   1bd52: 26 86        	mv	a2, s1
   1bd54: 81 46        	li	a3, 0
   1bd56: 62 87        	mv	a4, s8
   1bd58: 82 97        	jalr	a5
   1bd5a: 7d bf        	j	0x1bd18 <.LBB45_239+0x1b8>
   1bd5c: 37 55 02 00  	lui	a0, 37
   1bd60: 03 35 85 37  	ld	a0, 888(a0)
   1bd64: aa e5        	sd	a0, 200(sp)
   1bd66: 01 45        	li	a0, 0
;     if (bytes_len == 0) return;
   1bd68: 0d c9        	beqz	a0, 0x1bd9a <.LBB45_239+0x23a>
   1bd6a: ae 64        	ld	s1, 200(sp)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1bd6c: 63 8c 04 16  	beqz	s1, 0x1bee4 <.LBB45_239+0x384>
   1bd70: 2a 84        	mv	s0, a0
   1bd72: 03 39 0b 00  	ld	s2, 0(s6)
   1bd76: 83 39 8b 00  	ld	s3, 8(s6)
;     @memset(non_const_ptr, undefined, bytes_len);
   1bd7a: 93 05 a0 0a  	li	a1, 170
   1bd7e: 26 85        	mv	a0, s1
   1bd80: 22 86        	mv	a2, s0
   1bd82: 97 80 00 00  	auipc	ra, 8
   1bd86: e7 80 80 51  	jalr	1304(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1bd8a: 83 b7 09 01  	ld	a5, 16(s3)
   1bd8e: 4a 85        	mv	a0, s2
   1bd90: a6 85        	mv	a1, s1
   1bd92: 22 86        	mv	a2, s0
   1bd94: 81 46        	li	a3, 0
   1bd96: 62 87        	mv	a4, s8
   1bd98: 82 97        	jalr	a5
;                             const form_value = try parseFormValue(
   1bd9a: 6a 85        	mv	a0, s10
   1bd9c: 97 80 00 00  	auipc	ra, 8
   1bda0: e7 80 c0 e5  	jalr	-420(ra)
   1bda4: 23 90 ba 03  	sh	s11, 32(s5)
   1bda8: 49 ab        	j	0x1c33a <.LBB45_239+0x7da>
;         defer tmp_arena.deinit();
   1bdaa: 08 1a        	addi	a0, sp, 304
   1bdac: 97 b0 ff ff  	auipc	ra, 1048571
   1bdb0: e7 80 20 5d  	jalr	1490(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bdb4: 03 35 8c 00  	ld	a0, 8(s8)
   1bdb8: 23 3c a1 20  	sd	a0, 536(sp)
   1bdbc: 03 35 0c 00  	ld	a0, 0(s8)
   1bdc0: 23 38 a1 20  	sd	a0, 528(sp)
   1bdc4: 08 0c        	addi	a0, sp, 528
   1bdc6: a9 ab        	j	0x1c320 <.LBB45_239+0x7c0>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   1bdc8: 6a 85        	mv	a0, s10
   1bdca: 97 80 00 00  	auipc	ra, 8
   1bdce: e7 80 e0 e2  	jalr	-466(ra)
;     return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());
   1bdd2: 6a 85        	mv	a0, s10
   1bdd4: 97 80 00 00  	auipc	ra, 8
   1bdd8: e7 80 40 e2  	jalr	-476(ra)
;         const standard_opcode_lengths = try allocator.alloc(u8, opcode_base - 1);
   1bddc: 6a 85        	mv	a0, s10
   1bdde: 97 80 00 00  	auipc	ra, 8
   1bde2: e7 80 a0 e1  	jalr	-486(ra)
   1bde6: 45 45        	li	a0, 17
   1bde8: 23 10 ab 02  	sh	a0, 32(s6)
   1bdec: b9 a3        	j	0x1c33a <.LBB45_239+0x7da>
;             if (amt_read < 1) return error.EndOfStream;
   1bdee: 6a 85        	mv	a0, s10
   1bdf0: 97 80 00 00  	auipc	ra, 8
   1bdf4: e7 80 80 e0  	jalr	-504(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bdf8: 83 34 8c 00  	ld	s1, 8(s8)
   1bdfc: 03 39 0c 00  	ld	s2, 0(s8)
;     @memset(non_const_ptr, undefined, bytes_len);
   1be00: 93 05 a0 0a  	li	a1, 170
   1be04: 2e 64        	ld	s0, 200(sp)
   1be06: 22 85        	mv	a0, s0
   1be08: 5e 86        	mv	a2, s7
   1be0a: 97 80 00 00  	auipc	ra, 8
   1be0e: e7 80 00 49  	jalr	1168(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1be12: 9c 68        	ld	a5, 16(s1)
   1be14: 4a 85        	mv	a0, s2
   1be16: a2 85        	mv	a1, s0
   1be18: 5e 86        	mv	a2, s7
   1be1a: 81 46        	li	a3, 0
   1be1c: 4a 67        	ld	a4, 144(sp)
   1be1e: 39 a2        	j	0x1bf2c <.LBB45_239+0x3cc>
   1be20: 0a 75        	ld	a0, 160(sp)
   1be22: 2a eb        	sd	a0, 400(sp)
;         defer tmp_arena.deinit();
   1be24: 08 1a        	addi	a0, sp, 304
   1be26: 97 b0 ff ff  	auipc	ra, 1048571
   1be2a: e7 80 80 55  	jalr	1368(ra)
   1be2e: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1be30: 88 65        	ld	a0, 8(a1)
   1be32: 23 34 a1 4c  	sd	a0, 1224(sp)
   1be36: 88 61        	ld	a0, 0(a1)
   1be38: 23 30 a1 4c  	sd	a0, 1216(sp)
   1be3c: 13 05 01 4c  	addi	a0, sp, 1216
   1be40: ae 65        	ld	a1, 200(sp)
   1be42: 02 76        	ld	a2, 32(sp)
   1be44: 97 10 00 00  	auipc	ra, 1
   1be48: e7 80 00 a4  	jalr	-1472(ra)
   1be4c: 6a 85        	mv	a0, s10
   1be4e: 97 80 00 00  	auipc	ra, 8
   1be52: e7 80 a0 da  	jalr	-598(ra)
   1be56: 2a 65        	ld	a0, 136(sp)
   1be58: 23 10 95 02  	sh	s1, 32(a0)
   1be5c: f9 a9        	j	0x1c33a <.LBB45_239+0x7da>
;         defer tmp_arena.deinit();
   1be5e: 08 1a        	addi	a0, sp, 304
   1be60: 97 b0 ff ff  	auipc	ra, 1048571
   1be64: e7 80 e0 51  	jalr	1310(ra)
;         defer allocator.free(standard_opcode_lengths);
   1be68: 03 35 8c 00  	ld	a0, 8(s8)
   1be6c: 23 3c a1 64  	sd	a0, 1624(sp)
   1be70: 03 35 0c 00  	ld	a0, 0(s8)
   1be74: 23 38 a1 64  	sd	a0, 1616(sp)
   1be78: 13 05 01 65  	addi	a0, sp, 1616
   1be7c: ae 65        	ld	a1, 200(sp)
   1be7e: 02 76        	ld	a2, 32(sp)
   1be80: 97 10 00 00  	auipc	ra, 1
   1be84: e7 80 40 a0  	jalr	-1532(ra)
;                         if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1be88: 03 35 81 62  	ld	a0, 1576(sp)
   1be8c: 83 35 01 62  	ld	a1, 1568(sp)
   1be90: 03 36 81 61  	ld	a2, 1560(sp)
   1be94: 83 36 01 61  	ld	a3, 1552(sp)
   1be98: 91 a9        	j	0x1c2ec <.LBB45_239+0x78c>
   1be9a: 37 55 02 00  	lui	a0, 37
   1be9e: 83 39 85 37  	ld	s3, 888(a0)
   1bea2: 2d a0        	j	0x1becc <.LBB45_239+0x36c>
   1bea4: d2 7b        	ld	s7, 304(sp)
   1bea6: 72 7a        	ld	s4, 312(sp)
;     @memset(non_const_ptr, undefined, bytes_len);
   1bea8: 93 05 a0 0a  	li	a1, 170
   1beac: 22 85        	mv	a0, s0
   1beae: 26 86        	mv	a2, s1
   1beb0: 97 80 00 00  	auipc	ra, 8
   1beb4: e7 80 a0 3e  	jalr	1002(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1beb8: 83 37 0a 01  	ld	a5, 16(s4)
   1bebc: 5e 85        	mv	a0, s7
   1bebe: a2 85        	mv	a1, s0
   1bec0: 26 86        	mv	a2, s1
   1bec2: 81 46        	li	a3, 0
   1bec4: 66 87        	mv	a4, s9
   1bec6: 82 97        	jalr	a5
;         while (it) |node| {
   1bec8: e3 09 09 d8  	beqz	s2, 0x1bc5a <.LBB45_239+0xfa>
;             self.child_allocator.free(node.data);
   1becc: 03 35 09 01  	ld	a0, 16(s2)
   1bed0: 81 44        	li	s1, 0
   1bed2: 4e 84        	mv	s0, s3
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1bed4: 01 c5        	beqz	a0, 0x1bedc <.LBB45_239+0x37c>
   1bed6: 03 34 89 00  	ld	s0, 8(s2)
   1beda: aa 84        	mv	s1, a0
   1bedc: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1bee0: e5 d4        	beqz	s1, 0x1bec8 <.LBB45_239+0x368>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1bee2: 69 f0        	bnez	s0, 0x1bea4 <.LBB45_239+0x344>
   1bee4: 37 25 01 00  	lui	a0, 18
   1bee8: 13 05 a5 86  	addi	a0, a0, -1942
   1beec: f9 45        	li	a1, 30
   1beee: 81 46        	li	a3, 0
   1bef0: 97 70 00 00  	auipc	ra, 7
   1bef4: e7 80 a0 48  	jalr	1162(ra)
   1bef8: 37 55 02 00  	lui	a0, 37
   1befc: 03 34 85 37  	ld	s0, 888(a0)
   1bf00: 81 4a        	li	s5, 0
;     if (bytes_len == 0) return;
   1bf02: e3 8d 0a 96  	beqz	s5, 0x1b87c <.LBB45_180+0xa2>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1bf06: 79 dc        	beqz	s0, 0x1bee4 <.LBB45_239+0x384>
   1bf08: 03 39 0c 00  	ld	s2, 0(s8)
   1bf0c: 83 34 8c 00  	ld	s1, 8(s8)
;     @memset(non_const_ptr, undefined, bytes_len);
   1bf10: 93 05 a0 0a  	li	a1, 170
   1bf14: 22 85        	mv	a0, s0
   1bf16: 56 86        	mv	a2, s5
   1bf18: 97 80 00 00  	auipc	ra, 8
   1bf1c: e7 80 20 38  	jalr	898(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1bf20: 9c 68        	ld	a5, 16(s1)
   1bf22: 4a 85        	mv	a0, s2
   1bf24: a2 85        	mv	a1, s0
   1bf26: 56 86        	mv	a2, s5
   1bf28: 81 46        	li	a3, 0
   1bf2a: 66 87        	mv	a4, s9
   1bf2c: 82 97        	jalr	a5
   1bf2e: b9 b2        	j	0x1b87c <.LBB45_180+0xa2>
;             const new_item_ptr = try self.addOne();
   1bf30: 6a 85        	mv	a0, s10
   1bf32: 97 80 00 00  	auipc	ra, 8
   1bf36: e7 80 60 cc  	jalr	-826(ra)
;         defer tmp_arena.deinit();
   1bf3a: 08 1a        	addi	a0, sp, 304
   1bf3c: 97 b0 ff ff  	auipc	ra, 1048571
   1bf40: e7 80 20 44  	jalr	1090(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bf44: 03 35 8c 00  	ld	a0, 8(s8)
   1bf48: 2a ff        	sd	a0, 440(sp)
   1bf4a: 03 35 0c 00  	ld	a0, 0(s8)
   1bf4e: 2a fb        	sd	a0, 432(sp)
   1bf50: 08 1b        	addi	a0, sp, 432
   1bf52: f9 a6        	j	0x1c320 <.LBB45_239+0x7c0>
;             if (amt_read < 1) return error.EndOfStream;
   1bf54: 6a 85        	mv	a0, s10
   1bf56: 97 80 00 00  	auipc	ra, 8
   1bf5a: e7 80 20 ca  	jalr	-862(ra)
;         defer tmp_arena.deinit();
   1bf5e: 08 1a        	addi	a0, sp, 304
   1bf60: 97 b0 ff ff  	auipc	ra, 1048571
   1bf64: e7 80 e0 41  	jalr	1054(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bf68: 03 35 8c 00  	ld	a0, 8(s8)
   1bf6c: 23 3c a1 2a  	sd	a0, 696(sp)
   1bf70: 03 35 0c 00  	ld	a0, 0(s8)
   1bf74: 23 38 a1 2a  	sd	a0, 688(sp)
   1bf78: 08 1d        	addi	a0, sp, 688
   1bf7a: cd a4        	j	0x1c25c <.LBB45_239+0x6fc>
;     return error.InvalidDebugInfo;
   1bf7c: 6a 85        	mv	a0, s10
   1bf7e: 97 80 00 00  	auipc	ra, 8
   1bf82: e7 80 a0 c7  	jalr	-902(ra)
   1bf86: 13 05 20 03  	li	a0, 50
;                 if (directory_entry_format_count > dir_ent_fmt_buf.len) return badDwarf();
   1bf8a: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1bf8e: 08 1a        	addi	a0, sp, 304
   1bf90: 97 b0 ff ff  	auipc	ra, 1048571
   1bf94: e7 80 e0 3e  	jalr	1006(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bf98: 03 35 8c 00  	ld	a0, 8(s8)
   1bf9c: 23 34 a1 2c  	sd	a0, 712(sp)
   1bfa0: 03 35 0c 00  	ld	a0, 0(s8)
   1bfa4: 23 30 a1 2c  	sd	a0, 704(sp)
   1bfa8: 88 05        	addi	a0, sp, 704
   1bfaa: cd ac        	j	0x1c29c <.LBB45_239+0x73c>
;             const new_item_ptr = try self.addOne();
   1bfac: 6a 85        	mv	a0, s10
   1bfae: 97 80 00 00  	auipc	ra, 8
   1bfb2: e7 80 a0 c4  	jalr	-950(ra)
;         defer tmp_arena.deinit();
   1bfb6: 08 1a        	addi	a0, sp, 304
   1bfb8: 97 b0 ff ff  	auipc	ra, 1048571
   1bfbc: e7 80 60 3c  	jalr	966(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bfc0: 03 35 8c 00  	ld	a0, 8(s8)
   1bfc4: aa fb        	sd	a0, 496(sp)
   1bfc6: 03 35 0c 00  	ld	a0, 0(s8)
   1bfca: aa f7        	sd	a0, 488(sp)
   1bfcc: a8 13        	addi	a0, sp, 488
   1bfce: d9 a3        	j	0x1c594 <.LBB45_239+0xa34>
;         defer tmp_arena.deinit();
   1bfd0: 08 1a        	addi	a0, sp, 304
   1bfd2: 97 b0 ff ff  	auipc	ra, 1048571
   1bfd6: e7 80 c0 3a  	jalr	940(ra)
;         defer allocator.free(standard_opcode_lengths);
   1bfda: 03 35 8c 00  	ld	a0, 8(s8)
   1bfde: 23 3c a1 30  	sd	a0, 792(sp)
   1bfe2: 03 35 0c 00  	ld	a0, 0(s8)
   1bfe6: 23 38 a1 30  	sd	a0, 784(sp)
   1bfea: 08 0e        	addi	a0, sp, 784
   1bfec: 15 ae        	j	0x1c320 <.LBB45_239+0x7c0>
;             if (amt_read < 1) return error.EndOfStream;
   1bfee: 6a 85        	mv	a0, s10
   1bff0: 97 80 00 00  	auipc	ra, 8
   1bff4: e7 80 80 c0  	jalr	-1016(ra)
;         defer tmp_arena.deinit();
   1bff8: 08 1a        	addi	a0, sp, 304
   1bffa: 97 b0 ff ff  	auipc	ra, 1048571
   1bffe: e7 80 40 38  	jalr	900(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c002: 03 35 8c 00  	ld	a0, 8(s8)
   1c006: 23 34 a1 5c  	sd	a0, 1480(sp)
   1c00a: 03 35 0c 00  	ld	a0, 0(s8)
   1c00e: 23 30 a1 5c  	sd	a0, 1472(sp)
   1c012: 13 05 01 5c  	addi	a0, sp, 1472
   1c016: e9 ae        	j	0x1c3f0 <.LBB45_239+0x890>
;             if (amt_read < buf.len) return error.EndOfStream;
   1c018: 6a 85        	mv	a0, s10
   1c01a: 97 80 00 00  	auipc	ra, 8
   1c01e: e7 80 e0 bd  	jalr	-1058(ra)
;             try self.readNoEof(&bytes);
   1c022: 6a 85        	mv	a0, s10
   1c024: 97 80 00 00  	auipc	ra, 8
   1c028: e7 80 40 bd  	jalr	-1068(ra)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1c02c: 6a 85        	mv	a0, s10
   1c02e: 97 80 00 00  	auipc	ra, 8
   1c032: e7 80 a0 bc  	jalr	-1078(ra)
;         defer tmp_arena.deinit();
   1c036: 08 1a        	addi	a0, sp, 304
   1c038: 97 b0 ff ff  	auipc	ra, 1048571
   1c03c: e7 80 60 34  	jalr	838(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c040: 03 35 8c 00  	ld	a0, 8(s8)
   1c044: 85 65        	lui	a1, 1
   1c046: 9b 85 85 83  	addiw	a1, a1, -1992
   1c04a: 8a 95        	add	a1, a1, sp
   1c04c: 88 e1        	sd	a0, 0(a1)
   1c04e: 03 35 0c 00  	ld	a0, 0(s8)
   1c052: 85 65        	lui	a1, 1
   1c054: 9b 85 05 83  	addiw	a1, a1, -2000
   1c058: 8a 95        	add	a1, a1, sp
   1c05a: 88 e1        	sd	a0, 0(a1)
   1c05c: 05 65        	lui	a0, 1
   1c05e: 1b 05 05 83  	addiw	a0, a0, -2000
   1c062: 0a 95        	add	a0, a0, sp
   1c064: 71 a6        	j	0x1c3f0 <.LBB45_239+0x890>
;         defer tmp_arena.deinit();
   1c066: 08 1a        	addi	a0, sp, 304
   1c068: 97 b0 ff ff  	auipc	ra, 1048571
   1c06c: e7 80 60 31  	jalr	790(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c070: 03 35 8c 00  	ld	a0, 8(s8)
   1c074: 23 38 a1 22  	sd	a0, 560(sp)
   1c078: 03 35 0c 00  	ld	a0, 0(s8)
   1c07c: 23 34 a1 22  	sd	a0, 552(sp)
   1c080: 28 14        	addi	a0, sp, 552
   1c082: 79 ac        	j	0x1c320 <.LBB45_239+0x7c0>
;         defer tmp_arena.deinit();
   1c084: 08 1a        	addi	a0, sp, 304
   1c086: 97 b0 ff ff  	auipc	ra, 1048571
   1c08a: e7 80 80 2f  	jalr	760(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c08e: 03 35 8c 00  	ld	a0, 8(s8)
   1c092: 23 38 a1 24  	sd	a0, 592(sp)
   1c096: 03 35 0c 00  	ld	a0, 0(s8)
   1c09a: 23 34 a1 24  	sd	a0, 584(sp)
   1c09e: a8 04        	addi	a0, sp, 584
   1c0a0: 41 a4        	j	0x1c320 <.LBB45_239+0x7c0>
;         defer tmp_arena.deinit();
   1c0a2: 08 1a        	addi	a0, sp, 304
   1c0a4: 97 b0 ff ff  	auipc	ra, 1048571
   1c0a8: e7 80 a0 2d  	jalr	730(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c0ac: 03 35 8c 00  	ld	a0, 8(s8)
   1c0b0: 23 38 a1 26  	sd	a0, 624(sp)
   1c0b4: 03 35 0c 00  	ld	a0, 0(s8)
   1c0b8: 23 34 a1 26  	sd	a0, 616(sp)
   1c0bc: a8 14        	addi	a0, sp, 616
   1c0be: ae 65        	ld	a1, 200(sp)
   1c0c0: 5e 86        	mv	a2, s7
   1c0c2: 97 00 00 00  	auipc	ra, 0
   1c0c6: e7 80 20 7c  	jalr	1986(ra)
   1c0ca: 6a 85        	mv	a0, s10
   1c0cc: 97 80 00 00  	auipc	ra, 8
   1c0d0: e7 80 c0 b2  	jalr	-1236(ra)
   1c0d4: 23 10 9b 02  	sh	s1, 32(s6)
   1c0d8: 8d a4        	j	0x1c33a <.LBB45_239+0x7da>
;             const new_item_ptr = try self.addOne();
   1c0da: 6a 85        	mv	a0, s10
   1c0dc: 97 80 00 00  	auipc	ra, 8
   1c0e0: e7 80 c0 b1  	jalr	-1252(ra)
;         defer tmp_arena.deinit();
   1c0e4: 08 1a        	addi	a0, sp, 304
   1c0e6: 97 b0 ff ff  	auipc	ra, 1048571
   1c0ea: e7 80 80 29  	jalr	664(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c0ee: 03 35 8c 00  	ld	a0, 8(s8)
   1c0f2: 23 30 a1 28  	sd	a0, 640(sp)
   1c0f6: 03 35 0c 00  	ld	a0, 0(s8)
   1c0fa: 23 3c a1 26  	sd	a0, 632(sp)
   1c0fe: a8 1c        	addi	a0, sp, 632
   1c100: ae 65        	ld	a1, 200(sp)
   1c102: 5e 86        	mv	a2, s7
   1c104: 97 00 00 00  	auipc	ra, 0
   1c108: e7 80 00 78  	jalr	1920(ra)
;                 try file_entries.append(FileEntry{
   1c10c: 6a 85        	mv	a0, s10
   1c10e: 97 80 00 00  	auipc	ra, 8
   1c112: e7 80 a0 ae  	jalr	-1302(ra)
   1c116: 23 10 5b 03  	sh	s5, 32(s6)
   1c11a: 05 a4        	j	0x1c33a <.LBB45_239+0x7da>
;         defer tmp_arena.deinit();
   1c11c: 08 1a        	addi	a0, sp, 304
   1c11e: 97 b0 ff ff  	auipc	ra, 1048571
   1c122: e7 80 00 26  	jalr	608(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c126: 03 35 8c 00  	ld	a0, 8(s8)
   1c12a: 23 30 a1 2e  	sd	a0, 736(sp)
   1c12e: 03 35 0c 00  	ld	a0, 0(s8)
   1c132: 23 3c a1 2c  	sd	a0, 728(sp)
   1c136: a8 0d        	addi	a0, sp, 728
   1c138: b1 a9        	j	0x1c594 <.LBB45_239+0xa34>
;         defer tmp_arena.deinit();
   1c13a: 08 1a        	addi	a0, sp, 304
   1c13c: 97 b0 ff ff  	auipc	ra, 1048571
   1c140: e7 80 20 24  	jalr	578(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c144: 03 35 8c 00  	ld	a0, 8(s8)
   1c148: 23 3c a1 2e  	sd	a0, 760(sp)
   1c14c: 03 35 0c 00  	ld	a0, 0(s8)
   1c150: 23 38 a1 2e  	sd	a0, 752(sp)
   1c154: 88 1d        	addi	a0, sp, 752
   1c156: 3d a9        	j	0x1c594 <.LBB45_239+0xa34>
   1c158: 0a 75        	ld	a0, 160(sp)
   1c15a: aa f6        	sd	a0, 360(sp)
;         defer tmp_arena.deinit();
   1c15c: 08 1a        	addi	a0, sp, 304
   1c15e: 97 b0 ff ff  	auipc	ra, 1048571
   1c162: e7 80 00 22  	jalr	544(ra)
   1c166: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c168: 88 65        	ld	a0, 8(a1)
   1c16a: 23 3c a1 38  	sd	a0, 920(sp)
   1c16e: 88 61        	ld	a0, 0(a1)
   1c170: 23 38 a1 38  	sd	a0, 912(sp)
   1c174: 08 0f        	addi	a0, sp, 912
   1c176: 05 a0        	j	0x1c196 <.LBB45_239+0x636>
   1c178: 0a 75        	ld	a0, 160(sp)
   1c17a: aa f6        	sd	a0, 360(sp)
;         defer tmp_arena.deinit();
   1c17c: 08 1a        	addi	a0, sp, 304
   1c17e: 97 b0 ff ff  	auipc	ra, 1048571
   1c182: e7 80 00 20  	jalr	512(ra)
   1c186: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c188: 88 65        	ld	a0, 8(a1)
   1c18a: 23 38 a1 3a  	sd	a0, 944(sp)
   1c18e: 88 61        	ld	a0, 0(a1)
   1c190: 23 34 a1 3a  	sd	a0, 936(sp)
   1c194: 28 17        	addi	a0, sp, 936
   1c196: ae 65        	ld	a1, 200(sp)
   1c198: 02 76        	ld	a2, 32(sp)
   1c19a: 97 00 00 00  	auipc	ra, 0
   1c19e: e7 80 a0 6e  	jalr	1770(ra)
   1c1a2: 6a 85        	mv	a0, s10
   1c1a4: 97 80 00 00  	auipc	ra, 8
   1c1a8: e7 80 40 a5  	jalr	-1452(ra)
   1c1ac: 2a 65        	ld	a0, 136(sp)
   1c1ae: 23 10 85 02  	sh	s0, 32(a0)
   1c1b2: 61 a2        	j	0x1c33a <.LBB45_239+0x7da>
   1c1b4: 0a 75        	ld	a0, 160(sp)
   1c1b6: aa f6        	sd	a0, 360(sp)
;     return error.InvalidDebugInfo;
   1c1b8: 6a 85        	mv	a0, s10
   1c1ba: 97 80 00 00  	auipc	ra, 8
   1c1be: e7 80 e0 a3  	jalr	-1474(ra)
;             else => return badDwarf(),
   1c1c2: 6a 85        	mv	a0, s10
   1c1c4: 97 80 00 00  	auipc	ra, 8
   1c1c8: e7 80 40 a3  	jalr	-1484(ra)
;         defer tmp_arena.deinit();
   1c1cc: 08 1a        	addi	a0, sp, 304
   1c1ce: 97 b0 ff ff  	auipc	ra, 1048571
   1c1d2: e7 80 00 1b  	jalr	432(ra)
   1c1d6: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c1d8: 88 65        	ld	a0, 8(a1)
   1c1da: 23 30 a1 3e  	sd	a0, 992(sp)
   1c1de: 88 61        	ld	a0, 0(a1)
   1c1e0: 23 3c a1 3c  	sd	a0, 984(sp)
   1c1e4: a8 0f        	addi	a0, sp, 984
   1c1e6: 91 a9        	j	0x1c63a <.LBB45_239+0xada>
;             return self.ensureTotalCapacityPrecise(better_capacity);
   1c1e8: 6a 85        	mv	a0, s10
   1c1ea: 97 80 00 00  	auipc	ra, 8
   1c1ee: e7 80 e0 a0  	jalr	-1522(ra)
;             return self.ensureTotalCapacity(self.items.len + additional_count);
   1c1f2: 6a 85        	mv	a0, s10
   1c1f4: 97 80 00 00  	auipc	ra, 8
   1c1f8: e7 80 40 a0  	jalr	-1532(ra)
;         defer tmp_arena.deinit();
   1c1fc: 08 1a        	addi	a0, sp, 304
   1c1fe: 97 b0 ff ff  	auipc	ra, 1048571
   1c202: e7 80 00 18  	jalr	384(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c206: 03 35 8c 00  	ld	a0, 8(s8)
   1c20a: 23 34 a1 32  	sd	a0, 808(sp)
   1c20e: 03 35 0c 00  	ld	a0, 0(s8)
   1c212: 23 30 a1 32  	sd	a0, 800(sp)
   1c216: 08 16        	addi	a0, sp, 800
   1c218: ae 65        	ld	a1, 200(sp)
   1c21a: 5e 86        	mv	a2, s7
   1c21c: 97 00 00 00  	auipc	ra, 0
   1c220: e7 80 80 66  	jalr	1640(ra)
;                 try include_directories.ensureUnusedCapacity(directories_count);
   1c224: 6a 85        	mv	a0, s10
   1c226: 97 80 00 00  	auipc	ra, 8
   1c22a: e7 80 20 9d  	jalr	-1582(ra)
   1c22e: 23 10 9b 03  	sh	s9, 32(s6)
   1c232: 21 a2        	j	0x1c33a <.LBB45_239+0x7da>
;             if (amt_read < 1) return error.EndOfStream;
   1c234: 6a 85        	mv	a0, s10
   1c236: 97 80 00 00  	auipc	ra, 8
   1c23a: e7 80 20 9c  	jalr	-1598(ra)
;         defer tmp_arena.deinit();
   1c23e: 08 1a        	addi	a0, sp, 304
   1c240: 97 b0 ff ff  	auipc	ra, 1048571
   1c244: e7 80 e0 13  	jalr	318(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c248: 03 35 8c 00  	ld	a0, 8(s8)
   1c24c: 23 3c a1 40  	sd	a0, 1048(sp)
   1c250: 03 35 0c 00  	ld	a0, 0(s8)
   1c254: 23 38 a1 40  	sd	a0, 1040(sp)
   1c258: 13 05 01 41  	addi	a0, sp, 1040
   1c25c: ae 65        	ld	a1, 200(sp)
   1c25e: 5e 86        	mv	a2, s7
   1c260: 97 00 00 00  	auipc	ra, 0
   1c264: e7 80 40 62  	jalr	1572(ra)
   1c268: 6f f0 4f e1  	j	0x1b87c <.LBB45_180+0xa2>
;     return error.InvalidDebugInfo;
   1c26c: 6a 85        	mv	a0, s10
   1c26e: 97 80 00 00  	auipc	ra, 8
   1c272: e7 80 a0 98  	jalr	-1654(ra)
   1c276: 13 05 20 03  	li	a0, 50
;             if (file_name_entry_format_count > file_ent_fmt_buf.len) return badDwarf();
   1c27a: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1c27e: 08 1a        	addi	a0, sp, 304
   1c280: 97 b0 ff ff  	auipc	ra, 1048571
   1c284: e7 80 e0 0f  	jalr	254(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c288: 03 35 8c 00  	ld	a0, 8(s8)
   1c28c: 23 34 a1 42  	sd	a0, 1064(sp)
   1c290: 03 35 0c 00  	ld	a0, 0(s8)
   1c294: 23 30 a1 42  	sd	a0, 1056(sp)
   1c298: 13 05 01 42  	addi	a0, sp, 1056
   1c29c: ae 65        	ld	a1, 200(sp)
   1c29e: 5e 86        	mv	a2, s7
   1c2a0: 97 00 00 00  	auipc	ra, 0
   1c2a4: e7 80 40 5e  	jalr	1508(ra)
   1c2a8: 03 55 0b 02  	lhu	a0, 32(s6)
   1c2ac: 59 c5        	beqz	a0, 0x1c33a <.LBB45_239+0x7da>
   1c2ae: 6f f0 6f ee  	j	0x1b994 <.LBB45_180+0x1ba>
;         defer tmp_arena.deinit();
   1c2b2: 08 1a        	addi	a0, sp, 304
   1c2b4: 97 b0 ff ff  	auipc	ra, 1048571
   1c2b8: e7 80 a0 0c  	jalr	202(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c2bc: 03 35 8c 00  	ld	a0, 8(s8)
   1c2c0: 23 34 a1 7a  	sd	a0, 1960(sp)
   1c2c4: 03 35 0c 00  	ld	a0, 0(s8)
   1c2c8: 23 30 a1 7a  	sd	a0, 1952(sp)
   1c2cc: 13 05 01 7a  	addi	a0, sp, 1952
   1c2d0: ae 65        	ld	a1, 200(sp)
   1c2d2: 02 76        	ld	a2, 32(sp)
   1c2d4: 97 00 00 00  	auipc	ra, 0
   1c2d8: e7 80 00 5b  	jalr	1456(ra)
;                         if (try prog.checkLineMatch(allocator, file_entries.items)) |info| return info;
   1c2dc: 03 35 81 77  	ld	a0, 1912(sp)
   1c2e0: 83 35 01 77  	ld	a1, 1904(sp)
   1c2e4: 03 36 81 76  	ld	a2, 1896(sp)
   1c2e8: 83 36 01 76  	ld	a3, 1888(sp)
   1c2ec: 23 3c ab 00  	sd	a0, 24(s6)
   1c2f0: 23 38 bb 00  	sd	a1, 16(s6)
   1c2f4: 23 34 cb 00  	sd	a2, 8(s6)
   1c2f8: 23 30 db 00  	sd	a3, 0(s6)
   1c2fc: 23 10 0b 02  	sh	zero, 32(s6)
   1c300: 2d a8        	j	0x1c33a <.LBB45_239+0x7da>
;         defer tmp_arena.deinit();
   1c302: 08 1a        	addi	a0, sp, 304
   1c304: 97 b0 ff ff  	auipc	ra, 1048571
   1c308: e7 80 a0 07  	jalr	122(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c30c: 03 35 8c 00  	ld	a0, 8(s8)
   1c310: 23 3c a1 46  	sd	a0, 1144(sp)
   1c314: 03 35 0c 00  	ld	a0, 0(s8)
   1c318: 23 38 a1 46  	sd	a0, 1136(sp)
   1c31c: 13 05 01 47  	addi	a0, sp, 1136
   1c320: ae 65        	ld	a1, 200(sp)
   1c322: 5e 86        	mv	a2, s7
   1c324: 97 00 00 00  	auipc	ra, 0
   1c328: e7 80 00 56  	jalr	1376(ra)
   1c32c: 6a 85        	mv	a0, s10
   1c32e: 97 80 00 00  	auipc	ra, 8
   1c332: e7 80 a0 8c  	jalr	-1846(ra)
   1c336: 23 10 8b 02  	sh	s0, 32(s6)
   1c33a: 51 61        	addi	sp, sp, 272
   1c33c: 83 30 81 7e  	ld	ra, 2024(sp)
   1c340: 03 34 01 7e  	ld	s0, 2016(sp)
   1c344: 83 34 81 7d  	ld	s1, 2008(sp)
   1c348: 03 39 01 7d  	ld	s2, 2000(sp)
   1c34c: 83 39 81 7c  	ld	s3, 1992(sp)
   1c350: 03 3a 01 7c  	ld	s4, 1984(sp)
   1c354: 83 3a 81 7b  	ld	s5, 1976(sp)
   1c358: 03 3b 01 7b  	ld	s6, 1968(sp)
   1c35c: 83 3b 81 7a  	ld	s7, 1960(sp)
   1c360: 03 3c 01 7a  	ld	s8, 1952(sp)
   1c364: 83 3c 81 79  	ld	s9, 1944(sp)
   1c368: 03 3d 01 79  	ld	s10, 1936(sp)
   1c36c: 83 3d 81 78  	ld	s11, 1928(sp)
   1c370: 13 01 01 7f  	addi	sp, sp, 2032
   1c374: 82 80        	ret
;         defer tmp_arena.deinit();
   1c376: 08 1a        	addi	a0, sp, 304
   1c378: 97 b0 ff ff  	auipc	ra, 1048571
   1c37c: e7 80 60 00  	jalr	6(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c380: 03 35 8c 00  	ld	a0, 8(s8)
   1c384: 23 34 a1 5e  	sd	a0, 1512(sp)
   1c388: 03 35 0c 00  	ld	a0, 0(s8)
   1c38c: 23 30 a1 5e  	sd	a0, 1504(sp)
   1c390: 13 05 01 5e  	addi	a0, sp, 1504
   1c394: c9 a1        	j	0x1c856 <.LBB45_239+0xcf6>
;     return error.InvalidDebugInfo;
   1c396: 6a 85        	mv	a0, s10
   1c398: 97 80 00 00  	auipc	ra, 8
   1c39c: e7 80 00 86  	jalr	-1952(ra)
   1c3a0: 13 05 20 03  	li	a0, 50
;                 if (op_size < 1) return badDwarf();
   1c3a4: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1c3a8: 08 1a        	addi	a0, sp, 304
   1c3aa: 97 b0 ff ff  	auipc	ra, 1048571
   1c3ae: e7 80 40 fd  	jalr	-44(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c3b2: 03 35 8c 00  	ld	a0, 8(s8)
   1c3b6: 23 3c a1 5e  	sd	a0, 1528(sp)
   1c3ba: 03 35 0c 00  	ld	a0, 0(s8)
   1c3be: 23 38 a1 5e  	sd	a0, 1520(sp)
   1c3c2: 13 05 01 5f  	addi	a0, sp, 1520
   1c3c6: 89 b2        	j	0x1bd08 <.LBB45_239+0x1a8>
;             if (amt_read < 1) return error.EndOfStream;
   1c3c8: 6a 85        	mv	a0, s10
   1c3ca: 97 80 00 00  	auipc	ra, 8
   1c3ce: e7 80 e0 82  	jalr	-2002(ra)
;         defer tmp_arena.deinit();
   1c3d2: 08 1a        	addi	a0, sp, 304
   1c3d4: 97 b0 ff ff  	auipc	ra, 1048571
   1c3d8: e7 80 a0 fa  	jalr	-86(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c3dc: 03 35 8c 00  	ld	a0, 8(s8)
   1c3e0: 23 34 a1 60  	sd	a0, 1544(sp)
   1c3e4: 03 35 0c 00  	ld	a0, 0(s8)
   1c3e8: 23 30 a1 60  	sd	a0, 1536(sp)
   1c3ec: 13 05 01 60  	addi	a0, sp, 1536
   1c3f0: ae 65        	ld	a1, 200(sp)
   1c3f2: 02 76        	ld	a2, 32(sp)
   1c3f4: 97 00 00 00  	auipc	ra, 0
   1c3f8: e7 80 00 49  	jalr	1168(ra)
   1c3fc: 6f f0 0f c8  	j	0x1b87c <.LBB45_180+0xa2>
;         defer tmp_arena.deinit();
   1c400: 08 1a        	addi	a0, sp, 304
   1c402: 97 b0 ff ff  	auipc	ra, 1048571
   1c406: e7 80 c0 f7  	jalr	-132(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c40a: 03 35 8c 00  	ld	a0, 8(s8)
   1c40e: 23 3c a1 72  	sd	a0, 1848(sp)
   1c412: 03 35 0c 00  	ld	a0, 0(s8)
   1c416: 23 38 a1 72  	sd	a0, 1840(sp)
   1c41a: 13 05 01 73  	addi	a0, sp, 1840
   1c41e: 25 a9        	j	0x1c856 <.LBB45_239+0xcf6>
   1c420: 0a 75        	ld	a0, 160(sp)
   1c422: aa f6        	sd	a0, 360(sp)
   1c424: 19 a8        	j	0x1c43a <.LBB45_239+0x8da>
   1c426: 0a 75        	ld	a0, 160(sp)
   1c428: aa f6        	sd	a0, 360(sp)
   1c42a: b9 a0        	j	0x1c478 <.LBB45_239+0x918>
   1c42c: 0a 75        	ld	a0, 160(sp)
   1c42e: aa f6        	sd	a0, 360(sp)
;     return error.InvalidDebugInfo;
   1c430: 6a 85        	mv	a0, s10
   1c432: 97 70 00 00  	auipc	ra, 7
   1c436: e7 80 60 7c  	jalr	1990(ra)
   1c43a: 6a 85        	mv	a0, s10
   1c43c: 97 70 00 00  	auipc	ra, 7
   1c440: e7 80 c0 7b  	jalr	1980(ra)
   1c444: 6a 85        	mv	a0, s10
   1c446: 97 70 00 00  	auipc	ra, 7
   1c44a: e7 80 20 7b  	jalr	1970(ra)
;         defer tmp_arena.deinit();
   1c44e: 08 1a        	addi	a0, sp, 304
   1c450: 97 b0 ff ff  	auipc	ra, 1048571
   1c454: e7 80 e0 f2  	jalr	-210(ra)
   1c458: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c45a: 88 65        	ld	a0, 8(a1)
   1c45c: 23 30 a1 3c  	sd	a0, 960(sp)
   1c460: 88 61        	ld	a0, 0(a1)
   1c462: 23 3c a1 3a  	sd	a0, 952(sp)
   1c466: 28 1f        	addi	a0, sp, 952
   1c468: c9 aa        	j	0x1c63a <.LBB45_239+0xada>
   1c46a: 0a 75        	ld	a0, 160(sp)
   1c46c: aa f6        	sd	a0, 360(sp)
;     return error.InvalidDebugInfo;
   1c46e: 6a 85        	mv	a0, s10
   1c470: 97 70 00 00  	auipc	ra, 7
   1c474: e7 80 80 78  	jalr	1928(ra)
   1c478: 6a 85        	mv	a0, s10
   1c47a: 97 70 00 00  	auipc	ra, 7
   1c47e: e7 80 e0 77  	jalr	1918(ra)
   1c482: 6a 85        	mv	a0, s10
   1c484: 97 70 00 00  	auipc	ra, 7
   1c488: e7 80 40 77  	jalr	1908(ra)
;         defer tmp_arena.deinit();
   1c48c: 08 1a        	addi	a0, sp, 304
   1c48e: 97 b0 ff ff  	auipc	ra, 1048571
   1c492: e7 80 00 ef  	jalr	-272(ra)
   1c496: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c498: 88 65        	ld	a0, 8(a1)
   1c49a: 23 38 a1 3c  	sd	a0, 976(sp)
   1c49e: 88 61        	ld	a0, 0(a1)
   1c4a0: 23 34 a1 3c  	sd	a0, 968(sp)
   1c4a4: a8 07        	addi	a0, sp, 968
   1c4a6: 51 aa        	j	0x1c63a <.LBB45_239+0xada>
;         defer tmp_arena.deinit();
   1c4a8: 08 1a        	addi	a0, sp, 304
   1c4aa: 97 b0 ff ff  	auipc	ra, 1048571
   1c4ae: e7 80 40 ed  	jalr	-300(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c4b2: 03 35 8c 00  	ld	a0, 8(s8)
   1c4b6: 23 30 a1 44  	sd	a0, 1088(sp)
   1c4ba: 03 35 0c 00  	ld	a0, 0(s8)
   1c4be: 23 3c a1 42  	sd	a0, 1080(sp)
   1c4c2: 13 05 81 43  	addi	a0, sp, 1080
   1c4c6: f9 a0        	j	0x1c594 <.LBB45_239+0xa34>
;         defer tmp_arena.deinit();
   1c4c8: 08 1a        	addi	a0, sp, 304
   1c4ca: 97 b0 ff ff  	auipc	ra, 1048571
   1c4ce: e7 80 40 eb  	jalr	-332(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c4d2: 03 35 8c 00  	ld	a0, 8(s8)
   1c4d6: 23 3c a1 44  	sd	a0, 1112(sp)
   1c4da: 03 35 0c 00  	ld	a0, 0(s8)
   1c4de: 23 38 a1 44  	sd	a0, 1104(sp)
   1c4e2: 13 05 01 45  	addi	a0, sp, 1104
   1c4e6: 7d a0        	j	0x1c594 <.LBB45_239+0xa34>
   1c4e8: 0a 75        	ld	a0, 160(sp)
   1c4ea: 2a eb        	sd	a0, 400(sp)
;         defer tmp_arena.deinit();
   1c4ec: 08 1a        	addi	a0, sp, 304
   1c4ee: 97 b0 ff ff  	auipc	ra, 1048571
   1c4f2: e7 80 00 e9  	jalr	-368(ra)
   1c4f6: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c4f8: 88 65        	ld	a0, 8(a1)
   1c4fa: 23 34 a1 50  	sd	a0, 1288(sp)
   1c4fe: 88 61        	ld	a0, 0(a1)
   1c500: 23 30 a1 50  	sd	a0, 1280(sp)
   1c504: 13 05 01 50  	addi	a0, sp, 1280
   1c508: 25 ba        	j	0x1be40 <.LBB45_239+0x2e0>
   1c50a: 0a 75        	ld	a0, 160(sp)
   1c50c: 2a eb        	sd	a0, 400(sp)
;         defer tmp_arena.deinit();
   1c50e: 08 1a        	addi	a0, sp, 304
   1c510: 97 b0 ff ff  	auipc	ra, 1048571
   1c514: e7 80 e0 e6  	jalr	-402(ra)
   1c518: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c51a: 88 65        	ld	a0, 8(a1)
   1c51c: 23 30 a1 52  	sd	a0, 1312(sp)
   1c520: 88 61        	ld	a0, 0(a1)
   1c522: 23 3c a1 50  	sd	a0, 1304(sp)
   1c526: 13 05 81 51  	addi	a0, sp, 1304
   1c52a: 19 ba        	j	0x1be40 <.LBB45_239+0x2e0>
   1c52c: 0a 75        	ld	a0, 160(sp)
   1c52e: 2a eb        	sd	a0, 400(sp)
;     return error.InvalidDebugInfo;
   1c530: 6a 85        	mv	a0, s10
   1c532: 97 70 00 00  	auipc	ra, 7
   1c536: e7 80 60 6c  	jalr	1734(ra)
;             else => return badDwarf(),
   1c53a: 6a 85        	mv	a0, s10
   1c53c: 97 70 00 00  	auipc	ra, 7
   1c540: e7 80 c0 6b  	jalr	1724(ra)
;         defer tmp_arena.deinit();
   1c544: 08 1a        	addi	a0, sp, 304
   1c546: 97 b0 ff ff  	auipc	ra, 1048571
   1c54a: e7 80 80 e3  	jalr	-456(ra)
   1c54e: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c550: 88 65        	ld	a0, 8(a1)
   1c552: 23 38 a1 54  	sd	a0, 1360(sp)
   1c556: 88 61        	ld	a0, 0(a1)
   1c558: 23 34 a1 54  	sd	a0, 1352(sp)
   1c55c: 13 05 81 54  	addi	a0, sp, 1352
   1c560: e9 a8        	j	0x1c63a <.LBB45_239+0xada>
;             return self.ensureTotalCapacityPrecise(better_capacity);
   1c562: 6a 85        	mv	a0, s10
   1c564: 97 70 00 00  	auipc	ra, 7
   1c568: e7 80 40 69  	jalr	1684(ra)
;             return self.ensureTotalCapacity(self.items.len + additional_count);
   1c56c: 6a 85        	mv	a0, s10
   1c56e: 97 70 00 00  	auipc	ra, 7
   1c572: e7 80 a0 68  	jalr	1674(ra)
;         defer tmp_arena.deinit();
   1c576: 08 1a        	addi	a0, sp, 304
   1c578: 97 b0 ff ff  	auipc	ra, 1048571
   1c57c: e7 80 60 e0  	jalr	-506(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c580: 03 35 8c 00  	ld	a0, 8(s8)
   1c584: 23 34 a1 48  	sd	a0, 1160(sp)
   1c588: 03 35 0c 00  	ld	a0, 0(s8)
   1c58c: 23 30 a1 48  	sd	a0, 1152(sp)
   1c590: 13 05 01 48  	addi	a0, sp, 1152
   1c594: ae 65        	ld	a1, 200(sp)
   1c596: 5e 86        	mv	a2, s7
   1c598: 97 00 00 00  	auipc	ra, 0
   1c59c: e7 80 c0 2e  	jalr	748(ra)
   1c5a0: 6a 85        	mv	a0, s10
   1c5a2: 97 70 00 00  	auipc	ra, 7
   1c5a6: e7 80 60 65  	jalr	1622(ra)
   1c5aa: 23 10 2b 03  	sh	s2, 32(s6)
   1c5ae: 71 b3        	j	0x1c33a <.LBB45_239+0x7da>
   1c5b0: 0a 75        	ld	a0, 160(sp)
   1c5b2: 2a eb        	sd	a0, 400(sp)
   1c5b4: 19 a8        	j	0x1c5ca <.LBB45_239+0xa6a>
   1c5b6: 0a 75        	ld	a0, 160(sp)
   1c5b8: 2a eb        	sd	a0, 400(sp)
   1c5ba: 81 a8        	j	0x1c60a <.LBB45_239+0xaaa>
   1c5bc: 0a 75        	ld	a0, 160(sp)
   1c5be: 2a eb        	sd	a0, 400(sp)
;     return error.InvalidDebugInfo;
   1c5c0: 6a 85        	mv	a0, s10
   1c5c2: 97 70 00 00  	auipc	ra, 7
   1c5c6: e7 80 60 63  	jalr	1590(ra)
   1c5ca: 6a 85        	mv	a0, s10
   1c5cc: 97 70 00 00  	auipc	ra, 7
   1c5d0: e7 80 c0 62  	jalr	1580(ra)
   1c5d4: 6a 85        	mv	a0, s10
   1c5d6: 97 70 00 00  	auipc	ra, 7
   1c5da: e7 80 20 62  	jalr	1570(ra)
;         defer tmp_arena.deinit();
   1c5de: 08 1a        	addi	a0, sp, 304
   1c5e0: 97 b0 ff ff  	auipc	ra, 1048571
   1c5e4: e7 80 e0 d9  	jalr	-610(ra)
   1c5e8: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c5ea: 88 65        	ld	a0, 8(a1)
   1c5ec: 23 38 a1 52  	sd	a0, 1328(sp)
   1c5f0: 88 61        	ld	a0, 0(a1)
   1c5f2: 23 34 a1 52  	sd	a0, 1320(sp)
   1c5f6: 13 05 81 52  	addi	a0, sp, 1320
   1c5fa: 81 a0        	j	0x1c63a <.LBB45_239+0xada>
   1c5fc: 0a 75        	ld	a0, 160(sp)
   1c5fe: 2a eb        	sd	a0, 400(sp)
;     return error.InvalidDebugInfo;
   1c600: 6a 85        	mv	a0, s10
   1c602: 97 70 00 00  	auipc	ra, 7
   1c606: e7 80 60 5f  	jalr	1526(ra)
   1c60a: 6a 85        	mv	a0, s10
   1c60c: 97 70 00 00  	auipc	ra, 7
   1c610: e7 80 c0 5e  	jalr	1516(ra)
   1c614: 6a 85        	mv	a0, s10
   1c616: 97 70 00 00  	auipc	ra, 7
   1c61a: e7 80 20 5e  	jalr	1506(ra)
;         defer tmp_arena.deinit();
   1c61e: 08 1a        	addi	a0, sp, 304
   1c620: 97 b0 ff ff  	auipc	ra, 1048571
   1c624: e7 80 e0 d5  	jalr	-674(ra)
   1c628: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c62a: 88 65        	ld	a0, 8(a1)
   1c62c: 23 30 a1 54  	sd	a0, 1344(sp)
   1c630: 88 61        	ld	a0, 0(a1)
   1c632: 23 3c a1 52  	sd	a0, 1336(sp)
   1c636: 13 05 81 53  	addi	a0, sp, 1336
   1c63a: ae 65        	ld	a1, 200(sp)
   1c63c: 02 76        	ld	a2, 32(sp)
   1c63e: 97 00 00 00  	auipc	ra, 0
   1c642: e7 80 60 24  	jalr	582(ra)
   1c646: 6a 85        	mv	a0, s10
   1c648: 97 70 00 00  	auipc	ra, 7
   1c64c: e7 80 00 5b  	jalr	1456(ra)
   1c650: 13 05 20 03  	li	a0, 50
   1c654: aa 65        	ld	a1, 136(sp)
   1c656: 23 90 a5 02  	sh	a0, 32(a1)
   1c65a: c5 b1        	j	0x1c33a <.LBB45_239+0x7da>
;         defer tmp_arena.deinit();
   1c65c: 08 1a        	addi	a0, sp, 304
   1c65e: 97 b0 ff ff  	auipc	ra, 1048571
   1c662: e7 80 00 d2  	jalr	-736(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c666: 03 35 8c 00  	ld	a0, 8(s8)
   1c66a: 23 34 a1 64  	sd	a0, 1608(sp)
   1c66e: 03 35 0c 00  	ld	a0, 0(s8)
   1c672: 23 30 a1 64  	sd	a0, 1600(sp)
   1c676: 13 05 01 64  	addi	a0, sp, 1600
   1c67a: f1 aa        	j	0x1c856 <.LBB45_239+0xcf6>
;         defer tmp_arena.deinit();
   1c67c: 08 1a        	addi	a0, sp, 304
   1c67e: 97 b0 ff ff  	auipc	ra, 1048571
   1c682: e7 80 00 d0  	jalr	-768(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c686: 03 35 8c 00  	ld	a0, 8(s8)
   1c68a: 23 30 a1 68  	sd	a0, 1664(sp)
   1c68e: 03 35 0c 00  	ld	a0, 0(s8)
   1c692: 23 3c a1 66  	sd	a0, 1656(sp)
   1c696: 13 05 81 67  	addi	a0, sp, 1656
   1c69a: 75 aa        	j	0x1c856 <.LBB45_239+0xcf6>
;     return error.InvalidDebugInfo;
   1c69c: 6a 85        	mv	a0, s10
   1c69e: 97 70 00 00  	auipc	ra, 7
   1c6a2: e7 80 a0 55  	jalr	1370(ra)
   1c6a6: 13 05 20 03  	li	a0, 50
;                         const fwd_amt = math.cast(isize, op_size - 1) orelse return badDwarf();
   1c6aa: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1c6ae: 08 1a        	addi	a0, sp, 304
   1c6b0: 97 b0 ff ff  	auipc	ra, 1048571
   1c6b4: e7 80 e0 cc  	jalr	-818(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c6b8: 03 35 8c 00  	ld	a0, 8(s8)
   1c6bc: 23 3c a1 6e  	sd	a0, 1784(sp)
   1c6c0: 03 35 0c 00  	ld	a0, 0(s8)
   1c6c4: 23 38 a1 6e  	sd	a0, 1776(sp)
   1c6c8: 13 05 01 6f  	addi	a0, sp, 1776
   1c6cc: 6f f0 cf e3  	j	0x1bd08 <.LBB45_239+0x1a8>
;         defer tmp_arena.deinit();
   1c6d0: 08 1a        	addi	a0, sp, 304
   1c6d2: 97 b0 ff ff  	auipc	ra, 1048571
   1c6d6: e7 80 c0 ca  	jalr	-852(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c6da: 03 35 8c 00  	ld	a0, 8(s8)
   1c6de: 23 3c a1 68  	sd	a0, 1688(sp)
   1c6e2: 03 35 0c 00  	ld	a0, 0(s8)
   1c6e6: 23 38 a1 68  	sd	a0, 1680(sp)
   1c6ea: 13 05 01 69  	addi	a0, sp, 1680
   1c6ee: 65 b4        	j	0x1c196 <.LBB45_239+0x636>
;         defer tmp_arena.deinit();
   1c6f0: 08 1a        	addi	a0, sp, 304
   1c6f2: 97 b0 ff ff  	auipc	ra, 1048571
   1c6f6: e7 80 c0 c8  	jalr	-884(ra)
   1c6fa: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c6fc: 88 65        	ld	a0, 8(a1)
   1c6fe: 23 3c a1 6a  	sd	a0, 1720(sp)
   1c702: 88 61        	ld	a0, 0(a1)
   1c704: 23 38 a1 6a  	sd	a0, 1712(sp)
   1c708: 13 05 01 6b  	addi	a0, sp, 1712
   1c70c: 69 b4        	j	0x1c196 <.LBB45_239+0x636>
;         defer tmp_arena.deinit();
   1c70e: 08 1a        	addi	a0, sp, 304
   1c710: 97 b0 ff ff  	auipc	ra, 1048571
   1c714: e7 80 e0 c6  	jalr	-914(ra)
   1c718: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c71a: 88 65        	ld	a0, 8(a1)
   1c71c: 23 3c a1 6c  	sd	a0, 1752(sp)
   1c720: 88 61        	ld	a0, 0(a1)
   1c722: 23 38 a1 6c  	sd	a0, 1744(sp)
   1c726: 13 05 01 6d  	addi	a0, sp, 1744
   1c72a: 6f f0 6f f1  	j	0x1be40 <.LBB45_239+0x2e0>
;             const new_item_ptr = try self.addOne();
   1c72e: 6a 85        	mv	a0, s10
   1c730: 97 70 00 00  	auipc	ra, 7
   1c734: e7 80 80 4c  	jalr	1224(ra)
;         defer tmp_arena.deinit();
   1c738: 08 1a        	addi	a0, sp, 304
   1c73a: 97 b0 ff ff  	auipc	ra, 1048571
   1c73e: e7 80 40 c4  	jalr	-956(ra)
   1c742: ea 65        	ld	a1, 152(sp)
;         defer allocator.free(standard_opcode_lengths);
   1c744: 88 65        	ld	a0, 8(a1)
   1c746: 23 34 a1 6e  	sd	a0, 1768(sp)
   1c74a: 88 61        	ld	a0, 0(a1)
   1c74c: 23 30 a1 6e  	sd	a0, 1760(sp)
   1c750: 13 05 01 6e  	addi	a0, sp, 1760
   1c754: 6f f0 cf ee  	j	0x1be40 <.LBB45_239+0x2e0>
;         defer tmp_arena.deinit();
   1c758: 08 1a        	addi	a0, sp, 304
   1c75a: 97 b0 ff ff  	auipc	ra, 1048571
   1c75e: e7 80 40 c2  	jalr	-988(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c762: 03 35 8c 00  	ld	a0, 8(s8)
   1c766: 23 3c a1 78  	sd	a0, 1944(sp)
   1c76a: 03 35 0c 00  	ld	a0, 0(s8)
   1c76e: 23 38 a1 78  	sd	a0, 1936(sp)
   1c772: 13 05 01 79  	addi	a0, sp, 1936
   1c776: c5 a0        	j	0x1c856 <.LBB45_239+0xcf6>
;     return error.InvalidDebugInfo;
   1c778: 6a 85        	mv	a0, s10
   1c77a: 97 70 00 00  	auipc	ra, 7
   1c77e: e7 80 e0 47  	jalr	1150(ra)
   1c782: 13 05 20 03  	li	a0, 50
;                         if (opcode - 1 >= standard_opcode_lengths.len) return badDwarf();
   1c786: 23 10 ab 02  	sh	a0, 32(s6)
;         defer tmp_arena.deinit();
   1c78a: 08 1a        	addi	a0, sp, 304
   1c78c: 97 b0 ff ff  	auipc	ra, 1048571
   1c790: e7 80 20 bf  	jalr	-1038(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c794: 03 35 8c 00  	ld	a0, 8(s8)
   1c798: 85 65        	lui	a1, 1
   1c79a: 9b 85 85 84  	addiw	a1, a1, -1976
   1c79e: 8a 95        	add	a1, a1, sp
   1c7a0: 88 e1        	sd	a0, 0(a1)
   1c7a2: 03 35 0c 00  	ld	a0, 0(s8)
   1c7a6: 85 65        	lui	a1, 1
   1c7a8: 9b 85 05 84  	addiw	a1, a1, -1984
   1c7ac: 8a 95        	add	a1, a1, sp
   1c7ae: 88 e1        	sd	a0, 0(a1)
   1c7b0: 05 65        	lui	a0, 1
   1c7b2: 1b 05 05 84  	addiw	a0, a0, -1984
   1c7b6: 6f f0 0f d5  	j	0x1bd06 <.LBB45_239+0x1a6>
;         defer tmp_arena.deinit();
   1c7ba: 08 1a        	addi	a0, sp, 304
   1c7bc: 97 b0 ff ff  	auipc	ra, 1048571
   1c7c0: e7 80 20 bc  	jalr	-1086(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c7c4: 03 35 8c 00  	ld	a0, 8(s8)
   1c7c8: 23 34 a1 7c  	sd	a0, 1992(sp)
   1c7cc: 03 35 0c 00  	ld	a0, 0(s8)
   1c7d0: 23 30 a1 7c  	sd	a0, 1984(sp)
   1c7d4: 13 05 01 7c  	addi	a0, sp, 1984
   1c7d8: bd a8        	j	0x1c856 <.LBB45_239+0xcf6>
;         defer tmp_arena.deinit();
   1c7da: 08 1a        	addi	a0, sp, 304
   1c7dc: 97 b0 ff ff  	auipc	ra, 1048571
   1c7e0: e7 80 20 ba  	jalr	-1118(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c7e4: 03 35 8c 00  	ld	a0, 8(s8)
   1c7e8: 23 34 a1 7e  	sd	a0, 2024(sp)
   1c7ec: 03 35 0c 00  	ld	a0, 0(s8)
   1c7f0: 23 30 a1 7e  	sd	a0, 2016(sp)
   1c7f4: 13 05 01 7e  	addi	a0, sp, 2016
   1c7f8: b9 a8        	j	0x1c856 <.LBB45_239+0xcf6>
;         defer tmp_arena.deinit();
   1c7fa: 08 1a        	addi	a0, sp, 304
   1c7fc: 97 b0 ff ff  	auipc	ra, 1048571
   1c800: e7 80 20 b8  	jalr	-1150(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c804: 03 35 8c 00  	ld	a0, 8(s8)
   1c808: 85 65        	lui	a1, 1
   1c80a: 9b 85 85 80  	addiw	a1, a1, -2040
   1c80e: 8a 95        	add	a1, a1, sp
   1c810: 88 e1        	sd	a0, 0(a1)
   1c812: 03 35 0c 00  	ld	a0, 0(s8)
   1c816: 85 65        	lui	a1, 1
   1c818: 9b 85 05 80  	addiw	a1, a1, -2048
   1c81c: 8a 95        	add	a1, a1, sp
   1c81e: 88 e1        	sd	a0, 0(a1)
   1c820: 05 65        	lui	a0, 1
   1c822: 1b 05 05 80  	addiw	a0, a0, -2048
   1c826: 3d a0        	j	0x1c854 <.LBB45_239+0xcf4>
;         defer tmp_arena.deinit();
   1c828: 08 1a        	addi	a0, sp, 304
   1c82a: 97 b0 ff ff  	auipc	ra, 1048571
   1c82e: e7 80 40 b5  	jalr	-1196(ra)
;         defer allocator.free(standard_opcode_lengths);
   1c832: 03 35 8c 00  	ld	a0, 8(s8)
   1c836: 85 65        	lui	a1, 1
   1c838: 9b 85 85 82  	addiw	a1, a1, -2008
   1c83c: 8a 95        	add	a1, a1, sp
   1c83e: 88 e1        	sd	a0, 0(a1)
   1c840: 03 35 0c 00  	ld	a0, 0(s8)
   1c844: 85 65        	lui	a1, 1
   1c846: 9b 85 05 82  	addiw	a1, a1, -2016
   1c84a: 8a 95        	add	a1, a1, sp
   1c84c: 88 e1        	sd	a0, 0(a1)
   1c84e: 05 65        	lui	a0, 1
   1c850: 1b 05 05 82  	addiw	a0, a0, -2016
   1c854: 0a 95        	add	a0, a0, sp
   1c856: ae 65        	ld	a1, 200(sp)
   1c858: 02 76        	ld	a2, 32(sp)
   1c85a: e9 b4        	j	0x1c324 <.LBB45_239+0x7c4>
   1c85c: 37 15 01 00  	lui	a0, 17
   1c860: 13 05 95 5d  	addi	a0, a0, 1497
   1c864: c1 45        	li	a1, 16
   1c866: 81 46        	li	a3, 0
   1c868: 97 70 00 00  	auipc	ra, 7
   1c86c: e7 80 20 b1  	jalr	-1262(ra)
   1c870: 37 25 01 00  	lui	a0, 18
   1c874: 13 05 b5 a7  	addi	a0, a0, -1413
   1c878: e1 45        	li	a1, 24
   1c87a: 81 46        	li	a3, 0
   1c87c: 97 70 00 00  	auipc	ra, 7
   1c880: e7 80 e0 af  	jalr	-1282(ra)

000000000001c884 <mem.Allocator.free__anon_5362>:
; pub fn free(self: Allocator, memory: anytype) void {
   1c884: 79 71        	addi	sp, sp, -48
   1c886: 06 f4        	sd	ra, 40(sp)
   1c888: 22 f0        	sd	s0, 32(sp)
   1c88a: 26 ec        	sd	s1, 24(sp)
   1c88c: 4a e8        	sd	s2, 16(sp)
   1c88e: 4e e4        	sd	s3, 8(sp)
   1c890: 06 89        	mv	s2, ra
   1c892: aa 89        	mv	s3, a0
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1c894: 0d ce        	beqz	a2, 0x1c8ce <mem.Allocator.free__anon_5362+0x4a>
   1c896: 32 84        	mv	s0, a2
   1c898: ae 84        	mv	s1, a1
;     if (bytes_len == 0) return;
   1c89a: 21 c0        	beqz	s0, 0x1c8da <mem.Allocator.free__anon_5362+0x56>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1c89c: b1 c4        	beqz	s1, 0x1c8e8 <mem.Allocator.free__anon_5362+0x64>
;     @memset(non_const_ptr, undefined, bytes_len);
   1c89e: 93 05 a0 0a  	li	a1, 170
   1c8a2: 26 85        	mv	a0, s1
   1c8a4: 22 86        	mv	a2, s0
   1c8a6: 97 80 00 00  	auipc	ra, 8
   1c8aa: e7 80 40 9f  	jalr	-1548(ra)
;     self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());
   1c8ae: 83 b5 89 00  	ld	a1, 8(s3)
   1c8b2: 03 b5 09 00  	ld	a0, 0(s3)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1c8b6: 9c 69        	ld	a5, 16(a1)
   1c8b8: a6 85        	mv	a1, s1
   1c8ba: 22 86        	mv	a2, s0
   1c8bc: 81 46        	li	a3, 0
   1c8be: 4a 87        	mv	a4, s2
   1c8c0: a2 70        	ld	ra, 40(sp)
   1c8c2: 02 74        	ld	s0, 32(sp)
   1c8c4: e2 64        	ld	s1, 24(sp)
   1c8c6: 42 69        	ld	s2, 16(sp)
   1c8c8: a2 69        	ld	s3, 8(sp)
   1c8ca: 45 61        	addi	sp, sp, 48
   1c8cc: 82 87        	jr	a5
   1c8ce: 37 55 02 00  	lui	a0, 37
   1c8d2: 83 34 05 38  	ld	s1, 896(a0)
   1c8d6: 01 44        	li	s0, 0
;     if (bytes_len == 0) return;
   1c8d8: 71 f0        	bnez	s0, 0x1c89c <mem.Allocator.free__anon_5362+0x18>
   1c8da: a2 70        	ld	ra, 40(sp)
   1c8dc: 02 74        	ld	s0, 32(sp)
   1c8de: e2 64        	ld	s1, 24(sp)
   1c8e0: 42 69        	ld	s2, 16(sp)
   1c8e2: a2 69        	ld	s3, 8(sp)
   1c8e4: 45 61        	addi	sp, sp, 48
   1c8e6: 82 80        	ret
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1c8e8: 37 25 01 00  	lui	a0, 18
   1c8ec: 13 05 a5 86  	addi	a0, a0, -1942
   1c8f0: f9 45        	li	a1, 30
   1c8f2: 81 46        	li	a3, 0
   1c8f4: 97 70 00 00  	auipc	ra, 7
   1c8f8: e7 80 60 a8  	jalr	-1402(ra)

000000000001c8fc <debug.printSourceAtAddress__anon_4137>:
; pub fn printSourceAtAddress(debug_info: *DebugInfo, out_stream: anytype, address: usize, tty_config: TTY.Config) !void {
   1c8fc: 13 01 01 81  	addi	sp, sp, -2032
   1c900: 23 34 11 7e  	sd	ra, 2024(sp)
   1c904: 23 30 81 7e  	sd	s0, 2016(sp)
   1c908: 23 3c 91 7c  	sd	s1, 2008(sp)
   1c90c: 23 38 21 7d  	sd	s2, 2000(sp)
   1c910: 23 34 31 7d  	sd	s3, 1992(sp)
   1c914: 23 30 41 7d  	sd	s4, 1984(sp)
   1c918: 23 3c 51 7b  	sd	s5, 1976(sp)
   1c91c: 23 38 61 7b  	sd	s6, 1968(sp)
   1c920: 23 34 71 7b  	sd	s7, 1960(sp)
   1c924: 23 30 81 7b  	sd	s8, 1952(sp)
   1c928: 23 3c 91 79  	sd	s9, 1944(sp)
   1c92c: 23 38 a1 79  	sd	s10, 1936(sp)
   1c930: 23 34 b1 79  	sd	s11, 1928(sp)
   1c934: 89 67        	lui	a5, 2
   1c936: 9b 87 07 e0  	addiw	a5, a5, -512
   1c93a: 33 01 f1 40  	sub	sp, sp, a5
   1c93e: 06 8d        	mv	s10, ra
   1c940: 3a 8a        	mv	s4, a4
   1c942: b6 8a        	mv	s5, a3
   1c944: b2 8d        	mv	s11, a2
   1c946: 2e e6        	sd	a1, 264(sp)
   1c948: 2a 8c        	mv	s8, a0
   1c94a: 01 47        	li	a4, 0
   1c94c: 08 61        	ld	a0, 0(a0)
   1c94e: aa fd        	sd	a0, 248(sp)
   1c950: 37 55 02 00  	lui	a0, 37
   1c954: 83 35 85 38  	ld	a1, 904(a0)
;     const auxv = elf_aux_maybe orelse return 0;
   1c958: 37 55 02 00  	lui	a0, 37
   1c95c: 03 35 05 44  	ld	a0, 1088(a0)
;         var ctx: struct {
   1c960: 36 eb        	sd	a3, 400(sp)
   1c962: 2e ef        	sd	a1, 408(sp)
   1c964: 2e f3        	sd	a1, 416(sp)
   1c966: 2e f7        	sd	a1, 424(sp)
;     const auxv = elf_aux_maybe orelse return 0;
   1c968: 25 c1        	beqz	a0, 0x1c9c8 <debug.printSourceAtAddress__anon_4137+0xcc>
   1c96a: 81 46        	li	a3, 0
;     while (auxv[i].a_type != std.elf.AT_NULL) : (i += 1) {
   1c96c: 13 06 85 00  	addi	a2, a0, 8
   1c970: 1d 47        	li	a4, 7
   1c972: fd 57        	li	a5, -1
   1c974: 83 35 86 ff  	ld	a1, -8(a2)
   1c978: 95 c1        	beqz	a1, 0x1c99c <debug.printSourceAtAddress__anon_4137+0xa0>
   1c97a: 63 8c e5 00  	beq	a1, a4, 0x1c992 <debug.printSourceAtAddress__anon_4137+0x96>
   1c97e: 63 94 f6 00  	bne	a3, a5, 0x1c986 <debug.printSourceAtAddress__anon_4137+0x8a>
   1c982: 6f 30 f0 55  	j	0x206e0 <.LBB47_196+0x3266>
   1c986: 41 06        	addi	a2, a2, 16
   1c988: 85 06        	addi	a3, a3, 1
   1c98a: 83 35 86 ff  	ld	a1, -8(a2)
   1c98e: f5 f5        	bnez	a1, 0x1c97a <debug.printSourceAtAddress__anon_4137+0x7e>
   1c990: 31 a0        	j	0x1c99c <debug.printSourceAtAddress__anon_4137+0xa0>
;             return auxv[i].a_un.a_val;
   1c992: 83 39 06 00  	ld	s3, 0(a2)
   1c996: 81 45        	li	a1, 0
;             if (base != 0) {
   1c998: 63 92 09 04  	bnez	s3, 0x1c9dc <debug.printSourceAtAddress__anon_4137+0xe0>
;     while (auxv[i].a_type != std.elf.AT_NULL) : (i += 1) {
   1c99c: 13 96 45 00  	slli	a2, a1, 4
   1c9a0: 32 95        	add	a0, a0, a2
   1c9a2: 21 05        	addi	a0, a0, 8
   1c9a4: 0d 46        	li	a2, 3
   1c9a6: fd 56        	li	a3, -1
   1c9a8: 03 37 85 ff  	ld	a4, -8(a0)
   1c9ac: 11 cf        	beqz	a4, 0x1c9c8 <debug.printSourceAtAddress__anon_4137+0xcc>
   1c9ae: 63 0c c7 00  	beq	a4, a2, 0x1c9c6 <debug.printSourceAtAddress__anon_4137+0xca>
   1c9b2: 63 94 d5 00  	bne	a1, a3, 0x1c9ba <debug.printSourceAtAddress__anon_4137+0xbe>
   1c9b6: 6f 30 b0 52  	j	0x206e0 <.LBB47_196+0x3266>
   1c9ba: 41 05        	addi	a0, a0, 16
   1c9bc: 85 05        	addi	a1, a1, 1
   1c9be: 03 37 85 ff  	ld	a4, -8(a0)
   1c9c2: 75 f7        	bnez	a4, 0x1c9ae <debug.printSourceAtAddress__anon_4137+0xb2>
   1c9c4: 11 a0        	j	0x1c9c8 <debug.printSourceAtAddress__anon_4137+0xcc>
;             return auxv[i].a_un.a_val;
   1c9c6: 18 61        	ld	a4, 0(a0)
;             return phdr - @sizeOf(std.elf.Ehdr);
   1c9c8: 93 09 07 fc  	addi	s3, a4, -64
   1c9cc: 63 74 37 01  	bgeu	a4, s3, 0x1c9d4 <debug.printSourceAtAddress__anon_4137+0xd8>
   1c9d0: 6f 30 10 51  	j	0x206e0 <.LBB47_196+0x3266>
   1c9d4: 63 94 09 00  	bnez	s3, 0x1c9dc <debug.printSourceAtAddress__anon_4137+0xe0>
   1c9d8: 6f 20 60 68  	j	0x1f05e <.LBB47_196+0x1be4>
;     const ehdr = @intToPtr(*elf.Ehdr, elf_base);
   1c9dc: 13 f5 79 00  	andi	a0, s3, 7
   1c9e0: 63 11 05 1a  	bnez	a0, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;     if (a.ptr == b.ptr) return true;
   1c9e4: 37 25 01 00  	lui	a0, 18
   1c9e8: 13 05 15 bf  	addi	a0, a0, -1039
   1c9ec: 63 8a a9 02  	beq	s3, a0, 0x1ca20 <debug.printSourceAtAddress__anon_4137+0x124>
;     for (a) |item, index| {
   1c9f0: 03 c5 09 00  	lbu	a0, 0(s3)
   1c9f4: 93 05 f0 07  	li	a1, 127
;         if (b[index] != item) return false;
   1c9f8: 63 1f b5 0c  	bne	a0, a1, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (a) |item, index| {
   1c9fc: 03 c5 19 00  	lbu	a0, 1(s3)
   1ca00: 93 05 50 04  	li	a1, 69
;         if (b[index] != item) return false;
   1ca04: 63 19 b5 0c  	bne	a0, a1, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (a) |item, index| {
   1ca08: 03 c5 29 00  	lbu	a0, 2(s3)
   1ca0c: 93 05 c0 04  	li	a1, 76
;         if (b[index] != item) return false;
   1ca10: 63 13 b5 0c  	bne	a0, a1, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (a) |item, index| {
   1ca14: 03 c5 39 00  	lbu	a0, 3(s3)
   1ca18: 93 05 60 04  	li	a1, 70
;         if (b[index] != item) return false;
   1ca1c: 63 1d b5 0a  	bne	a0, a1, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     const phdrs = (@intToPtr([*]elf.Phdr, elf_base + ehdr.e_phoff))[0..n_phdr];
   1ca20: 03 b5 09 02  	ld	a0, 32(s3)
   1ca24: 4e 95        	add	a0, a0, s3
   1ca26: 63 74 35 01  	bgeu	a0, s3, 0x1ca2e <debug.printSourceAtAddress__anon_4137+0x132>
   1ca2a: 6f 30 70 4b  	j	0x206e0 <.LBB47_196+0x3266>
   1ca2e: 19 e1        	bnez	a0, 0x1ca34 <debug.printSourceAtAddress__anon_4137+0x138>
   1ca30: 6f 20 e0 62  	j	0x1f05e <.LBB47_196+0x1be4>
   1ca34: 93 75 75 00  	andi	a1, a0, 7
   1ca38: 63 95 05 14  	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
   1ca3c: 03 d8 89 03  	lhu	a6, 56(s3)
;     const _DYNAMIC = get_DYNAMIC() orelse {
   1ca40: 37 06 00 00  	lui	a2, 0
   1ca44: 93 06 06 00  	mv	a3, a2
   1ca48: b5 c6        	beqz	a3, 0x1cab4 <debug.printSourceAtAddress__anon_4137+0x1b8>
   1ca4a: 01 46        	li	a2, 0
   1ca4c: 13 89 89 03  	addi	s2, s3, 56
   1ca50: a1 06        	addi	a3, a3, 8
   1ca52: 0d 47        	li	a4, 3
   1ca54: fd 57        	li	a5, -1
   1ca56: d5 44        	li	s1, 21
;         while (_DYNAMIC[i].d_tag != elf.DT_NULL) : (i += 1) {
   1ca58: 03 b4 86 ff  	ld	s0, -8(a3)
   1ca5c: 63 0d e4 00  	beq	s0, a4, 0x1ca76 <debug.printSourceAtAddress__anon_4137+0x17a>
   1ca60: 63 04 94 00  	beq	s0, s1, 0x1ca68 <debug.printSourceAtAddress__anon_4137+0x16c>
   1ca64: 19 ec        	bnez	s0, 0x1ca82 <debug.printSourceAtAddress__anon_4137+0x186>
   1ca66: b9 a0        	j	0x1cab4 <debug.printSourceAtAddress__anon_4137+0x1b8>
;                     const ptr = @intToPtr(?*RDebug, _DYNAMIC[i].d_val);
   1ca68: 80 62        	ld	s0, 0(a3)
   1ca6a: 93 75 74 00  	andi	a1, s0, 7
   1ca6e: 63 9a 05 10  	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
   1ca72: 01 c8        	beqz	s0, 0x1ca82 <debug.printSourceAtAddress__anon_4137+0x186>
   1ca74: 15 a0        	j	0x1ca98 <debug.printSourceAtAddress__anon_4137+0x19c>
;                     const ptr = @intToPtr(?[*]usize, _DYNAMIC[i].d_val);
   1ca76: 80 62        	ld	s0, 0(a3)
   1ca78: 93 75 74 00  	andi	a1, s0, 7
   1ca7c: 63 93 05 10  	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;                     if (ptr) |got_table| {
   1ca80: 0d e4        	bnez	s0, 0x1caaa <debug.printSourceAtAddress__anon_4137+0x1ae>
;         while (_DYNAMIC[i].d_tag != elf.DT_NULL) : (i += 1) {
   1ca82: 63 14 f6 00  	bne	a2, a5, 0x1ca8a <debug.printSourceAtAddress__anon_4137+0x18e>
   1ca86: 6f 30 b0 45  	j	0x206e0 <.LBB47_196+0x3266>
   1ca8a: c1 06        	addi	a3, a3, 16
   1ca8c: 05 06        	addi	a2, a2, 1
   1ca8e: 03 b4 86 ff  	ld	s0, -8(a3)
   1ca92: e3 17 e4 fc  	bne	s0, a4, 0x1ca60 <debug.printSourceAtAddress__anon_4137+0x164>
   1ca96: c5 b7        	j	0x1ca76 <debug.printSourceAtAddress__anon_4137+0x17a>
;                         if (r_debug.r_version != 1) return error.InvalidExe;
   1ca98: 0c 40        	lw	a1, 0(s0)
   1ca9a: 05 46        	li	a2, 1
   1ca9c: 63 84 c5 00  	beq	a1, a2, 0x1caa4 <debug.printSourceAtAddress__anon_4137+0x1a8>
   1caa0: 6f 40 40 1f  	j	0x20c94 <.LBB47_196+0x381a>
;                         break :init r_debug.r_map;
   1caa4: 10 64        	ld	a2, 8(s0)
   1caa6: 51 ea        	bnez	a2, 0x1cb3a <debug.printSourceAtAddress__anon_4137+0x23e>
   1caa8: 31 a0        	j	0x1cab4 <debug.printSourceAtAddress__anon_4137+0x1b8>
;                         break :init @intToPtr(?*LinkMap, got_table[1]);
   1caaa: 10 64        	ld	a2, 8(s0)
   1caac: 93 75 76 00  	andi	a1, a2, 7
   1cab0: e9 e9        	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
   1cab2: 41 e6        	bnez	a2, 0x1cb3a <debug.printSourceAtAddress__anon_4137+0x23e>
   1cab4: 63 01 08 02  	beqz	a6, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
   1cab8: 01 46        	li	a2, 0
   1caba: 93 05 80 03  	li	a1, 56
;             if (phdr.p_type == elf.PT_PHDR) {
   1cabe: b3 06 b8 02  	mul	a3, a6, a1
   1cac2: 19 47        	li	a4, 6
   1cac4: b3 07 c5 00  	add	a5, a0, a2
   1cac8: 8c 43        	lw	a1, 0(a5)
   1caca: 63 82 e5 0c  	beq	a1, a4, 0x1cb8e <debug.printSourceAtAddress__anon_4137+0x292>
;         const base_address = for (phdrs) |*phdr| {
   1cace: 13 06 86 03  	addi	a2, a2, 56
   1cad2: e3 99 c6 fe  	bne	a3, a2, 0x1cac4 <debug.printSourceAtAddress__anon_4137+0x1c8>
   1cad6: 37 25 01 00  	lui	a0, 18
   1cada: 13 05 b5 a7  	addi	a0, a0, -1413
   1cade: e1 45        	li	a1, 24
   1cae0: 81 46        	li	a3, 0
   1cae2: 97 70 00 00  	auipc	ra, 7
   1cae6: e7 80 80 89  	jalr	-1896(ra)
   1caea: 83 96 06 00  	lh	a3, 0(a3)
;             .dlpi_addr = entry.l_addr,
   1caee: 05 67        	lui	a4, 1
   1caf0: 1b 07 07 2d  	addiw	a4, a4, 720
   1caf4: 0a 97        	add	a4, a4, sp
   1caf6: 08 e3        	sd	a0, 0(a4)
;             .dlpi_name = entry.l_name,
   1caf8: 08 66        	ld	a0, 8(a2)
   1cafa: 05 66        	lui	a2, 1
   1cafc: 1b 06 86 2d  	addiw	a2, a2, 728
   1cb00: 0a 96        	add	a2, a2, sp
   1cb02: 08 e2        	sd	a0, 0(a2)
   1cb04: 05 65        	lui	a0, 1
   1cb06: 1b 05 05 2e  	addiw	a0, a0, 736
   1cb0a: 0a 95        	add	a0, a0, sp
   1cb0c: 0c e1        	sd	a1, 0(a0)
   1cb0e: 05 65        	lui	a0, 1
   1cb10: 1b 05 85 2e  	addiw	a0, a0, 744
   1cb14: 0a 95        	add	a0, a0, sp
   1cb16: 23 10 d5 00  	sh	a3, 0(a0)
;         try callback(&info, @sizeOf(dl_phdr_info), context);
   1cb1a: 05 65        	lui	a0, 1
   1cb1c: 1b 05 05 2d  	addiw	a0, a0, 720
   1cb20: b3 05 a1 00  	add	a1, sp, a0
   1cb24: 10 0b        	addi	a2, sp, 400
   1cb26: 62 85        	mv	a0, s8
   1cb28: 97 70 ff ff  	auipc	ra, 1048567
   1cb2c: e7 80 80 4e  	jalr	1256(ra)
   1cb30: 2a 84        	mv	s0, a0
   1cb32: 42 15        	slli	a0, a0, 48
   1cb34: 41 91        	srli	a0, a0, 48
   1cb36: 26 86        	mv	a2, s1
   1cb38: 4d e1        	bnez	a0, 0x1cbda <debug.printSourceAtAddress__anon_4137+0x2de>
   1cb3a: 41 ca        	beqz	a2, 0x1cbca <debug.printSourceAtAddress__anon_4137+0x2ce>
;         if (entry.l_addr != 0) {
   1cb3c: 08 62        	ld	a0, 0(a2)
;                 self.current = it.l_next;
   1cb3e: 04 6e        	ld	s1, 24(a2)
;         if (entry.l_addr != 0) {
   1cb40: 1d c1        	beqz	a0, 0x1cb66 <debug.printSourceAtAddress__anon_4137+0x26a>
;             const elf_header = @intToPtr(*elf.Ehdr, entry.l_addr);
   1cb42: 93 75 75 00  	andi	a1, a0, 7
   1cb46: 95 ed        	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;             dlpi_phdr = @intToPtr([*]elf.Phdr, entry.l_addr + elf_header.e_phoff);
   1cb48: 0c 71        	ld	a1, 32(a0)
   1cb4a: aa 95        	add	a1, a1, a0
   1cb4c: 63 f4 a5 00  	bgeu	a1, a0, 0x1cb54 <debug.printSourceAtAddress__anon_4137+0x258>
   1cb50: 6f 30 10 39  	j	0x206e0 <.LBB47_196+0x3266>
   1cb54: 99 e1        	bnez	a1, 0x1cb5a <debug.printSourceAtAddress__anon_4137+0x25e>
   1cb56: 6f 20 80 50  	j	0x1f05e <.LBB47_196+0x1be4>
   1cb5a: 93 f6 75 00  	andi	a3, a1, 7
   1cb5e: 95 e2        	bnez	a3, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;             dlpi_phnum = elf_header.e_phnum;
   1cb60: 93 06 85 03  	addi	a3, a0, 56
   1cb64: 59 b7        	j	0x1caea <debug.printSourceAtAddress__anon_4137+0x1ee>
;             dlpi_phdr = @intToPtr([*]elf.Phdr, elf_base + ehdr.e_phoff);
   1cb66: 83 b5 09 02  	ld	a1, 32(s3)
   1cb6a: ce 95        	add	a1, a1, s3
   1cb6c: 63 f4 35 01  	bgeu	a1, s3, 0x1cb74 <debug.printSourceAtAddress__anon_4137+0x278>
   1cb70: 6f 30 10 37  	j	0x206e0 <.LBB47_196+0x3266>
   1cb74: 99 e1        	bnez	a1, 0x1cb7a <debug.printSourceAtAddress__anon_4137+0x27e>
   1cb76: 6f 20 80 4e  	j	0x1f05e <.LBB47_196+0x1be4>
   1cb7a: 13 f7 75 00  	andi	a4, a1, 7
   1cb7e: ca 86        	mv	a3, s2
   1cb80: 2d d7        	beqz	a4, 0x1caea <debug.printSourceAtAddress__anon_4137+0x1ee>
   1cb82: 37 15 01 00  	lui	a0, 17
   1cb86: 13 05 75 63  	addi	a0, a0, 1591
   1cb8a: 6f 40 c0 01  	j	0x20ba6 <.LBB47_196+0x372c>
;                 break @ptrToInt(phdrs.ptr) - phdr.p_vaddr;
   1cb8e: 8c 6b        	ld	a1, 16(a5)
   1cb90: 33 06 b5 40  	sub	a2, a0, a1
   1cb94: 63 74 c5 00  	bgeu	a0, a2, 0x1cb9c <debug.printSourceAtAddress__anon_4137+0x2a0>
   1cb98: 6f 30 90 34  	j	0x206e0 <.LBB47_196+0x3266>
;         var info = dl_phdr_info{
   1cb9c: 23 38 c1 2c  	sd	a2, 720(sp)
   1cba0: b7 25 01 00  	lui	a1, 18
   1cba4: 93 85 05 98  	addi	a1, a1, -1664
   1cba8: 23 3c b1 2c  	sd	a1, 728(sp)
;             .dlpi_phdr = phdrs.ptr,
   1cbac: 23 30 a1 2e  	sd	a0, 736(sp)
;             .dlpi_phnum = ehdr.e_phnum,
   1cbb0: 23 14 01 2f  	sh	a6, 744(sp)
;         return callback(&info, @sizeOf(dl_phdr_info), context);
   1cbb4: 8c 0d        	addi	a1, sp, 720
   1cbb6: 10 0b        	addi	a2, sp, 400
   1cbb8: 62 85        	mv	a0, s8
   1cbba: 97 70 ff ff  	auipc	ra, 1048567
   1cbbe: e7 80 60 45  	jalr	1110(ra)
   1cbc2: 2a 84        	mv	s0, a0
   1cbc4: 42 15        	slli	a0, a0, 48
   1cbc6: 41 91        	srli	a0, a0, 48
   1cbc8: 09 e9        	bnez	a0, 0x1cbda <debug.printSourceAtAddress__anon_4137+0x2de>
;             return error.MissingDebugInfo;
   1cbca: 62 85        	mv	a0, s8
   1cbcc: 97 70 00 00  	auipc	ra, 7
   1cbd0: e7 80 c0 02  	jalr	44(ra)
   1cbd4: cd 4c        	li	s9, 19
   1cbd6: 6f 30 10 1a  	j	0x20576 <.LBB47_196+0x30fc>
   1cbda: 62 85        	mv	a0, s8
   1cbdc: 97 70 00 00  	auipc	ra, 7
   1cbe0: e7 80 c0 01  	jalr	28(ra)
;         if (os.dl_iterate_phdr(&ctx, error{Found}, struct {
   1cbe4: 13 15 04 03  	slli	a0, s0, 48
   1cbe8: 41 91        	srli	a0, a0, 48
   1cbea: d5 45        	li	a1, 21
   1cbec: 63 04 b5 00  	beq	a0, a1, 0x1cbf4 <debug.printSourceAtAddress__anon_4137+0x2f8>
   1cbf0: 6f 40 60 0d  	j	0x20cc6 <.LBB47_196+0x384c>
;         } else |err| switch (err) {
   1cbf4: 6e 75        	ld	a0, 248(sp)
   1cbf6: 23 30 ac 00  	sd	a0, 0(s8)
   1cbfa: b2 65        	ld	a1, 264(sp)
;             return self.unmanaged.getContext(key, self.ctx);
   1cbfc: 88 69        	ld	a0, 16(a1)
   1cbfe: 90 4d        	lw	a2, 24(a1)
;         if (self.address_map.get(ctx.base_address)) |obj_di| {
   1cc00: 7a 6b        	ld	s6, 408(sp)
   1cc02: 13 78 75 00  	andi	a6, a0, 7
;             if (self.size == 0) {
   1cc06: 75 c2        	beqz	a2, 0x1ccea <debug.printSourceAtAddress__anon_4137+0x3ee>
;             if (self.metadata == null) return 0;
   1cc08: 19 e1        	bnez	a0, 0x1cc0e <debug.printSourceAtAddress__anon_4137+0x312>
   1cc0a: 6f 30 70 2d  	j	0x206e0 <.LBB47_196+0x3266>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   1cc0e: e3 1a 08 f6  	bnez	a6, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;             const mask = self.capacity() - 1;
   1cc12: 03 26 85 ff  	lw	a2, -8(a0)
   1cc16: 9b 06 f6 ff  	addiw	a3, a2, -1
   1cc1a: 63 74 d6 00  	bgeu	a2, a3, 0x1cc22 <debug.printSourceAtAddress__anon_4137+0x326>
   1cc1e: 6f 30 30 2c  	j	0x206e0 <.LBB47_196+0x3266>
   1cc22: 13 57 0b 02  	srli	a4, s6, 32
   1cc26: b7 57 02 00  	lui	a5, 37
   1cc2a: 83 b7 07 39  	ld	a5, 912(a5)
   1cc2e: b7 54 02 00  	lui	s1, 37
   1cc32: 83 b4 84 39  	ld	s1, 920(s1)
   1cc36: 13 14 0b 02  	slli	s0, s6, 32
   1cc3a: 41 8f        	or	a4, a4, s0
   1cc3c: 3d 8f        	xor	a4, a4, a5
   1cc3e: b3 07 97 02  	mul	a5, a4, s1
   1cc42: 37 54 02 00  	lui	s0, 37
   1cc46: 03 34 04 3a  	ld	s0, 928(s0)
   1cc4a: 33 37 97 02  	mulhu	a4, a4, s1
   1cc4e: 3d 8f        	xor	a4, a4, a5
   1cc50: 13 47 87 00  	xori	a4, a4, 8
   1cc54: b3 07 87 02  	mul	a5, a4, s0
   1cc58: 33 37 87 02  	mulhu	a4, a4, s0
   1cc5c: b3 44 f7 00  	xor	s1, a4, a5
;             var idx = @truncate(usize, hash & mask);
   1cc60: 82 16        	slli	a3, a3, 32
   1cc62: 13 d7 06 02  	srli	a4, a3, 32
   1cc66: b3 77 97 00  	and	a5, a4, s1
   1cc6a: b3 06 f5 00  	add	a3, a0, a5
;             while (!metadata[0].isFree() and limit != 0) {
   1cc6e: 03 c4 06 00  	lbu	s0, 0(a3)
   1cc72: b7 26 01 00  	lui	a3, 18
   1cc76: 93 88 06 e4  	addi	a7, a3, -448
;             while (!metadata[0].isFree() and limit != 0) {
   1cc7a: 25 cc        	beqz	s0, 0x1ccf2 <debug.printSourceAtAddress__anon_4137+0x3f6>
   1cc7c: e5 90        	srli	s1, s1, 57
   1cc7e: 05 a0        	j	0x1cc9e <debug.printSourceAtAddress__anon_4137+0x3a2>
;                 idx = (idx + 1) & mask;
   1cc80: 93 85 17 00  	addi	a1, a5, 1
   1cc84: b3 f7 e5 00  	and	a5, a1, a4
   1cc88: b3 05 f5 00  	add	a1, a0, a5
;             while (!metadata[0].isFree() and limit != 0) {
   1cc8c: 03 c4 05 00  	lbu	s0, 0(a1)
;                 limit -= 1;
   1cc90: 7d 36        	addiw	a2, a2, -1
;             while (!metadata[0].isFree() and limit != 0) {
   1cc92: b3 35 80 00  	snez	a1, s0
   1cc96: b3 36 c0 00  	snez	a3, a2
;             while (!metadata[0].isFree() and limit != 0) {
   1cc9a: f5 8d        	and	a1, a1, a3
   1cc9c: b9 c9        	beqz	a1, 0x1ccf2 <debug.printSourceAtAddress__anon_4137+0x3f6>
;                 return self.used == 1;
   1cc9e: 93 15 84 03  	slli	a1, s0, 56
   1cca2: e1 95        	srai	a1, a1, 56
   1cca4: 93 a5 05 00  	slti	a1, a1, 0
   1cca8: 13 74 f4 07  	andi	s0, s0, 127
   1ccac: 25 8c        	xor	s0, s0, s1
   1ccae: 13 34 14 00  	seqz	s0, s0
;                 if (metadata[0].isUsed() and metadata[0].fingerprint == fingerprint) {
   1ccb2: e1 8d        	and	a1, a1, s0
   1ccb4: f1 d5        	beqz	a1, 0x1cc80 <debug.printSourceAtAddress__anon_4137+0x384>
;             return self.header().keys;
   1ccb6: 83 35 05 ff  	ld	a1, -16(a0)
;                     const test_key = &self.keys()[idx];
   1ccba: 13 94 37 00  	slli	s0, a5, 3
   1ccbe: a2 95        	add	a1, a1, s0
;                     const eql = ctx.eql(key, test_key.*);
   1ccc0: 8c 61        	ld	a1, 0(a1)
;                     if (eql) {
   1ccc2: e3 1f bb fa  	bne	s6, a1, 0x1cc80 <debug.printSourceAtAddress__anon_4137+0x384>
;                         return idx;
   1ccc6: 85 65        	lui	a1, 1
   1ccc8: 9b 85 05 2d  	addiw	a1, a1, 720
   1cccc: 8a 95        	add	a1, a1, sp
   1ccce: 9c e1        	sd	a5, 0(a1)
   1ccd0: 85 45        	li	a1, 1
   1ccd2: 05 66        	lui	a2, 1
   1ccd4: 1b 06 86 2d  	addiw	a2, a2, 728
   1ccd8: 0a 96        	add	a2, a2, sp
   1ccda: 23 00 b6 00  	sb	a1, 0(a2)
   1ccde: 85 65        	lui	a1, 1
   1cce0: 9b 85 05 2d  	addiw	a1, a1, 720
   1cce4: b3 08 b1 00  	add	a7, sp, a1
   1cce8: 29 a0        	j	0x1ccf2 <debug.printSourceAtAddress__anon_4137+0x3f6>
   1ccea: 37 26 01 00  	lui	a2, 18
   1ccee: 93 08 06 e4  	addi	a7, a2, -448
;             return null;
   1ccf2: 83 c5 88 00  	lbu	a1, 8(a7)
   1ccf6: 62 ee        	sd	s8, 280(sp)
   1ccf8: ea f9        	sd	s10, 240(sp)
   1ccfa: 52 f1        	sd	s4, 160(sp)
   1ccfc: 56 ed        	sd	s5, 152(sp)
   1ccfe: 6e f5        	sd	s11, 168(sp)
   1cd00: 85 c1        	beqz	a1, 0x1cd20 <debug.printSourceAtAddress__anon_4137+0x424>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   1cd02: 19 e1        	bnez	a0, 0x1cd08 <debug.printSourceAtAddress__anon_4137+0x40c>
   1cd04: 6f 30 70 7d  	j	0x20cda <.LBB47_196+0x3860>
   1cd08: e3 1d 08 e6  	bnez	a6, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
   1cd0c: 83 b5 08 00  	ld	a1, 0(a7)
;             return self.header().values;
   1cd10: 03 35 85 fe  	ld	a0, -24(a0)
;                 return self.values()[idx];
   1cd14: 8e 05        	slli	a1, a1, 3
   1cd16: 2e 95        	add	a0, a0, a1
   1cd18: 00 61        	ld	s0, 0(a0)
;         if (self.address_map.get(ctx.base_address)) |obj_di| {
   1cd1a: 19 c0        	beqz	s0, 0x1cd20 <debug.printSourceAtAddress__anon_4137+0x424>
   1cd1c: 6f 30 20 0a  	j	0x1fdbe <.LBB47_196+0x2944>
   1cd20: 32 65        	ld	a0, 264(sp)
;     const slice = try self.allocAdvancedWithRetAddr(T, null, 1, @returnAddress());
   1cd22: 0c 65        	ld	a1, 8(a0)
   1cd24: 08 61        	ld	a0, 0(a0)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1cd26: 98 61        	ld	a4, 0(a1)
   1cd28: 93 05 80 12  	li	a1, 296
   1cd2c: 0d 46        	li	a2, 3
   1cd2e: ea 86        	mv	a3, s10
   1cd30: 02 97        	jalr	a4
   1cd32: 19 e1        	bnez	a0, 0x1cd38 <debug.printSourceAtAddress__anon_4137+0x43c>
   1cd34: 6f 10 d0 71  	j	0x1ec50 <.LBB47_196+0x17d6>
   1cd38: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   1cd3a: 93 05 a0 0a  	li	a1, 170
   1cd3e: 13 06 80 12  	li	a2, 296
   1cd42: 97 70 00 00  	auipc	ra, 7
   1cd46: e7 80 80 55  	jalr	1368(ra)
   1cd4a: a2 e1        	sd	s0, 192(sp)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   1cd4c: 13 75 74 00  	andi	a0, s0, 7
   1cd50: e3 19 05 e2  	bnez	a0, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;         const copy = if (ctx.name.len > 0)
   1cd54: 3a 74        	ld	s0, 424(sp)
   1cd56: 4d cc        	beqz	s0, 0x1ce10 <debug.printSourceAtAddress__anon_4137+0x514>
;             fs.cwd().openFile(ctx.name, .{ .intended_io_mode = .blocking })
   1cd58: 9a 74        	ld	s1, 416(sp)
   1cd5a: 01 45        	li	a0, 0
;         if (slice[i] == value) return i;
   1cd5c: b3 85 a4 00  	add	a1, s1, a0
   1cd60: 83 c5 05 00  	lbu	a1, 0(a1)
   1cd64: e3 89 05 d6  	beqz	a1, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     while (i < slice.len) : (i += 1) {
   1cd68: 05 05        	addi	a0, a0, 1
   1cd6a: e3 19 a4 fe  	bne	s0, a0, 0x1cd5c <debug.printSourceAtAddress__anon_4137+0x460>
;     var path_with_null: [MAX_PATH_BYTES - 1:0]u8 = undefined;
   1cd6e: 05 65        	lui	a0, 1
   1cd70: 1b 05 05 2d  	addiw	a0, a0, 720
   1cd74: 0a 95        	add	a0, a0, sp
   1cd76: 93 05 a0 0a  	li	a1, 170
   1cd7a: 05 66        	lui	a2, 1
   1cd7c: 85 66        	lui	a3, 1
   1cd7e: 9b 86 06 2d  	addiw	a3, a3, 720
   1cd82: 33 09 d1 00  	add	s2, sp, a3
   1cd86: 97 70 00 00  	auipc	ra, 7
   1cd8a: e7 80 40 51  	jalr	1300(ra)
;     if (file_path.len >= MAX_PATH_BYTES) return error.NameTooLong;
   1cd8e: 13 55 c4 00  	srli	a0, s0, 12
   1cd92: 19 c1        	beqz	a0, 0x1cd98 <debug.printSourceAtAddress__anon_4137+0x49c>
   1cd94: 6f 20 80 09  	j	0x1ee2c <.LBB47_196+0x19b2>
;         dest[i] = s;
   1cd98: 05 65        	lui	a0, 1
   1cd9a: 1b 05 05 2d  	addiw	a0, a0, 720
   1cd9e: 0a 95        	add	a0, a0, sp
   1cda0: a6 85        	mv	a1, s1
   1cda2: 22 86        	mv	a2, s0
   1cda4: 97 70 00 00  	auipc	ra, 7
   1cda8: e7 80 00 4d  	jalr	1232(ra)
;     path_with_null[file_path.len] = 0;
   1cdac: 33 05 89 00  	add	a0, s2, s0
   1cdb0: 23 00 05 00  	sb	zero, 0(a0)
;     return path_with_null;
   1cdb4: 88 0d        	addi	a0, sp, 720
   1cdb6: 85 65        	lui	a1, 1
   1cdb8: 9b 85 05 2d  	addiw	a1, a1, 720
   1cdbc: 8a 95        	add	a1, a1, sp
   1cdbe: 05 66        	lui	a2, 1
   1cdc0: 97 70 00 00  	auipc	ra, 7
   1cdc4: e7 80 40 4b  	jalr	1204(ra)
;         return self.openFileZ(&path_c, flags);
   1cdc8: 37 25 01 00  	lui	a0, 18
   1cdcc: 13 07 c5 e2  	addi	a4, a0, -468
   1cdd0: 09 65        	lui	a0, 2
   1cdd2: 1b 05 85 4d  	addiw	a0, a0, 1240
   1cdd6: 0a 95        	add	a0, a0, sp
   1cdd8: 13 06 c0 f9  	li	a2, -100
   1cddc: 94 0d        	addi	a3, sp, 720
   1cdde: e2 85        	mv	a1, s8
   1cde0: 97 40 00 00  	auipc	ra, 4
   1cde4: e7 80 40 6d  	jalr	1748(ra)
   1cde8: 09 65        	lui	a0, 2
   1cdea: 1b 05 85 4d  	addiw	a0, a0, 1240
   1cdee: 0a 95        	add	a0, a0, sp
   1cdf0: 04 41        	lw	s1, 0(a0)
   1cdf2: 09 65        	lui	a0, 2
   1cdf4: 1b 05 c5 4d  	addiw	a0, a0, 1244
   1cdf8: 0a 95        	add	a0, a0, sp
   1cdfa: 83 59 05 00  	lhu	s3, 0(a0)
   1cdfe: 23 28 91 1a  	sw	s1, 432(sp)
   1ce02: 63 84 09 00  	beqz	s3, 0x1ce0a <debug.printSourceAtAddress__anon_4137+0x50e>
   1ce06: 6f 20 e0 0d  	j	0x1eee4 <.LBB47_196+0x1a6a>
   1ce0a: 13 09 01 1b  	addi	s2, sp, 432
   1ce0e: 99 a8        	j	0x1ce64 <debug.printSourceAtAddress__anon_4137+0x568>
;     return cwd().openFileZ(absolute_path_c, flags);
   1ce10: 37 25 01 00  	lui	a0, 18
   1ce14: 93 06 05 98  	addi	a3, a0, -1664
   1ce18: 37 25 01 00  	lui	a0, 18
   1ce1c: 13 07 c5 e2  	addi	a4, a0, -468
   1ce20: 05 65        	lui	a0, 1
   1ce22: 1b 05 05 2d  	addiw	a0, a0, 720
   1ce26: 0a 95        	add	a0, a0, sp
   1ce28: 13 06 c0 f9  	li	a2, -100
   1ce2c: e2 85        	mv	a1, s8
   1ce2e: 97 40 00 00  	auipc	ra, 4
   1ce32: e7 80 60 68  	jalr	1670(ra)
   1ce36: 05 65        	lui	a0, 1
   1ce38: 1b 05 45 2d  	addiw	a0, a0, 724
   1ce3c: 0a 95        	add	a0, a0, sp
   1ce3e: 83 59 05 00  	lhu	s3, 0(a0)
   1ce42: 05 65        	lui	a0, 1
   1ce44: 1b 05 05 2d  	addiw	a0, a0, 720
   1ce48: 0a 95        	add	a0, a0, sp
   1ce4a: 04 41        	lw	s1, 0(a0)
   1ce4c: 63 84 09 00  	beqz	s3, 0x1ce54 <debug.printSourceAtAddress__anon_4137+0x558>
   1ce50: 6f 20 a0 07  	j	0x1eeca <.LBB47_196+0x1a50>
;         return openFileAbsoluteZ("/proc/self/exe", flags);
   1ce54: 23 2c 91 1a  	sw	s1, 440(sp)
   1ce58: 13 09 81 1b  	addi	s2, sp, 440
   1ce5c: 63 84 09 00  	beqz	s3, 0x1ce64 <debug.printSourceAtAddress__anon_4137+0x568>
   1ce60: 6f 20 40 08  	j	0x1eee4 <.LBB47_196+0x1a6a>
;                 return item;
   1ce64: 88 0d        	addi	a0, sp, 720
   1ce66: 13 06 00 08  	li	a2, 128
   1ce6a: 81 45        	li	a1, 0
   1ce6c: 97 70 00 00  	auipc	ra, 7
   1ce70: e7 80 e0 42  	jalr	1070(ra)
;     return asm volatile ("ecall"
   1ce74: 93 08 00 05  	li	a7, 80
   1ce78: 8c 0d        	addi	a1, sp, 720
   1ce7a: 7d 75        	lui	a0, 1048575
   1ce7c: 1b 06 15 00  	addiw	a2, a0, 1
   1ce80: 26 85        	mv	a0, s1
   1ce82: 73 00 00 00  	ecall	
   1ce86: 63 64 c5 00  	bltu	a0, a2, 0x1ce8e <debug.printSourceAtAddress__anon_4137+0x592>
   1ce8a: 6f 10 10 69  	j	0x1ed1a <.LBB47_196+0x18a0>
   1ce8e: 5a e9        	sd	s6, 144(sp)
;         .SUCCESS => return stat,
   1ce90: 83 36 01 30  	ld	a3, 768(sp)
;             file.handle,
   1ce94: 03 28 09 00  	lw	a6, 0(s2)
   1ce98: 41 6b        	lui	s6, 16
   1ce9a: 9b 04 fb ff  	addiw	s1, s6, -1
   1ce9e: 09 65        	lui	a0, 2
   1cea0: 1b 05 85 4d  	addiw	a0, a0, 1240
   1cea4: 0a 95        	add	a0, a0, sp
   1cea6: 05 47        	li	a4, 1
   1cea8: 85 47        	li	a5, 1
   1ceaa: e2 85        	mv	a1, s8
   1ceac: 01 46        	li	a2, 0
   1ceae: 97 70 ff ff  	auipc	ra, 1048567
   1ceb2: e7 80 40 e5  	jalr	-428(ra)
   1ceb6: 09 65        	lui	a0, 2
   1ceb8: 1b 05 85 4e  	addiw	a0, a0, 1256
   1cebc: 0a 95        	add	a0, a0, sp
   1cebe: 83 5c 05 00  	lhu	s9, 0(a0)
   1cec2: 63 84 0c 00  	beqz	s9, 0x1ceca <debug.printSourceAtAddress__anon_4137+0x5ce>
   1cec6: 6f 10 30 67  	j	0x1ed38 <.LBB47_196+0x18be>
;         defer file.close();
   1ceca: 03 25 09 00  	lw	a0, 0(s2)
;         const mapped_mem = try os.mmap(
   1cece: 89 65        	lui	a1, 2
   1ced0: 9b 85 85 4d  	addiw	a1, a1, 1240
   1ced4: 8a 95        	add	a1, a1, sp
   1ced6: 80 61        	ld	s0, 0(a1)
   1ced8: 89 65        	lui	a1, 2
   1ceda: 9b 85 05 4e  	addiw	a1, a1, 1248
   1cede: 8a 95        	add	a1, a1, sp
   1cee0: 94 61        	ld	a3, 0(a1)
;     return asm volatile ("ecall"
   1cee2: 93 08 90 03  	li	a7, 57
   1cee6: 73 00 00 00  	ecall	
   1ceea: fd 75        	lui	a1, 1048575
   1ceec: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1ceee: b3 35 b5 00  	sltu	a1, a0, a1
   1cef2: 65 8d        	and	a0, a0, s1
   1cef4: 1b 06 7b ff  	addiw	a2, s6, -9
   1cef8: 31 8d        	xor	a0, a0, a2
   1cefa: 33 35 a0 00  	snez	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1cefe: 4d 8d        	or	a0, a0, a1
   1cf00: e3 0b 05 bc  	beqz	a0, 0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;         const hdr = @ptrCast(*const elf.Ehdr, &mapped_mem[0]);
   1cf04: 99 e2        	bnez	a3, 0x1cf0a <debug.printSourceAtAddress__anon_4137+0x60e>
   1cf06: 6f 30 90 5e  	j	0x20cee <.LBB47_196+0x3874>
;     if (a.ptr == b.ptr) return true;
   1cf0a: 37 25 01 00  	lui	a0, 18
   1cf0e: 13 05 15 bf  	addi	a0, a0, -1039
   1cf12: 63 02 a4 04  	beq	s0, a0, 0x1cf56 <debug.printSourceAtAddress__anon_4137+0x65a>
;     for (a) |item, index| {
   1cf16: 03 45 04 00  	lbu	a0, 0(s0)
   1cf1a: 93 05 f0 07  	li	a1, 127
;         if (b[index] != item) return false;
   1cf1e: 63 04 b5 00  	beq	a0, a1, 0x1cf26 <debug.printSourceAtAddress__anon_4137+0x62a>
   1cf22: 6f 10 90 4b  	j	0x1ebda <.LBB47_196+0x1760>
;     for (a) |item, index| {
   1cf26: 03 45 14 00  	lbu	a0, 1(s0)
   1cf2a: 93 05 50 04  	li	a1, 69
;         if (b[index] != item) return false;
   1cf2e: 63 04 b5 00  	beq	a0, a1, 0x1cf36 <debug.printSourceAtAddress__anon_4137+0x63a>
   1cf32: 6f 10 90 4a  	j	0x1ebda <.LBB47_196+0x1760>
;     for (a) |item, index| {
   1cf36: 03 45 24 00  	lbu	a0, 2(s0)
   1cf3a: 93 05 c0 04  	li	a1, 76
;         if (b[index] != item) return false;
   1cf3e: 63 04 b5 00  	beq	a0, a1, 0x1cf46 <debug.printSourceAtAddress__anon_4137+0x64a>
   1cf42: 6f 10 90 49  	j	0x1ebda <.LBB47_196+0x1760>
;     for (a) |item, index| {
   1cf46: 03 45 34 00  	lbu	a0, 3(s0)
   1cf4a: 93 05 60 04  	li	a1, 70
;         if (b[index] != item) return false;
   1cf4e: 63 04 b5 00  	beq	a0, a1, 0x1cf56 <debug.printSourceAtAddress__anon_4137+0x65a>
   1cf52: 6f 10 90 48  	j	0x1ebda <.LBB47_196+0x1760>
;         if (hdr.e_ident[elf.EI_VERSION] != 1) return error.InvalidElfVersion;
   1cf56: 83 45 64 00  	lbu	a1, 6(s0)
   1cf5a: 05 45        	li	a0, 1
   1cf5c: 63 84 a5 00  	beq	a1, a0, 0x1cf64 <debug.printSourceAtAddress__anon_4137+0x668>
   1cf60: 6f 10 30 67  	j	0x1edd2 <.LBB47_196+0x1958>
;         const endian: std.builtin.Endian = switch (hdr.e_ident[elf.EI_DATA]) {
   1cf64: 83 45 54 00  	lbu	a1, 5(s0)
   1cf68: 63 84 a5 00  	beq	a1, a0, 0x1cf70 <debug.printSourceAtAddress__anon_4137+0x674>
   1cf6c: 6f 10 f0 68  	j	0x1edfa <.LBB47_196+0x1980>
;         const str_section_off = shoff + @as(u64, hdr.e_shentsize) * @as(u64, hdr.e_shstrndx);
   1cf70: 83 55 a4 03  	lhu	a1, 58(s0)
   1cf74: 03 56 e4 03  	lhu	a2, 62(s0)
;         const shoff = hdr.e_shoff;
   1cf78: 08 74        	ld	a0, 40(s0)
;         const str_section_off = shoff + @as(u64, hdr.e_shentsize) * @as(u64, hdr.e_shstrndx);
   1cf7a: b3 05 b6 02  	mul	a1, a2, a1
   1cf7e: aa 95        	add	a1, a1, a0
   1cf80: 63 f4 a5 00  	bgeu	a1, a0, 0x1cf88 <debug.printSourceAtAddress__anon_4137+0x68c>
   1cf84: 6f 30 c0 75  	j	0x206e0 <.LBB47_196+0x3266>
;             @alignCast(@alignOf(elf.Shdr), &mapped_mem[math.cast(usize, str_section_off) orelse return error.Overflow]),
   1cf88: 63 e4 d5 00  	bltu	a1, a3, 0x1cf90 <debug.printSourceAtAddress__anon_4137+0x694>
   1cf8c: 6f 30 30 41  	j	0x20b9e <.LBB47_196+0x3724>
   1cf90: a2 95        	add	a1, a1, s0
   1cf92: 13 f6 75 00  	andi	a2, a1, 7
   1cf96: e3 16 06 be  	bnez	a2, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;         const header_strings = mapped_mem[str_shdr.sh_offset .. str_shdr.sh_offset + str_shdr.sh_size];
   1cf9a: 90 6d        	ld	a2, 24(a1)
   1cf9c: 8c 71        	ld	a1, 32(a1)
   1cf9e: 33 07 b6 00  	add	a4, a2, a1
   1cfa2: 63 74 c7 00  	bgeu	a4, a2, 0x1cfaa <debug.printSourceAtAddress__anon_4137+0x6ae>
   1cfa6: 6f 30 a0 73  	j	0x206e0 <.LBB47_196+0x3266>
   1cfaa: 63 f4 e6 00  	bgeu	a3, a4, 0x1cfb2 <debug.printSourceAtAddress__anon_4137+0x6b6>
   1cfae: 6f 30 10 3f  	j	0x20b9e <.LBB47_196+0x3724>
;             @alignCast(@alignOf(elf.Shdr), &mapped_mem[shoff]),
   1cfb2: 63 64 d5 00  	bltu	a0, a3, 0x1cfba <debug.printSourceAtAddress__anon_4137+0x6be>
   1cfb6: 6f 30 90 3e  	j	0x20b9e <.LBB47_196+0x3724>
   1cfba: b3 08 a4 00  	add	a7, s0, a0
   1cfbe: 93 f5 78 00  	andi	a1, a7, 7
   1cfc2: e3 90 05 bc  	bnez	a1, 0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;         )[0..hdr.e_shnum];
   1cfc6: 83 55 c4 03  	lhu	a1, 60(s0)
;         for (shdrs) |*shdr| {
   1cfca: 99 e1        	bnez	a1, 0x1cfd0 <debug.printSourceAtAddress__anon_4137+0x6d4>
   1cfcc: 6f 10 90 67  	j	0x1ee44 <.LBB47_196+0x19ca>
   1cfd0: b6 f5        	sd	a3, 232(sp)
   1cfd2: 81 47        	li	a5, 0
   1cfd4: 82 f8        	sd	zero, 112(sp)
   1cfd6: 82 f4        	sd	zero, 104(sp)
   1cfd8: 82 ed        	sd	zero, 216(sp)
   1cfda: 82 e9        	sd	zero, 208(sp)
   1cfdc: 02 f0        	sd	zero, 32(sp)
   1cfde: 02 ec        	sd	zero, 24(sp)
   1cfe0: 02 f8        	sd	zero, 48(sp)
   1cfe2: 02 f4        	sd	zero, 40(sp)
   1cfe4: 02 f9        	sd	zero, 176(sp)
   1cfe6: 02 e5        	sd	zero, 136(sp)
   1cfe8: 02 e1        	sd	zero, 128(sp)
   1cfea: 82 fc        	sd	zero, 120(sp)
   1cfec: 82 e5        	sd	zero, 200(sp)
   1cfee: 02 fd        	sd	zero, 184(sp)
   1cff0: 81 4b        	li	s7, 0
   1cff2: 01 4d        	li	s10, 0
   1cff4: 01 43        	li	t1, 0
   1cff6: 81 42        	li	t0, 0
   1cff8: 01 48        	li	a6, 0
   1cffa: 01 4b        	li	s6, 0
   1cffc: 02 e2        	sd	zero, 256(sp)
   1cffe: 02 ea        	sd	zero, 272(sp)
   1d000: 01 49        	li	s2, 0
   1d002: 82 f0        	sd	zero, 96(sp)
   1d004: a2 f1        	sd	s0, 224(sp)
   1d006: b3 03 c4 00  	add	t2, s0, a2
   1d00a: 33 0e c7 40  	sub	t3, a4, a2
   1d00e: 37 06 01 00  	lui	a2, 16
   1d012: 93 0e 46 65  	addi	t4, a2, 1620
   1d016: 37 16 01 00  	lui	a2, 17
   1d01a: 13 0f 76 6f  	addi	t5, a2, 1783
   1d01e: 37 16 01 00  	lui	a2, 17
   1d022: 93 0f 86 79  	addi	t6, a2, 1944
   1d026: 37 26 01 00  	lui	a2, 18
   1d02a: 13 06 16 a1  	addi	a2, a2, -1519
   1d02e: 32 fc        	sd	a2, 56(sp)
   1d030: 37 16 01 00  	lui	a2, 17
   1d034: 13 06 f6 76  	addi	a2, a2, 1903
   1d038: 32 e4        	sd	a2, 8(sp)
   1d03a: 37 16 01 00  	lui	a2, 17
   1d03e: 93 09 86 6b  	addi	s3, a2, 1720
   1d042: 37 26 01 00  	lui	a2, 18
   1d046: 13 06 d6 a1  	addi	a2, a2, -1507
   1d04a: b2 e0        	sd	a2, 64(sp)
   1d04c: 37 16 01 00  	lui	a2, 17
   1d050: 13 0c 36 5f  	addi	s8, a2, 1523
   1d054: 37 16 01 00  	lui	a2, 17
   1d058: 13 06 56 6c  	addi	a2, a2, 1733
   1d05c: b2 e4        	sd	a2, 72(sp)
   1d05e: 37 16 01 00  	lui	a2, 17
   1d062: 13 0a 26 70  	addi	s4, a2, 1794
   1d066: 37 16 01 00  	lui	a2, 17
   1d06a: 13 06 96 67  	addi	a2, a2, 1657
   1d06e: b2 e8        	sd	a2, 80(sp)
   1d070: 37 16 01 00  	lui	a2, 17
   1d074: 13 06 96 66  	addi	a2, a2, 1641
   1d078: 32 e8        	sd	a2, 16(sp)
   1d07a: 37 16 01 00  	lui	a2, 17
   1d07e: 93 0c 56 6a  	addi	s9, a2, 1701
   1d082: 32 66        	ld	a2, 264(sp)
   1d084: 41 06        	addi	a2, a2, 16
   1d086: b2 ec        	sd	a2, 88(sp)
   1d088: a1 4d        	li	s11, 8
   1d08a: 93 00 e0 02  	li	ra, 46
   1d08e: 93 0a 50 06  	li	s5, 101
   1d092: 39 a0        	j	0x1d0a0 <.LBB47_104+0x6>
;     if (a.ptr == b.ptr) return true;
   1d094: a6 66        	ld	a3, 72(sp)
   1d096: e3 02 d6 10  	beq	a2, a3, 0x1d99a <.LBB47_196+0x520>

000000000001d09a <.LBB47_104>:
   1d09a: 85 07        	addi	a5, a5, 1
;         for (shdrs) |*shdr| {
   1d09c: e3 82 b7 12  	beq	a5, a1, 0x1d9c0 <.LBB47_196+0x546>
   1d0a0: 13 96 67 00  	slli	a2, a5, 6
   1d0a4: 33 87 c8 00  	add	a4, a7, a2
;             if (shdr.sh_type == elf.SHT_NULL) continue;
   1d0a8: 50 43        	lw	a2, 4(a4)
   1d0aa: 65 da        	beqz	a2, 0x1d09a <.LBB47_104>
;             const name = mem.sliceTo(header_strings[shdr.sh_name..], 0);
   1d0ac: 03 66 07 00  	lwu	a2, 0(a4)
   1d0b0: 63 74 ce 00  	bgeu	t3, a2, 0x1d0b8 <.LBB47_104+0x1e>
   1d0b4: 6f 30 b0 3c  	j	0x20c7e <.LBB47_196+0x3804>
   1d0b8: b3 06 ce 40  	sub	a3, t3, a2
;     while (i < slice.len) : (i += 1) {
   1d0bc: f9 de        	beqz	a3, 0x1d09a <.LBB47_104>
   1d0be: 01 44        	li	s0, 0
   1d0c0: 1e 96        	add	a2, a2, t2
;         if (slice[i] == value) return i;
   1d0c2: b3 04 86 00  	add	s1, a2, s0
   1d0c6: 83 c4 04 00  	lbu	s1, 0(s1)
   1d0ca: 91 c4        	beqz	s1, 0x1d0d6 <.LBB47_104+0x3c>
   1d0cc: 05 04        	addi	s0, s0, 1
;     while (i < slice.len) : (i += 1) {
   1d0ce: e3 9a 86 fe  	bne	a3, s0, 0x1d0c2 <.LBB47_104+0x28>
   1d0d2: 36 84        	mv	s0, a3
   1d0d4: 29 a0        	j	0x1d0de <.LBB47_104+0x44>
;         return ptr[0..length];
   1d0d6: 63 f4 86 00  	bgeu	a3, s0, 0x1d0de <.LBB47_104+0x44>
   1d0da: 6f 30 50 2c  	j	0x20b9e <.LBB47_196+0x3724>
;     if (a.len != b.len) return false;
   1d0de: 93 06 64 ff  	addi	a3, s0, -10
   1d0e2: e3 ec dd fa  	bltu	s11, a3, 0x1d09a <.LBB47_104>
   1d0e6: 8a 06        	slli	a3, a3, 2
   1d0e8: f6 96        	add	a3, a3, t4
   1d0ea: 94 42        	lw	a3, 0(a3)
   1d0ec: 82 86        	jr	a3

000000000001d0ee <.LBB47_115>:
;     if (a.ptr == b.ptr) return true;
   1d0ee: 63 0c e6 07  	beq	a2, t5, 0x1d166 <.LBB47_115+0x78>
;     for (a) |item, index| {
   1d0f2: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d0f6: e3 92 16 fa  	bne	a3, ra, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d0fa: 83 46 16 00  	lbu	a3, 1(a2)
;         if (b[index] != item) return false;
   1d0fe: 13 04 40 06  	li	s0, 100
   1d102: e3 9c 86 f8  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d106: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d10a: 13 04 50 06  	li	s0, 101
   1d10e: e3 96 86 f8  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d112: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d116: 13 05 20 06  	li	a0, 98
   1d11a: e3 90 a6 f8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d11e: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d122: 13 05 50 07  	li	a0, 117
   1d126: e3 9a a6 f6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d12a: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d12e: 13 05 70 06  	li	a0, 103
   1d132: e3 94 a6 f6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d136: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d13a: 13 05 f0 05  	li	a0, 95
   1d13e: e3 9e a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d142: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d146: 13 05 30 07  	li	a0, 115
   1d14a: e3 98 a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d14e: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d152: 13 05 40 07  	li	a0, 116
   1d156: e3 92 a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d15a: 03 46 96 00  	lbu	a2, 9(a2)
;         if (b[index] != item) return false;
   1d15e: 13 05 20 07  	li	a0, 114
   1d162: e3 1c a6 f2  	bne	a2, a0, 0x1d09a <.LBB47_104>
;                 opt_debug_str = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d166: 10 6f        	ld	a2, 24(a4)
   1d168: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d16a: b2 96        	add	a3, a3, a2
   1d16c: 63 f4 c6 00  	bgeu	a3, a2, 0x1d174 <.LBB47_115+0x86>
   1d170: 6f 30 00 57  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d174: 2e 77        	ld	a4, 232(sp)
   1d176: 63 74 d7 00  	bgeu	a4, a3, 0x1d17e <.LBB47_115+0x90>
   1d17a: 6f 30 50 22  	j	0x20b9e <.LBB47_196+0x3724>
   1d17e: 33 8b c6 40  	sub	s6, a3, a2
   1d182: 8e 76        	ld	a3, 224(sp)
   1d184: 33 88 c6 00  	add	a6, a3, a2
   1d188: 09 bf        	j	0x1d09a <.LBB47_104>

000000000001d18a <.LBB47_129>:
;     if (a.ptr == b.ptr) return true;
   1d18a: 63 02 f6 09  	beq	a2, t6, 0x1d20e <.LBB47_129+0x84>
;     for (a) |item, index| {
   1d18e: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d192: 63 93 16 3e  	bne	a3, ra, 0x1d578 <.LBB47_196+0xfe>
;     for (a) |item, index| {
   1d196: 03 44 16 00  	lbu	s0, 1(a2)
;         if (b[index] != item) return false;
   1d19a: 93 06 40 06  	li	a3, 100
   1d19e: 63 1d d4 3c  	bne	s0, a3, 0x1d578 <.LBB47_196+0xfe>
;     for (a) |item, index| {
   1d1a2: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d1a6: 93 04 50 06  	li	s1, 101
   1d1aa: 63 92 96 4a  	bne	a3, s1, 0x1d64e <.LBB47_196+0x1d4>
;     for (a) |item, index| {
   1d1ae: 83 44 36 00  	lbu	s1, 3(a2)
;         if (b[index] != item) return false;
   1d1b2: 13 05 20 06  	li	a0, 98
   1d1b6: 63 9c a4 62  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1ba: 83 44 46 00  	lbu	s1, 4(a2)
;         if (b[index] != item) return false;
   1d1be: 13 05 50 07  	li	a0, 117
   1d1c2: 63 96 a4 62  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1c6: 83 44 56 00  	lbu	s1, 5(a2)
;         if (b[index] != item) return false;
   1d1ca: 13 05 70 06  	li	a0, 103
   1d1ce: 63 90 a4 62  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1d2: 83 44 66 00  	lbu	s1, 6(a2)
;         if (b[index] != item) return false;
   1d1d6: 13 05 f0 05  	li	a0, 95
   1d1da: 63 9a a4 60  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1de: 83 44 76 00  	lbu	s1, 7(a2)
;         if (b[index] != item) return false;
   1d1e2: 13 05 90 06  	li	a0, 105
   1d1e6: 63 94 a4 60  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1ea: 83 44 86 00  	lbu	s1, 8(a2)
;         if (b[index] != item) return false;
   1d1ee: 13 05 e0 06  	li	a0, 110
   1d1f2: 63 9e a4 5e  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d1f6: 83 44 96 00  	lbu	s1, 9(a2)
;         if (b[index] != item) return false;
   1d1fa: 13 05 60 06  	li	a0, 102
   1d1fe: 63 98 a4 5e  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;     for (a) |item, index| {
   1d202: 83 44 a6 00  	lbu	s1, 10(a2)
;         if (b[index] != item) return false;
   1d206: 13 05 f0 06  	li	a0, 111
   1d20a: 63 92 a4 5e  	bne	s1, a0, 0x1d7ee <.LBB47_196+0x374>
;                 opt_debug_info = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d20e: 10 6f        	ld	a2, 24(a4)
   1d210: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d212: b2 96        	add	a3, a3, a2
   1d214: 63 f4 c6 00  	bgeu	a3, a2, 0x1d21c <.LBB47_129+0x92>
   1d218: 6f 30 80 4c  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d21c: 2e 77        	ld	a4, 232(sp)
   1d21e: 63 74 d7 00  	bgeu	a4, a3, 0x1d226 <.LBB47_129+0x9c>
   1d222: 6f 30 d0 17  	j	0x20b9e <.LBB47_196+0x3724>
   1d226: 33 8d c6 40  	sub	s10, a3, a2
   1d22a: 8e 76        	ld	a3, 224(sp)
   1d22c: b3 8b c6 00  	add	s7, a3, a2
   1d230: ad b5        	j	0x1d09a <.LBB47_104>

000000000001d232 <.LBB47_144>:
;     if (a.ptr == b.ptr) return true;
   1d232: 63 08 36 09  	beq	a2, s3, 0x1d2c2 <.LBB47_144+0x90>
;     for (a) |item, index| {
   1d236: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d23a: 63 9d 16 34  	bne	a3, ra, 0x1d594 <.LBB47_196+0x11a>
;     for (a) |item, index| {
   1d23e: 03 44 16 00  	lbu	s0, 1(a2)
;         if (b[index] != item) return false;
   1d242: 93 04 40 06  	li	s1, 100
   1d246: 63 1b 94 34  	bne	s0, s1, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d24a: 03 44 26 00  	lbu	s0, 2(a2)
;         if (b[index] != item) return false;
   1d24e: 93 04 50 06  	li	s1, 101
   1d252: 63 15 94 34  	bne	s0, s1, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d256: 03 44 36 00  	lbu	s0, 3(a2)
;         if (b[index] != item) return false;
   1d25a: 13 05 20 06  	li	a0, 98
   1d25e: 63 1f a4 32  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d262: 03 44 46 00  	lbu	s0, 4(a2)
;         if (b[index] != item) return false;
   1d266: 13 05 50 07  	li	a0, 117
   1d26a: 63 19 a4 32  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d26e: 03 44 56 00  	lbu	s0, 5(a2)
;         if (b[index] != item) return false;
   1d272: 13 05 70 06  	li	a0, 103
   1d276: 63 13 a4 32  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d27a: 03 44 66 00  	lbu	s0, 6(a2)
;         if (b[index] != item) return false;
   1d27e: 13 05 f0 05  	li	a0, 95
   1d282: 63 1d a4 30  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d286: 03 44 76 00  	lbu	s0, 7(a2)
;         if (b[index] != item) return false;
   1d28a: 13 05 e0 06  	li	a0, 110
   1d28e: 63 17 a4 30  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d292: 03 44 86 00  	lbu	s0, 8(a2)
;         if (b[index] != item) return false;
   1d296: 13 05 10 06  	li	a0, 97
   1d29a: 63 11 a4 30  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d29e: 03 44 96 00  	lbu	s0, 9(a2)
;         if (b[index] != item) return false;
   1d2a2: 13 05 d0 06  	li	a0, 109
   1d2a6: 63 1b a4 2e  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d2aa: 03 44 a6 00  	lbu	s0, 10(a2)
;         if (b[index] != item) return false;
   1d2ae: 93 04 50 06  	li	s1, 101
   1d2b2: 63 15 94 2e  	bne	s0, s1, 0x1d59c <.LBB47_196+0x122>
;     for (a) |item, index| {
   1d2b6: 03 44 b6 00  	lbu	s0, 11(a2)
;         if (b[index] != item) return false;
   1d2ba: 13 05 30 07  	li	a0, 115
   1d2be: 63 1f a4 2c  	bne	s0, a0, 0x1d59c <.LBB47_196+0x122>
;                 opt_debug_names = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d2c2: 10 6f        	ld	a2, 24(a4)
   1d2c4: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d2c6: b2 96        	add	a3, a3, a2
   1d2c8: 63 f4 c6 00  	bgeu	a3, a2, 0x1d2d0 <.LBB47_144+0x9e>
   1d2cc: 6f 30 40 41  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d2d0: 2e 77        	ld	a4, 232(sp)
   1d2d2: 63 74 d7 00  	bgeu	a4, a3, 0x1d2da <.LBB47_144+0xa8>
   1d2d6: 6f 30 90 0c  	j	0x20b9e <.LBB47_196+0x3724>
   1d2da: 91 8e        	sub	a3, a3, a2
   1d2dc: b6 ed        	sd	a3, 216(sp)
   1d2de: 8e 76        	ld	a3, 224(sp)
   1d2e0: 36 96        	add	a2, a2, a3
;                 opt_debug_names = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d2e2: b2 e9        	sd	a2, 208(sp)
   1d2e4: 5d bb        	j	0x1d09a <.LBB47_104>

000000000001d2e6 <.LBB47_160>:
;     if (a.ptr == b.ptr) return true;
   1d2e6: 63 0e 86 09  	beq	a2, s8, 0x1d382 <.LBB47_160+0x9c>
;     for (a) |item, index| {
   1d2ea: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d2ee: e3 93 16 da  	bne	a3, ra, 0x1d094 <debug.printSourceAtAddress__anon_4137+0x798>
;     for (a) |item, index| {
   1d2f2: 83 46 16 00  	lbu	a3, 1(a2)
;         if (b[index] != item) return false;
   1d2f6: 13 04 40 06  	li	s0, 100
   1d2fa: e3 9d 86 d8  	bne	a3, s0, 0x1d094 <debug.printSourceAtAddress__anon_4137+0x798>
;     for (a) |item, index| {
   1d2fe: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d302: 13 04 50 06  	li	s0, 101
   1d306: e3 97 86 d8  	bne	a3, s0, 0x1d094 <debug.printSourceAtAddress__anon_4137+0x798>
;     for (a) |item, index| {
   1d30a: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d30e: 13 05 20 06  	li	a0, 98
   1d312: e3 91 a6 d8  	bne	a3, a0, 0x1d094 <debug.printSourceAtAddress__anon_4137+0x798>
;     for (a) |item, index| {
   1d316: 03 44 46 00  	lbu	s0, 4(a2)
;         if (b[index] != item) return false;
   1d31a: 13 05 50 07  	li	a0, 117
   1d31e: 63 11 a4 60  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d322: 03 44 56 00  	lbu	s0, 5(a2)
;         if (b[index] != item) return false;
   1d326: 13 05 70 06  	li	a0, 103
   1d32a: 63 1b a4 5e  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d32e: 03 44 66 00  	lbu	s0, 6(a2)
;         if (b[index] != item) return false;
   1d332: 13 05 f0 05  	li	a0, 95
   1d336: 63 15 a4 5e  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d33a: 03 44 76 00  	lbu	s0, 7(a2)
;         if (b[index] != item) return false;
   1d33e: 13 05 10 06  	li	a0, 97
   1d342: 63 1f a4 5c  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d346: 03 44 86 00  	lbu	s0, 8(a2)
;         if (b[index] != item) return false;
   1d34a: 13 05 20 06  	li	a0, 98
   1d34e: 63 19 a4 5c  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d352: 03 44 96 00  	lbu	s0, 9(a2)
;         if (b[index] != item) return false;
   1d356: 13 05 20 06  	li	a0, 98
   1d35a: 63 13 a4 5c  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d35e: 03 44 a6 00  	lbu	s0, 10(a2)
;         if (b[index] != item) return false;
   1d362: 13 05 20 07  	li	a0, 114
   1d366: 63 1d a4 5a  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d36a: 03 44 b6 00  	lbu	s0, 11(a2)
;         if (b[index] != item) return false;
   1d36e: 93 04 50 06  	li	s1, 101
   1d372: 63 17 94 5a  	bne	s0, s1, 0x1d920 <.LBB47_196+0x4a6>
;     for (a) |item, index| {
   1d376: 03 44 c6 00  	lbu	s0, 12(a2)
;         if (b[index] != item) return false;
   1d37a: 13 05 60 07  	li	a0, 118
   1d37e: 63 11 a4 5a  	bne	s0, a0, 0x1d920 <.LBB47_196+0x4a6>
;                 opt_debug_abbrev = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d382: 10 6f        	ld	a2, 24(a4)
   1d384: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d386: b2 96        	add	a3, a3, a2
   1d388: 63 f4 c6 00  	bgeu	a3, a2, 0x1d390 <.LBB47_160+0xaa>
   1d38c: 6f 30 40 35  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d390: 2e 77        	ld	a4, 232(sp)
   1d392: 63 74 d7 00  	bgeu	a4, a3, 0x1d39a <.LBB47_160+0xb4>
   1d396: 6f 30 90 00  	j	0x20b9e <.LBB47_196+0x3724>
   1d39a: b3 82 c6 40  	sub	t0, a3, a2
   1d39e: 8e 76        	ld	a3, 224(sp)
   1d3a0: 33 83 c6 00  	add	t1, a3, a2
   1d3a4: dd b9        	j	0x1d09a <.LBB47_104>

000000000001d3a6 <.LBB47_177>:
;     if (a.ptr == b.ptr) return true;
   1d3a6: 63 08 46 0b  	beq	a2, s4, 0x1d456 <.LBB47_177+0xb0>
;     for (a) |item, index| {
   1d3aa: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d3ae: 63 9c 16 1c  	bne	a3, ra, 0x1d586 <.LBB47_196+0x10c>
;     for (a) |item, index| {
   1d3b2: 03 44 16 00  	lbu	s0, 1(a2)
;         if (b[index] != item) return false;
   1d3b6: 93 06 40 06  	li	a3, 100
   1d3ba: 63 16 d4 1c  	bne	s0, a3, 0x1d586 <.LBB47_196+0x10c>
;     for (a) |item, index| {
   1d3be: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d3c2: 93 04 50 06  	li	s1, 101
   1d3c6: 63 98 96 28  	bne	a3, s1, 0x1d656 <.LBB47_196+0x1dc>
;     for (a) |item, index| {
   1d3ca: 83 44 36 00  	lbu	s1, 3(a2)
;         if (b[index] != item) return false;
   1d3ce: 13 05 20 06  	li	a0, 98
   1d3d2: 63 96 a4 28  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d3d6: 83 44 46 00  	lbu	s1, 4(a2)
;         if (b[index] != item) return false;
   1d3da: 13 05 50 07  	li	a0, 117
   1d3de: 63 90 a4 28  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d3e2: 83 44 56 00  	lbu	s1, 5(a2)
;         if (b[index] != item) return false;
   1d3e6: 13 05 70 06  	li	a0, 103
   1d3ea: 63 9a a4 26  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d3ee: 83 44 66 00  	lbu	s1, 6(a2)
;         if (b[index] != item) return false;
   1d3f2: 13 05 f0 05  	li	a0, 95
   1d3f6: 63 94 a4 26  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d3fa: 83 44 76 00  	lbu	s1, 7(a2)
;         if (b[index] != item) return false;
   1d3fe: 13 05 c0 06  	li	a0, 108
   1d402: 63 9e a4 24  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d406: 83 44 86 00  	lbu	s1, 8(a2)
;         if (b[index] != item) return false;
   1d40a: 13 05 90 06  	li	a0, 105
   1d40e: 63 98 a4 24  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d412: 83 44 96 00  	lbu	s1, 9(a2)
;         if (b[index] != item) return false;
   1d416: 13 05 e0 06  	li	a0, 110
   1d41a: 63 92 a4 24  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d41e: 83 44 a6 00  	lbu	s1, 10(a2)
;         if (b[index] != item) return false;
   1d422: 63 9e 54 23  	bne	s1, s5, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d426: 83 44 b6 00  	lbu	s1, 11(a2)
;         if (b[index] != item) return false;
   1d42a: 13 05 f0 05  	li	a0, 95
   1d42e: 63 98 a4 22  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d432: 83 44 c6 00  	lbu	s1, 12(a2)
;         if (b[index] != item) return false;
   1d436: 13 05 30 07  	li	a0, 115
   1d43a: 63 92 a4 22  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d43e: 83 44 d6 00  	lbu	s1, 13(a2)
;         if (b[index] != item) return false;
   1d442: 13 05 40 07  	li	a0, 116
   1d446: 63 9c a4 20  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;     for (a) |item, index| {
   1d44a: 83 44 e6 00  	lbu	s1, 14(a2)
;         if (b[index] != item) return false;
   1d44e: 13 05 20 07  	li	a0, 114
   1d452: 63 96 a4 20  	bne	s1, a0, 0x1d65e <.LBB47_196+0x1e4>
;                 opt_debug_line_str = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d456: 10 6f        	ld	a2, 24(a4)
   1d458: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d45a: b2 96        	add	a3, a3, a2
   1d45c: 63 f4 c6 00  	bgeu	a3, a2, 0x1d464 <.LBB47_177+0xbe>
   1d460: 6f 30 00 28  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d464: 2e 77        	ld	a4, 232(sp)
   1d466: 63 74 d7 00  	bgeu	a4, a3, 0x1d46e <.LBB47_177+0xc8>
   1d46a: 6f 30 40 73  	j	0x20b9e <.LBB47_196+0x3724>
   1d46e: 91 8e        	sub	a3, a3, a2
   1d470: b6 e5        	sd	a3, 200(sp)
   1d472: 8e 76        	ld	a3, 224(sp)
   1d474: 36 96        	add	a2, a2, a3
;                 opt_debug_line_str = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d476: 32 fd        	sd	a2, 184(sp)
   1d478: 0d b1        	j	0x1d09a <.LBB47_104>

000000000001d47a <.LBB47_196>:
;     if (a.ptr == b.ptr) return true;
   1d47a: 63 0c 96 0d  	beq	a2, s9, 0x1d552 <.LBB47_196+0xd8>
;     for (a) |item, index| {
   1d47e: 83 46 06 00  	lbu	a3, 0(a2)
;         if (b[index] != item) return false;
   1d482: e3 9c 16 c0  	bne	a3, ra, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d486: 83 46 16 00  	lbu	a3, 1(a2)
;         if (b[index] != item) return false;
   1d48a: 13 04 40 06  	li	s0, 100
   1d48e: e3 96 86 c0  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d492: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d496: 13 04 50 06  	li	s0, 101
   1d49a: e3 90 86 c0  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d49e: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d4a2: 13 05 20 06  	li	a0, 98
   1d4a6: e3 9a a6 be  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4aa: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d4ae: 13 05 50 07  	li	a0, 117
   1d4b2: e3 94 a6 be  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4b6: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d4ba: 13 05 70 06  	li	a0, 103
   1d4be: e3 9e a6 bc  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4c2: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d4c6: 13 05 f0 05  	li	a0, 95
   1d4ca: e3 98 a6 bc  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4ce: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d4d2: 13 05 30 07  	li	a0, 115
   1d4d6: e3 92 a6 bc  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4da: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d4de: 13 05 40 07  	li	a0, 116
   1d4e2: e3 9c a6 ba  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4e6: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d4ea: 13 05 20 07  	li	a0, 114
   1d4ee: e3 96 a6 ba  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4f2: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d4f6: 13 05 f0 05  	li	a0, 95
   1d4fa: e3 90 a6 ba  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d4fe: 83 46 b6 00  	lbu	a3, 11(a2)
;         if (b[index] != item) return false;
   1d502: 13 05 f0 06  	li	a0, 111
   1d506: e3 9a a6 b8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d50a: 83 46 c6 00  	lbu	a3, 12(a2)
;         if (b[index] != item) return false;
   1d50e: 13 05 60 06  	li	a0, 102
   1d512: e3 94 a6 b8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d516: 83 46 d6 00  	lbu	a3, 13(a2)
;         if (b[index] != item) return false;
   1d51a: 13 05 60 06  	li	a0, 102
   1d51e: e3 9e a6 b6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d522: 83 46 e6 00  	lbu	a3, 14(a2)
;         if (b[index] != item) return false;
   1d526: 13 05 30 07  	li	a0, 115
   1d52a: e3 98 a6 b6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d52e: 83 46 f6 00  	lbu	a3, 15(a2)
;         if (b[index] != item) return false;
   1d532: 13 04 50 06  	li	s0, 101
   1d536: e3 92 86 b6  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d53a: 83 46 06 01  	lbu	a3, 16(a2)
;         if (b[index] != item) return false;
   1d53e: 13 05 40 07  	li	a0, 116
   1d542: e3 9c a6 b4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d546: 03 46 16 01  	lbu	a2, 17(a2)
;         if (b[index] != item) return false;
   1d54a: 13 05 30 07  	li	a0, 115
   1d54e: e3 16 a6 b4  	bne	a2, a0, 0x1d09a <.LBB47_104>
;                 opt_debug_str_offsets = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d552: 10 6f        	ld	a2, 24(a4)
   1d554: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d556: b2 96        	add	a3, a3, a2
   1d558: 63 f4 c6 00  	bgeu	a3, a2, 0x1d560 <.LBB47_196+0xe6>
   1d55c: 6f 30 40 18  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d560: 2e 77        	ld	a4, 232(sp)
   1d562: 63 74 d7 00  	bgeu	a4, a3, 0x1d56a <.LBB47_196+0xf0>
   1d566: 6f 30 80 63  	j	0x20b9e <.LBB47_196+0x3724>
   1d56a: 91 8e        	sub	a3, a3, a2
   1d56c: 36 ea        	sd	a3, 272(sp)
   1d56e: 8e 76        	ld	a3, 224(sp)
   1d570: 33 85 c6 00  	add	a0, a3, a2
;                 opt_debug_str_offsets = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d574: 2a e2        	sd	a0, 256(sp)
   1d576: 15 b6        	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d578: e2 76        	ld	a3, 56(sp)
   1d57a: 63 01 d6 2e  	beq	a2, a3, 0x1d85c <.LBB47_196+0x3e2>
   1d57e: a2 66        	ld	a3, 8(sp)
   1d580: e3 1d d6 b0  	bne	a2, a3, 0x1d09a <.LBB47_104>
   1d584: 9d ae        	j	0x1d8fa <.LBB47_196+0x480>
   1d586: c6 66        	ld	a3, 80(sp)
   1d588: 63 0a d6 16  	beq	a2, a3, 0x1d6fc <.LBB47_196+0x282>
   1d58c: c2 66        	ld	a3, 16(sp)
   1d58e: e3 16 d6 b0  	bne	a2, a3, 0x1d09a <.LBB47_104>
   1d592: 25 ac        	j	0x1d7ca <.LBB47_196+0x350>
   1d594: 86 66        	ld	a3, 64(sp)
   1d596: e3 12 d6 b0  	bne	a2, a3, 0x1d09a <.LBB47_104>
   1d59a: 41 a8        	j	0x1d62a <.LBB47_196+0x1b0>
   1d59c: 06 64        	ld	s0, 64(sp)
   1d59e: 63 06 86 08  	beq	a2, s0, 0x1d62a <.LBB47_196+0x1b0>
;         if (b[index] != item) return false;
   1d5a2: e3 9c 16 ae  	bne	a3, ra, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5a6: 83 46 16 00  	lbu	a3, 1(a2)
;         if (b[index] != item) return false;
   1d5aa: 13 04 40 06  	li	s0, 100
   1d5ae: e3 96 86 ae  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5b2: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d5b6: 13 04 50 06  	li	s0, 101
   1d5ba: e3 90 86 ae  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5be: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d5c2: 13 05 20 06  	li	a0, 98
   1d5c6: e3 9a a6 ac  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5ca: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d5ce: 13 05 50 07  	li	a0, 117
   1d5d2: e3 94 a6 ac  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5d6: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d5da: 13 05 70 06  	li	a0, 103
   1d5de: e3 9e a6 aa  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5e2: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d5e6: 13 05 f0 05  	li	a0, 95
   1d5ea: e3 98 a6 aa  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5ee: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d5f2: 13 05 60 06  	li	a0, 102
   1d5f6: e3 92 a6 aa  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d5fa: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d5fe: 13 05 20 07  	li	a0, 114
   1d602: e3 9c a6 a8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d606: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d60a: 13 05 10 06  	li	a0, 97
   1d60e: e3 96 a6 a8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d612: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d616: 13 05 d0 06  	li	a0, 109
   1d61a: e3 90 a6 a8  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d61e: 03 46 b6 00  	lbu	a2, 11(a2)
;         if (b[index] != item) return false;
   1d622: 93 06 50 06  	li	a3, 101
   1d626: e3 1a d6 a6  	bne	a2, a3, 0x1d09a <.LBB47_104>
;                 opt_debug_frame = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d62a: 10 6f        	ld	a2, 24(a4)
   1d62c: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d62e: b2 96        	add	a3, a3, a2
   1d630: 63 f4 c6 00  	bgeu	a3, a2, 0x1d638 <.LBB47_196+0x1be>
   1d634: 6f 30 c0 0a  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d638: 2e 77        	ld	a4, 232(sp)
   1d63a: 63 74 d7 00  	bgeu	a4, a3, 0x1d642 <.LBB47_196+0x1c8>
   1d63e: 6f 30 00 56  	j	0x20b9e <.LBB47_196+0x3724>
   1d642: 91 8e        	sub	a3, a3, a2
   1d644: b6 f8        	sd	a3, 112(sp)
   1d646: 8e 76        	ld	a3, 224(sp)
   1d648: 36 96        	add	a2, a2, a3
   1d64a: b2 f4        	sd	a2, 104(sp)
   1d64c: b9 b4        	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d64e: e2 76        	ld	a3, 56(sp)
   1d650: 63 18 d6 22  	bne	a2, a3, 0x1d880 <.LBB47_196+0x406>
   1d654: 21 a4        	j	0x1d85c <.LBB47_196+0x3e2>
   1d656: c6 66        	ld	a3, 80(sp)
   1d658: 63 14 d6 0c  	bne	a2, a3, 0x1d720 <.LBB47_196+0x2a6>
   1d65c: 45 a0        	j	0x1d6fc <.LBB47_196+0x282>
   1d65e: c6 64        	ld	s1, 80(sp)
   1d660: 63 0e 96 08  	beq	a2, s1, 0x1d6fc <.LBB47_196+0x282>
;         if (b[index] != item) return false;
   1d664: 93 04 50 06  	li	s1, 101
   1d668: 63 9c 96 0a  	bne	a3, s1, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d66c: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d670: 13 05 20 06  	li	a0, 98
   1d674: 63 96 a6 0a  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d678: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d67c: 13 05 50 07  	li	a0, 117
   1d680: 63 90 a6 0a  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d684: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d688: 13 05 70 06  	li	a0, 103
   1d68c: 63 9a a6 08  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d690: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d694: 13 05 f0 05  	li	a0, 95
   1d698: 63 94 a6 08  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d69c: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d6a0: 13 05 c0 06  	li	a0, 108
   1d6a4: 63 9e a6 06  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6a8: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d6ac: 13 05 f0 06  	li	a0, 111
   1d6b0: 63 98 a6 06  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6b4: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d6b8: 13 05 30 06  	li	a0, 99
   1d6bc: 63 92 a6 06  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6c0: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d6c4: 13 05 c0 06  	li	a0, 108
   1d6c8: 63 9c a6 04  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6cc: 83 46 b6 00  	lbu	a3, 11(a2)
;         if (b[index] != item) return false;
   1d6d0: 13 05 90 06  	li	a0, 105
   1d6d4: 63 96 a6 04  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6d8: 83 46 c6 00  	lbu	a3, 12(a2)
;         if (b[index] != item) return false;
   1d6dc: 13 05 30 07  	li	a0, 115
   1d6e0: 63 90 a6 04  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6e4: 83 46 d6 00  	lbu	a3, 13(a2)
;         if (b[index] != item) return false;
   1d6e8: 13 05 40 07  	li	a0, 116
   1d6ec: 63 9a a6 02  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;     for (a) |item, index| {
   1d6f0: 83 46 e6 00  	lbu	a3, 14(a2)
;         if (b[index] != item) return false;
   1d6f4: 13 05 30 07  	li	a0, 115
   1d6f8: 63 94 a6 02  	bne	a3, a0, 0x1d720 <.LBB47_196+0x2a6>
;                 opt_debug_loclists = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d6fc: 10 6f        	ld	a2, 24(a4)
   1d6fe: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d700: b2 96        	add	a3, a3, a2
   1d702: 63 f4 c6 00  	bgeu	a3, a2, 0x1d70a <.LBB47_196+0x290>
   1d706: 6f 20 b0 7d  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d70a: 2e 77        	ld	a4, 232(sp)
   1d70c: 63 74 d7 00  	bgeu	a4, a3, 0x1d714 <.LBB47_196+0x29a>
   1d710: 6f 30 e0 48  	j	0x20b9e <.LBB47_196+0x3724>
   1d714: 91 8e        	sub	a3, a3, a2
   1d716: 36 f9        	sd	a3, 176(sp)
   1d718: 8e 76        	ld	a3, 224(sp)
   1d71a: 36 96        	add	a2, a2, a3
;                 opt_debug_loclists = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d71c: 32 e5        	sd	a2, 136(sp)
   1d71e: b5 ba        	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d720: c2 66        	ld	a3, 16(sp)
   1d722: 63 04 d6 0a  	beq	a2, a3, 0x1d7ca <.LBB47_196+0x350>
;         if (b[index] != item) return false;
   1d726: 93 06 40 06  	li	a3, 100
   1d72a: e3 18 d4 96  	bne	s0, a3, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d72e: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d732: 13 04 50 06  	li	s0, 101
   1d736: e3 92 86 96  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d73a: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d73e: 13 05 20 06  	li	a0, 98
   1d742: e3 9c a6 94  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d746: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d74a: 13 05 50 07  	li	a0, 117
   1d74e: e3 96 a6 94  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d752: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d756: 13 05 70 06  	li	a0, 103
   1d75a: e3 90 a6 94  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d75e: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d762: 13 05 f0 05  	li	a0, 95
   1d766: e3 9a a6 92  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d76a: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d76e: 13 05 20 07  	li	a0, 114
   1d772: e3 94 a6 92  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d776: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d77a: 13 05 e0 06  	li	a0, 110
   1d77e: e3 9e a6 90  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d782: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d786: 13 05 70 06  	li	a0, 103
   1d78a: e3 98 a6 90  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d78e: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d792: 13 05 c0 06  	li	a0, 108
   1d796: e3 92 a6 90  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d79a: 83 46 b6 00  	lbu	a3, 11(a2)
;         if (b[index] != item) return false;
   1d79e: 13 05 90 06  	li	a0, 105
   1d7a2: e3 9c a6 8e  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d7a6: 83 46 c6 00  	lbu	a3, 12(a2)
;         if (b[index] != item) return false;
   1d7aa: 13 05 30 07  	li	a0, 115
   1d7ae: e3 96 a6 8e  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d7b2: 83 46 d6 00  	lbu	a3, 13(a2)
;         if (b[index] != item) return false;
   1d7b6: 13 05 40 07  	li	a0, 116
   1d7ba: e3 90 a6 8e  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d7be: 03 46 e6 00  	lbu	a2, 14(a2)
;         if (b[index] != item) return false;
   1d7c2: 13 05 30 07  	li	a0, 115
   1d7c6: e3 1a a6 8c  	bne	a2, a0, 0x1d09a <.LBB47_104>
;                 opt_debug_rnglists = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d7ca: 10 6f        	ld	a2, 24(a4)
   1d7cc: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d7ce: b2 96        	add	a3, a3, a2
   1d7d0: 63 f4 c6 00  	bgeu	a3, a2, 0x1d7d8 <.LBB47_196+0x35e>
   1d7d4: 6f 20 d0 70  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d7d8: 2e 77        	ld	a4, 232(sp)
   1d7da: 63 74 d7 00  	bgeu	a4, a3, 0x1d7e2 <.LBB47_196+0x368>
   1d7de: 6f 30 00 3c  	j	0x20b9e <.LBB47_196+0x3724>
   1d7e2: 91 8e        	sub	a3, a3, a2
   1d7e4: 36 f8        	sd	a3, 48(sp)
   1d7e6: 8e 76        	ld	a3, 224(sp)
   1d7e8: 36 96        	add	a2, a2, a3
;                 opt_debug_rnglists = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d7ea: 32 f4        	sd	a2, 40(sp)
   1d7ec: 7d b0        	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d7ee: e2 74        	ld	s1, 56(sp)
   1d7f0: 63 06 96 06  	beq	a2, s1, 0x1d85c <.LBB47_196+0x3e2>
;         if (b[index] != item) return false;
   1d7f4: 93 04 50 06  	li	s1, 101
   1d7f8: 63 94 96 08  	bne	a3, s1, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d7fc: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d800: 13 05 20 06  	li	a0, 98
   1d804: 63 9e a6 06  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d808: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d80c: 13 05 50 07  	li	a0, 117
   1d810: 63 98 a6 06  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d814: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d818: 13 05 70 06  	li	a0, 103
   1d81c: 63 92 a6 06  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d820: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d824: 13 05 f0 05  	li	a0, 95
   1d828: 63 9c a6 04  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d82c: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d830: 13 05 c0 06  	li	a0, 108
   1d834: 63 96 a6 04  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d838: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d83c: 13 05 90 06  	li	a0, 105
   1d840: 63 90 a6 04  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d844: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d848: 13 05 e0 06  	li	a0, 110
   1d84c: 63 9a a6 02  	bne	a3, a0, 0x1d880 <.LBB47_196+0x406>
;     for (a) |item, index| {
   1d850: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d854: 93 04 50 06  	li	s1, 101
   1d858: 63 94 96 02  	bne	a3, s1, 0x1d880 <.LBB47_196+0x406>
;                 opt_debug_line = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d85c: 10 6f        	ld	a2, 24(a4)
   1d85e: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d860: b2 96        	add	a3, a3, a2
   1d862: 63 f4 c6 00  	bgeu	a3, a2, 0x1d86a <.LBB47_196+0x3f0>
   1d866: 6f 20 b0 67  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d86a: 2e 77        	ld	a4, 232(sp)
   1d86c: 63 74 d7 00  	bgeu	a4, a3, 0x1d874 <.LBB47_196+0x3fa>
   1d870: 6f 30 e0 32  	j	0x20b9e <.LBB47_196+0x3724>
   1d874: 91 8e        	sub	a3, a3, a2
   1d876: b6 f0        	sd	a3, 96(sp)
   1d878: 8e 76        	ld	a3, 224(sp)
   1d87a: 33 89 c6 00  	add	s2, a3, a2
   1d87e: 31 b8        	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d880: a2 66        	ld	a3, 8(sp)
   1d882: 63 0c d6 06  	beq	a2, a3, 0x1d8fa <.LBB47_196+0x480>
;         if (b[index] != item) return false;
   1d886: 93 06 40 06  	li	a3, 100
   1d88a: e3 18 d4 80  	bne	s0, a3, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d88e: 83 46 26 00  	lbu	a3, 2(a2)
;         if (b[index] != item) return false;
   1d892: 13 04 50 06  	li	s0, 101
   1d896: e3 92 86 80  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d89a: 83 46 36 00  	lbu	a3, 3(a2)
;         if (b[index] != item) return false;
   1d89e: 13 05 20 06  	li	a0, 98
   1d8a2: 63 9c a6 fe  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8a6: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d8aa: 13 05 50 07  	li	a0, 117
   1d8ae: 63 96 a6 fe  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8b2: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d8b6: 13 05 70 06  	li	a0, 103
   1d8ba: 63 90 a6 fe  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8be: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d8c2: 13 05 f0 05  	li	a0, 95
   1d8c6: 63 9a a6 fc  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8ca: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d8ce: 13 05 10 06  	li	a0, 97
   1d8d2: 63 94 a6 fc  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8d6: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d8da: 13 04 40 06  	li	s0, 100
   1d8de: 63 9e 86 fa  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8e2: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d8e6: 13 04 40 06  	li	s0, 100
   1d8ea: 63 98 86 fa  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d8ee: 03 46 a6 00  	lbu	a2, 10(a2)
;         if (b[index] != item) return false;
   1d8f2: 13 05 20 07  	li	a0, 114
   1d8f6: 63 12 a6 fa  	bne	a2, a0, 0x1d09a <.LBB47_104>
;                 opt_debug_addr = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d8fa: 10 6f        	ld	a2, 24(a4)
   1d8fc: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d8fe: b2 96        	add	a3, a3, a2
   1d900: 63 f4 c6 00  	bgeu	a3, a2, 0x1d908 <.LBB47_196+0x48e>
   1d904: 6f 20 d0 5d  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d908: 2e 77        	ld	a4, 232(sp)
   1d90a: 63 74 d7 00  	bgeu	a4, a3, 0x1d912 <.LBB47_196+0x498>
   1d90e: 6f 30 00 29  	j	0x20b9e <.LBB47_196+0x3724>
   1d912: 91 8e        	sub	a3, a3, a2
   1d914: 36 f0        	sd	a3, 32(sp)
   1d916: 8e 76        	ld	a3, 224(sp)
   1d918: 36 96        	add	a2, a2, a3
;                 opt_debug_addr = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d91a: 32 ec        	sd	a2, 24(sp)
   1d91c: 6f f0 ef f7  	j	0x1d09a <.LBB47_104>
;     if (a.ptr == b.ptr) return true;
   1d920: 26 64        	ld	s0, 72(sp)
   1d922: 63 0c 86 06  	beq	a2, s0, 0x1d99a <.LBB47_196+0x520>
;         if (b[index] != item) return false;
   1d926: 13 05 20 06  	li	a0, 98
   1d92a: 63 98 a6 f6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d92e: 83 46 46 00  	lbu	a3, 4(a2)
;         if (b[index] != item) return false;
   1d932: 13 05 50 07  	li	a0, 117
   1d936: 63 92 a6 f6  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d93a: 83 46 56 00  	lbu	a3, 5(a2)
;         if (b[index] != item) return false;
   1d93e: 13 05 70 06  	li	a0, 103
   1d942: 63 9c a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d946: 83 46 66 00  	lbu	a3, 6(a2)
;         if (b[index] != item) return false;
   1d94a: 13 05 f0 05  	li	a0, 95
   1d94e: 63 96 a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d952: 83 46 76 00  	lbu	a3, 7(a2)
;         if (b[index] != item) return false;
   1d956: 13 05 20 07  	li	a0, 114
   1d95a: 63 90 a6 f4  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d95e: 83 46 86 00  	lbu	a3, 8(a2)
;         if (b[index] != item) return false;
   1d962: 13 05 10 06  	li	a0, 97
   1d966: 63 9a a6 f2  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d96a: 83 46 96 00  	lbu	a3, 9(a2)
;         if (b[index] != item) return false;
   1d96e: 13 05 e0 06  	li	a0, 110
   1d972: 63 94 a6 f2  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d976: 83 46 a6 00  	lbu	a3, 10(a2)
;         if (b[index] != item) return false;
   1d97a: 13 05 70 06  	li	a0, 103
   1d97e: 63 9e a6 f0  	bne	a3, a0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d982: 83 46 b6 00  	lbu	a3, 11(a2)
;         if (b[index] != item) return false;
   1d986: 13 04 50 06  	li	s0, 101
   1d98a: 63 98 86 f0  	bne	a3, s0, 0x1d09a <.LBB47_104>
;     for (a) |item, index| {
   1d98e: 03 46 c6 00  	lbu	a2, 12(a2)
;         if (b[index] != item) return false;
   1d992: 13 05 30 07  	li	a0, 115
   1d996: 63 12 a6 f0  	bne	a2, a0, 0x1d09a <.LBB47_104>
;                 opt_debug_ranges = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d99a: 10 6f        	ld	a2, 24(a4)
   1d99c: 14 73        	ld	a3, 32(a4)
;     const end = start + (math.cast(usize, size) orelse return error.Overflow);
   1d99e: b2 96        	add	a3, a3, a2
   1d9a0: 63 f4 c6 00  	bgeu	a3, a2, 0x1d9a8 <.LBB47_196+0x52e>
   1d9a4: 6f 20 d0 53  	j	0x206e0 <.LBB47_196+0x3266>
;     return ptr[start..end];
   1d9a8: 2e 77        	ld	a4, 232(sp)
   1d9aa: 63 74 d7 00  	bgeu	a4, a3, 0x1d9b2 <.LBB47_196+0x538>
   1d9ae: 6f 30 00 1f  	j	0x20b9e <.LBB47_196+0x3724>
   1d9b2: 91 8e        	sub	a3, a3, a2
   1d9b4: 36 e1        	sd	a3, 128(sp)
   1d9b6: 8e 76        	ld	a3, 224(sp)
   1d9b8: 36 96        	add	a2, a2, a3
;                 opt_debug_ranges = try chopSlice(mapped_mem, shdr.sh_offset, shdr.sh_size);
   1d9ba: b2 fc        	sd	a2, 120(sp)
   1d9bc: 6f f0 ef ed  	j	0x1d09a <.LBB47_104>
   1d9c0: 05 45        	li	a0, 1
;         var di = DW.DwarfInfo{
   1d9c2: 85 65        	lui	a1, 1
   1d9c4: 9b 85 85 3d  	addiw	a1, a1, 984
   1d9c8: 8a 95        	add	a1, a1, sp
   1d9ca: 23 80 a5 00  	sb	a0, 0(a1)
   1d9ce: 63 94 0b 00  	bnez	s7, 0x1d9d6 <.LBB47_196+0x55c>
   1d9d2: 6f 10 00 48  	j	0x1ee52 <.LBB47_196+0x19d8>
   1d9d6: 05 65        	lui	a0, 1
   1d9d8: 1b 05 05 2d  	addiw	a0, a0, 720
   1d9dc: 0a 95        	add	a0, a0, sp
   1d9de: 23 30 75 01  	sd	s7, 0(a0)
   1d9e2: 05 65        	lui	a0, 1
   1d9e4: 1b 05 85 2d  	addiw	a0, a0, 728
   1d9e8: 0a 95        	add	a0, a0, sp
   1d9ea: 23 30 a5 01  	sd	s10, 0(a0)
   1d9ee: aa 7d        	ld	s11, 168(sp)
;             .debug_info = opt_debug_info orelse return error.MissingDebugInfo,
   1d9f0: 63 14 03 00  	bnez	t1, 0x1d9f8 <.LBB47_196+0x57e>
   1d9f4: 6f 10 e0 20  	j	0x1ec02 <.LBB47_196+0x1788>
   1d9f8: 05 65        	lui	a0, 1
   1d9fa: 1b 05 05 2e  	addiw	a0, a0, 736
   1d9fe: 0a 95        	add	a0, a0, sp
   1da00: 23 30 65 00  	sd	t1, 0(a0)
   1da04: 05 65        	lui	a0, 1
   1da06: 1b 05 85 2e  	addiw	a0, a0, 744
   1da0a: 0a 95        	add	a0, a0, sp
   1da0c: 23 30 55 00  	sd	t0, 0(a0)
;             .debug_abbrev = opt_debug_abbrev orelse return error.MissingDebugInfo,
   1da10: 63 14 08 00  	bnez	a6, 0x1da18 <.LBB47_196+0x59e>
   1da14: 6f 10 e0 1e  	j	0x1ec02 <.LBB47_196+0x1788>
   1da18: 05 65        	lui	a0, 1
   1da1a: 1b 05 05 2f  	addiw	a0, a0, 752
   1da1e: 0a 95        	add	a0, a0, sp
   1da20: 23 30 05 01  	sd	a6, 0(a0)
   1da24: 05 65        	lui	a0, 1
   1da26: 1b 05 85 2f  	addiw	a0, a0, 760
   1da2a: 0a 95        	add	a0, a0, sp
   1da2c: 23 30 65 01  	sd	s6, 0(a0)
;             .debug_str = opt_debug_str orelse return error.MissingDebugInfo,
   1da30: 12 65        	ld	a0, 256(sp)
   1da32: 85 65        	lui	a1, 1
   1da34: 9b 85 05 30  	addiw	a1, a1, 768
   1da38: 8a 95        	add	a1, a1, sp
   1da3a: 88 e1        	sd	a0, 0(a1)
   1da3c: 52 65        	ld	a0, 272(sp)
   1da3e: 85 65        	lui	a1, 1
   1da40: 9b 85 85 30  	addiw	a1, a1, 776
   1da44: 8a 95        	add	a1, a1, sp
   1da46: 88 e1        	sd	a0, 0(a1)
   1da48: 63 14 09 00  	bnez	s2, 0x1da50 <.LBB47_196+0x5d6>
   1da4c: 6f 10 60 1b  	j	0x1ec02 <.LBB47_196+0x1788>
   1da50: 05 65        	lui	a0, 1
   1da52: 1b 05 05 31  	addiw	a0, a0, 784
   1da56: 0a 95        	add	a0, a0, sp
   1da58: 23 30 25 01  	sd	s2, 0(a0)
   1da5c: 06 75        	ld	a0, 96(sp)
   1da5e: 85 65        	lui	a1, 1
   1da60: 9b 85 85 31  	addiw	a1, a1, 792
   1da64: 8a 95        	add	a1, a1, sp
   1da66: 88 e1        	sd	a0, 0(a1)
;             .debug_line = opt_debug_line orelse return error.MissingDebugInfo,
   1da68: 6a 75        	ld	a0, 184(sp)
   1da6a: 85 65        	lui	a1, 1
   1da6c: 9b 85 05 32  	addiw	a1, a1, 800
   1da70: 8a 95        	add	a1, a1, sp
   1da72: 88 e1        	sd	a0, 0(a1)
   1da74: 2e 65        	ld	a0, 200(sp)
   1da76: 85 65        	lui	a1, 1
   1da78: 9b 85 85 32  	addiw	a1, a1, 808
   1da7c: 8a 95        	add	a1, a1, sp
   1da7e: 88 e1        	sd	a0, 0(a1)
   1da80: 66 75        	ld	a0, 120(sp)
   1da82: 85 65        	lui	a1, 1
   1da84: 9b 85 05 33  	addiw	a1, a1, 816
   1da88: 8a 95        	add	a1, a1, sp
   1da8a: 88 e1        	sd	a0, 0(a1)
   1da8c: 0a 65        	ld	a0, 128(sp)
   1da8e: 85 65        	lui	a1, 1
   1da90: 9b 85 85 33  	addiw	a1, a1, 824
   1da94: 8a 95        	add	a1, a1, sp
   1da96: 88 e1        	sd	a0, 0(a1)
   1da98: 2a 65        	ld	a0, 136(sp)
   1da9a: 85 65        	lui	a1, 1
   1da9c: 9b 85 05 34  	addiw	a1, a1, 832
   1daa0: 8a 95        	add	a1, a1, sp
   1daa2: 88 e1        	sd	a0, 0(a1)
   1daa4: 4a 75        	ld	a0, 176(sp)
   1daa6: 85 65        	lui	a1, 1
   1daa8: 9b 85 85 34  	addiw	a1, a1, 840
   1daac: 8a 95        	add	a1, a1, sp
   1daae: 88 e1        	sd	a0, 0(a1)
   1dab0: 22 75        	ld	a0, 40(sp)
   1dab2: 85 65        	lui	a1, 1
   1dab4: 9b 85 05 35  	addiw	a1, a1, 848
   1dab8: 8a 95        	add	a1, a1, sp
   1daba: 88 e1        	sd	a0, 0(a1)
   1dabc: 42 75        	ld	a0, 48(sp)
   1dabe: 85 65        	lui	a1, 1
   1dac0: 9b 85 85 35  	addiw	a1, a1, 856
   1dac4: 8a 95        	add	a1, a1, sp
   1dac6: 88 e1        	sd	a0, 0(a1)
   1dac8: 62 65        	ld	a0, 24(sp)
   1daca: 85 65        	lui	a1, 1
   1dacc: 9b 85 05 36  	addiw	a1, a1, 864
   1dad0: 8a 95        	add	a1, a1, sp
   1dad2: 88 e1        	sd	a0, 0(a1)
   1dad4: 02 75        	ld	a0, 32(sp)
   1dad6: 85 65        	lui	a1, 1
   1dad8: 9b 85 85 36  	addiw	a1, a1, 872
   1dadc: 8a 95        	add	a1, a1, sp
   1dade: 88 e1        	sd	a0, 0(a1)
   1dae0: 4e 65        	ld	a0, 208(sp)
   1dae2: 85 65        	lui	a1, 1
   1dae4: 9b 85 05 37  	addiw	a1, a1, 880
   1dae8: 8a 95        	add	a1, a1, sp
   1daea: 88 e1        	sd	a0, 0(a1)
   1daec: 6e 65        	ld	a0, 216(sp)
   1daee: 85 65        	lui	a1, 1
   1daf0: 9b 85 85 37  	addiw	a1, a1, 888
   1daf4: 8a 95        	add	a1, a1, sp
   1daf6: 88 e1        	sd	a0, 0(a1)
   1daf8: 26 75        	ld	a0, 104(sp)
   1dafa: 85 65        	lui	a1, 1
   1dafc: 9b 85 05 38  	addiw	a1, a1, 896
   1db00: 8a 95        	add	a1, a1, sp
   1db02: 88 e1        	sd	a0, 0(a1)
   1db04: 37 55 02 00  	lui	a0, 37
   1db08: 83 35 85 38  	ld	a1, 904(a0)
   1db0c: 46 75        	ld	a0, 112(sp)
   1db0e: 05 66        	lui	a2, 1
   1db10: 1b 06 86 38  	addiw	a2, a2, 904
   1db14: 0a 96        	add	a2, a2, sp
   1db16: 08 e2        	sd	a0, 0(a2)
   1db18: 05 65        	lui	a0, 1
   1db1a: 1b 05 85 39  	addiw	a0, a0, 920
   1db1e: 0a 95        	add	a0, a0, sp
   1db20: 23 30 05 00  	sd	zero, 0(a0)
   1db24: 05 65        	lui	a0, 1
   1db26: 1b 05 05 3a  	addiw	a0, a0, 928
   1db2a: 0a 95        	add	a0, a0, sp
   1db2c: 23 30 05 00  	sd	zero, 0(a0)
   1db30: 05 65        	lui	a0, 1
   1db32: 1b 05 05 39  	addiw	a0, a0, 912
   1db36: 0a 95        	add	a0, a0, sp
   1db38: 0c e1        	sd	a1, 0(a0)
   1db3a: 05 65        	lui	a0, 1
   1db3c: 1b 05 85 3b  	addiw	a0, a0, 952
   1db40: 0a 95        	add	a0, a0, sp
   1db42: 23 30 05 00  	sd	zero, 0(a0)
   1db46: 05 65        	lui	a0, 1
   1db48: 1b 05 05 3b  	addiw	a0, a0, 944
   1db4c: 0a 95        	add	a0, a0, sp
   1db4e: 23 30 05 00  	sd	zero, 0(a0)
   1db52: 05 65        	lui	a0, 1
   1db54: 1b 05 85 3a  	addiw	a0, a0, 936
   1db58: 0a 95        	add	a0, a0, sp
   1db5a: 0c e1        	sd	a1, 0(a0)
   1db5c: ae fc        	sd	a1, 120(sp)
   1db5e: 05 65        	lui	a0, 1
   1db60: 1b 05 05 3c  	addiw	a0, a0, 960
   1db64: 0a 95        	add	a0, a0, sp
   1db66: 0c e1        	sd	a1, 0(a0)
   1db68: 05 65        	lui	a0, 1
   1db6a: 1b 05 85 3c  	addiw	a0, a0, 968
   1db6e: 0a 95        	add	a0, a0, sp
   1db70: 23 30 05 00  	sd	zero, 0(a0)
   1db74: 05 65        	lui	a0, 1
   1db76: 1b 05 05 3d  	addiw	a0, a0, 976
   1db7a: 0a 95        	add	a0, a0, sp
   1db7c: 23 30 05 00  	sd	zero, 0(a0)
   1db80: 72 65        	ld	a0, 280(sp)
   1db82: 08 61        	ld	a0, 0(a0)
;         var stream = io.fixedBufferStream(di.debug_info);
   1db84: 2a f9        	sd	a0, 176(sp)
   1db86: 09 65        	lui	a0, 2
   1db88: 1b 05 05 2d  	addiw	a0, a0, 720
   1db8c: 0a 95        	add	a0, a0, sp
   1db8e: 23 30 75 01  	sd	s7, 0(a0)
   1db92: 09 65        	lui	a0, 2
   1db94: 1b 05 85 2d  	addiw	a0, a0, 728
   1db98: 0a 95        	add	a0, a0, sp
   1db9a: 23 30 a5 01  	sd	s10, 0(a0)
   1db9e: 09 65        	lui	a0, 2
   1dba0: 1b 05 05 2e  	addiw	a0, a0, 736
   1dba4: 0a 95        	add	a0, a0, sp
   1dba6: 23 30 05 00  	sd	zero, 0(a0)
   1dbaa: 09 65        	lui	a0, 2
   1dbac: 1b 05 05 2d  	addiw	a0, a0, 720
   1dbb0: 0a 95        	add	a0, a0, sp
;             return .{ .context = self };
   1dbb2: 89 65        	lui	a1, 2
   1dbb4: 9b 85 85 2e  	addiw	a1, a1, 744
   1dbb8: 8a 95        	add	a1, a1, sp
   1dbba: 88 e1        	sd	a0, 0(a1)
   1dbbc: b2 65        	ld	a1, 264(sp)
;             return .{
   1dbbe: 88 61        	ld	a0, 0(a1)
   1dbc0: 8c 65        	ld	a1, 8(a1)
;         return (State{}).promote(child_allocator);
   1dbc2: 09 66        	lui	a2, 2
   1dbc4: 1b 06 06 2f  	addiw	a2, a2, 752
   1dbc8: 0a 96        	add	a2, a2, sp
   1dbca: 08 e2        	sd	a0, 0(a2)
   1dbcc: 09 65        	lui	a0, 2
   1dbce: 1b 05 85 2f  	addiw	a0, a0, 760
   1dbd2: 0a 95        	add	a0, a0, sp
   1dbd4: 0c e1        	sd	a1, 0(a0)
   1dbd6: 09 65        	lui	a0, 2
   1dbd8: 1b 05 05 30  	addiw	a0, a0, 768
   1dbdc: 0a 95        	add	a0, a0, sp
   1dbde: 23 30 05 00  	sd	zero, 0(a0)
   1dbe2: 09 65        	lui	a0, 2
   1dbe4: 1b 05 85 30  	addiw	a0, a0, 776
   1dbe8: 0a 95        	add	a0, a0, sp
   1dbea: 23 30 05 00  	sd	zero, 0(a0)
   1dbee: 09 65        	lui	a0, 2
   1dbf0: 1b 05 05 2f  	addiw	a0, a0, 752
   1dbf4: 0a 95        	add	a0, a0, sp
;         return .{
   1dbf6: 89 65        	lui	a1, 2
   1dbf8: 9b 85 05 31  	addiw	a1, a1, 784
   1dbfc: 8a 95        	add	a1, a1, sp
   1dbfe: 88 e1        	sd	a0, 0(a1)
   1dc00: 37 15 01 00  	lui	a0, 17
   1dc04: 13 05 05 02  	addi	a0, a0, 32
   1dc08: 89 65        	lui	a1, 2
   1dc0a: 9b 85 85 31  	addiw	a1, a1, 792
   1dc0e: 8a 95        	add	a1, a1, sp
   1dc10: 88 e1        	sd	a0, 0(a1)
   1dc12: e3 0a 0d 74  	beqz	s10, 0x1eb66 <.LBB47_196+0x16ec>
   1dc16: 81 45        	li	a1, 0
   1dc18: 37 b5 aa aa  	lui	a0, 699051
   1dc1c: 1b 05 a5 aa  	addiw	a0, a0, -1366
   1dc20: 2a e5        	sd	a0, 136(sp)
   1dc22: 09 65        	lui	a0, 2
   1dc24: 1b 05 05 57  	addiw	a0, a0, 1392
   1dc28: b3 0b a1 00  	add	s7, sp, a0
   1dc2c: 91 4a        	li	s5, 4
   1dc2e: 41 65        	lui	a0, 16
   1dc30: 1b 05 05 f0  	addiw	a0, a0, -256
   1dc34: aa f8        	sd	a0, 112(sp)
   1dc36: 21 4b        	li	s6, 8
   1dc38: 2d 65        	lui	a0, 11
   1dc3a: 1b 05 a5 aa  	addiw	a0, a0, -1366
   1dc3e: aa f4        	sd	a0, 104(sp)
   1dc40: 89 49        	li	s3, 2
   1dc42: 37 05 00 04  	lui	a0, 16384
   1dc46: 1b 05 15 20  	addiw	a0, a0, 513
   1dc4a: 52 05        	slli	a0, a0, 20
   1dc4c: 21 05        	addi	a0, a0, 8
   1dc4e: aa ed        	sd	a0, 216(sp)
   1dc50: 8d 4d        	li	s11, 3
   1dc52: 37 55 02 00  	lui	a0, 37
   1dc56: 03 35 85 3a  	ld	a0, 936(a0)
   1dc5a: 2a f8        	sd	a0, 48(sp)
   1dc5c: 21 a8        	j	0x1dc74 <.LBB47_196+0x7fa>
;         while (this_unit_offset < try seekable.getEndPos()) {
   1dc5e: 09 65        	lui	a0, 2
   1dc60: 1b 05 85 2d  	addiw	a0, a0, 728
   1dc64: 0a 95        	add	a0, a0, sp
   1dc66: 03 3d 05 00  	ld	s10, 0(a0)
   1dc6a: 89 49        	li	s3, 2
   1dc6c: 4a 84        	mv	s0, s2
   1dc6e: a2 85        	mv	a1, s0
;         while (this_unit_offset < try seekable.getEndPos()) {
   1dc70: e3 7b a4 6f  	bgeu	s0, s10, 0x1eb66 <.LBB47_196+0x16ec>
   1dc74: 2e 85        	mv	a0, a1
   1dc76: ae e9        	sd	a1, 208(sp)
   1dc78: 63 63 bd 00  	bltu	s10, a1, 0x1dc7e <.LBB47_196+0x804>
   1dc7c: 4e 6d        	ld	s10, 208(sp)
;             const unit_length = try readUnitLength(in, di.endian, &is_64);
   1dc7e: 05 65        	lui	a0, 1
   1dc80: 1b 05 85 3d  	addiw	a0, a0, 984
   1dc84: 0a 95        	add	a0, a0, sp
   1dc86: 03 09 05 00  	lb	s2, 0(a0)
;     const first_32_bits = try in_stream.readInt(u32, endian);
   1dc8a: 09 65        	lui	a0, 2
   1dc8c: 1b 05 85 2e  	addiw	a0, a0, 744
   1dc90: 0a 95        	add	a0, a0, sp
   1dc92: 00 61        	ld	s0, 0(a0)
   1dc94: 81 44        	li	s1, 0
   1dc96: 09 65        	lui	a0, 2
   1dc98: 1b 05 05 2e  	addiw	a0, a0, 736
   1dc9c: 0a 95        	add	a0, a0, sp
   1dc9e: 23 30 a5 01  	sd	s10, 0(a0)
;             var bytes: [num_bytes]u8 = undefined;
   1dca2: 2a 65        	ld	a0, 136(sp)
   1dca4: 89 65        	lui	a1, 2
   1dca6: 9b 85 05 57  	addiw	a1, a1, 1392
   1dcaa: 8a 95        	add	a1, a1, sp
   1dcac: 88 c1        	sw	a0, 0(a1)
   1dcae: 72 6c        	ld	s8, 280(sp)
   1dcb0: 4e 7d        	ld	s10, 240(sp)
;                 const amt = try self.read(buffer[index..]);
   1dcb2: 33 86 9b 00  	add	a2, s7, s1
   1dcb6: b3 86 9a 40  	sub	a3, s5, s1
;             return readFn(self.context, buffer);
   1dcba: 88 0d        	addi	a0, sp, 720
   1dcbc: a2 85        	mv	a1, s0
   1dcbe: 97 40 00 00  	auipc	ra, 4
   1dcc2: e7 80 a0 9f  	jalr	-1542(ra)
   1dcc6: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1dcca: 19 e1        	bnez	a0, 0x1dcd0 <.LBB47_196+0x856>
   1dccc: 6f 00 90 7a  	j	0x1ec74 <.LBB47_196+0x17fa>
;                 index += amt;
   1dcd0: 26 95        	add	a0, a0, s1
   1dcd2: 63 74 95 00  	bgeu	a0, s1, 0x1dcda <.LBB47_196+0x860>
   1dcd6: 6f 20 b0 20  	j	0x206e0 <.LBB47_196+0x3266>
   1dcda: aa 84        	mv	s1, a0
;             while (index < len) {
   1dcdc: e3 6b 55 fd  	bltu	a0, s5, 0x1dcb2 <.LBB47_196+0x838>
;             return bytes;
   1dce0: 09 65        	lui	a0, 2
   1dce2: 1b 05 05 57  	addiw	a0, a0, 1392
   1dce6: 0a 95        	add	a0, a0, sp
   1dce8: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1dcec: 13 79 19 00  	andi	s2, s2, 1
   1dcf0: 63 12 09 02  	bnez	s2, 0x1dd14 <.LBB47_196+0x89a>
   1dcf4: 93 55 85 00  	srli	a1, a0, 8
   1dcf8: 46 76        	ld	a2, 112(sp)
   1dcfa: f1 8d        	and	a1, a1, a2
   1dcfc: 13 56 85 01  	srli	a2, a0, 24
   1dd00: d1 8d        	or	a1, a1, a2
   1dd02: 13 16 85 00  	slli	a2, a0, 8
   1dd06: b7 06 ff 00  	lui	a3, 4080
   1dd0a: 75 8e        	and	a2, a2, a3
   1dd0c: 1b 15 85 01  	slliw	a0, a0, 24
   1dd10: 51 8d        	or	a0, a0, a2
   1dd12: 4d 8d        	or	a0, a0, a1
;     if (endian == native_endian) {
   1dd14: 1b 0a 05 00  	sext.w	s4, a0
;     is_64.* = (first_32_bits == 0xffffffff);
   1dd18: 93 05 1a 00  	addi	a1, s4, 1
   1dd1c: 93 b5 15 00  	seqz	a1, a1
   1dd20: 09 66        	lui	a2, 2
   1dd22: 1b 06 76 32  	addiw	a2, a2, 807
   1dd26: 0a 96        	add	a2, a2, sp
   1dd28: 23 00 b6 00  	sb	a1, 0(a2)
;     if (is_64.*) {
   1dd2c: fd 55        	li	a1, -1
   1dd2e: 63 0a ba 00  	beq	s4, a1, 0x1dd42 <.LBB47_196+0x8c8>
;         if (first_32_bits >= 0xfffffff0) return badDwarf();
   1dd32: bd 55        	li	a1, -17
   1dd34: 63 f4 45 01  	bgeu	a1, s4, 0x1dd3c <.LBB47_196+0x8c2>
   1dd38: 6f 20 10 3b  	j	0x208e8 <.LBB47_196+0x346e>
;         return @as(u64, first_32_bits);
   1dd3c: 02 15        	slli	a0, a0, 32
   1dd3e: 01 91        	srli	a0, a0, 32
   1dd40: 59 a8        	j	0x1ddd6 <.LBB47_196+0x95c>
   1dd42: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1dd44: 66 75        	ld	a0, 120(sp)
   1dd46: 89 65        	lui	a1, 2
   1dd48: 9b 85 05 57  	addiw	a1, a1, 1392
   1dd4c: 8a 95        	add	a1, a1, sp
   1dd4e: 88 e1        	sd	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1dd50: 33 86 9b 00  	add	a2, s7, s1
   1dd54: b3 06 9b 40  	sub	a3, s6, s1
;             return readFn(self.context, buffer);
   1dd58: 88 0d        	addi	a0, sp, 720
   1dd5a: a2 85        	mv	a1, s0
   1dd5c: 97 40 00 00  	auipc	ra, 4
   1dd60: e7 80 c0 95  	jalr	-1700(ra)
   1dd64: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1dd68: e3 06 05 70  	beqz	a0, 0x1ec74 <.LBB47_196+0x17fa>
;                 index += amt;
   1dd6c: 26 95        	add	a0, a0, s1
   1dd6e: 63 74 95 00  	bgeu	a0, s1, 0x1dd76 <.LBB47_196+0x8fc>
   1dd72: 6f 20 f0 16  	j	0x206e0 <.LBB47_196+0x3266>
   1dd76: aa 84        	mv	s1, a0
;             while (index < len) {
   1dd78: e3 6c 65 fd  	bltu	a0, s6, 0x1dd50 <.LBB47_196+0x8d6>
;             return bytes;
   1dd7c: 09 65        	lui	a0, 2
   1dd7e: 1b 05 05 57  	addiw	a0, a0, 1392
   1dd82: 0a 95        	add	a0, a0, sp
   1dd84: 08 61        	ld	a0, 0(a0)
;     if (endian == native_endian) {
   1dd86: 63 18 09 04  	bnez	s2, 0x1ddd6 <.LBB47_196+0x95c>
   1dd8a: 93 55 85 01  	srli	a1, a0, 24
   1dd8e: 37 06 ff 00  	lui	a2, 4080
   1dd92: f1 8d        	and	a1, a1, a2
   1dd94: 13 56 85 00  	srli	a2, a0, 8
   1dd98: 13 07 f0 0f  	li	a4, 255
   1dd9c: 93 16 87 01  	slli	a3, a4, 24
   1dda0: 75 8e        	and	a2, a2, a3
   1dda2: d1 8d        	or	a1, a1, a2
   1dda4: 13 56 85 02  	srli	a2, a0, 40
   1dda8: c6 76        	ld	a3, 112(sp)
   1ddaa: 75 8e        	and	a2, a2, a3
   1ddac: 93 56 85 03  	srli	a3, a0, 56
   1ddb0: 55 8e        	or	a2, a2, a3
   1ddb2: d1 8d        	or	a1, a1, a2
   1ddb4: 13 16 85 01  	slli	a2, a0, 24
   1ddb8: 93 16 87 02  	slli	a3, a4, 40
   1ddbc: 75 8e        	and	a2, a2, a3
   1ddbe: 9b 56 85 01  	srliw	a3, a0, 24
   1ddc2: 82 16        	slli	a3, a3, 32
   1ddc4: 55 8e        	or	a2, a2, a3
   1ddc6: 93 16 85 02  	slli	a3, a0, 40
   1ddca: 42 17        	slli	a4, a4, 48
   1ddcc: f9 8e        	and	a3, a3, a4
   1ddce: 62 15        	slli	a0, a0, 56
   1ddd0: 55 8d        	or	a0, a0, a3
   1ddd2: 51 8d        	or	a0, a0, a2
   1ddd4: 4d 8d        	or	a0, a0, a1
;             if (unit_length == 0) return;
   1ddd6: 19 e1        	bnez	a0, 0x1dddc <.LBB47_196+0x962>
   1ddd8: 6f 10 40 14  	j	0x1ef1c <.LBB47_196+0x1aa2>
   1dddc: b1 45        	li	a1, 12
   1ddde: 7d 56        	li	a2, -1
   1dde0: 63 03 ca 00  	beq	s4, a2, 0x1dde6 <.LBB47_196+0x96c>
   1dde4: 91 45        	li	a1, 4
;             const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1dde6: aa 95        	add	a1, a1, a0
   1dde8: 2e fd        	sd	a1, 184(sp)
;             const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1ddea: 63 f4 a5 00  	bgeu	a1, a0, 0x1ddf2 <.LBB47_196+0x978>
   1ddee: 6f 20 30 0f  	j	0x206e0 <.LBB47_196+0x3266>
;             const version = try in.readInt(u16, di.endian);
   1ddf2: 05 65        	lui	a0, 1
   1ddf4: 1b 05 85 3d  	addiw	a0, a0, 984
   1ddf8: 0a 95        	add	a0, a0, sp
   1ddfa: 03 04 05 00  	lb	s0, 0(a0)
   1ddfe: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1de00: 26 75        	ld	a0, 104(sp)
   1de02: 89 65        	lui	a1, 2
   1de04: 9b 85 05 57  	addiw	a1, a1, 1392
   1de08: 8a 95        	add	a1, a1, sp
   1de0a: 23 90 a5 00  	sh	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1de0e: 33 86 9b 00  	add	a2, s7, s1
   1de12: b3 86 99 40  	sub	a3, s3, s1
;             return readFn(self.context, buffer);
   1de16: 88 0d        	addi	a0, sp, 720
   1de18: 89 65        	lui	a1, 2
   1de1a: 9b 85 05 2d  	addiw	a1, a1, 720
   1de1e: 8a 95        	add	a1, a1, sp
   1de20: 97 40 00 00  	auipc	ra, 4
   1de24: e7 80 80 89  	jalr	-1896(ra)
   1de28: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1de2c: e3 00 05 60  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;                 index += amt;
   1de30: 26 95        	add	a0, a0, s1
   1de32: 63 74 95 00  	bgeu	a0, s1, 0x1de3a <.LBB47_196+0x9c0>
   1de36: 6f 20 b0 0a  	j	0x206e0 <.LBB47_196+0x3266>
   1de3a: aa 84        	mv	s1, a0
;             while (index < len) {
   1de3c: e3 69 35 fd  	bltu	a0, s3, 0x1de0e <.LBB47_196+0x994>
;             return bytes;
   1de40: 09 65        	lui	a0, 2
   1de42: 1b 05 05 57  	addiw	a0, a0, 1392
   1de46: 0a 95        	add	a0, a0, sp
   1de48: 83 54 05 00  	lhu	s1, 0(a0)
;     if (endian == native_endian) {
   1de4c: 13 75 14 00  	andi	a0, s0, 1
   1de50: 19 e5        	bnez	a0, 0x1de5e <.LBB47_196+0x9e4>
   1de52: 13 d5 84 00  	srli	a0, s1, 8
   1de56: 93 95 84 00  	slli	a1, s1, 8
   1de5a: b3 e4 a5 00  	or	s1, a1, a0
;             if (version < 2 or version > 5) return badDwarf();
   1de5e: 1b 85 a4 ff  	addiw	a0, s1, -6
   1de62: 42 15        	slli	a0, a0, 48
   1de64: 41 91        	srli	a0, a0, 48
   1de66: c1 65        	lui	a1, 16
   1de68: ed 35        	addiw	a1, a1, -5
   1de6a: 63 e4 a5 00  	bltu	a1, a0, 0x1de72 <.LBB47_196+0x9f8>
   1de6e: 6f 20 70 47  	j	0x20ae4 <.LBB47_196+0x366a>
;             if (version >= 5) {
   1de72: 13 95 04 03  	slli	a0, s1, 48
   1de76: 41 91        	srli	a0, a0, 48
   1de78: 95 45        	li	a1, 5
   1de7a: 26 e1        	sd	s1, 128(sp)
   1de7c: 63 6e b5 10  	bltu	a0, a1, 0x1df98 <.LBB47_196+0xb1e>
;             var bytes: [num_bytes]u8 = undefined;
   1de80: 13 05 a0 0a  	li	a0, 170
   1de84: 89 65        	lui	a1, 2
   1de86: 9b 85 05 57  	addiw	a1, a1, 1392
   1de8a: 8a 95        	add	a1, a1, sp
   1de8c: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1de90: 88 0d        	addi	a0, sp, 720
   1de92: 89 65        	lui	a1, 2
   1de94: 9b 85 05 2d  	addiw	a1, a1, 720
   1de98: 8a 95        	add	a1, a1, sp
   1de9a: 09 66        	lui	a2, 2
   1de9c: 1b 06 06 57  	addiw	a2, a2, 1392
   1dea0: 0a 96        	add	a2, a2, sp
   1dea2: 85 46        	li	a3, 1
   1dea4: 97 40 00 00  	auipc	ra, 4
   1dea8: e7 80 40 81  	jalr	-2028(ra)
   1deac: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1deb0: e3 0e 05 56  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;             return bytes;
   1deb4: 09 65        	lui	a0, 2
   1deb6: 1b 05 05 57  	addiw	a0, a0, 1392
   1deba: 0a 95        	add	a0, a0, sp
   1debc: 03 45 05 00  	lbu	a0, 0(a0)
;                 if (unit_type != UT.compile) return badDwarf();
   1dec0: 85 45        	li	a1, 1
   1dec2: 63 04 b5 00  	beq	a0, a1, 0x1deca <.LBB47_196+0xa50>
   1dec6: 6f 20 f0 41  	j	0x20ae4 <.LBB47_196+0x366a>
;             var result: [1]u8 = undefined;
   1deca: 13 05 a0 0a  	li	a0, 170
   1dece: 89 65        	lui	a1, 2
   1ded0: 9b 85 05 57  	addiw	a1, a1, 1392
   1ded4: 8a 95        	add	a1, a1, sp
   1ded6: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1deda: 88 0d        	addi	a0, sp, 720
   1dedc: 89 65        	lui	a1, 2
   1dede: 9b 85 05 2d  	addiw	a1, a1, 720
   1dee2: 8a 95        	add	a1, a1, sp
   1dee4: 09 66        	lui	a2, 2
   1dee6: 1b 06 06 57  	addiw	a2, a2, 1392
   1deea: 0a 96        	add	a2, a2, sp
   1deec: 85 46        	li	a3, 1
   1deee: 97 30 00 00  	auipc	ra, 3
   1def2: e7 80 a0 7c  	jalr	1994(ra)
   1def6: 03 35 01 2d  	ld	a0, 720(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1defa: e3 03 05 54  	beqz	a0, 0x1ec40 <.LBB47_196+0x17c6>
;             return result[0];
   1defe: 09 65        	lui	a0, 2
   1df00: 1b 05 05 57  	addiw	a0, a0, 1392
   1df04: 0a 95        	add	a0, a0, sp
   1df06: 03 49 05 00  	lbu	s2, 0(a0)
   1df0a: 05 65        	lui	a0, 1
   1df0c: 1b 05 85 3d  	addiw	a0, a0, 984
   1df10: 0a 95        	add	a0, a0, sp
   1df12: 83 09 05 00  	lb	s3, 0(a0)
   1df16: 01 44        	li	s0, 0
;                 debug_abbrev_offset = if (is_64)
   1df18: 7d 55        	li	a0, -1
   1df1a: e3 02 aa 3a  	beq	s4, a0, 0x1eabe <.LBB47_196+0x1644>
;             var bytes: [num_bytes]u8 = undefined;
   1df1e: 2a 65        	ld	a0, 136(sp)
   1df20: 89 65        	lui	a1, 2
   1df22: 9b 85 05 57  	addiw	a1, a1, 1392
   1df26: 8a 95        	add	a1, a1, sp
   1df28: 88 c1        	sw	a0, 0(a1)
   1df2a: 13 0a e0 02  	li	s4, 46
;                 const amt = try self.read(buffer[index..]);
   1df2e: 33 86 8b 00  	add	a2, s7, s0
   1df32: b3 86 8a 40  	sub	a3, s5, s0
;             return readFn(self.context, buffer);
   1df36: 88 0d        	addi	a0, sp, 720
   1df38: 89 65        	lui	a1, 2
   1df3a: 9b 85 05 2d  	addiw	a1, a1, 720
   1df3e: 8a 95        	add	a1, a1, sp
   1df40: 97 30 00 00  	auipc	ra, 3
   1df44: e7 80 80 77  	jalr	1912(ra)
   1df48: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1df4c: e3 00 05 4e  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;                 index += amt;
   1df50: 22 95        	add	a0, a0, s0
   1df52: 63 74 85 00  	bgeu	a0, s0, 0x1df5a <.LBB47_196+0xae0>
   1df56: 6f 20 a0 78  	j	0x206e0 <.LBB47_196+0x3266>
   1df5a: 2a 84        	mv	s0, a0
;             while (index < len) {
   1df5c: e3 69 55 fd  	bltu	a0, s5, 0x1df2e <.LBB47_196+0xab4>
;             return bytes;
   1df60: 09 65        	lui	a0, 2
   1df62: 1b 05 05 57  	addiw	a0, a0, 1392
   1df66: 0a 95        	add	a0, a0, sp
   1df68: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1df6c: 93 f5 19 00  	andi	a1, s3, 1
   1df70: 85 e1        	bnez	a1, 0x1df90 <.LBB47_196+0xb16>
   1df72: 93 55 85 00  	srli	a1, a0, 8
   1df76: 46 76        	ld	a2, 112(sp)
   1df78: f1 8d        	and	a1, a1, a2
   1df7a: 13 56 85 01  	srli	a2, a0, 24
   1df7e: d1 8d        	or	a1, a1, a2
   1df80: 13 16 85 00  	slli	a2, a0, 8
   1df84: b7 06 ff 00  	lui	a3, 4080
   1df88: 75 8e        	and	a2, a2, a3
   1df8a: 62 05        	slli	a0, a0, 24
   1df8c: 51 8d        	or	a0, a0, a2
   1df8e: 4d 8d        	or	a0, a0, a1
;                     try in.readInt(u32, di.endian);
   1df90: 02 15        	slli	a0, a0, 32
   1df92: 93 54 05 02  	srli	s1, a0, 32
   1df96: 8d aa        	j	0x1e108 <.LBB47_196+0xc8e>
   1df98: 05 65        	lui	a0, 1
   1df9a: 1b 05 85 3d  	addiw	a0, a0, 984
   1df9e: 0a 95        	add	a0, a0, sp
   1dfa0: 03 09 05 00  	lb	s2, 0(a0)
   1dfa4: 01 44        	li	s0, 0
;                 debug_abbrev_offset = if (is_64)
   1dfa6: 7d 55        	li	a0, -1
   1dfa8: 63 0f aa 06  	beq	s4, a0, 0x1e026 <.LBB47_196+0xbac>
;             var bytes: [num_bytes]u8 = undefined;
   1dfac: 2a 65        	ld	a0, 136(sp)
   1dfae: 89 65        	lui	a1, 2
   1dfb0: 9b 85 05 57  	addiw	a1, a1, 1392
   1dfb4: 8a 95        	add	a1, a1, sp
   1dfb6: 88 c1        	sw	a0, 0(a1)
   1dfb8: 13 0a e0 02  	li	s4, 46
;                 const amt = try self.read(buffer[index..]);
   1dfbc: 33 86 8b 00  	add	a2, s7, s0
   1dfc0: b3 86 8a 40  	sub	a3, s5, s0
;             return readFn(self.context, buffer);
   1dfc4: 88 0d        	addi	a0, sp, 720
   1dfc6: 89 65        	lui	a1, 2
   1dfc8: 9b 85 05 2d  	addiw	a1, a1, 720
   1dfcc: 8a 95        	add	a1, a1, sp
   1dfce: 97 30 00 00  	auipc	ra, 3
   1dfd2: e7 80 a0 6e  	jalr	1770(ra)
   1dfd6: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1dfda: e3 09 05 44  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;                 index += amt;
   1dfde: 22 95        	add	a0, a0, s0
   1dfe0: 63 74 85 00  	bgeu	a0, s0, 0x1dfe8 <.LBB47_196+0xb6e>
   1dfe4: 6f 20 c0 6f  	j	0x206e0 <.LBB47_196+0x3266>
   1dfe8: 2a 84        	mv	s0, a0
;             while (index < len) {
   1dfea: e3 69 55 fd  	bltu	a0, s5, 0x1dfbc <.LBB47_196+0xb42>
;             return bytes;
   1dfee: 09 65        	lui	a0, 2
   1dff0: 1b 05 05 57  	addiw	a0, a0, 1392
   1dff4: 0a 95        	add	a0, a0, sp
   1dff6: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1dffa: 93 75 19 00  	andi	a1, s2, 1
   1dffe: 85 e1        	bnez	a1, 0x1e01e <.LBB47_196+0xba4>
   1e000: 93 55 85 00  	srli	a1, a0, 8
   1e004: 46 76        	ld	a2, 112(sp)
   1e006: f1 8d        	and	a1, a1, a2
   1e008: 13 56 85 01  	srli	a2, a0, 24
   1e00c: d1 8d        	or	a1, a1, a2
   1e00e: 13 16 85 00  	slli	a2, a0, 8
   1e012: b7 06 ff 00  	lui	a3, 4080
   1e016: 75 8e        	and	a2, a2, a3
   1e018: 62 05        	slli	a0, a0, 24
   1e01a: 51 8d        	or	a0, a0, a2
   1e01c: 4d 8d        	or	a0, a0, a1
;                     try in.readInt(u32, di.endian);
   1e01e: 02 15        	slli	a0, a0, 32
   1e020: 93 54 05 02  	srli	s1, a0, 32
   1e024: 55 a0        	j	0x1e0c8 <.LBB47_196+0xc4e>
;             var bytes: [num_bytes]u8 = undefined;
   1e026: 66 75        	ld	a0, 120(sp)
   1e028: 89 65        	lui	a1, 2
   1e02a: 9b 85 05 57  	addiw	a1, a1, 1392
   1e02e: 8a 95        	add	a1, a1, sp
   1e030: 88 e1        	sd	a0, 0(a1)
   1e032: 13 0a e0 02  	li	s4, 46
;                 const amt = try self.read(buffer[index..]);
   1e036: 33 86 8b 00  	add	a2, s7, s0
   1e03a: b3 06 8b 40  	sub	a3, s6, s0
;             return readFn(self.context, buffer);
   1e03e: 88 0d        	addi	a0, sp, 720
   1e040: 89 65        	lui	a1, 2
   1e042: 9b 85 05 2d  	addiw	a1, a1, 720
   1e046: 8a 95        	add	a1, a1, sp
   1e048: 97 30 00 00  	auipc	ra, 3
   1e04c: e7 80 00 67  	jalr	1648(ra)
   1e050: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1e054: e3 0c 05 3c  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;                 index += amt;
   1e058: 22 95        	add	a0, a0, s0
   1e05a: 63 74 85 00  	bgeu	a0, s0, 0x1e062 <.LBB47_196+0xbe8>
   1e05e: 6f 20 20 68  	j	0x206e0 <.LBB47_196+0x3266>
   1e062: 2a 84        	mv	s0, a0
;             while (index < len) {
   1e064: e3 69 65 fd  	bltu	a0, s6, 0x1e036 <.LBB47_196+0xbbc>
;             return bytes;
   1e068: 09 65        	lui	a0, 2
   1e06a: 1b 05 05 57  	addiw	a0, a0, 1392
   1e06e: 0a 95        	add	a0, a0, sp
   1e070: 04 61        	ld	s1, 0(a0)
;     if (endian == native_endian) {
   1e072: 13 75 19 00  	andi	a0, s2, 1
   1e076: 29 e9        	bnez	a0, 0x1e0c8 <.LBB47_196+0xc4e>
   1e078: 13 d5 84 01  	srli	a0, s1, 24
   1e07c: b7 05 ff 00  	lui	a1, 4080
   1e080: 6d 8d        	and	a0, a0, a1
   1e082: 93 d5 84 00  	srli	a1, s1, 8
   1e086: 93 06 f0 0f  	li	a3, 255
   1e08a: 13 96 86 01  	slli	a2, a3, 24
   1e08e: f1 8d        	and	a1, a1, a2
   1e090: 4d 8d        	or	a0, a0, a1
   1e092: 93 d5 84 02  	srli	a1, s1, 40
   1e096: 46 76        	ld	a2, 112(sp)
   1e098: f1 8d        	and	a1, a1, a2
   1e09a: 13 d6 84 03  	srli	a2, s1, 56
   1e09e: d1 8d        	or	a1, a1, a2
   1e0a0: 4d 8d        	or	a0, a0, a1
   1e0a2: 93 95 84 01  	slli	a1, s1, 24
   1e0a6: 13 96 86 02  	slli	a2, a3, 40
   1e0aa: f1 8d        	and	a1, a1, a2
   1e0ac: 1b d6 84 01  	srliw	a2, s1, 24
   1e0b0: 02 16        	slli	a2, a2, 32
   1e0b2: d1 8d        	or	a1, a1, a2
   1e0b4: 13 96 84 02  	slli	a2, s1, 40
   1e0b8: c2 16        	slli	a3, a3, 48
   1e0ba: 75 8e        	and	a2, a2, a3
   1e0bc: 93 96 84 03  	slli	a3, s1, 56
   1e0c0: 55 8e        	or	a2, a2, a3
   1e0c2: d1 8d        	or	a1, a1, a2
   1e0c4: b3 e4 a5 00  	or	s1, a1, a0
;             var result: [1]u8 = undefined;
   1e0c8: 13 05 a0 0a  	li	a0, 170
   1e0cc: 89 65        	lui	a1, 2
   1e0ce: 9b 85 05 57  	addiw	a1, a1, 1392
   1e0d2: 8a 95        	add	a1, a1, sp
   1e0d4: 23 80 a5 00  	sb	a0, 0(a1)
;             return readFn(self.context, buffer);
   1e0d8: 88 0d        	addi	a0, sp, 720
   1e0da: 89 65        	lui	a1, 2
   1e0dc: 9b 85 05 2d  	addiw	a1, a1, 720
   1e0e0: 8a 95        	add	a1, a1, sp
   1e0e2: 09 66        	lui	a2, 2
   1e0e4: 1b 06 06 57  	addiw	a2, a2, 1392
   1e0e8: 0a 96        	add	a2, a2, sp
   1e0ea: 85 46        	li	a3, 1
   1e0ec: 97 30 00 00  	auipc	ra, 3
   1e0f0: e7 80 c0 5c  	jalr	1484(ra)
   1e0f4: 03 35 01 2d  	ld	a0, 720(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1e0f8: e3 04 05 34  	beqz	a0, 0x1ec40 <.LBB47_196+0x17c6>
;             return result[0];
   1e0fc: 09 65        	lui	a0, 2
   1e0fe: 1b 05 05 57  	addiw	a0, a0, 1392
   1e102: 0a 95        	add	a0, a0, sp
   1e104: 03 49 05 00  	lbu	s2, 0(a0)
;             if (address_size != @sizeOf(usize)) return badDwarf();
   1e108: 63 04 69 01  	beq	s2, s6, 0x1e110 <.LBB47_196+0xc96>
   1e10c: 6f 20 90 1d  	j	0x20ae4 <.LBB47_196+0x366a>
;             const compile_unit_pos = try seekable.getPos();
   1e110: 09 65        	lui	a0, 2
   1e112: 1b 05 05 2e  	addiw	a0, a0, 736
   1e116: 0a 95        	add	a0, a0, sp
   1e118: 00 61        	ld	s0, 0(a0)
;             const abbrev_table = try di.getAbbrevTable(allocator, debug_abbrev_offset);
   1e11a: 09 65        	lui	a0, 2
   1e11c: 1b 05 85 32  	addiw	a0, a0, 808
   1e120: 0a 95        	add	a0, a0, sp
   1e122: 85 65        	lui	a1, 1
   1e124: 9b 85 05 2d  	addiw	a1, a1, 720
   1e128: 33 06 b1 00  	add	a2, sp, a1
   1e12c: e2 85        	mv	a1, s8
   1e12e: b2 66        	ld	a3, 264(sp)
   1e130: 26 87        	mv	a4, s1
   1e132: 97 60 ff ff  	auipc	ra, 1048566
   1e136: e7 80 80 75  	jalr	1880(ra)
   1e13a: 09 65        	lui	a0, 2
   1e13c: 1b 05 05 33  	addiw	a0, a0, 816
   1e140: 0a 95        	add	a0, a0, sp
   1e142: 83 5c 05 00  	lhu	s9, 0(a0)
   1e146: 93 04 10 03  	li	s1, 49
   1e14a: e3 9b 0c 34  	bnez	s9, 0x1eca0 <.LBB47_196+0x1826>
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1e14e: 09 65        	lui	a0, 2
   1e150: 1b 05 85 2d  	addiw	a0, a0, 728
   1e154: 0a 95        	add	a0, a0, sp
   1e156: 03 3d 05 00  	ld	s10, 0(a0)
   1e15a: 6a 89        	mv	s2, s10
   1e15c: 63 63 8d 00  	bltu	s10, s0, 0x1e162 <.LBB47_196+0xce8>
   1e160: 22 89        	mv	s2, s0
   1e162: 09 65        	lui	a0, 2
   1e164: 1b 05 85 32  	addiw	a0, a0, 808
   1e168: 0a 95        	add	a0, a0, sp
   1e16a: 08 61        	ld	a0, 0(a0)
   1e16c: 2a ea        	sd	a0, 272(sp)
   1e16e: 4e 65        	ld	a0, 208(sp)
;             const next_unit_pos = this_unit_offset + next_offset;
   1e170: ea 75        	ld	a1, 184(sp)
   1e172: 33 04 b5 00  	add	s0, a0, a1
   1e176: 89 65        	lui	a1, 2
   1e178: 9b 85 05 2e  	addiw	a1, a1, 736
   1e17c: 8a 95        	add	a1, a1, sp
   1e17e: 23 b0 25 01  	sd	s2, 0(a1)
   1e182: 89 49        	li	s3, 2
;             const next_unit_pos = this_unit_offset + next_offset;
   1e184: 63 74 a4 00  	bgeu	s0, a0, 0x1e18c <.LBB47_196+0xd12>
   1e188: 6f 20 80 55  	j	0x206e0 <.LBB47_196+0x3266>
;             var compile_unit: CompileUnit = undefined;
   1e18c: 09 65        	lui	a0, 2
   1e18e: 1b 05 85 33  	addiw	a0, a0, 824
   1e192: 0a 95        	add	a0, a0, sp
   1e194: 93 05 a0 0a  	li	a1, 170
   1e198: 13 06 80 04  	li	a2, 72
   1e19c: 97 60 00 00  	auipc	ra, 6
   1e1a0: e7 80 e0 0f  	jalr	254(ra)
;             while ((try seekable.getPos()) < next_unit_pos) {
   1e1a4: e3 75 89 ac  	bgeu	s2, s0, 0x1dc6e <.LBB47_196+0x7f4>
   1e1a8: 72 6c        	ld	s8, 280(sp)
   1e1aa: 4e 7d        	ld	s10, 240(sp)
   1e1ac: 22 89        	mv	s2, s0
   1e1ae: a2 e5        	sd	s0, 200(sp)
   1e1b0: 01 a8        	j	0x1e1c0 <.LBB47_196+0xd46>
   1e1b2: 89 65        	lui	a1, 2
   1e1b4: 9b 85 05 2e  	addiw	a1, a1, 736
   1e1b8: 8a 95        	add	a1, a1, sp
   1e1ba: 88 e1        	sd	a0, 0(a1)
;             while ((try seekable.getPos()) < next_unit_pos) {
   1e1bc: e3 71 25 ab  	bgeu	a0, s2, 0x1dc5e <.LBB47_196+0x7e4>
;                 var die_obj = (try di.parseDie(arena, in, abbrev_table, is_64)) orelse continue;
   1e1c0: 09 65        	lui	a0, 2
   1e1c2: 1b 05 75 32  	addiw	a0, a0, 807
   1e1c6: 0a 95        	add	a0, a0, sp
   1e1c8: 03 04 05 00  	lb	s0, 0(a0)
   1e1cc: 09 65        	lui	a0, 2
   1e1ce: 1b 05 85 3c  	addiw	a0, a0, 968
   1e1d2: 0a 95        	add	a0, a0, sp
   1e1d4: 85 65        	lui	a1, 1
   1e1d6: 9b 85 05 2d  	addiw	a1, a1, 720
   1e1da: 33 06 b1 00  	add	a2, sp, a1
   1e1de: 89 65        	lui	a1, 2
   1e1e0: 9b 85 05 31  	addiw	a1, a1, 784
   1e1e4: b3 06 b1 00  	add	a3, sp, a1
   1e1e8: 89 65        	lui	a1, 2
   1e1ea: 9b 85 85 2e  	addiw	a1, a1, 744
   1e1ee: 33 07 b1 00  	add	a4, sp, a1
   1e1f2: e2 85        	mv	a1, s8
   1e1f4: d2 67        	ld	a5, 272(sp)
   1e1f6: 22 88        	mv	a6, s0
   1e1f8: 97 80 ff ff  	auipc	ra, 1048568
   1e1fc: e7 80 e0 b9  	jalr	-1122(ra)
   1e200: 09 65        	lui	a0, 2
   1e202: 1b 05 85 41  	addiw	a0, a0, 1048
   1e206: 0a 95        	add	a0, a0, sp
   1e208: 83 5c 05 00  	lhu	s9, 0(a0)
   1e20c: e3 90 0c 5e  	bnez	s9, 0x1efec <.LBB47_196+0x1b72>
   1e210: 09 65        	lui	a0, 2
   1e212: 1b 05 05 41  	addiw	a0, a0, 1040
   1e216: 0a 95        	add	a0, a0, sp
   1e218: 03 45 05 00  	lbu	a0, 0(a0)
   1e21c: 63 00 05 24  	beqz	a0, 0x1e45c <.LBB47_196+0xfe2>
   1e220: 09 65        	lui	a0, 2
   1e222: 1b 05 05 38  	addiw	a0, a0, 896
   1e226: 0a 95        	add	a0, a0, sp
   1e228: 89 65        	lui	a1, 2
   1e22a: 9b 85 85 3c  	addiw	a1, a1, 968
   1e22e: 8a 95        	add	a1, a1, sp
   1e230: 13 06 80 04  	li	a2, 72
   1e234: 97 60 00 00  	auipc	ra, 6
   1e238: e7 80 00 04  	jalr	64(ra)
;                 switch (die_obj.tag_id) {
   1e23c: 09 65        	lui	a0, 2
   1e23e: 1b 05 05 3a  	addiw	a0, a0, 928
   1e242: 0a 95        	add	a0, a0, sp
   1e244: 08 61        	ld	a0, 0(a0)
;                 const after_die_offset = try seekable.getPos();
   1e246: 89 65        	lui	a1, 2
   1e248: 9b 85 05 2e  	addiw	a1, a1, 736
   1e24c: 8a 95        	add	a1, a1, sp
   1e24e: 83 b8 05 00  	ld	a7, 0(a1)
;                 switch (die_obj.tag_id) {
   1e252: e3 6c aa 04  	bltu	s4, a0, 0x1eaaa <.LBB47_196+0x1630>
   1e256: ee 65        	ld	a1, 216(sp)
   1e258: b3 d5 a5 00  	srl	a1, a1, a0
   1e25c: 85 89        	andi	a1, a1, 1
   1e25e: 63 84 05 2c  	beqz	a1, 0x1e526 <.LBB47_196+0x10ac>
   1e262: 46 e2        	sd	a7, 256(sp)
;                             var this_die_obj = die_obj;
   1e264: 09 65        	lui	a0, 2
   1e266: 1b 05 05 42  	addiw	a0, a0, 1056
   1e26a: 0a 95        	add	a0, a0, sp
   1e26c: 89 65        	lui	a1, 2
   1e26e: 9b 85 85 3c  	addiw	a1, a1, 968
   1e272: 8a 95        	add	a1, a1, sp
   1e274: 13 06 80 04  	li	a2, 72
   1e278: 97 60 00 00  	auipc	ra, 6
   1e27c: e7 80 c0 ff  	jalr	-4(ra)
   1e280: 0d 49        	li	s2, 3
;         for (self.attrs.items) |*attr| {
   1e282: 09 65        	lui	a0, 2
   1e284: 1b 05 05 45  	addiw	a0, a0, 1104
   1e288: 0a 95        	add	a0, a0, sp
   1e28a: 0c 61        	ld	a1, 0(a0)
   1e28c: 63 84 05 1c  	beqz	a1, 0x1e454 <.LBB47_196+0xfda>
   1e290: 09 65        	lui	a0, 2
   1e292: 1b 05 85 44  	addiw	a0, a0, 1096
   1e296: 0a 95        	add	a0, a0, sp
   1e298: 08 61        	ld	a0, 0(a0)
   1e29a: 2a 86        	mv	a2, a0
   1e29c: ae 86        	mv	a3, a1
   1e29e: 93 07 70 04  	li	a5, 71
;             if (attr.id == id) return &attr.value;
   1e2a2: 18 62        	ld	a4, 0(a2)
   1e2a4: 63 05 b7 1d  	beq	a4, s11, 0x1e46e <.LBB47_196+0xff4>
;         for (self.attrs.items) |*attr| {
   1e2a8: fd 16        	addi	a3, a3, -1
   1e2aa: 13 06 06 02  	addi	a2, a2, 32
   1e2ae: f5 fa        	bnez	a3, 0x1e2a2 <.LBB47_196+0xe28>
   1e2b0: 2a 86        	mv	a2, a0
   1e2b2: ae 86        	mv	a3, a1
;             if (attr.id == id) return &attr.value;
   1e2b4: 18 62        	ld	a4, 0(a2)
   1e2b6: 63 05 97 02  	beq	a4, s1, 0x1e2e0 <.LBB47_196+0xe66>
;         for (self.attrs.items) |*attr| {
   1e2ba: fd 16        	addi	a3, a3, -1
   1e2bc: 13 06 06 02  	addi	a2, a2, 32
   1e2c0: f5 fa        	bnez	a3, 0x1e2b4 <.LBB47_196+0xe3a>
   1e2c2: 2a 86        	mv	a2, a0
   1e2c4: ae 86        	mv	a3, a1
;             if (attr.id == id) return &attr.value;
   1e2c6: 18 62        	ld	a4, 0(a2)
   1e2c8: 63 05 f7 0c  	beq	a4, a5, 0x1e392 <.LBB47_196+0xf18>
;         for (self.attrs.items) |*attr| {
   1e2cc: fd 16        	addi	a3, a3, -1
   1e2ce: 13 06 06 02  	addi	a2, a2, 32
   1e2d2: f5 fa        	bnez	a3, 0x1e2c6 <.LBB47_196+0xe4c>
   1e2d4: 41 a2        	j	0x1e454 <.LBB47_196+0xfda>
   1e2d6: fd 15        	addi	a1, a1, -1
   1e2d8: 13 05 05 02  	addi	a0, a0, 32
   1e2dc: e3 8c 05 26  	beqz	a1, 0x1ed54 <.LBB47_196+0x18da>
;             if (attr.id == id) return &attr.value;
   1e2e0: 10 61        	ld	a2, 0(a0)
   1e2e2: e3 1a 96 fe  	bne	a2, s1, 0x1e2d6 <.LBB47_196+0xe5c>
;         return switch (form_value.*) {
   1e2e6: 83 45 85 01  	lbu	a1, 24(a0)
   1e2ea: 1d 46        	li	a2, 7
   1e2ec: 63 84 c5 00  	beq	a1, a2, 0x1e2f4 <.LBB47_196+0xe7a>
   1e2f0: 6f 20 80 41  	j	0x20708 <.LBB47_196+0x328e>
   1e2f4: 08 65        	ld	a0, 8(a0)
;                                     if (ref_offset > next_offset) return badDwarf();
   1e2f6: ea 75        	ld	a1, 184(sp)
   1e2f8: 63 f4 a5 00  	bgeu	a1, a0, 0x1e300 <.LBB47_196+0xe86>
   1e2fc: 6f 20 40 41  	j	0x20710 <.LBB47_196+0x3296>
   1e300: ce 65        	ld	a1, 208(sp)
;                                     try seekable.seekTo(this_unit_offset + ref_offset);
   1e302: 2e 95        	add	a0, a0, a1
   1e304: 63 74 b5 00  	bgeu	a0, a1, 0x1e30c <.LBB47_196+0xe92>
   1e308: 6f 20 80 3d  	j	0x206e0 <.LBB47_196+0x3266>
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1e30c: 89 65        	lui	a1, 2
   1e30e: 9b 85 85 2d  	addiw	a1, a1, 728
   1e312: 8a 95        	add	a1, a1, sp
   1e314: 8c 61        	ld	a1, 0(a1)
   1e316: 63 e3 a5 00  	bltu	a1, a0, 0x1e31c <.LBB47_196+0xea2>
   1e31a: aa 85        	mv	a1, a0
   1e31c: 09 65        	lui	a0, 2
   1e31e: 1b 05 05 2e  	addiw	a0, a0, 736
   1e322: 0a 95        	add	a0, a0, sp
   1e324: 0c e1        	sd	a1, 0(a0)
;                                     this_die_obj = (try di.parseDie(
   1e326: 09 65        	lui	a0, 2
   1e328: 1b 05 05 48  	addiw	a0, a0, 1152
   1e32c: 0a 95        	add	a0, a0, sp
   1e32e: 85 65        	lui	a1, 1
   1e330: 9b 85 05 2d  	addiw	a1, a1, 720
   1e334: 33 06 b1 00  	add	a2, sp, a1
   1e338: 89 65        	lui	a1, 2
   1e33a: 9b 85 05 31  	addiw	a1, a1, 784
   1e33e: b3 06 b1 00  	add	a3, sp, a1
   1e342: 89 65        	lui	a1, 2
   1e344: 9b 85 85 2e  	addiw	a1, a1, 744
   1e348: 33 07 b1 00  	add	a4, sp, a1
   1e34c: e2 85        	mv	a1, s8
   1e34e: d2 67        	ld	a5, 272(sp)
   1e350: 22 88        	mv	a6, s0
   1e352: 97 80 ff ff  	auipc	ra, 1048568
   1e356: e7 80 40 a4  	jalr	-1468(ra)
   1e35a: 09 65        	lui	a0, 2
   1e35c: 1b 05 05 4d  	addiw	a0, a0, 1232
   1e360: 0a 95        	add	a0, a0, sp
   1e362: 83 5c 05 00  	lhu	s9, 0(a0)
   1e366: 63 84 0c 00  	beqz	s9, 0x1e36e <.LBB47_196+0xef4>
   1e36a: 6f 20 20 43  	j	0x2079c <.LBB47_196+0x3322>
   1e36e: 09 65        	lui	a0, 2
   1e370: 1b 05 85 4c  	addiw	a0, a0, 1224
   1e374: 0a 95        	add	a0, a0, sp
   1e376: 03 45 05 00  	lbu	a0, 0(a0)
   1e37a: 89 65        	lui	a1, 2
   1e37c: 9b 85 05 48  	addiw	a1, a1, 1152
   1e380: 8a 95        	add	a1, a1, sp
   1e382: 45 ed        	bnez	a0, 0x1e43a <.LBB47_196+0xfc0>
   1e384: 6f 20 e0 48  	j	0x20812 <.LBB47_196+0x3398>
;         for (self.attrs.items) |*attr| {
   1e388: fd 15        	addi	a1, a1, -1
   1e38a: 13 05 05 02  	addi	a0, a0, 32
   1e38e: e3 8f 05 2e  	beqz	a1, 0x1ee8c <.LBB47_196+0x1a12>
;             if (attr.id == id) return &attr.value;
   1e392: 10 61        	ld	a2, 0(a0)
   1e394: e3 1a f6 fe  	bne	a2, a5, 0x1e388 <.LBB47_196+0xf0e>
;         return switch (form_value.*) {
   1e398: 83 45 85 01  	lbu	a1, 24(a0)
   1e39c: 1d 46        	li	a2, 7
   1e39e: 63 84 c5 00  	beq	a1, a2, 0x1e3a6 <.LBB47_196+0xf2c>
   1e3a2: 6f 20 c0 59  	j	0x2093e <.LBB47_196+0x34c4>
   1e3a6: 08 65        	ld	a0, 8(a0)
;                                     if (ref_offset > next_offset) return badDwarf();
   1e3a8: ea 75        	ld	a1, 184(sp)
   1e3aa: 63 f4 a5 00  	bgeu	a1, a0, 0x1e3b2 <.LBB47_196+0xf38>
   1e3ae: 6f 20 80 59  	j	0x20946 <.LBB47_196+0x34cc>
   1e3b2: ce 65        	ld	a1, 208(sp)
;                                     try seekable.seekTo(this_unit_offset + ref_offset);
   1e3b4: 2e 95        	add	a0, a0, a1
   1e3b6: 63 74 b5 00  	bgeu	a0, a1, 0x1e3be <.LBB47_196+0xf44>
   1e3ba: 6f 20 60 32  	j	0x206e0 <.LBB47_196+0x3266>
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1e3be: 89 65        	lui	a1, 2
   1e3c0: 9b 85 85 2d  	addiw	a1, a1, 728
   1e3c4: 8a 95        	add	a1, a1, sp
   1e3c6: 8c 61        	ld	a1, 0(a1)
   1e3c8: 63 e3 a5 00  	bltu	a1, a0, 0x1e3ce <.LBB47_196+0xf54>
   1e3cc: aa 85        	mv	a1, a0
   1e3ce: 09 65        	lui	a0, 2
   1e3d0: 1b 05 05 2e  	addiw	a0, a0, 736
   1e3d4: 0a 95        	add	a0, a0, sp
   1e3d6: 0c e1        	sd	a1, 0(a0)
;                                     this_die_obj = (try di.parseDie(
   1e3d8: 09 65        	lui	a0, 2
   1e3da: 1b 05 85 4d  	addiw	a0, a0, 1240
   1e3de: 0a 95        	add	a0, a0, sp
   1e3e0: 85 65        	lui	a1, 1
   1e3e2: 9b 85 05 2d  	addiw	a1, a1, 720
   1e3e6: 33 06 b1 00  	add	a2, sp, a1
   1e3ea: 89 65        	lui	a1, 2
   1e3ec: 9b 85 05 31  	addiw	a1, a1, 784
   1e3f0: b3 06 b1 00  	add	a3, sp, a1
   1e3f4: 89 65        	lui	a1, 2
   1e3f6: 9b 85 85 2e  	addiw	a1, a1, 744
   1e3fa: 33 07 b1 00  	add	a4, sp, a1
   1e3fe: e2 85        	mv	a1, s8
   1e400: d2 67        	ld	a5, 272(sp)
   1e402: 22 88        	mv	a6, s0
   1e404: 97 80 ff ff  	auipc	ra, 1048568
   1e408: e7 80 20 99  	jalr	-1646(ra)
   1e40c: 09 65        	lui	a0, 2
   1e40e: 1b 05 85 52  	addiw	a0, a0, 1320
   1e412: 0a 95        	add	a0, a0, sp
   1e414: 83 5c 05 00  	lhu	s9, 0(a0)
   1e418: 63 84 0c 00  	beqz	s9, 0x1e420 <.LBB47_196+0xfa6>
   1e41c: 6f 20 20 5b  	j	0x209ce <.LBB47_196+0x3554>
   1e420: 09 65        	lui	a0, 2
   1e422: 1b 05 05 52  	addiw	a0, a0, 1312
   1e426: 0a 95        	add	a0, a0, sp
   1e428: 03 45 05 00  	lbu	a0, 0(a0)
   1e42c: 89 65        	lui	a1, 2
   1e42e: 9b 85 85 4d  	addiw	a1, a1, 1240
   1e432: 8a 95        	add	a1, a1, sp
   1e434: 19 e1        	bnez	a0, 0x1e43a <.LBB47_196+0xfc0>
   1e436: 6f 20 00 61  	j	0x20a46 <.LBB47_196+0x35cc>
   1e43a: 09 65        	lui	a0, 2
   1e43c: 1b 05 05 42  	addiw	a0, a0, 1056
   1e440: 0a 95        	add	a0, a0, sp
   1e442: 13 06 80 04  	li	a2, 72
   1e446: 97 60 00 00  	auipc	ra, 6
   1e44a: e7 80 e0 e2  	jalr	-466(ra)
   1e44e: 7d 39        	addiw	s2, s2, -1
;                             while (depth > 0) : (depth -= 1) {
   1e450: e3 19 09 e2  	bnez	s2, 0x1e282 <.LBB47_196+0xe08>
   1e454: 0d 49        	li	s2, 3
   1e456: 01 4c        	li	s8, 0
   1e458: 01 4d        	li	s10, 0
   1e45a: b1 aa        	j	0x1e5b6 <.LBB47_196+0x113c>
;             while ((try seekable.getPos()) < next_unit_pos) {
   1e45c: 09 65        	lui	a0, 2
   1e45e: 1b 05 05 2e  	addiw	a0, a0, 736
   1e462: 0a 95        	add	a0, a0, sp
   1e464: 08 61        	ld	a0, 0(a0)
   1e466: e3 6d 25 d5  	bltu	a0, s2, 0x1e1c0 <.LBB47_196+0xd46>
   1e46a: 6f f0 4f ff  	j	0x1dc5e <.LBB47_196+0x7e4>
;                                     const name = try this_die_obj.getAttrString(di, AT.name, di.debug_str, compile_unit);
   1e46e: 05 65        	lui	a0, 1
   1e470: 1b 05 05 2f  	addiw	a0, a0, 752
   1e474: 0a 95        	add	a0, a0, sp
   1e476: 1c 61        	ld	a5, 0(a0)
   1e478: 05 65        	lui	a0, 1
   1e47a: 1b 05 85 2f  	addiw	a0, a0, 760
   1e47e: 0a 95        	add	a0, a0, sp
   1e480: 03 38 05 00  	ld	a6, 0(a0)
   1e484: 09 65        	lui	a0, 2
   1e486: 1b 05 85 46  	addiw	a0, a0, 1128
   1e48a: 0a 95        	add	a0, a0, sp
   1e48c: 89 65        	lui	a1, 2
   1e48e: 9b 85 05 42  	addiw	a1, a1, 1056
   1e492: 33 06 b1 00  	add	a2, sp, a1
   1e496: 85 65        	lui	a1, 1
   1e498: 9b 85 05 2d  	addiw	a1, a1, 720
   1e49c: b3 06 b1 00  	add	a3, sp, a1
   1e4a0: 0d 47        	li	a4, 3
   1e4a2: 89 65        	lui	a1, 2
   1e4a4: 9b 85 85 33  	addiw	a1, a1, 824
   1e4a8: b3 08 b1 00  	add	a7, sp, a1
   1e4ac: e2 85        	mv	a1, s8
   1e4ae: 97 90 ff ff  	auipc	ra, 1048569
   1e4b2: e7 80 80 f6  	jalr	-152(ra)
   1e4b6: 09 65        	lui	a0, 2
   1e4b8: 1b 05 85 47  	addiw	a0, a0, 1144
   1e4bc: 0a 95        	add	a0, a0, sp
   1e4be: 83 5c 05 00  	lhu	s9, 0(a0)
   1e4c2: 63 9f 0c 7c  	bnez	s9, 0x1eca0 <.LBB47_196+0x1826>
   1e4c6: 09 65        	lui	a0, 2
   1e4c8: 1b 05 05 47  	addiw	a0, a0, 1136
   1e4cc: 0a 95        	add	a0, a0, sp
   1e4ce: 03 3d 05 00  	ld	s10, 0(a0)
   1e4d2: 63 00 0d 0e  	beqz	s10, 0x1e5b2 <.LBB47_196+0x1138>
   1e4d6: 32 65        	ld	a0, 264(sp)
;     const new_buf = try allocator.alloc(T, m.len);
   1e4d8: 0c 65        	ld	a1, 8(a0)
   1e4da: 09 66        	lui	a2, 2
   1e4dc: 1b 06 86 46  	addiw	a2, a2, 1128
   1e4e0: 0a 96        	add	a2, a2, sp
   1e4e2: 00 62        	ld	s0, 0(a2)
;     const new_buf = try allocator.alloc(T, m.len);
   1e4e4: 08 61        	ld	a0, 0(a0)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1e4e6: 98 61        	ld	a4, 0(a1)
   1e4e8: ea 85        	mv	a1, s10
   1e4ea: 01 46        	li	a2, 0
   1e4ec: ce 76        	ld	a3, 240(sp)
   1e4ee: 02 97        	jalr	a4
   1e4f0: 19 e1        	bnez	a0, 0x1e4f6 <.LBB47_196+0x107c>
   1e4f2: 6f 20 20 21  	j	0x20704 <.LBB47_196+0x328a>
   1e4f6: 2a 8c        	mv	s8, a0
   1e4f8: 0d 49        	li	s2, 3
;     @memset(byte_ptr, undefined, byte_count);
   1e4fa: 93 05 a0 0a  	li	a1, 170
   1e4fe: 6a 86        	mv	a2, s10
   1e500: 97 60 00 00  	auipc	ra, 6
   1e504: e7 80 a0 d9  	jalr	-614(ra)
   1e508: 01 45        	li	a0, 0
   1e50a: 93 09 80 02  	li	s3, 40
;     for (source) |s, i|
   1e50e: b3 05 a4 00  	add	a1, s0, a0
   1e512: 83 85 05 00  	lb	a1, 0(a1)
;         dest[i] = s;
   1e516: 33 06 ac 00  	add	a2, s8, a0
   1e51a: 05 05        	addi	a0, a0, 1
   1e51c: 23 00 b6 00  	sb	a1, 0(a2)
;     for (source) |s, i|
   1e520: e3 17 ad fe  	bne	s10, a0, 0x1e50e <.LBB47_196+0x1094>
   1e524: 59 a8        	j	0x1e5ba <.LBB47_196+0x1140>
   1e526: c5 45        	li	a1, 17
   1e528: 63 11 b5 58  	bne	a0, a1, 0x1eaaa <.LBB47_196+0x1630>
;                         compile_unit = .{
   1e52c: 0a 65        	ld	a0, 128(sp)
   1e52e: 89 65        	lui	a1, 2
   1e530: 9b 85 85 37  	addiw	a1, a1, 888
   1e534: 8a 95        	add	a1, a1, sp
   1e536: 23 90 a5 00  	sh	a0, 0(a1)
   1e53a: 13 75 14 00  	andi	a0, s0, 1
   1e53e: 89 65        	lui	a1, 2
   1e540: 9b 85 a5 37  	addiw	a1, a1, 890
   1e544: 8a 95        	add	a1, a1, sp
   1e546: 23 80 a5 00  	sb	a0, 0(a1)
;         for (self.attrs.items) |*attr| {
   1e54a: 09 65        	lui	a0, 2
   1e54c: 1b 05 05 3b  	addiw	a0, a0, 944
   1e550: 0a 95        	add	a0, a0, sp
   1e552: 0c 61        	ld	a1, 0(a0)
;                         compile_unit = .{
   1e554: 09 65        	lui	a0, 2
   1e556: 1b 05 05 38  	addiw	a0, a0, 896
   1e55a: 0a 95        	add	a0, a0, sp
   1e55c: 09 66        	lui	a2, 2
   1e55e: 1b 06 86 33  	addiw	a2, a2, 824
   1e562: 0a 96        	add	a2, a2, sp
   1e564: 08 e2        	sd	a0, 0(a2)
   1e566: 09 65        	lui	a0, 2
   1e568: 1b 05 05 34  	addiw	a0, a0, 832
   1e56c: 0a 95        	add	a0, a0, sp
   1e56e: 23 38 05 00  	sd	zero, 16(a0)
   1e572: 23 34 05 00  	sd	zero, 8(a0)
   1e576: 23 30 05 00  	sd	zero, 0(a0)
   1e57a: 09 65        	lui	a0, 2
;         for (self.attrs.items) |*attr| {
   1e57c: 63 80 05 24  	beqz	a1, 0x1e7bc <.LBB47_196+0x1342>
   1e580: 1b 05 85 3a  	addiw	a0, a0, 936
   1e584: 0a 95        	add	a0, a0, sp
   1e586: 08 61        	ld	a0, 0(a0)
;         for (self.attrs.items) |*attr| {
   1e588: 41 05        	addi	a0, a0, 16
   1e58a: ae 86        	mv	a3, a1
   1e58c: 2a 86        	mv	a2, a0
   1e58e: 93 07 20 07  	li	a5, 114
   1e592: 13 04 40 07  	li	s0, 116
   1e596: 13 08 c0 08  	li	a6, 140
;             if (attr.id == id) return &attr.value;
   1e59a: 03 37 06 ff  	ld	a4, -16(a2)
   1e59e: 63 0c f7 28  	beq	a4, a5, 0x1e836 <.LBB47_196+0x13bc>
;         for (self.attrs.items) |*attr| {
   1e5a2: fd 16        	addi	a3, a3, -1
   1e5a4: 13 06 06 02  	addi	a2, a2, 32
   1e5a8: ed fa        	bnez	a3, 0x1e59a <.LBB47_196+0x1120>
   1e5aa: 01 46        	li	a2, 0
   1e5ac: 93 07 30 07  	li	a5, 115
   1e5b0: 6d a4        	j	0x1e85a <.LBB47_196+0x13e0>
   1e5b2: 0d 49        	li	s2, 3
   1e5b4: 7d 5c        	li	s8, -1
   1e5b6: 93 09 80 02  	li	s3, 40
;                             if (die_obj.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| {
   1e5ba: 09 65        	lui	a0, 2
   1e5bc: 1b 05 85 53  	addiw	a0, a0, 1336
   1e5c0: 0a 95        	add	a0, a0, sp
   1e5c2: 89 65        	lui	a1, 2
   1e5c4: 9b 85 05 38  	addiw	a1, a1, 896
   1e5c8: 33 06 b1 00  	add	a2, sp, a1
   1e5cc: 85 65        	lui	a1, 1
   1e5ce: 9b 85 05 2d  	addiw	a1, a1, 720
   1e5d2: b3 06 b1 00  	add	a3, sp, a1
   1e5d6: 89 65        	lui	a1, 2
   1e5d8: 9b 85 85 33  	addiw	a1, a1, 824
   1e5dc: 33 07 b1 00  	add	a4, sp, a1
   1e5e0: 72 64        	ld	s0, 280(sp)
   1e5e2: a2 85        	mv	a1, s0
   1e5e4: 97 90 ff ff  	auipc	ra, 1048569
   1e5e8: e7 80 00 1a  	jalr	416(ra)
   1e5ec: 09 65        	lui	a0, 2
   1e5ee: 1b 05 05 54  	addiw	a0, a0, 1344
   1e5f2: 0a 95        	add	a0, a0, sp
   1e5f4: 83 5c 05 00  	lhu	s9, 0(a0)
   1e5f8: 4d 45        	li	a0, 19
   1e5fa: 63 84 ac 06  	beq	s9, a0, 0x1e662 <.LBB47_196+0x11e8>
   1e5fe: 92 68        	ld	a7, 256(sp)
;         defer tmp_arena.deinit();
   1e600: 09 65        	lui	a0, 2
;                             if (die_obj.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| {
   1e602: e3 9e 0c 2c  	bnez	s9, 0x1f0de <.LBB47_196+0x1c64>
;         for (self.attrs.items) |*attr| {
   1e606: 1b 05 05 3b  	addiw	a0, a0, 944
   1e60a: 0a 95        	add	a0, a0, sp
   1e60c: 0c 61        	ld	a1, 0(a0)
   1e60e: c9 46        	li	a3, 18
   1e610: 8d c5        	beqz	a1, 0x1e63a <.LBB47_196+0x11c0>
   1e612: 09 65        	lui	a0, 2
   1e614: 1b 05 85 3a  	addiw	a0, a0, 936
   1e618: 0a 95        	add	a0, a0, sp
   1e61a: 08 61        	ld	a0, 0(a0)
   1e61c: 09 66        	lui	a2, 2
   1e61e: 1b 06 86 53  	addiw	a2, a2, 1336
   1e622: 0a 96        	add	a2, a2, sp
   1e624: 83 3d 06 00  	ld	s11, 0(a2)
;         for (self.attrs.items) |*attr| {
   1e628: 41 05        	addi	a0, a0, 16
;             if (attr.id == id) return &attr.value;
   1e62a: 03 36 05 ff  	ld	a2, -16(a0)
   1e62e: 63 01 d6 16  	beq	a2, a3, 0x1e790 <.LBB47_196+0x1316>
;         for (self.attrs.items) |*attr| {
   1e632: fd 15        	addi	a1, a1, -1
   1e634: 13 05 05 02  	addi	a0, a0, 32
   1e638: ed f9        	bnez	a1, 0x1e62a <.LBB47_196+0x11b0>
   1e63a: 81 4c        	li	s9, 0
;                                     break :x null;
   1e63c: 09 65        	lui	a0, 2
   1e63e: 1b 05 65 53  	addiw	a0, a0, 1334
   1e642: 0a 95        	add	a0, a0, sp
   1e644: 23 00 05 00  	sb	zero, 0(a0)
   1e648: 09 65        	lui	a0, 2
   1e64a: 1b 05 45 53  	addiw	a0, a0, 1332
   1e64e: 0a 95        	add	a0, a0, sp
   1e650: 23 10 05 00  	sh	zero, 0(a0)
   1e654: 09 65        	lui	a0, 2
   1e656: 1b 05 05 53  	addiw	a0, a0, 1328
   1e65a: 0a 95        	add	a0, a0, sp
   1e65c: 23 20 05 00  	sw	zero, 0(a0)
   1e660: 3d a0        	j	0x1e68e <.LBB47_196+0x1214>
   1e662: 81 4c        	li	s9, 0
;                                 break :x null;
   1e664: 09 65        	lui	a0, 2
   1e666: 1b 05 65 53  	addiw	a0, a0, 1334
   1e66a: 0a 95        	add	a0, a0, sp
   1e66c: 23 00 05 00  	sb	zero, 0(a0)
   1e670: 09 65        	lui	a0, 2
   1e672: 1b 05 45 53  	addiw	a0, a0, 1332
   1e676: 0a 95        	add	a0, a0, sp
   1e678: 23 10 05 00  	sh	zero, 0(a0)
   1e67c: 09 65        	lui	a0, 2
   1e67e: 1b 05 05 53  	addiw	a0, a0, 1328
   1e682: 0a 95        	add	a0, a0, sp
   1e684: 23 20 05 00  	sw	zero, 0(a0)
   1e688: 4a 75        	ld	a0, 176(sp)
   1e68a: 08 e0        	sd	a0, 0(s0)
   1e68c: 92 68        	ld	a7, 256(sp)
;                         try di.func_list.append(allocator, Func{
   1e68e: 09 65        	lui	a0, 2
   1e690: 1b 05 65 53  	addiw	a0, a0, 1334
   1e694: 0a 95        	add	a0, a0, sp
   1e696: 83 05 05 00  	lb	a1, 0(a0)
   1e69a: 09 65        	lui	a0, 2
   1e69c: 1b 05 45 53  	addiw	a0, a0, 1332
   1e6a0: 0a 95        	add	a0, a0, sp
   1e6a2: 03 16 05 00  	lh	a2, 0(a0)
;             const newlen = self.items.len + 1;
   1e6a6: 05 65        	lui	a0, 1
   1e6a8: 1b 05 85 3c  	addiw	a0, a0, 968
   1e6ac: 0a 95        	add	a0, a0, sp
   1e6ae: 08 61        	ld	a0, 0(a0)
;                         try di.func_list.append(allocator, Func{
   1e6b0: 89 66        	lui	a3, 2
   1e6b2: 9b 86 06 53  	addiw	a3, a3, 1328
   1e6b6: 8a 96        	add	a3, a3, sp
   1e6b8: 94 42        	lw	a3, 0(a3)
   1e6ba: 09 67        	lui	a4, 2
   1e6bc: 1b 07 e7 54  	addiw	a4, a4, 1358
   1e6c0: 0a 97        	add	a4, a4, sp
   1e6c2: 23 00 b7 00  	sb	a1, 0(a4)
   1e6c6: 89 65        	lui	a1, 2
   1e6c8: 9b 85 c5 54  	addiw	a1, a1, 1356
   1e6cc: 8a 95        	add	a1, a1, sp
   1e6ce: 23 90 c5 00  	sh	a2, 0(a1)
;             const newlen = self.items.len + 1;
   1e6d2: 93 05 15 00  	addi	a1, a0, 1
;                         try di.func_list.append(allocator, Func{
   1e6d6: 09 66        	lui	a2, 2
   1e6d8: 1b 06 86 54  	addiw	a2, a2, 1352
   1e6dc: 0a 96        	add	a2, a2, sp
   1e6de: 14 c2        	sw	a3, 0(a2)
;             const newlen = self.items.len + 1;
   1e6e0: 99 e1        	bnez	a1, 0x1e6e6 <.LBB47_196+0x126c>
   1e6e2: 6f 10 f0 7f  	j	0x206e0 <.LBB47_196+0x3266>
;             if (self.capacity >= new_capacity) return;
   1e6e6: 05 66        	lui	a2, 1
   1e6e8: 1b 06 06 3d  	addiw	a2, a2, 976
   1e6ec: 0a 96        	add	a2, a2, sp
   1e6ee: 03 3b 06 00  	ld	s6, 0(a2)
   1e6f2: 63 73 bb 30  	bgeu	s6, a1, 0x1e9f8 <.LBB47_196+0x157e>
   1e6f6: 5a 89        	mv	s2, s6
   1e6f8: 19 a0        	j	0x1e6fe <.LBB47_196+0x1284>
;                 if (better_capacity >= new_capacity) break;
   1e6fa: 63 7c b9 00  	bgeu	s2, a1, 0x1e712 <.LBB47_196+0x1298>
   1e6fe: ca 86        	mv	a3, s2
;                 better_capacity +|= better_capacity / 2 + 8;
   1e700: 13 56 19 00  	srli	a2, s2, 1
   1e704: 4a 96        	add	a2, a2, s2
   1e706: 21 06        	addi	a2, a2, 8
   1e708: 7d 59        	li	s2, -1
   1e70a: e3 68 d6 fe  	bltu	a2, a3, 0x1e6fa <.LBB47_196+0x1280>
   1e70e: 32 89        	mv	s2, a2
   1e710: ed b7        	j	0x1e6fa <.LBB47_196+0x1280>
;             if (self.capacity >= new_capacity) return;
   1e712: 63 71 2b 2f  	bgeu	s6, s2, 0x1e9f4 <.LBB47_196+0x157a>
;             const old_memory = self.allocatedSlice();
   1e716: 05 65        	lui	a0, 1
   1e718: 1b 05 05 3c  	addiw	a0, a0, 960
   1e71c: 0a 95        	add	a0, a0, sp
   1e71e: 0c 61        	ld	a1, 0(a0)
   1e720: 32 66        	ld	a2, 264(sp)
;             if (allocator.resize(old_memory, new_capacity)) {
   1e722: 08 62        	ld	a0, 0(a2)
   1e724: 14 66        	ld	a3, 8(a2)
   1e726: 90 0d        	addi	a2, sp, 720
   1e728: 09 67        	lui	a4, 2
   1e72a: 1b 07 87 57  	addiw	a4, a4, 1400
   1e72e: 0a 97        	add	a4, a4, sp
   1e730: 10 e3        	sd	a2, 0(a4)
   1e732: 13 06 00 02  	li	a2, 32
   1e736: 09 67        	lui	a4, 2
   1e738: 1b 07 07 58  	addiw	a4, a4, 1408
   1e73c: 0a 97        	add	a4, a4, sp
   1e73e: 10 e3        	sd	a2, 0(a4)
   1e740: 09 66        	lui	a2, 2
   1e742: 1b 06 06 57  	addiw	a2, a2, 1392
   1e746: 0a 96        	add	a2, a2, sp
   1e748: 23 30 06 00  	sd	zero, 0(a2)
   1e74c: 33 06 3b 03  	mul	a2, s6, s3
   1e750: b3 37 3b 03  	mulhu	a5, s6, s3
;     if (old_mem.len == 0) {
   1e754: ae e8        	sd	a1, 80(sp)
   1e756: b2 e4        	sd	a2, 72(sp)
   1e758: be f0        	sd	a5, 96(sp)
   1e75a: 63 0b 0b 06  	beqz	s6, 0x1e7d0 <.LBB47_196+0x1356>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1e75e: 99 c3        	beqz	a5, 0x1e764 <.LBB47_196+0x12ea>
   1e760: 6f 10 10 78  	j	0x206e0 <.LBB47_196+0x3266>
;     const ov = @mulWithOverflow(a, b);
   1e764: 33 37 39 03  	mulhu	a4, s2, s3
;     if (ov[1] != 0) return error.Overflow;
   1e768: 19 c3        	beqz	a4, 0x1e76e <.LBB47_196+0x12f4>
   1e76a: 6f 20 c0 38  	j	0x20af6 <.LBB47_196+0x367c>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   1e76e: 84 66        	ld	s1, 8(a3)
   1e770: 33 0a 39 03  	mul	s4, s2, s3
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   1e774: 8d 46        	li	a3, 3
   1e776: 52 87        	mv	a4, s4
   1e778: ce 77        	ld	a5, 240(sp)
   1e77a: 82 94        	jalr	s1
   1e77c: 92 68        	ld	a7, 256(sp)
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   1e77e: 05 89        	andi	a0, a0, 1
;             if (allocator.resize(old_memory, new_capacity)) {
   1e780: 63 1c 05 24  	bnez	a0, 0x1e9d8 <.LBB47_196+0x155e>
   1e784: 22 fc        	sd	s0, 56(sp)
   1e786: ee e0        	sd	s11, 64(sp)
   1e788: 32 65        	ld	a0, 264(sp)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   1e78a: 14 65        	ld	a3, 8(a0)
   1e78c: 08 61        	ld	a0, 0(a0)
   1e78e: 91 a8        	j	0x1e7e2 <.LBB47_196+0x1368>
;                                     const pc_end = switch (high_pc_value.*) {
   1e790: 83 45 85 00  	lbu	a1, 8(a0)
   1e794: 03 34 85 ff  	ld	s0, -8(a0)
   1e798: 85 4c        	li	s9, 1
   1e79a: e3 8a 05 ee  	beqz	a1, 0x1e68e <.LBB47_196+0x1214>
   1e79e: 63 84 25 01  	beq	a1, s2, 0x1e7a6 <.LBB47_196+0x132c>
   1e7a2: 6f 20 80 44  	j	0x20bea <.LBB47_196+0x3770>
   1e7a6: 03 45 05 00  	lbu	a0, 0(a0)
;         if (self.signed) return badDwarf();
   1e7aa: 05 89        	andi	a0, a0, 1
   1e7ac: 19 c1        	beqz	a0, 0x1e7b2 <.LBB47_196+0x1338>
   1e7ae: 6f 20 00 44  	j	0x20bee <.LBB47_196+0x3774>
;                                             break :b (low_pc + offset);
   1e7b2: 6e 94        	add	s0, s0, s11
   1e7b4: e3 7d b4 ed  	bgeu	s0, s11, 0x1e68e <.LBB47_196+0x1214>
   1e7b8: 6f 10 90 72  	j	0x206e0 <.LBB47_196+0x3266>
   1e7bc: 1b 05 85 35  	addiw	a0, a0, 856
   1e7c0: 0a 95        	add	a0, a0, sp
   1e7c2: 23 38 05 00  	sd	zero, 16(a0)
   1e7c6: 23 34 05 00  	sd	zero, 8(a0)
   1e7ca: 23 30 05 00  	sd	zero, 0(a0)
   1e7ce: 2d a2        	j	0x1e8f8 <.LBB47_196+0x147e>
;     const ov = @mulWithOverflow(a, b);
   1e7d0: 33 37 39 03  	mulhu	a4, s2, s3
;     if (ov[1] != 0) return error.Overflow;
   1e7d4: 19 c3        	beqz	a4, 0x1e7da <.LBB47_196+0x1360>
   1e7d6: 6f 20 00 33  	j	0x20b06 <.LBB47_196+0x368c>
   1e7da: 22 fc        	sd	s0, 56(sp)
   1e7dc: ee e0        	sd	s11, 64(sp)
   1e7de: 33 0a 39 03  	mul	s4, s2, s3
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1e7e2: 98 62        	ld	a4, 0(a3)
   1e7e4: 0d 46        	li	a2, 3
   1e7e6: d2 85        	mv	a1, s4
   1e7e8: ce 76        	ld	a3, 240(sp)
   1e7ea: 02 97        	jalr	a4
   1e7ec: 19 e1        	bnez	a0, 0x1e7f2 <.LBB47_196+0x1378>
   1e7ee: 6f 20 20 32  	j	0x20b10 <.LBB47_196+0x3696>
   1e7f2: aa 8d        	mv	s11, a0
;     @memset(byte_ptr, undefined, byte_count);
   1e7f4: 93 05 a0 0a  	li	a1, 170
   1e7f8: 52 86        	mv	a2, s4
   1e7fa: 97 60 00 00  	auipc	ra, 6
   1e7fe: e7 80 00 aa  	jalr	-1376(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   1e802: 13 f5 7d 00  	andi	a0, s11, 7
   1e806: 13 35 15 00  	seqz	a0, a0
   1e80a: 93 35 1a 00  	seqz	a1, s4
   1e80e: 4d 8d        	or	a0, a0, a1
   1e810: 19 e1        	bnez	a0, 0x1e816 <.LBB47_196+0x139c>
   1e812: 6f e0 0f b7  	j	0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
   1e816: 92 68        	ld	a7, 256(sp)
;     if (bytes.len == 0) {
   1e818: 63 0d 0a 10  	beqz	s4, 0x1e932 <.LBB47_196+0x14b8>
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   1e81c: 42 75        	ld	a0, 48(sp)
   1e81e: 33 35 aa 02  	mulhu	a0, s4, a0
   1e822: 13 59 55 00  	srli	s2, a0, 5
   1e826: 33 05 39 03  	mul	a0, s2, s3
   1e82a: 33 05 aa 40  	sub	a0, s4, a0
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   1e82e: 63 04 05 10  	beqz	a0, 0x1e936 <.LBB47_196+0x14bc>
   1e832: 6f 20 e0 4c  	j	0x20d00 <.LBB47_196+0x3886>
;         switch (fv) {
   1e836: 83 46 86 00  	lbu	a3, 8(a2)
   1e83a: 19 47        	li	a4, 6
   1e83c: 93 07 30 07  	li	a5, 115
   1e840: 63 8b e6 00  	beq	a3, a4, 0x1e856 <.LBB47_196+0x13dc>
   1e844: 63 84 b6 01  	beq	a3, s11, 0x1e84c <.LBB47_196+0x13d2>
   1e848: 6f 20 20 29  	j	0x20ada <.LBB47_196+0x3660>
   1e84c: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1e850: 99 c2        	beqz	a3, 0x1e856 <.LBB47_196+0x13dc>
   1e852: 6f 20 e0 27  	j	0x20ad0 <.LBB47_196+0x3656>
   1e856: 03 36 86 ff  	ld	a2, -8(a2)
   1e85a: 89 66        	lui	a3, 2
   1e85c: 9b 86 86 35  	addiw	a3, a3, 856
   1e860: 8a 96        	add	a3, a3, sp
   1e862: 90 e2        	sd	a2, 0(a3)
   1e864: ae 86        	mv	a3, a1
   1e866: 2a 86        	mv	a2, a0
;             if (attr.id == id) return &attr.value;
   1e868: 03 37 06 ff  	ld	a4, -16(a2)
   1e86c: 63 08 f7 00  	beq	a4, a5, 0x1e87c <.LBB47_196+0x1402>
;         for (self.attrs.items) |*attr| {
   1e870: fd 16        	addi	a3, a3, -1
   1e872: 13 06 06 02  	addi	a2, a2, 32
   1e876: ed fa        	bnez	a3, 0x1e868 <.LBB47_196+0x13ee>
   1e878: 01 46        	li	a2, 0
   1e87a: 0d a0        	j	0x1e89c <.LBB47_196+0x1422>
;         switch (fv) {
   1e87c: 83 46 86 00  	lbu	a3, 8(a2)
   1e880: 19 47        	li	a4, 6
   1e882: 63 8b e6 00  	beq	a3, a4, 0x1e898 <.LBB47_196+0x141e>
   1e886: 63 84 b6 01  	beq	a3, s11, 0x1e88e <.LBB47_196+0x1414>
   1e88a: 6f 20 00 25  	j	0x20ada <.LBB47_196+0x3660>
   1e88e: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1e892: 99 c2        	beqz	a3, 0x1e898 <.LBB47_196+0x141e>
   1e894: 6f 20 c0 23  	j	0x20ad0 <.LBB47_196+0x3656>
   1e898: 03 36 86 ff  	ld	a2, -8(a2)
   1e89c: 89 66        	lui	a3, 2
   1e89e: 9b 86 06 36  	addiw	a3, a3, 864
   1e8a2: 8a 96        	add	a3, a3, sp
   1e8a4: 90 e2        	sd	a2, 0(a3)
   1e8a6: ae 86        	mv	a3, a1
   1e8a8: 2a 86        	mv	a2, a0
;             if (attr.id == id) return &attr.value;
   1e8aa: 03 37 06 ff  	ld	a4, -16(a2)
   1e8ae: 63 08 87 00  	beq	a4, s0, 0x1e8be <.LBB47_196+0x1444>
;         for (self.attrs.items) |*attr| {
   1e8b2: fd 16        	addi	a3, a3, -1
   1e8b4: 13 06 06 02  	addi	a2, a2, 32
   1e8b8: ed fa        	bnez	a3, 0x1e8aa <.LBB47_196+0x1430>
   1e8ba: 01 46        	li	a2, 0
   1e8bc: 0d a0        	j	0x1e8de <.LBB47_196+0x1464>
;         switch (fv) {
   1e8be: 83 46 86 00  	lbu	a3, 8(a2)
   1e8c2: 19 47        	li	a4, 6
   1e8c4: 63 8b e6 00  	beq	a3, a4, 0x1e8da <.LBB47_196+0x1460>
   1e8c8: 63 84 b6 01  	beq	a3, s11, 0x1e8d0 <.LBB47_196+0x1456>
   1e8cc: 6f 20 e0 20  	j	0x20ada <.LBB47_196+0x3660>
   1e8d0: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1e8d4: 99 c2        	beqz	a3, 0x1e8da <.LBB47_196+0x1460>
   1e8d6: 6f 20 a0 1f  	j	0x20ad0 <.LBB47_196+0x3656>
   1e8da: 03 36 86 ff  	ld	a2, -8(a2)
   1e8de: 89 66        	lui	a3, 2
   1e8e0: 9b 86 86 36  	addiw	a3, a3, 872
   1e8e4: 8a 96        	add	a3, a3, sp
   1e8e6: 90 e2        	sd	a2, 0(a3)
;             if (attr.id == id) return &attr.value;
   1e8e8: 03 36 05 ff  	ld	a2, -16(a0)
   1e8ec: 63 0d 06 01  	beq	a2, a6, 0x1e906 <.LBB47_196+0x148c>
;         for (self.attrs.items) |*attr| {
   1e8f0: fd 15        	addi	a1, a1, -1
   1e8f2: 13 05 05 02  	addi	a0, a0, 32
   1e8f6: ed f9        	bnez	a1, 0x1e8e8 <.LBB47_196+0x146e>
;                             .loclists_base = if (die_obj.getAttr(AT.loclists_base)) |fv| try fv.getUInt(usize) else 0,
   1e8f8: 09 65        	lui	a0, 2
   1e8fa: 1b 05 05 37  	addiw	a0, a0, 880
   1e8fe: 0a 95        	add	a0, a0, sp
   1e900: 23 30 05 00  	sd	zero, 0(a0)
   1e904: 5d a2        	j	0x1eaaa <.LBB47_196+0x1630>
;         switch (fv) {
   1e906: 83 45 85 00  	lbu	a1, 8(a0)
   1e90a: 19 46        	li	a2, 6
   1e90c: 63 8b c5 00  	beq	a1, a2, 0x1e922 <.LBB47_196+0x14a8>
   1e910: 63 84 b5 01  	beq	a1, s11, 0x1e918 <.LBB47_196+0x149e>
   1e914: 6f 20 60 1c  	j	0x20ada <.LBB47_196+0x3660>
   1e918: 83 45 05 00  	lbu	a1, 0(a0)
;         if (self.signed) return badDwarf();
   1e91c: 99 c1        	beqz	a1, 0x1e922 <.LBB47_196+0x14a8>
   1e91e: 6f 20 20 1b  	j	0x20ad0 <.LBB47_196+0x3656>
   1e922: 03 35 85 ff  	ld	a0, -8(a0)
;                             .loclists_base = if (die_obj.getAttr(AT.loclists_base)) |fv| try fv.getUInt(usize) else 0,
   1e926: 89 65        	lui	a1, 2
   1e928: 9b 85 05 37  	addiw	a1, a1, 880
   1e92c: 8a 95        	add	a1, a1, sp
   1e92e: 88 e1        	sd	a0, 0(a1)
   1e930: ad aa        	j	0x1eaaa <.LBB47_196+0x1630>
   1e932: 01 49        	li	s2, 0
   1e934: e6 7d        	ld	s11, 120(sp)
;                 mem.copy(T, new_memory, self.items);
   1e936: 05 65        	lui	a0, 1
   1e938: 1b 05 85 3c  	addiw	a0, a0, 968
   1e93c: 0a 95        	add	a0, a0, sp
   1e93e: 08 61        	ld	a0, 0(a0)
;     if (!ok) unreachable; // assertion failure
   1e940: 63 74 a9 00  	bgeu	s2, a0, 0x1e948 <.LBB47_196+0x14ce>
   1e944: 6f e0 2f 99  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (source) |s, i|
   1e948: 1d c5        	beqz	a0, 0x1e976 <.LBB47_196+0x14fc>
   1e94a: 85 65        	lui	a1, 1
   1e94c: 9b 85 05 3c  	addiw	a1, a1, 960
   1e950: 8a 95        	add	a1, a1, sp
   1e952: 8c 61        	ld	a1, 0(a1)
   1e954: 6e 86        	mv	a2, s11
;         dest[i] = s;
   1e956: 94 61        	ld	a3, 0(a1)
   1e958: 98 71        	ld	a4, 32(a1)
   1e95a: 9c 6d        	ld	a5, 24(a1)
   1e95c: 80 69        	ld	s0, 16(a1)
   1e95e: 84 65        	ld	s1, 8(a1)
   1e960: 18 f2        	sd	a4, 32(a2)
   1e962: 1c ee        	sd	a5, 24(a2)
   1e964: 00 ea        	sd	s0, 16(a2)
   1e966: 04 e6        	sd	s1, 8(a2)
   1e968: 14 e2        	sd	a3, 0(a2)
;     for (source) |s, i|
   1e96a: 7d 15        	addi	a0, a0, -1
   1e96c: 13 06 86 02  	addi	a2, a2, 40
   1e970: 93 85 85 02  	addi	a1, a1, 40
   1e974: 6d f1        	bnez	a0, 0x1e956 <.LBB47_196+0x14dc>
   1e976: 32 65        	ld	a0, 264(sp)
;                 allocator.free(old_memory);
   1e978: 04 61        	ld	s1, 0(a0)
   1e97a: 03 3a 85 00  	ld	s4, 8(a0)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1e97e: 63 0d 0b 00  	beqz	s6, 0x1e998 <.LBB47_196+0x151e>
   1e982: 93 09 80 02  	li	s3, 40
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1e986: 06 75        	ld	a0, 96(sp)
   1e988: 19 c1        	beqz	a0, 0x1e98e <.LBB47_196+0x1514>
   1e98a: 6f 10 70 55  	j	0x206e0 <.LBB47_196+0x3266>
   1e98e: 46 64        	ld	s0, 80(sp)
   1e990: 26 6b        	ld	s6, 72(sp)
;     if (bytes_len == 0) return;
   1e992: 63 18 0b 00  	bnez	s6, 0x1e9a2 <.LBB47_196+0x1528>
   1e996: 0d a8        	j	0x1e9c8 <.LBB47_196+0x154e>
   1e998: 21 44        	li	s0, 8
   1e99a: 93 09 80 02  	li	s3, 40
;     if (bytes_len == 0) return;
   1e99e: 63 05 0b 02  	beqz	s6, 0x1e9c8 <.LBB47_196+0x154e>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1e9a2: 63 0e 04 6a  	beqz	s0, 0x1f05e <.LBB47_196+0x1be4>
;     @memset(non_const_ptr, undefined, bytes_len);
   1e9a6: 93 05 a0 0a  	li	a1, 170
   1e9aa: 22 85        	mv	a0, s0
   1e9ac: 5a 86        	mv	a2, s6
   1e9ae: 97 60 00 00  	auipc	ra, 6
   1e9b2: e7 80 c0 8e  	jalr	-1812(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1e9b6: 83 37 0a 01  	ld	a5, 16(s4)
   1e9ba: 8d 46        	li	a3, 3
   1e9bc: 26 85        	mv	a0, s1
   1e9be: a2 85        	mv	a1, s0
   1e9c0: 5a 86        	mv	a2, s6
   1e9c2: 4e 77        	ld	a4, 240(sp)
   1e9c4: 82 97        	jalr	a5
   1e9c6: 92 68        	ld	a7, 256(sp)
;                 self.items.ptr = new_memory.ptr;
   1e9c8: 05 65        	lui	a0, 1
   1e9ca: 1b 05 05 3c  	addiw	a0, a0, 960
   1e9ce: 0a 95        	add	a0, a0, sp
   1e9d0: 23 30 b5 01  	sd	s11, 0(a0)
   1e9d4: 86 6d        	ld	s11, 64(sp)
   1e9d6: 62 74        	ld	s0, 56(sp)
   1e9d8: 05 65        	lui	a0, 1
   1e9da: 1b 05 05 3d  	addiw	a0, a0, 976
   1e9de: 0a 95        	add	a0, a0, sp
   1e9e0: 23 30 25 01  	sd	s2, 0(a0)
;             assert(self.items.len < self.capacity);
   1e9e4: 05 65        	lui	a0, 1
   1e9e6: 1b 05 85 3c  	addiw	a0, a0, 968
   1e9ea: 0a 95        	add	a0, a0, sp
   1e9ec: 08 61        	ld	a0, 0(a0)
   1e9ee: 4a 8b        	mv	s6, s2
   1e9f0: 13 0a e0 02  	li	s4, 46
   1e9f4: 93 04 10 03  	li	s1, 49
   1e9f8: 2e 69        	ld	s2, 200(sp)
;     if (!ok) unreachable; // assertion failure
   1e9fa: 63 64 65 01  	bltu	a0, s6, 0x1ea02 <.LBB47_196+0x1588>
   1e9fe: 6f e0 8f 8d  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;             self.items.len += 1;
   1ea02: 93 05 15 00  	addi	a1, a0, 1
   1ea06: 05 66        	lui	a2, 1
   1ea08: 1b 06 86 3c  	addiw	a2, a2, 968
   1ea0c: 0a 96        	add	a2, a2, sp
   1ea0e: 0c e2        	sd	a1, 0(a2)
;             return &self.items[self.items.len - 1];
   1ea10: 85 65        	lui	a1, 1
   1ea12: 9b 85 05 3c  	addiw	a1, a1, 960
   1ea16: 8a 95        	add	a1, a1, sp
   1ea18: 8c 61        	ld	a1, 0(a1)
   1ea1a: 33 05 35 03  	mul	a0, a0, s3
   1ea1e: 2e 95        	add	a0, a0, a1
;             new_item_ptr.* = item;
   1ea20: 23 30 b5 01  	sd	s11, 0(a0)
   1ea24: 00 e5        	sd	s0, 8(a0)
   1ea26: 23 08 95 01  	sb	s9, 16(a0)
   1ea2a: 89 65        	lui	a1, 2
   1ea2c: 9b 85 85 54  	addiw	a1, a1, 1352
   1ea30: 8a 95        	add	a1, a1, sp
   1ea32: 83 85 05 00  	lb	a1, 0(a1)
   1ea36: a3 08 b5 00  	sb	a1, 17(a0)
   1ea3a: 89 65        	lui	a1, 2
   1ea3c: 9b 85 95 54  	addiw	a1, a1, 1353
   1ea40: 8a 95        	add	a1, a1, sp
   1ea42: 83 85 05 00  	lb	a1, 0(a1)
   1ea46: 23 09 b5 00  	sb	a1, 18(a0)
   1ea4a: 89 65        	lui	a1, 2
   1ea4c: 9b 85 a5 54  	addiw	a1, a1, 1354
   1ea50: 8a 95        	add	a1, a1, sp
   1ea52: 83 85 05 00  	lb	a1, 0(a1)
   1ea56: a3 09 b5 00  	sb	a1, 19(a0)
   1ea5a: 89 65        	lui	a1, 2
   1ea5c: 9b 85 b5 54  	addiw	a1, a1, 1355
   1ea60: 8a 95        	add	a1, a1, sp
   1ea62: 83 85 05 00  	lb	a1, 0(a1)
   1ea66: 23 0a b5 00  	sb	a1, 20(a0)
   1ea6a: 89 65        	lui	a1, 2
   1ea6c: 9b 85 c5 54  	addiw	a1, a1, 1356
   1ea70: 8a 95        	add	a1, a1, sp
   1ea72: 83 85 05 00  	lb	a1, 0(a1)
   1ea76: a3 0a b5 00  	sb	a1, 21(a0)
   1ea7a: 89 65        	lui	a1, 2
   1ea7c: 9b 85 d5 54  	addiw	a1, a1, 1357
   1ea80: 8a 95        	add	a1, a1, sp
   1ea82: 83 85 05 00  	lb	a1, 0(a1)
   1ea86: 23 0b b5 00  	sb	a1, 22(a0)
   1ea8a: 89 65        	lui	a1, 2
   1ea8c: 9b 85 e5 54  	addiw	a1, a1, 1358
   1ea90: 8a 95        	add	a1, a1, sp
   1ea92: 83 85 05 00  	lb	a1, 0(a1)
   1ea96: a3 0b b5 00  	sb	a1, 23(a0)
   1ea9a: 23 3c 85 01  	sd	s8, 24(a0)
   1ea9e: 23 30 a5 03  	sd	s10, 32(a0)
   1eaa2: 72 6c        	ld	s8, 280(sp)
   1eaa4: 4e 7d        	ld	s10, 240(sp)
   1eaa6: 21 4b        	li	s6, 8
   1eaa8: 8d 4d        	li	s11, 3
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1eaaa: 09 65        	lui	a0, 2
   1eaac: 1b 05 85 2d  	addiw	a0, a0, 728
   1eab0: 0a 95        	add	a0, a0, sp
   1eab2: 08 61        	ld	a0, 0(a0)
   1eab4: 63 6f 15 ef  	bltu	a0, a7, 0x1e1b2 <.LBB47_196+0xd38>
   1eab8: 46 85        	mv	a0, a7
   1eaba: 6f f0 8f ef  	j	0x1e1b2 <.LBB47_196+0xd38>
;             var bytes: [num_bytes]u8 = undefined;
   1eabe: 66 75        	ld	a0, 120(sp)
   1eac0: 89 65        	lui	a1, 2
   1eac2: 9b 85 05 57  	addiw	a1, a1, 1392
   1eac6: 8a 95        	add	a1, a1, sp
   1eac8: 88 e1        	sd	a0, 0(a1)
   1eaca: 13 0a e0 02  	li	s4, 46
;                 const amt = try self.read(buffer[index..]);
   1eace: 33 86 8b 00  	add	a2, s7, s0
   1ead2: b3 06 8b 40  	sub	a3, s6, s0
;             return readFn(self.context, buffer);
   1ead6: 88 0d        	addi	a0, sp, 720
   1ead8: 89 65        	lui	a1, 2
   1eada: 9b 85 05 2d  	addiw	a1, a1, 720
   1eade: 8a 95        	add	a1, a1, sp
   1eae0: 97 30 00 00  	auipc	ra, 3
   1eae4: e7 80 80 bd  	jalr	-1064(ra)
   1eae8: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1eaec: 63 00 05 14  	beqz	a0, 0x1ec2c <.LBB47_196+0x17b2>
;                 index += amt;
   1eaf0: 22 95        	add	a0, a0, s0
   1eaf2: 63 74 85 00  	bgeu	a0, s0, 0x1eafa <.LBB47_196+0x1680>
   1eaf6: 6f 10 b0 3e  	j	0x206e0 <.LBB47_196+0x3266>
   1eafa: 2a 84        	mv	s0, a0
;             while (index < len) {
   1eafc: e3 69 65 fd  	bltu	a0, s6, 0x1eace <.LBB47_196+0x1654>
;             return bytes;
   1eb00: 09 65        	lui	a0, 2
   1eb02: 1b 05 05 57  	addiw	a0, a0, 1392
   1eb06: 0a 95        	add	a0, a0, sp
   1eb08: 04 61        	ld	s1, 0(a0)
;     if (endian == native_endian) {
   1eb0a: 13 f5 19 00  	andi	a0, s3, 1
   1eb0e: 63 1d 05 de  	bnez	a0, 0x1e108 <.LBB47_196+0xc8e>
   1eb12: 13 d5 84 01  	srli	a0, s1, 24
   1eb16: b7 05 ff 00  	lui	a1, 4080
   1eb1a: 6d 8d        	and	a0, a0, a1
   1eb1c: 93 d5 84 00  	srli	a1, s1, 8
   1eb20: 93 06 f0 0f  	li	a3, 255
   1eb24: 13 96 86 01  	slli	a2, a3, 24
   1eb28: f1 8d        	and	a1, a1, a2
   1eb2a: 4d 8d        	or	a0, a0, a1
   1eb2c: 93 d5 84 02  	srli	a1, s1, 40
   1eb30: 46 76        	ld	a2, 112(sp)
   1eb32: f1 8d        	and	a1, a1, a2
   1eb34: 13 d6 84 03  	srli	a2, s1, 56
   1eb38: d1 8d        	or	a1, a1, a2
   1eb3a: 4d 8d        	or	a0, a0, a1
   1eb3c: 93 95 84 01  	slli	a1, s1, 24
   1eb40: 13 96 86 02  	slli	a2, a3, 40
   1eb44: f1 8d        	and	a1, a1, a2
   1eb46: 1b d6 84 01  	srliw	a2, s1, 24
   1eb4a: 02 16        	slli	a2, a2, 32
   1eb4c: d1 8d        	or	a1, a1, a2
   1eb4e: 13 96 84 02  	slli	a2, s1, 40
   1eb52: c2 16        	slli	a3, a3, 48
   1eb54: 75 8e        	and	a2, a2, a3
   1eb56: 93 96 84 03  	slli	a3, s1, 56
   1eb5a: 55 8e        	or	a2, a2, a3
   1eb5c: d1 8d        	or	a1, a1, a2
   1eb5e: b3 e4 a5 00  	or	s1, a1, a0
   1eb62: 6f f0 6f da  	j	0x1e108 <.LBB47_196+0xc8e>
;         var it = self.state.buffer_list.first;
   1eb66: 09 65        	lui	a0, 2
   1eb68: 1b 05 05 30  	addiw	a0, a0, 768
   1eb6c: 0a 95        	add	a0, a0, sp
   1eb6e: 03 39 05 00  	ld	s2, 0(a0)
   1eb72: 72 6c        	ld	s8, 280(sp)
   1eb74: 4e 7b        	ld	s6, 240(sp)
;         while (it) |node| {
   1eb76: 63 05 09 58  	beqz	s2, 0x1f100 <.LBB47_196+0x1c86>
   1eb7a: 37 55 02 00  	lui	a0, 37
   1eb7e: 03 3a 85 38  	ld	s4, 904(a0)
   1eb82: 3d a8        	j	0x1ebc0 <.LBB47_196+0x1746>
   1eb84: 09 65        	lui	a0, 2
   1eb86: 1b 05 05 2f  	addiw	a0, a0, 752
   1eb8a: 0a 95        	add	a0, a0, sp
   1eb8c: 83 39 05 00  	ld	s3, 0(a0)
   1eb90: 09 65        	lui	a0, 2
   1eb92: 1b 05 85 2f  	addiw	a0, a0, 760
   1eb96: 0a 95        	add	a0, a0, sp
   1eb98: 83 3a 05 00  	ld	s5, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1eb9c: 93 05 a0 0a  	li	a1, 170
   1eba0: 22 85        	mv	a0, s0
   1eba2: 26 86        	mv	a2, s1
   1eba4: 97 50 00 00  	auipc	ra, 5
   1eba8: e7 80 60 6f  	jalr	1782(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1ebac: 83 b7 0a 01  	ld	a5, 16(s5)
   1ebb0: 4e 85        	mv	a0, s3
   1ebb2: a2 85        	mv	a1, s0
   1ebb4: 26 86        	mv	a2, s1
   1ebb6: 81 46        	li	a3, 0
   1ebb8: 5a 87        	mv	a4, s6
   1ebba: 82 97        	jalr	a5
;         while (it) |node| {
   1ebbc: 63 02 09 54  	beqz	s2, 0x1f100 <.LBB47_196+0x1c86>
;             self.child_allocator.free(node.data);
   1ebc0: 03 35 09 01  	ld	a0, 16(s2)
   1ebc4: 81 44        	li	s1, 0
   1ebc6: 52 84        	mv	s0, s4
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1ebc8: 01 c5        	beqz	a0, 0x1ebd0 <.LBB47_196+0x1756>
   1ebca: 03 34 89 00  	ld	s0, 8(s2)
   1ebce: aa 84        	mv	s1, a0
   1ebd0: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1ebd4: e5 d4        	beqz	s1, 0x1ebbc <.LBB47_196+0x1742>
   1ebd6: 5d f4        	bnez	s0, 0x1eb84 <.LBB47_196+0x170a>
   1ebd8: 59 a1        	j	0x1f05e <.LBB47_196+0x1be4>
;         if (!mem.eql(u8, hdr.e_ident[0..4], elf.MAGIC)) return error.InvalidElfMagic;
   1ebda: 62 85        	mv	a0, s8
   1ebdc: 97 50 00 00  	auipc	ra, 5
   1ebe0: e7 80 c0 01  	jalr	28(ra)
   1ebe4: 37 15 01 00  	lui	a0, 17
   1ebe8: 93 05 05 83  	addi	a1, a0, -2000
   1ebec: 88 03        	addi	a0, sp, 448
   1ebee: 13 06 00 11  	li	a2, 272
   1ebf2: 97 50 00 00  	auipc	ra, 5
   1ebf6: e7 80 20 68  	jalr	1666(ra)
   1ebfa: 93 0c d0 02  	li	s9, 45
   1ebfe: 6f 10 b0 15  	j	0x20558 <.LBB47_196+0x30de>
   1ec02: 72 6c        	ld	s8, 280(sp)
   1ec04: 62 85        	mv	a0, s8
   1ec06: 97 50 00 00  	auipc	ra, 5
   1ec0a: e7 80 20 ff  	jalr	-14(ra)
   1ec0e: 37 15 01 00  	lui	a0, 17
   1ec12: 93 05 05 bc  	addi	a1, a0, -1088
   1ec16: 88 03        	addi	a0, sp, 448
   1ec18: 13 06 00 11  	li	a2, 272
   1ec1c: 97 50 00 00  	auipc	ra, 5
   1ec20: e7 80 80 65  	jalr	1624(ra)
   1ec24: cd 4c        	li	s9, 19
   1ec26: 0a 7a        	ld	s4, 160(sp)
   1ec28: ea 6a        	ld	s5, 152(sp)
   1ec2a: 89 ac        	j	0x1ee7c <.LBB47_196+0x1a02>
   1ec2c: 62 85        	mv	a0, s8
   1ec2e: 97 50 00 00  	auipc	ra, 5
   1ec32: e7 80 a0 fc  	jalr	-54(ra)
   1ec36: 62 85        	mv	a0, s8
   1ec38: 97 50 00 00  	auipc	ra, 5
   1ec3c: e7 80 00 fc  	jalr	-64(ra)
   1ec40: 62 85        	mv	a0, s8
   1ec42: 97 50 00 00  	auipc	ra, 5
   1ec46: e7 80 60 fb  	jalr	-74(ra)
   1ec4a: 93 0c 10 03  	li	s9, 49
   1ec4e: 89 a8        	j	0x1eca0 <.LBB47_196+0x1826>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   1ec50: 62 85        	mv	a0, s8
   1ec52: 97 50 00 00  	auipc	ra, 5
   1ec56: e7 80 60 fa  	jalr	-90(ra)
;     const slice = try self.allocAdvancedWithRetAddr(T, null, 1, @returnAddress());
   1ec5a: 62 85        	mv	a0, s8
   1ec5c: 97 50 00 00  	auipc	ra, 5
   1ec60: e7 80 c0 f9  	jalr	-100(ra)
;         const obj_di = try self.allocator.create(ModuleDebugInfo);
   1ec64: 62 85        	mv	a0, s8
   1ec66: 97 50 00 00  	auipc	ra, 5
   1ec6a: e7 80 20 f9  	jalr	-110(ra)
   1ec6e: c5 4c        	li	s9, 17
   1ec70: 6f 10 70 10  	j	0x20576 <.LBB47_196+0x30fc>
   1ec74: 62 85        	mv	a0, s8
   1ec76: 97 50 00 00  	auipc	ra, 5
   1ec7a: e7 80 20 f8  	jalr	-126(ra)
   1ec7e: 62 85        	mv	a0, s8
   1ec80: 97 50 00 00  	auipc	ra, 5
   1ec84: e7 80 80 f7  	jalr	-136(ra)
   1ec88: 93 0c 10 03  	li	s9, 49
   1ec8c: 62 85        	mv	a0, s8
   1ec8e: 97 50 00 00  	auipc	ra, 5
   1ec92: e7 80 a0 f6  	jalr	-150(ra)
   1ec96: 62 85        	mv	a0, s8
   1ec98: 97 50 00 00  	auipc	ra, 5
   1ec9c: e7 80 00 f6  	jalr	-160(ra)
;         var it = self.state.buffer_list.first;
   1eca0: 09 65        	lui	a0, 2
   1eca2: 1b 05 05 30  	addiw	a0, a0, 768
   1eca6: 0a 95        	add	a0, a0, sp
   1eca8: 03 39 05 00  	ld	s2, 0(a0)
   1ecac: 63 16 09 00  	bnez	s2, 0x1ecb8 <.LBB47_196+0x183e>
   1ecb0: 0a 7a        	ld	s4, 160(sp)
   1ecb2: ea 6a        	ld	s5, 152(sp)
   1ecb4: aa 7d        	ld	s11, 168(sp)
   1ecb6: e5 aa        	j	0x1eeae <.LBB47_196+0x1a34>
   1ecb8: 37 55 02 00  	lui	a0, 37
   1ecbc: 83 3a 85 38  	ld	s5, 904(a0)
   1ecc0: aa 7d        	ld	s11, 168(sp)
   1ecc2: 3d a8        	j	0x1ed00 <.LBB47_196+0x1886>
   1ecc4: 09 65        	lui	a0, 2
   1ecc6: 1b 05 05 2f  	addiw	a0, a0, 752
   1ecca: 0a 95        	add	a0, a0, sp
   1eccc: 03 3a 05 00  	ld	s4, 0(a0)
   1ecd0: 09 65        	lui	a0, 2
   1ecd2: 1b 05 85 2f  	addiw	a0, a0, 760
   1ecd6: 0a 95        	add	a0, a0, sp
   1ecd8: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1ecdc: 93 05 a0 0a  	li	a1, 170
   1ece0: 22 85        	mv	a0, s0
   1ece2: 26 86        	mv	a2, s1
   1ece4: 97 50 00 00  	auipc	ra, 5
   1ece8: e7 80 60 5b  	jalr	1462(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1ecec: 83 37 0b 01  	ld	a5, 16(s6)
   1ecf0: 52 85        	mv	a0, s4
   1ecf2: a2 85        	mv	a1, s0
   1ecf4: 26 86        	mv	a2, s1
   1ecf6: 81 46        	li	a3, 0
   1ecf8: 6a 87        	mv	a4, s10
   1ecfa: 82 97        	jalr	a5
   1ecfc: 63 07 09 1a  	beqz	s2, 0x1eeaa <.LBB47_196+0x1a30>
;             self.child_allocator.free(node.data);
   1ed00: 03 35 09 01  	ld	a0, 16(s2)
   1ed04: 81 44        	li	s1, 0
   1ed06: 56 84        	mv	s0, s5
   1ed08: 01 c5        	beqz	a0, 0x1ed10 <.LBB47_196+0x1896>
   1ed0a: 03 34 89 00  	ld	s0, 8(s2)
   1ed0e: aa 84        	mv	s1, a0
   1ed10: 03 39 09 00  	ld	s2, 0(s2)
   1ed14: e5 d4        	beqz	s1, 0x1ecfc <.LBB47_196+0x1882>
   1ed16: 5d f4        	bnez	s0, 0x1ecc4 <.LBB47_196+0x184a>
   1ed18: 99 a6        	j	0x1f05e <.LBB47_196+0x1be4>
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1ed1a: 3b 05 a0 40  	negw	a0, a0
;     switch (errno(fstat_sym(fd, &stat))) {
   1ed1e: 42 15        	slli	a0, a0, 48
   1ed20: 41 91        	srli	a0, a0, 48
   1ed22: b1 45        	li	a1, 12
   1ed24: 63 cf a5 14  	blt	a1, a0, 0x1ee82 <.LBB47_196+0x1a08>
   1ed28: 9d 4c        	li	s9, 7
   1ed2a: 63 0f b5 34  	beq	a0, a1, 0x1f088 <.LBB47_196+0x1c0e>
   1ed2e: a5 45        	li	a1, 9
   1ed30: 63 16 b5 34  	bne	a0, a1, 0x1f07c <.LBB47_196+0x1c02>
   1ed34: 6f d0 3f da  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;         defer file.close();
   1ed38: 03 25 09 00  	lw	a0, 0(s2)
;     return asm volatile ("ecall"
   1ed3c: 93 08 90 03  	li	a7, 57
   1ed40: 73 00 00 00  	ecall	
   1ed44: fd 75        	lui	a1, 1048575
   1ed46: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1ed48: b3 35 b5 00  	sltu	a1, a0, a1
   1ed4c: 65 8d        	and	a0, a0, s1
   1ed4e: 1b 06 7b ff  	addiw	a2, s6, -9
   1ed52: 85 ae        	j	0x1f0c2 <.LBB47_196+0x1c48>
   1ed54: cd 4c        	li	s9, 19
   1ed56: 62 85        	mv	a0, s8
   1ed58: 97 50 00 00  	auipc	ra, 5
   1ed5c: e7 80 00 ea  	jalr	-352(ra)
;         var it = self.state.buffer_list.first;
   1ed60: 09 65        	lui	a0, 2
   1ed62: 1b 05 05 30  	addiw	a0, a0, 768
   1ed66: 0a 95        	add	a0, a0, sp
   1ed68: 03 39 05 00  	ld	s2, 0(a0)
   1ed6c: aa 7d        	ld	s11, 168(sp)
   1ed6e: 63 0e 09 12  	beqz	s2, 0x1eeaa <.LBB47_196+0x1a30>
   1ed72: 37 55 02 00  	lui	a0, 37
   1ed76: 83 3a 85 38  	ld	s5, 904(a0)
   1ed7a: 3d a8        	j	0x1edb8 <.LBB47_196+0x193e>
   1ed7c: 09 65        	lui	a0, 2
   1ed7e: 1b 05 05 2f  	addiw	a0, a0, 752
   1ed82: 0a 95        	add	a0, a0, sp
   1ed84: 03 3a 05 00  	ld	s4, 0(a0)
   1ed88: 09 65        	lui	a0, 2
   1ed8a: 1b 05 85 2f  	addiw	a0, a0, 760
   1ed8e: 0a 95        	add	a0, a0, sp
   1ed90: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1ed94: 93 05 a0 0a  	li	a1, 170
   1ed98: 22 85        	mv	a0, s0
   1ed9a: 26 86        	mv	a2, s1
   1ed9c: 97 50 00 00  	auipc	ra, 5
   1eda0: e7 80 e0 4f  	jalr	1278(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1eda4: 83 37 0b 01  	ld	a5, 16(s6)
   1eda8: 52 85        	mv	a0, s4
   1edaa: a2 85        	mv	a1, s0
   1edac: 26 86        	mv	a2, s1
   1edae: 81 46        	li	a3, 0
   1edb0: 6a 87        	mv	a4, s10
   1edb2: 82 97        	jalr	a5
;         while (it) |node| {
   1edb4: 63 0b 09 0e  	beqz	s2, 0x1eeaa <.LBB47_196+0x1a30>
;             self.child_allocator.free(node.data);
   1edb8: 03 35 09 01  	ld	a0, 16(s2)
   1edbc: 81 44        	li	s1, 0
   1edbe: 56 84        	mv	s0, s5
   1edc0: 01 c5        	beqz	a0, 0x1edc8 <.LBB47_196+0x194e>
   1edc2: 03 34 89 00  	ld	s0, 8(s2)
   1edc6: aa 84        	mv	s1, a0
   1edc8: 03 39 09 00  	ld	s2, 0(s2)
   1edcc: e5 d4        	beqz	s1, 0x1edb4 <.LBB47_196+0x193a>
   1edce: 5d f4        	bnez	s0, 0x1ed7c <.LBB47_196+0x1902>
   1edd0: 79 a4        	j	0x1f05e <.LBB47_196+0x1be4>
;         if (hdr.e_ident[elf.EI_VERSION] != 1) return error.InvalidElfVersion;
   1edd2: 62 85        	mv	a0, s8
   1edd4: 97 50 00 00  	auipc	ra, 5
   1edd8: e7 80 40 e2  	jalr	-476(ra)
   1eddc: 37 15 01 00  	lui	a0, 17
   1ede0: 93 05 05 96  	addi	a1, a0, -1696
   1ede4: 88 03        	addi	a0, sp, 448
   1ede6: 13 06 00 11  	li	a2, 272
   1edea: 97 50 00 00  	auipc	ra, 5
   1edee: e7 80 a0 48  	jalr	1162(ra)
   1edf2: 93 0c e0 02  	li	s9, 46
   1edf6: 6f 10 20 76  	j	0x20558 <.LBB47_196+0x30de>
   1edfa: 09 45        	li	a0, 2
;         const endian: std.builtin.Endian = switch (hdr.e_ident[elf.EI_DATA]) {
   1edfc: 63 94 a5 00  	bne	a1, a0, 0x1ee04 <.LBB47_196+0x198a>
   1ee00: 6f d0 7f cd  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;             else => return error.InvalidElfEndian,
   1ee04: 62 85        	mv	a0, s8
   1ee06: 97 50 00 00  	auipc	ra, 5
   1ee0a: e7 80 20 df  	jalr	-526(ra)
   1ee0e: 37 15 01 00  	lui	a0, 17
   1ee12: 93 05 05 a9  	addi	a1, a0, -1392
   1ee16: 88 03        	addi	a0, sp, 448
   1ee18: 13 06 00 11  	li	a2, 272
   1ee1c: 97 50 00 00  	auipc	ra, 5
   1ee20: e7 80 80 45  	jalr	1112(ra)
   1ee24: 93 0c f0 02  	li	s9, 47
   1ee28: 6f 10 00 73  	j	0x20558 <.LBB47_196+0x30de>
;     if (file_path.len >= MAX_PATH_BYTES) return error.NameTooLong;
   1ee2c: 62 85        	mv	a0, s8
   1ee2e: 97 50 00 00  	auipc	ra, 5
   1ee32: e7 80 a0 dc  	jalr	-566(ra)
;         const path_c = try os.toPosixPath(sub_path);
   1ee36: 62 85        	mv	a0, s8
   1ee38: 97 50 00 00  	auipc	ra, 5
   1ee3c: e7 80 00 dc  	jalr	-576(ra)
   1ee40: e9 49        	li	s3, 26
   1ee42: 75 a0        	j	0x1eeee <.LBB47_196+0x1a74>
   1ee44: 05 45        	li	a0, 1
;         var di = DW.DwarfInfo{
   1ee46: 85 65        	lui	a1, 1
   1ee48: 9b 85 85 3d  	addiw	a1, a1, 984
   1ee4c: 8a 95        	add	a1, a1, sp
   1ee4e: 23 80 a5 00  	sb	a0, 0(a1)
   1ee52: 72 6c        	ld	s8, 280(sp)
;             .debug_info = opt_debug_info orelse return error.MissingDebugInfo,
   1ee54: 62 85        	mv	a0, s8
   1ee56: 97 50 00 00  	auipc	ra, 5
   1ee5a: e7 80 20 da  	jalr	-606(ra)
   1ee5e: 37 15 01 00  	lui	a0, 17
   1ee62: 93 05 05 bc  	addi	a1, a0, -1088
   1ee66: 88 03        	addi	a0, sp, 448
   1ee68: 13 06 00 11  	li	a2, 272
   1ee6c: 97 50 00 00  	auipc	ra, 5
   1ee70: e7 80 80 40  	jalr	1032(ra)
   1ee74: cd 4c        	li	s9, 19
   1ee76: 0a 7a        	ld	s4, 160(sp)
   1ee78: ea 6a        	ld	s5, 152(sp)
   1ee7a: aa 7d        	ld	s11, 168(sp)
   1ee7c: 4e 7d        	ld	s10, 240(sp)
   1ee7e: 6f 10 a0 6d  	j	0x20558 <.LBB47_196+0x30de>
   1ee82: b5 45        	li	a1, 13
;     switch (errno(fstat_sym(fd, &stat))) {
   1ee84: 63 17 b5 1e  	bne	a0, a1, 0x1f072 <.LBB47_196+0x1bf8>
   1ee88: 95 4c        	li	s9, 5
   1ee8a: fd aa        	j	0x1f088 <.LBB47_196+0x1c0e>
   1ee8c: cd 4c        	li	s9, 19
   1ee8e: 62 85        	mv	a0, s8
   1ee90: 97 50 00 00  	auipc	ra, 5
   1ee94: e7 80 80 d6  	jalr	-664(ra)
;         var it = self.state.buffer_list.first;
   1ee98: 09 65        	lui	a0, 2
   1ee9a: 1b 05 05 30  	addiw	a0, a0, 768
   1ee9e: 0a 95        	add	a0, a0, sp
   1eea0: 03 39 05 00  	ld	s2, 0(a0)
   1eea4: aa 7d        	ld	s11, 168(sp)
;         while (it) |node| {
   1eea6: 63 13 09 0e  	bnez	s2, 0x1ef8c <.LBB47_196+0x1b12>
   1eeaa: 0a 7a        	ld	s4, 160(sp)
   1eeac: ea 6a        	ld	s5, 152(sp)
   1eeae: 62 85        	mv	a0, s8
   1eeb0: 97 50 00 00  	auipc	ra, 5
   1eeb4: e7 80 80 d4  	jalr	-696(ra)
   1eeb8: 62 85        	mv	a0, s8
   1eeba: 97 50 00 00  	auipc	ra, 5
   1eebe: e7 80 e0 d3  	jalr	-706(ra)
   1eec2: e3 89 0c 68  	beqz	s9, 0x1fd54 <.LBB47_196+0x28da>
   1eec6: 6f 10 80 68  	j	0x2054e <.LBB47_196+0x30d4>
;     return cwd().openFileZ(absolute_path_c, flags);
   1eeca: 62 85        	mv	a0, s8
   1eecc: 97 50 00 00  	auipc	ra, 5
   1eed0: e7 80 c0 d2  	jalr	-724(ra)
;         return openFileAbsoluteZ("/proc/self/exe", flags);
   1eed4: 23 2c 91 1a  	sw	s1, 440(sp)
   1eed8: 13 09 81 1b  	addi	s2, sp, 440
   1eedc: 63 94 09 00  	bnez	s3, 0x1eee4 <.LBB47_196+0x1a6a>
   1eee0: 6f d0 5f f8  	j	0x1ce64 <debug.printSourceAtAddress__anon_4137+0x568>
   1eee4: 62 85        	mv	a0, s8
   1eee6: 97 50 00 00  	auipc	ra, 5
   1eeea: e7 80 20 d1  	jalr	-750(ra)
   1eeee: 32 65        	ld	a0, 264(sp)
   1eef0: 0c 65        	ld	a1, 8(a0)
   1eef2: 08 61        	ld	a0, 0(a0)
   1eef4: 9c 69        	ld	a5, 16(a1)
   1eef6: 13 06 80 12  	li	a2, 296
   1eefa: 8d 46        	li	a3, 3
   1eefc: 8e 65        	ld	a1, 192(sp)
   1eefe: 6a 87        	mv	a4, s10
   1ef00: 82 97        	jalr	a5
   1ef02: 62 85        	mv	a0, s8
   1ef04: 97 50 00 00  	auipc	ra, 5
   1ef08: e7 80 40 cf  	jalr	-780(ra)
   1ef0c: 61 45        	li	a0, 24
   1ef0e: cd 4c        	li	s9, 19
;         const elf_file = copy catch |err| switch (err) {
   1ef10: 63 84 a9 00  	beq	s3, a0, 0x1ef18 <.LBB47_196+0x1a9e>
   1ef14: 6f 10 40 66  	j	0x20578 <.LBB47_196+0x30fe>
   1ef18: 6f 10 e0 65  	j	0x20576 <.LBB47_196+0x30fc>
;         var it = self.state.buffer_list.first;
   1ef1c: 09 65        	lui	a0, 2
   1ef1e: 1b 05 05 30  	addiw	a0, a0, 768
   1ef22: 0a 95        	add	a0, a0, sp
   1ef24: 03 39 05 00  	ld	s2, 0(a0)
;         while (it) |node| {
   1ef28: 63 0c 09 1c  	beqz	s2, 0x1f100 <.LBB47_196+0x1c86>
   1ef2c: 37 55 02 00  	lui	a0, 37
   1ef30: 03 3a 85 38  	ld	s4, 904(a0)
   1ef34: 3d a8        	j	0x1ef72 <.LBB47_196+0x1af8>
   1ef36: 09 65        	lui	a0, 2
   1ef38: 1b 05 05 2f  	addiw	a0, a0, 752
   1ef3c: 0a 95        	add	a0, a0, sp
   1ef3e: 83 39 05 00  	ld	s3, 0(a0)
   1ef42: 09 65        	lui	a0, 2
   1ef44: 1b 05 85 2f  	addiw	a0, a0, 760
   1ef48: 0a 95        	add	a0, a0, sp
   1ef4a: 83 3a 05 00  	ld	s5, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1ef4e: 93 05 a0 0a  	li	a1, 170
   1ef52: 22 85        	mv	a0, s0
   1ef54: 26 86        	mv	a2, s1
   1ef56: 97 50 00 00  	auipc	ra, 5
   1ef5a: e7 80 40 34  	jalr	836(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1ef5e: 83 b7 0a 01  	ld	a5, 16(s5)
   1ef62: 4e 85        	mv	a0, s3
   1ef64: a2 85        	mv	a1, s0
   1ef66: 26 86        	mv	a2, s1
   1ef68: 81 46        	li	a3, 0
   1ef6a: 6a 87        	mv	a4, s10
   1ef6c: 82 97        	jalr	a5
;         while (it) |node| {
   1ef6e: 63 09 09 18  	beqz	s2, 0x1f100 <.LBB47_196+0x1c86>
;             self.child_allocator.free(node.data);
   1ef72: 03 35 09 01  	ld	a0, 16(s2)
   1ef76: 81 44        	li	s1, 0
   1ef78: 52 84        	mv	s0, s4
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1ef7a: 01 c5        	beqz	a0, 0x1ef82 <.LBB47_196+0x1b08>
   1ef7c: 03 34 89 00  	ld	s0, 8(s2)
   1ef80: aa 84        	mv	s1, a0
   1ef82: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1ef86: e5 d4        	beqz	s1, 0x1ef6e <.LBB47_196+0x1af4>
   1ef88: 5d f4        	bnez	s0, 0x1ef36 <.LBB47_196+0x1abc>
   1ef8a: d1 a8        	j	0x1f05e <.LBB47_196+0x1be4>
   1ef8c: 37 55 02 00  	lui	a0, 37
   1ef90: 83 3a 85 38  	ld	s5, 904(a0)
   1ef94: 3d a8        	j	0x1efd2 <.LBB47_196+0x1b58>
   1ef96: 09 65        	lui	a0, 2
   1ef98: 1b 05 05 2f  	addiw	a0, a0, 752
   1ef9c: 0a 95        	add	a0, a0, sp
   1ef9e: 03 3a 05 00  	ld	s4, 0(a0)
   1efa2: 09 65        	lui	a0, 2
   1efa4: 1b 05 85 2f  	addiw	a0, a0, 760
   1efa8: 0a 95        	add	a0, a0, sp
   1efaa: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1efae: 93 05 a0 0a  	li	a1, 170
   1efb2: 22 85        	mv	a0, s0
   1efb4: 26 86        	mv	a2, s1
   1efb6: 97 50 00 00  	auipc	ra, 5
   1efba: e7 80 40 2e  	jalr	740(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1efbe: 83 37 0b 01  	ld	a5, 16(s6)
   1efc2: 52 85        	mv	a0, s4
   1efc4: a2 85        	mv	a1, s0
   1efc6: 26 86        	mv	a2, s1
   1efc8: 81 46        	li	a3, 0
   1efca: 6a 87        	mv	a4, s10
   1efcc: 82 97        	jalr	a5
;         while (it) |node| {
   1efce: e3 0e 09 ec  	beqz	s2, 0x1eeaa <.LBB47_196+0x1a30>
;             self.child_allocator.free(node.data);
   1efd2: 03 35 09 01  	ld	a0, 16(s2)
   1efd6: 81 44        	li	s1, 0
   1efd8: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1efda: 01 c5        	beqz	a0, 0x1efe2 <.LBB47_196+0x1b68>
   1efdc: 03 34 89 00  	ld	s0, 8(s2)
   1efe0: aa 84        	mv	s1, a0
   1efe2: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1efe6: e5 d4        	beqz	s1, 0x1efce <.LBB47_196+0x1b54>
   1efe8: 5d f4        	bnez	s0, 0x1ef96 <.LBB47_196+0x1b1c>
   1efea: 95 a8        	j	0x1f05e <.LBB47_196+0x1be4>
;         var it = self.state.buffer_list.first;
   1efec: 09 65        	lui	a0, 2
   1efee: 1b 05 05 30  	addiw	a0, a0, 768
   1eff2: 0a 95        	add	a0, a0, sp
   1eff4: 03 39 05 00  	ld	s2, 0(a0)
;         while (it) |node| {
   1eff8: 63 14 09 00  	bnez	s2, 0x1f000 <.LBB47_196+0x1b86>
   1effc: 6f 10 60 53  	j	0x20532 <.LBB47_196+0x30b8>
   1f000: 37 55 02 00  	lui	a0, 37
   1f004: 83 3a 85 38  	ld	s5, 904(a0)
   1f008: 3d a8        	j	0x1f046 <.LBB47_196+0x1bcc>
   1f00a: 09 65        	lui	a0, 2
   1f00c: 1b 05 05 2f  	addiw	a0, a0, 752
   1f010: 0a 95        	add	a0, a0, sp
   1f012: 03 3a 05 00  	ld	s4, 0(a0)
   1f016: 09 65        	lui	a0, 2
   1f018: 1b 05 85 2f  	addiw	a0, a0, 760
   1f01c: 0a 95        	add	a0, a0, sp
   1f01e: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   1f022: 93 05 a0 0a  	li	a1, 170
   1f026: 22 85        	mv	a0, s0
   1f028: 26 86        	mv	a2, s1
   1f02a: 97 50 00 00  	auipc	ra, 5
   1f02e: e7 80 00 27  	jalr	624(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1f032: 83 37 0b 01  	ld	a5, 16(s6)
   1f036: 52 85        	mv	a0, s4
   1f038: a2 85        	mv	a1, s0
   1f03a: 26 86        	mv	a2, s1
   1f03c: 81 46        	li	a3, 0
   1f03e: 6a 87        	mv	a4, s10
   1f040: 82 97        	jalr	a5
;         while (it) |node| {
   1f042: 63 06 09 0a  	beqz	s2, 0x1f0ee <.LBB47_196+0x1c74>
;             self.child_allocator.free(node.data);
   1f046: 03 35 09 01  	ld	a0, 16(s2)
   1f04a: 81 44        	li	s1, 0
   1f04c: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1f04e: 01 c5        	beqz	a0, 0x1f056 <.LBB47_196+0x1bdc>
   1f050: 03 34 89 00  	ld	s0, 8(s2)
   1f054: aa 84        	mv	s1, a0
   1f056: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   1f05a: e5 d4        	beqz	s1, 0x1f042 <.LBB47_196+0x1bc8>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1f05c: 5d f4        	bnez	s0, 0x1f00a <.LBB47_196+0x1b90>
   1f05e: 37 25 01 00  	lui	a0, 18
   1f062: 13 05 a5 86  	addi	a0, a0, -1942
   1f066: f9 45        	li	a1, 30
   1f068: 81 46        	li	a3, 0
   1f06a: 97 40 00 00  	auipc	ra, 4
   1f06e: e7 80 00 31  	jalr	784(ra)
   1f072: d9 45        	li	a1, 22
;     switch (errno(fstat_sym(fd, &stat))) {
   1f074: 63 14 b5 00  	bne	a0, a1, 0x1f07c <.LBB47_196+0x1c02>
   1f078: 6f d0 ff a5  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     return error.Unexpected;
   1f07c: 62 85        	mv	a0, s8
   1f07e: 97 50 00 00  	auipc	ra, 5
   1f082: e7 80 a0 b7  	jalr	-1158(ra)
   1f086: b5 4c        	li	s9, 13
   1f088: 62 85        	mv	a0, s8
   1f08a: 97 50 00 00  	auipc	ra, 5
   1f08e: e7 80 e0 b6  	jalr	-1170(ra)
;         const st = try os.fstat(self.handle);
   1f092: 62 85        	mv	a0, s8
   1f094: 97 50 00 00  	auipc	ra, 5
   1f098: e7 80 40 b6  	jalr	-1180(ra)
;         return (try self.stat()).size;
   1f09c: 62 85        	mv	a0, s8
   1f09e: 97 50 00 00  	auipc	ra, 5
   1f0a2: e7 80 a0 b5  	jalr	-1190(ra)
;         defer file.close();
   1f0a6: 03 25 09 00  	lw	a0, 0(s2)
;     return asm volatile ("ecall"
   1f0aa: 93 08 90 03  	li	a7, 57
   1f0ae: 73 00 00 00  	ecall	
   1f0b2: fd 75        	lui	a1, 1048575
   1f0b4: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   1f0b6: b3 35 b5 00  	sltu	a1, a0, a1
   1f0ba: 42 15        	slli	a0, a0, 48
   1f0bc: 41 91        	srli	a0, a0, 48
   1f0be: 41 66        	lui	a2, 16
   1f0c0: 5d 36        	addiw	a2, a2, -9
   1f0c2: 31 8d        	xor	a0, a0, a2
   1f0c4: 33 35 a0 00  	snez	a0, a0
   1f0c8: 4d 8d        	or	a0, a0, a1
   1f0ca: 19 e1        	bnez	a0, 0x1f0d0 <.LBB47_196+0x1c56>
   1f0cc: 6f d0 bf a0  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
   1f0d0: 62 85        	mv	a0, s8
   1f0d2: 97 50 00 00  	auipc	ra, 5
   1f0d6: e7 80 60 b2  	jalr	-1242(ra)
   1f0da: 6f 10 40 47  	j	0x2054e <.LBB47_196+0x30d4>
;         defer tmp_arena.deinit();
   1f0de: 1b 05 05 2f  	addiw	a0, a0, 752
   1f0e2: 0a 95        	add	a0, a0, sp
   1f0e4: 97 80 ff ff  	auipc	ra, 1048568
   1f0e8: e7 80 a0 29  	jalr	666(ra)
   1f0ec: 72 6c        	ld	s8, 280(sp)
   1f0ee: 62 85        	mv	a0, s8
   1f0f0: 97 50 00 00  	auipc	ra, 5
   1f0f4: e7 80 80 b0  	jalr	-1272(ra)
;     try di.scanAllFunctions(allocator);
   1f0f8: 63 84 0c 00  	beqz	s9, 0x1f100 <.LBB47_196+0x1c86>
   1f0fc: 6f 10 00 44  	j	0x2053c <.LBB47_196+0x30c2>
;         var stream = io.fixedBufferStream(di.debug_info);
   1f100: 05 65        	lui	a0, 1
   1f102: 1b 05 05 2d  	addiw	a0, a0, 720
   1f106: 0a 95        	add	a0, a0, sp
   1f108: 0c 61        	ld	a1, 0(a0)
   1f10a: 05 65        	lui	a0, 1
   1f10c: 1b 05 85 2d  	addiw	a0, a0, 728
   1f110: 0a 95        	add	a0, a0, sp
   1f112: 08 61        	ld	a0, 0(a0)
   1f114: 03 36 0c 00  	ld	a2, 0(s8)
   1f118: 32 e5        	sd	a2, 136(sp)
   1f11a: 09 66        	lui	a2, 2
   1f11c: 1b 06 06 38  	addiw	a2, a2, 896
   1f120: 0a 96        	add	a2, a2, sp
   1f122: 0c e2        	sd	a1, 0(a2)
   1f124: 89 65        	lui	a1, 2
   1f126: 9b 85 85 38  	addiw	a1, a1, 904
   1f12a: 8a 95        	add	a1, a1, sp
   1f12c: 88 e1        	sd	a0, 0(a1)
   1f12e: 89 65        	lui	a1, 2
   1f130: 9b 85 05 38  	addiw	a1, a1, 896
   1f134: 8a 95        	add	a1, a1, sp
;         const in = &stream.reader();
   1f136: 09 66        	lui	a2, 2
   1f138: 1b 06 86 53  	addiw	a2, a2, 1336
   1f13c: 0a 96        	add	a2, a2, sp
   1f13e: 0c e2        	sd	a1, 0(a2)
;         while (this_unit_offset < try seekable.getEndPos()) {
   1f140: e3 05 05 40  	beqz	a0, 0x1fd4a <.LBB47_196+0x28d0>
   1f144: 01 4a        	li	s4, 0
   1f146: 13 0b a0 0a  	li	s6, 170
   1f14a: ad 65        	lui	a1, 11
   1f14c: 9b 85 a5 aa  	addiw	a1, a1, -1366
   1f150: 2e fd        	sd	a1, 184(sp)
   1f152: 89 65        	lui	a1, 2
   1f154: 9b 85 85 3c  	addiw	a1, a1, 968
   1f158: 33 0d b1 00  	add	s10, sp, a1
   1f15c: 89 4a        	li	s5, 2
   1f15e: c1 65        	lui	a1, 16
   1f160: ed 35        	addiw	a1, a1, -5
   1f162: 2e f9        	sd	a1, 176(sp)
   1f164: b7 55 02 00  	lui	a1, 37
   1f168: 83 b5 85 38  	ld	a1, 904(a1)
   1f16c: ae e5        	sd	a1, 200(sp)
   1f16e: a1 4b        	li	s7, 8
   1f170: b7 b5 aa aa  	lui	a1, 699051
   1f174: 9b 85 a5 aa  	addiw	a1, a1, -1366
   1f178: 2e e1        	sd	a1, 128(sp)
   1f17a: b7 55 02 00  	lui	a1, 37
   1f17e: 83 b5 05 3b  	ld	a1, 944(a1)
   1f182: ae fc        	sd	a1, 120(sp)
   1f184: b7 15 01 00  	lui	a1, 17
   1f188: 93 89 05 02  	addi	s3, a1, 32
   1f18c: 63 63 45 01  	bltu	a0, s4, 0x1f192 <.LBB47_196+0x1d18>
   1f190: 52 85        	mv	a0, s4
;             const unit_length = try readUnitLength(in, di.endian, &is_64);
   1f192: 85 65        	lui	a1, 1
   1f194: 9b 85 85 3d  	addiw	a1, a1, 984
   1f198: 8a 95        	add	a1, a1, sp
   1f19a: 83 86 05 00  	lb	a3, 0(a1)
   1f19e: 89 65        	lui	a1, 2
   1f1a0: 9b 85 05 39  	addiw	a1, a1, 912
   1f1a4: 8a 95        	add	a1, a1, sp
   1f1a6: 88 e1        	sd	a0, 0(a1)
;             var is_64: bool = undefined;
   1f1a8: 09 65        	lui	a0, 2
   1f1aa: 1b 05 85 32  	addiw	a0, a0, 808
   1f1ae: 0a 95        	add	a0, a0, sp
   1f1b0: 23 00 65 01  	sb	s6, 0(a0)
;             const unit_length = try readUnitLength(in, di.endian, &is_64);
   1f1b4: 09 65        	lui	a0, 2
   1f1b6: 1b 05 05 2d  	addiw	a0, a0, 720
   1f1ba: 0a 95        	add	a0, a0, sp
   1f1bc: 89 65        	lui	a1, 2
   1f1be: 9b 85 85 53  	addiw	a1, a1, 1336
   1f1c2: 33 06 b1 00  	add	a2, sp, a1
   1f1c6: 89 65        	lui	a1, 2
   1f1c8: 9b 85 85 32  	addiw	a1, a1, 808
   1f1cc: 33 07 b1 00  	add	a4, sp, a1
   1f1d0: f2 65        	ld	a1, 280(sp)
   1f1d2: 97 90 ff ff  	auipc	ra, 1048569
   1f1d6: e7 80 40 87  	jalr	-1932(ra)
   1f1da: 09 65        	lui	a0, 2
   1f1dc: 1b 05 85 2d  	addiw	a0, a0, 728
   1f1e0: 0a 95        	add	a0, a0, sp
   1f1e2: 83 5c 05 00  	lhu	s9, 0(a0)
   1f1e6: 63 84 0c 00  	beqz	s9, 0x1f1ee <.LBB47_196+0x1d74>
   1f1ea: 6f 10 60 34  	j	0x20530 <.LBB47_196+0x30b6>
   1f1ee: 09 65        	lui	a0, 2
   1f1f0: 1b 05 05 2d  	addiw	a0, a0, 720
   1f1f4: 0a 95        	add	a0, a0, sp
   1f1f6: 08 61        	ld	a0, 0(a0)
;             if (unit_length == 0) return;
   1f1f8: e3 09 05 34  	beqz	a0, 0x1fd4a <.LBB47_196+0x28d0>
;             const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1f1fc: 89 65        	lui	a1, 2
   1f1fe: 9b 85 85 32  	addiw	a1, a1, 808
   1f202: 8a 95        	add	a1, a1, sp
   1f204: 03 cc 05 00  	lbu	s8, 0(a1)
   1f208: b1 45        	li	a1, 12
   1f20a: 63 13 0c 00  	bnez	s8, 0x1f210 <.LBB47_196+0x1d96>
   1f20e: 91 45        	li	a1, 4
;             const next_offset = unit_length + (if (is_64) @as(usize, 12) else @as(usize, 4));
   1f210: aa 95        	add	a1, a1, a0
   1f212: 2e e2        	sd	a1, 256(sp)
   1f214: 63 f4 a5 00  	bgeu	a1, a0, 0x1f21c <.LBB47_196+0x1da2>
   1f218: 6f 10 80 4c  	j	0x206e0 <.LBB47_196+0x3266>
;             const version = try in.readInt(u16, di.endian);
   1f21c: 05 65        	lui	a0, 1
   1f21e: 1b 05 85 3d  	addiw	a0, a0, 984
   1f222: 0a 95        	add	a0, a0, sp
   1f224: 03 09 05 00  	lb	s2, 0(a0)
;             const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);
   1f228: 09 65        	lui	a0, 2
   1f22a: 1b 05 85 53  	addiw	a0, a0, 1336
   1f22e: 0a 95        	add	a0, a0, sp
   1f230: 00 61        	ld	s0, 0(a0)
   1f232: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1f234: 6a 75        	ld	a0, 184(sp)
   1f236: 89 65        	lui	a1, 2
   1f238: 9b 85 85 3c  	addiw	a1, a1, 968
   1f23c: 8a 95        	add	a1, a1, sp
   1f23e: 23 90 a5 00  	sh	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1f242: 33 06 9d 00  	add	a2, s10, s1
   1f246: b3 86 9a 40  	sub	a3, s5, s1
;             return readFn(self.context, buffer);
   1f24a: 88 0d        	addi	a0, sp, 720
   1f24c: a2 85        	mv	a1, s0
   1f24e: 97 20 00 00  	auipc	ra, 2
   1f252: e7 80 a0 46  	jalr	1130(ra)
   1f256: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1f25a: 19 e1        	bnez	a0, 0x1f260 <.LBB47_196+0x1de6>
   1f25c: 6f 10 80 03  	j	0x20294 <.LBB47_196+0x2e1a>
;                 index += amt;
   1f260: 26 95        	add	a0, a0, s1
   1f262: 63 74 95 00  	bgeu	a0, s1, 0x1f26a <.LBB47_196+0x1df0>
   1f266: 6f 10 a0 47  	j	0x206e0 <.LBB47_196+0x3266>
   1f26a: aa 84        	mv	s1, a0
;             while (index < len) {
   1f26c: e3 6b 55 fd  	bltu	a0, s5, 0x1f242 <.LBB47_196+0x1dc8>
;             return bytes;
   1f270: 09 65        	lui	a0, 2
   1f272: 1b 05 85 3c  	addiw	a0, a0, 968
   1f276: 0a 95        	add	a0, a0, sp
   1f278: 83 54 05 00  	lhu	s1, 0(a0)
;     if (endian == native_endian) {
   1f27c: 13 75 19 00  	andi	a0, s2, 1
   1f280: 19 e5        	bnez	a0, 0x1f28e <.LBB47_196+0x1e14>
   1f282: 13 d5 84 00  	srli	a0, s1, 8
   1f286: 93 95 84 00  	slli	a1, s1, 8
   1f28a: b3 e4 a5 00  	or	s1, a1, a0
;             if (version < 2 or version > 5) return badDwarf();
   1f28e: 1b 85 a4 ff  	addiw	a0, s1, -6
   1f292: 42 15        	slli	a0, a0, 48
   1f294: 41 91        	srli	a0, a0, 48
   1f296: ca 75        	ld	a1, 176(sp)
   1f298: 63 e4 a5 00  	bltu	a1, a0, 0x1f2a0 <.LBB47_196+0x1e26>
   1f29c: 6f 10 80 45  	j	0x206f4 <.LBB47_196+0x327a>
;             if (version >= 5) {
   1f2a0: 13 95 04 03  	slli	a0, s1, 48
   1f2a4: 41 91        	srli	a0, a0, 48
   1f2a6: 95 45        	li	a1, 5
   1f2a8: a6 e9        	sd	s1, 208(sp)
   1f2aa: 63 6d b5 12  	bltu	a0, a1, 0x1f3e4 <.LBB47_196+0x1f6a>
;             var bytes: [num_bytes]u8 = undefined;
   1f2ae: 09 65        	lui	a0, 2
   1f2b0: 1b 05 85 3c  	addiw	a0, a0, 968
   1f2b4: 0a 95        	add	a0, a0, sp
   1f2b6: 23 00 65 01  	sb	s6, 0(a0)
;             return readFn(self.context, buffer);
   1f2ba: 88 0d        	addi	a0, sp, 720
   1f2bc: 89 65        	lui	a1, 2
   1f2be: 9b 85 85 3c  	addiw	a1, a1, 968
   1f2c2: 33 06 b1 00  	add	a2, sp, a1
   1f2c6: 85 46        	li	a3, 1
   1f2c8: a2 85        	mv	a1, s0
   1f2ca: 97 20 00 00  	auipc	ra, 2
   1f2ce: e7 80 e0 3e  	jalr	1006(ra)
   1f2d2: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1f2d6: 19 e1        	bnez	a0, 0x1f2dc <.LBB47_196+0x1e62>
   1f2d8: 6f 00 d0 7b  	j	0x20294 <.LBB47_196+0x2e1a>
;             return bytes;
   1f2dc: 09 65        	lui	a0, 2
   1f2de: 1b 05 85 3c  	addiw	a0, a0, 968
   1f2e2: 0a 95        	add	a0, a0, sp
   1f2e4: 03 45 05 00  	lbu	a0, 0(a0)
;                 if (unit_type != UT.compile) return badDwarf();
   1f2e8: 85 45        	li	a1, 1
   1f2ea: 63 04 b5 00  	beq	a0, a1, 0x1f2f2 <.LBB47_196+0x1e78>
   1f2ee: 6f 10 60 40  	j	0x206f4 <.LBB47_196+0x327a>
;             var result: [1]u8 = undefined;
   1f2f2: 09 65        	lui	a0, 2
   1f2f4: 1b 05 85 3c  	addiw	a0, a0, 968
   1f2f8: 0a 95        	add	a0, a0, sp
   1f2fa: 23 00 65 01  	sb	s6, 0(a0)
;             return readFn(self.context, buffer);
   1f2fe: 88 0d        	addi	a0, sp, 720
   1f300: 89 65        	lui	a1, 2
   1f302: 9b 85 85 3c  	addiw	a1, a1, 968
   1f306: 33 06 b1 00  	add	a2, sp, a1
   1f30a: 85 46        	li	a3, 1
   1f30c: a2 85        	mv	a1, s0
   1f30e: 97 20 00 00  	auipc	ra, 2
   1f312: e7 80 a0 3a  	jalr	938(ra)
   1f316: 03 35 01 2d  	ld	a0, 720(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1f31a: 19 e1        	bnez	a0, 0x1f320 <.LBB47_196+0x1ea6>
   1f31c: 6f 10 80 5c  	j	0x208e4 <.LBB47_196+0x346a>
;             return result[0];
   1f320: 09 65        	lui	a0, 2
   1f322: 1b 05 85 3c  	addiw	a0, a0, 968
   1f326: 0a 95        	add	a0, a0, sp
   1f328: 03 49 05 00  	lbu	s2, 0(a0)
   1f32c: 05 65        	lui	a0, 1
   1f32e: 1b 05 85 3d  	addiw	a0, a0, 984
   1f332: 0a 95        	add	a0, a0, sp
   1f334: 03 0b 05 00  	lb	s6, 0(a0)
   1f338: 81 44        	li	s1, 0
;                 debug_abbrev_offset = if (is_64)
   1f33a: 63 0a 0c 72  	beqz	s8, 0x1fa6e <.LBB47_196+0x25f4>
;             var bytes: [num_bytes]u8 = undefined;
   1f33e: 2e 65        	ld	a0, 200(sp)
   1f340: 89 65        	lui	a1, 2
   1f342: 9b 85 85 3c  	addiw	a1, a1, 968
   1f346: 8a 95        	add	a1, a1, sp
   1f348: 88 e1        	sd	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1f34a: 33 06 9d 00  	add	a2, s10, s1
   1f34e: b3 86 9b 40  	sub	a3, s7, s1
;             return readFn(self.context, buffer);
   1f352: 88 0d        	addi	a0, sp, 720
   1f354: a2 85        	mv	a1, s0
   1f356: 97 20 00 00  	auipc	ra, 2
   1f35a: e7 80 20 36  	jalr	866(ra)
   1f35e: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1f362: e3 09 05 72  	beqz	a0, 0x20294 <.LBB47_196+0x2e1a>
;                 index += amt;
   1f366: 26 95        	add	a0, a0, s1
   1f368: 63 74 95 00  	bgeu	a0, s1, 0x1f370 <.LBB47_196+0x1ef6>
   1f36c: 6f 10 40 37  	j	0x206e0 <.LBB47_196+0x3266>
   1f370: aa 84        	mv	s1, a0
;             while (index < len) {
   1f372: e3 6c 75 fd  	bltu	a0, s7, 0x1f34a <.LBB47_196+0x1ed0>
;             return bytes;
   1f376: 09 65        	lui	a0, 2
   1f378: 1b 05 85 3c  	addiw	a0, a0, 968
   1f37c: 0a 95        	add	a0, a0, sp
   1f37e: 04 61        	ld	s1, 0(a0)
;     if (endian == native_endian) {
   1f380: 13 75 1b 00  	andi	a0, s6, 1
   1f384: 63 10 05 1c  	bnez	a0, 0x1f544 <.LBB47_196+0x20ca>
   1f388: 13 d5 84 01  	srli	a0, s1, 24
   1f38c: b7 05 ff 00  	lui	a1, 4080
   1f390: 6d 8d        	and	a0, a0, a1
   1f392: 93 d5 84 00  	srli	a1, s1, 8
   1f396: 93 06 f0 0f  	li	a3, 255
   1f39a: 13 96 86 01  	slli	a2, a3, 24
   1f39e: f1 8d        	and	a1, a1, a2
   1f3a0: 4d 8d        	or	a0, a0, a1
   1f3a2: 93 d5 84 02  	srli	a1, s1, 40
   1f3a6: 41 66        	lui	a2, 16
   1f3a8: 1b 06 06 f0  	addiw	a2, a2, -256
   1f3ac: f1 8d        	and	a1, a1, a2
   1f3ae: 13 d6 84 03  	srli	a2, s1, 56
   1f3b2: d1 8d        	or	a1, a1, a2
   1f3b4: 4d 8d        	or	a0, a0, a1
   1f3b6: 93 95 84 01  	slli	a1, s1, 24
   1f3ba: 13 96 86 02  	slli	a2, a3, 40
   1f3be: f1 8d        	and	a1, a1, a2
   1f3c0: 1b d6 84 01  	srliw	a2, s1, 24
   1f3c4: 02 16        	slli	a2, a2, 32
   1f3c6: d1 8d        	or	a1, a1, a2
   1f3c8: 13 96 84 02  	slli	a2, s1, 40
   1f3cc: c2 16        	slli	a3, a3, 48
   1f3ce: 75 8e        	and	a2, a2, a3
   1f3d0: 93 96 84 03  	slli	a3, s1, 56
   1f3d4: 55 8e        	or	a2, a2, a3
   1f3d6: d1 8d        	or	a1, a1, a2
   1f3d8: b3 e4 a5 00  	or	s1, a1, a0
   1f3dc: 63 08 79 17  	beq	s2, s7, 0x1f54c <.LBB47_196+0x20d2>
   1f3e0: 6f 10 40 31  	j	0x206f4 <.LBB47_196+0x327a>
   1f3e4: 05 65        	lui	a0, 1
   1f3e6: 1b 05 85 3d  	addiw	a0, a0, 984
   1f3ea: 0a 95        	add	a0, a0, sp
   1f3ec: 03 09 05 00  	lb	s2, 0(a0)
   1f3f0: 81 44        	li	s1, 0
;                 debug_abbrev_offset = if (is_64)
   1f3f2: 63 01 0c 0a  	beqz	s8, 0x1f494 <.LBB47_196+0x201a>
;             var bytes: [num_bytes]u8 = undefined;
   1f3f6: 2e 65        	ld	a0, 200(sp)
   1f3f8: 89 65        	lui	a1, 2
   1f3fa: 9b 85 85 3c  	addiw	a1, a1, 968
   1f3fe: 8a 95        	add	a1, a1, sp
   1f400: 88 e1        	sd	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1f402: 33 06 9d 00  	add	a2, s10, s1
   1f406: b3 86 9b 40  	sub	a3, s7, s1
;             return readFn(self.context, buffer);
   1f40a: 88 0d        	addi	a0, sp, 720
   1f40c: a2 85        	mv	a1, s0
   1f40e: 97 20 00 00  	auipc	ra, 2
   1f412: e7 80 a0 2a  	jalr	682(ra)
   1f416: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1f41a: e3 0d 05 66  	beqz	a0, 0x20294 <.LBB47_196+0x2e1a>
;                 index += amt;
   1f41e: 26 95        	add	a0, a0, s1
   1f420: 63 74 95 00  	bgeu	a0, s1, 0x1f428 <.LBB47_196+0x1fae>
   1f424: 6f 10 c0 2b  	j	0x206e0 <.LBB47_196+0x3266>
   1f428: aa 84        	mv	s1, a0
;             while (index < len) {
   1f42a: e3 6c 75 fd  	bltu	a0, s7, 0x1f402 <.LBB47_196+0x1f88>
;             return bytes;
   1f42e: 09 65        	lui	a0, 2
   1f430: 1b 05 85 3c  	addiw	a0, a0, 968
   1f434: 0a 95        	add	a0, a0, sp
   1f436: 04 61        	ld	s1, 0(a0)
;     if (endian == native_endian) {
   1f438: 13 75 19 00  	andi	a0, s2, 1
   1f43c: 79 e5        	bnez	a0, 0x1f50a <.LBB47_196+0x2090>
   1f43e: 13 d5 84 01  	srli	a0, s1, 24
   1f442: b7 05 ff 00  	lui	a1, 4080
   1f446: 6d 8d        	and	a0, a0, a1
   1f448: 93 d5 84 00  	srli	a1, s1, 8
   1f44c: 93 06 f0 0f  	li	a3, 255
   1f450: 13 96 86 01  	slli	a2, a3, 24
   1f454: f1 8d        	and	a1, a1, a2
   1f456: 4d 8d        	or	a0, a0, a1
   1f458: 93 d5 84 02  	srli	a1, s1, 40
   1f45c: 41 66        	lui	a2, 16
   1f45e: 1b 06 06 f0  	addiw	a2, a2, -256
   1f462: f1 8d        	and	a1, a1, a2
   1f464: 13 d6 84 03  	srli	a2, s1, 56
   1f468: d1 8d        	or	a1, a1, a2
   1f46a: 4d 8d        	or	a0, a0, a1
   1f46c: 93 95 84 01  	slli	a1, s1, 24
   1f470: 13 96 86 02  	slli	a2, a3, 40
   1f474: f1 8d        	and	a1, a1, a2
   1f476: 1b d6 84 01  	srliw	a2, s1, 24
   1f47a: 02 16        	slli	a2, a2, 32
   1f47c: d1 8d        	or	a1, a1, a2
   1f47e: 13 96 84 02  	slli	a2, s1, 40
   1f482: c2 16        	slli	a3, a3, 48
   1f484: 75 8e        	and	a2, a2, a3
   1f486: 93 96 84 03  	slli	a3, s1, 56
   1f48a: 55 8e        	or	a2, a2, a3
   1f48c: d1 8d        	or	a1, a1, a2
   1f48e: b3 e4 a5 00  	or	s1, a1, a0
   1f492: a5 a8        	j	0x1f50a <.LBB47_196+0x2090>
;             var bytes: [num_bytes]u8 = undefined;
   1f494: 0a 65        	ld	a0, 128(sp)
   1f496: 89 65        	lui	a1, 2
   1f498: 9b 85 85 3c  	addiw	a1, a1, 968
   1f49c: 8a 95        	add	a1, a1, sp
   1f49e: 88 c1        	sw	a0, 0(a1)
   1f4a0: 91 45        	li	a1, 4
;                 const amt = try self.read(buffer[index..]);
   1f4a2: 33 06 9d 00  	add	a2, s10, s1
   1f4a6: b3 86 95 40  	sub	a3, a1, s1
;             return readFn(self.context, buffer);
   1f4aa: 88 0d        	addi	a0, sp, 720
   1f4ac: a2 85        	mv	a1, s0
   1f4ae: 97 20 00 00  	auipc	ra, 2
   1f4b2: e7 80 a0 20  	jalr	522(ra)
   1f4b6: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1f4ba: e3 0d 05 5c  	beqz	a0, 0x20294 <.LBB47_196+0x2e1a>
;                 index += amt;
   1f4be: 26 95        	add	a0, a0, s1
   1f4c0: 63 74 95 00  	bgeu	a0, s1, 0x1f4c8 <.LBB47_196+0x204e>
   1f4c4: 6f 10 c0 21  	j	0x206e0 <.LBB47_196+0x3266>
   1f4c8: aa 84        	mv	s1, a0
   1f4ca: 91 45        	li	a1, 4
;             while (index < len) {
   1f4cc: e3 6b b5 fc  	bltu	a0, a1, 0x1f4a2 <.LBB47_196+0x2028>
;             return bytes;
   1f4d0: 09 65        	lui	a0, 2
   1f4d2: 1b 05 85 3c  	addiw	a0, a0, 968
   1f4d6: 0a 95        	add	a0, a0, sp
   1f4d8: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1f4dc: 93 75 19 00  	andi	a1, s2, 1
   1f4e0: 95 e1        	bnez	a1, 0x1f504 <.LBB47_196+0x208a>
   1f4e2: 93 55 85 00  	srli	a1, a0, 8
   1f4e6: 41 66        	lui	a2, 16
   1f4e8: 1b 06 06 f0  	addiw	a2, a2, -256
   1f4ec: f1 8d        	and	a1, a1, a2
   1f4ee: 13 56 85 01  	srli	a2, a0, 24
   1f4f2: d1 8d        	or	a1, a1, a2
   1f4f4: 13 16 85 00  	slli	a2, a0, 8
   1f4f8: b7 06 ff 00  	lui	a3, 4080
   1f4fc: 75 8e        	and	a2, a2, a3
   1f4fe: 62 05        	slli	a0, a0, 24
   1f500: 51 8d        	or	a0, a0, a2
   1f502: 4d 8d        	or	a0, a0, a1
;                     try in.readInt(u32, di.endian);
   1f504: 02 15        	slli	a0, a0, 32
   1f506: 93 54 05 02  	srli	s1, a0, 32
;             var result: [1]u8 = undefined;
   1f50a: 09 65        	lui	a0, 2
   1f50c: 1b 05 85 3c  	addiw	a0, a0, 968
   1f510: 0a 95        	add	a0, a0, sp
   1f512: 23 00 65 01  	sb	s6, 0(a0)
;             return readFn(self.context, buffer);
   1f516: 88 0d        	addi	a0, sp, 720
   1f518: 89 65        	lui	a1, 2
   1f51a: 9b 85 85 3c  	addiw	a1, a1, 968
   1f51e: 33 06 b1 00  	add	a2, sp, a1
   1f522: 85 46        	li	a3, 1
   1f524: a2 85        	mv	a1, s0
   1f526: 97 20 00 00  	auipc	ra, 2
   1f52a: e7 80 20 19  	jalr	402(ra)
   1f52e: 03 35 01 2d  	ld	a0, 720(sp)
;             if (amt_read < 1) return error.EndOfStream;
   1f532: 19 e1        	bnez	a0, 0x1f538 <.LBB47_196+0x20be>
   1f534: 6f 10 00 3b  	j	0x208e4 <.LBB47_196+0x346a>
;             return result[0];
   1f538: 09 65        	lui	a0, 2
   1f53a: 1b 05 85 3c  	addiw	a0, a0, 968
   1f53e: 0a 95        	add	a0, a0, sp
   1f540: 03 49 05 00  	lbu	s2, 0(a0)
;             if (address_size != @sizeOf(usize)) return badDwarf();
   1f544: 63 04 79 01  	beq	s2, s7, 0x1f54c <.LBB47_196+0x20d2>
   1f548: 6f 10 c0 1a  	j	0x206f4 <.LBB47_196+0x327a>
;             const compile_unit_pos = try seekable.getPos();
   1f54c: 09 65        	lui	a0, 2
   1f54e: 1b 05 05 39  	addiw	a0, a0, 912
   1f552: 0a 95        	add	a0, a0, sp
   1f554: 00 61        	ld	s0, 0(a0)
;             const abbrev_table = try di.getAbbrevTable(allocator, debug_abbrev_offset);
   1f556: 09 65        	lui	a0, 2
   1f558: 1b 05 85 46  	addiw	a0, a0, 1128
   1f55c: 0a 95        	add	a0, a0, sp
   1f55e: 85 65        	lui	a1, 1
   1f560: 9b 85 05 2d  	addiw	a1, a1, 720
   1f564: 33 06 b1 00  	add	a2, sp, a1
   1f568: f2 65        	ld	a1, 280(sp)
   1f56a: b2 66        	ld	a3, 264(sp)
   1f56c: 26 87        	mv	a4, s1
   1f56e: 97 50 ff ff  	auipc	ra, 1048565
   1f572: e7 80 c0 31  	jalr	796(ra)
   1f576: 09 65        	lui	a0, 2
   1f578: 1b 05 05 47  	addiw	a0, a0, 1136
   1f57c: 0a 95        	add	a0, a0, sp
   1f57e: 83 5c 05 00  	lhu	s9, 0(a0)
   1f582: 63 84 0c 00  	beqz	s9, 0x1f58a <.LBB47_196+0x2110>
   1f586: 6f 00 b0 7a  	j	0x20530 <.LBB47_196+0x30b6>
;             self.pos = if (std.math.cast(usize, pos)) |x| std.math.min(self.buffer.len, x) else self.buffer.len;
   1f58a: 09 65        	lui	a0, 2
   1f58c: 1b 05 85 38  	addiw	a0, a0, 904
   1f590: 0a 95        	add	a0, a0, sp
   1f592: 08 61        	ld	a0, 0(a0)
   1f594: 63 63 85 00  	bltu	a0, s0, 0x1f59a <.LBB47_196+0x2120>
   1f598: 22 85        	mv	a0, s0
   1f59a: 89 65        	lui	a1, 2
   1f59c: 9b 85 05 39  	addiw	a1, a1, 912
   1f5a0: 8a 95        	add	a1, a1, sp
   1f5a2: 88 e1        	sd	a0, 0(a1)
   1f5a4: 32 65        	ld	a0, 264(sp)
;             const compile_unit_die = try allocator.create(Die);
   1f5a6: 0c 65        	ld	a1, 8(a0)
   1f5a8: 09 66        	lui	a2, 2
   1f5aa: 1b 06 86 46  	addiw	a2, a2, 1128
   1f5ae: 0a 96        	add	a2, a2, sp
   1f5b0: 00 62        	ld	s0, 0(a2)
;             const compile_unit_die = try allocator.create(Die);
   1f5b2: 08 61        	ld	a0, 0(a0)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1f5b4: 98 61        	ld	a4, 0(a1)
   1f5b6: 93 05 80 04  	li	a1, 72
   1f5ba: 0d 46        	li	a2, 3
   1f5bc: ce 76        	ld	a3, 240(sp)
   1f5be: 02 97        	jalr	a4
   1f5c0: 19 e1        	bnez	a0, 0x1f5c6 <.LBB47_196+0x214c>
   1f5c2: 6f 10 e0 32  	j	0x208f0 <.LBB47_196+0x3476>
   1f5c6: aa 84        	mv	s1, a0
   1f5c8: 52 ea        	sd	s4, 272(sp)
;     @memset(byte_ptr, undefined, byte_count);
   1f5ca: 93 05 a0 0a  	li	a1, 170
   1f5ce: 13 06 80 04  	li	a2, 72
   1f5d2: 97 50 00 00  	auipc	ra, 5
   1f5d6: e7 80 80 cc  	jalr	-824(ra)
   1f5da: a6 ed        	sd	s1, 216(sp)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   1f5dc: 13 f5 74 00  	andi	a0, s1, 7
   1f5e0: 19 c1        	beqz	a0, 0x1f5e6 <.LBB47_196+0x216c>
   1f5e2: 6f d0 0f da  	j	0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;         const abbrev_code = try leb.readULEB128(u64, in_stream);
   1f5e6: 09 65        	lui	a0, 2
   1f5e8: 1b 05 05 2f  	addiw	a0, a0, 752
   1f5ec: 0a 95        	add	a0, a0, sp
   1f5ee: 89 65        	lui	a1, 2
   1f5f0: 9b 85 85 53  	addiw	a1, a1, 1336
   1f5f4: 33 06 b1 00  	add	a2, sp, a1
   1f5f8: f2 65        	ld	a1, 280(sp)
   1f5fa: 97 50 ff ff  	auipc	ra, 1048565
   1f5fe: e7 80 c0 cf  	jalr	-772(ra)
   1f602: 09 65        	lui	a0, 2
   1f604: 1b 05 85 2f  	addiw	a0, a0, 760
   1f608: 0a 95        	add	a0, a0, sp
   1f60a: 83 5c 05 00  	lhu	s9, 0(a0)
   1f60e: e3 92 0c 70  	bnez	s9, 0x20512 <.LBB47_196+0x3098>
   1f612: 09 65        	lui	a0, 2
   1f614: 1b 05 05 2f  	addiw	a0, a0, 752
   1f618: 0a 95        	add	a0, a0, sp
   1f61a: 08 61        	ld	a0, 0(a0)
;         if (abbrev_code == 0) return null;
   1f61c: 19 e1        	bnez	a0, 0x1f622 <.LBB47_196+0x21a8>
   1f61e: 6f 10 a0 2e  	j	0x20908 <.LBB47_196+0x348e>
;     for (abbrev_table.items) |*table_entry| {
   1f622: 0c 64        	ld	a1, 8(s0)
   1f624: 93 0c 20 03  	li	s9, 50
   1f628: e3 8f 05 6c  	beqz	a1, 0x20506 <.LBB47_196+0x308c>
   1f62c: 00 60        	ld	s0, 0(s0)
;         if (table_entry.abbrev_code == abbrev_code) return table_entry;
   1f62e: 10 60        	ld	a2, 0(s0)
   1f630: 63 08 a6 00  	beq	a2, a0, 0x1f640 <.LBB47_196+0x21c6>
;     for (abbrev_table.items) |*table_entry| {
   1f634: fd 15        	addi	a1, a1, -1
   1f636: 13 04 04 04  	addi	s0, s0, 64
   1f63a: f5 f9        	bnez	a1, 0x1f62e <.LBB47_196+0x21b4>
   1f63c: 6f 00 b0 6c  	j	0x20506 <.LBB47_196+0x308c>
   1f640: b2 65        	ld	a1, 264(sp)
;             return .{
   1f642: 88 65        	ld	a0, 8(a1)
   1f644: 09 66        	lui	a2, 2
   1f646: 1b 06 06 3d  	addiw	a2, a2, 976
   1f64a: 0a 96        	add	a2, a2, sp
   1f64c: 08 e2        	sd	a0, 0(a2)
   1f64e: 88 61        	ld	a0, 0(a1)
   1f650: 89 65        	lui	a1, 2
   1f652: 9b 85 85 3c  	addiw	a1, a1, 968
   1f656: 8a 95        	add	a1, a1, sp
   1f658: 88 e1        	sd	a0, 0(a1)
   1f65a: 09 65        	lui	a0, 2
   1f65c: 1b 05 85 3d  	addiw	a0, a0, 984
   1f660: 0a 95        	add	a0, a0, sp
   1f662: 23 34 05 00  	sd	zero, 8(a0)
   1f666: 23 30 05 00  	sd	zero, 0(a0)
;         return (State{}).promote(child_allocator);
   1f66a: 09 65        	lui	a0, 2
   1f66c: 1b 05 05 3e  	addiw	a0, a0, 992
   1f670: 0a 95        	add	a0, a0, sp
   1f672: 08 61        	ld	a0, 0(a0)
   1f674: 89 65        	lui	a1, 2
   1f676: 9b 85 85 3d  	addiw	a1, a1, 984
   1f67a: 8a 95        	add	a1, a1, sp
   1f67c: 8c 61        	ld	a1, 0(a1)
   1f67e: 09 66        	lui	a2, 2
   1f680: 1b 06 06 3d  	addiw	a2, a2, 976
   1f684: 0a 96        	add	a2, a2, sp
   1f686: 10 62        	ld	a2, 0(a2)
   1f688: 89 66        	lui	a3, 2
   1f68a: 9b 86 86 3c  	addiw	a3, a3, 968
   1f68e: 8a 96        	add	a3, a3, sp
   1f690: 94 62        	ld	a3, 0(a3)
   1f692: 23 34 a1 2e  	sd	a0, 744(sp)
   1f696: 23 30 b1 2e  	sd	a1, 736(sp)
   1f69a: 23 3c c1 2c  	sd	a2, 728(sp)
   1f69e: 23 38 d1 2c  	sd	a3, 720(sp)
;             .tag_id = table_entry.tag_id,
   1f6a2: 08 64        	ld	a0, 8(s0)
   1f6a4: 23 38 a1 2e  	sd	a0, 752(sp)
;             .has_children = table_entry.has_children,
   1f6a8: 03 45 84 03  	lbu	a0, 56(s0)
   1f6ac: 05 89        	andi	a0, a0, 1
   1f6ae: 23 08 a1 30  	sb	a0, 784(sp)
   1f6b2: a8 1d        	addi	a0, sp, 760
   1f6b4: 23 38 05 00  	sd	zero, 16(a0)
   1f6b8: 23 34 05 00  	sd	zero, 8(a0)
   1f6bc: ae 65        	ld	a1, 200(sp)
   1f6be: 0c e1        	sd	a1, 0(a0)
;         try result.attrs.resize(allocator, table_entry.attrs.items.len);
   1f6c0: 04 6c        	ld	s1, 24(s0)
;             if (self.capacity >= new_capacity) return;
   1f6c2: 85 cc        	beqz	s1, 0x1f6fa <.LBB47_196+0x2280>
   1f6c4: 81 46        	li	a3, 0
   1f6c6: 19 a0        	j	0x1f6cc <.LBB47_196+0x2252>
;                 if (better_capacity >= new_capacity) break;
   1f6c8: 63 fc 96 00  	bgeu	a3, s1, 0x1f6e0 <.LBB47_196+0x2266>
   1f6cc: b6 85        	mv	a1, a3
;                 better_capacity +|= better_capacity / 2 + 8;
   1f6ce: 13 d5 16 00  	srli	a0, a3, 1
   1f6d2: 36 95        	add	a0, a0, a3
   1f6d4: 21 05        	addi	a0, a0, 8
   1f6d6: fd 56        	li	a3, -1
   1f6d8: e3 68 b5 fe  	bltu	a0, a1, 0x1f6c8 <.LBB47_196+0x224e>
   1f6dc: aa 86        	mv	a3, a0
   1f6de: ed b7        	j	0x1f6c8 <.LBB47_196+0x224e>
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   1f6e0: 72 65        	ld	a0, 280(sp)
   1f6e2: ac 1d        	addi	a1, sp, 760
   1f6e4: 32 66        	ld	a2, 264(sp)
   1f6e6: 97 30 00 00  	auipc	ra, 3
   1f6ea: e7 80 00 2d  	jalr	720(ra)
   1f6ee: aa 8c        	mv	s9, a0
   1f6f0: 42 15        	slli	a0, a0, 48
   1f6f2: 41 91        	srli	a0, a0, 48
   1f6f4: 19 c1        	beqz	a0, 0x1f6fa <.LBB47_196+0x2280>
   1f6f6: 6f 10 00 46  	j	0x20b56 <.LBB47_196+0x36dc>
;             self.items.len = new_len;
   1f6fa: 23 30 91 30  	sd	s1, 768(sp)
;         for (table_entry.attrs.items) |attr, i| {
   1f6fe: 03 39 84 01  	ld	s2, 24(s0)
   1f702: 63 0b 09 0e  	beqz	s2, 0x1f7f8 <.LBB47_196+0x237e>
   1f706: 08 68        	ld	a0, 16(s0)
   1f708: 81 44        	li	s1, 0
   1f70a: 81 4b        	li	s7, 0
;             result.attrs.items[i] = Die.Attr{
   1f70c: 13 0a 05 01  	addi	s4, a0, 16
   1f710: 39 a0        	j	0x1f71e <.LBB47_196+0x22a4>
;                 result.attrs.items[i].value.Const.payload = @bitCast(u64, attr.payload);
   1f712: 85 0b        	addi	s7, s7, 1
;         for (table_entry.attrs.items) |attr, i| {
   1f714: 93 84 04 02  	addi	s1, s1, 32
   1f718: 61 0a        	addi	s4, s4, 24
   1f71a: 63 0f 79 0d  	beq	s2, s7, 0x1f7f8 <.LBB47_196+0x237e>
;             result.attrs.items[i] = Die.Attr{
   1f71e: 03 35 01 30  	ld	a0, 768(sp)
   1f722: 63 e4 ab 00  	bltu	s7, a0, 0x1f72a <.LBB47_196+0x22b0>
   1f726: 6f 10 80 47  	j	0x20b9e <.LBB47_196+0x3724>
   1f72a: 03 35 81 2f  	ld	a0, 760(sp)
;         for (table_entry.attrs.items) |attr, i| {
   1f72e: 83 35 0a ff  	ld	a1, -16(s4)
   1f732: 03 34 8a ff  	ld	s0, -8(s4)
   1f736: 03 3b 0a 00  	ld	s6, 0(s4)
;                 .id = attr.attr_id,
   1f73a: b3 0d 95 00  	add	s11, a0, s1
   1f73e: 23 b0 bd 00  	sd	a1, 0(s11)
;                     di.endian,
   1f742: 05 65        	lui	a0, 1
   1f744: 1b 05 85 3d  	addiw	a0, a0, 984
   1f748: 0a 95        	add	a0, a0, sp
   1f74a: 83 07 05 00  	lb	a5, 0(a0)
;         return .{
   1f74e: 88 0d        	addi	a0, sp, 720
   1f750: 89 65        	lui	a1, 2
   1f752: 9b 85 85 33  	addiw	a1, a1, 824
   1f756: 8a 95        	add	a1, a1, sp
   1f758: 88 e1        	sd	a0, 0(a1)
   1f75a: 09 65        	lui	a0, 2
   1f75c: 1b 05 05 34  	addiw	a0, a0, 832
   1f760: 0a 95        	add	a0, a0, sp
   1f762: 23 30 35 01  	sd	s3, 0(a0)
;                     di.endian,
   1f766: 09 65        	lui	a0, 2
   1f768: 1b 05 05 42  	addiw	a0, a0, 1056
   1f76c: 0a 95        	add	a0, a0, sp
   1f76e: 89 65        	lui	a1, 2
   1f770: 9b 85 85 33  	addiw	a1, a1, 824
   1f774: 33 06 b1 00  	add	a2, sp, a1
   1f778: 89 65        	lui	a1, 2
   1f77a: 9b 85 85 53  	addiw	a1, a1, 1336
   1f77e: b3 06 b1 00  	add	a3, sp, a1
   1f782: f2 65        	ld	a1, 280(sp)
   1f784: 22 87        	mv	a4, s0
   1f786: 62 88        	mv	a6, s8
   1f788: 97 80 ff ff  	auipc	ra, 1048568
   1f78c: e7 80 80 4b  	jalr	1208(ra)
   1f790: 09 65        	lui	a0, 2
   1f792: 1b 05 85 43  	addiw	a0, a0, 1080
   1f796: 0a 95        	add	a0, a0, sp
   1f798: 83 5c 05 00  	lhu	s9, 0(a0)
   1f79c: e3 9b 0c 56  	bnez	s9, 0x20512 <.LBB47_196+0x3098>
;                 .value = try parseFormValue(
   1f7a0: 09 65        	lui	a0, 2
   1f7a2: 1b 05 05 43  	addiw	a0, a0, 1072
   1f7a6: 0a 95        	add	a0, a0, sp
   1f7a8: 08 61        	ld	a0, 0(a0)
   1f7aa: 23 bc ad 00  	sd	a0, 24(s11)
   1f7ae: 09 65        	lui	a0, 2
   1f7b0: 1b 05 85 42  	addiw	a0, a0, 1064
   1f7b4: 0a 95        	add	a0, a0, sp
   1f7b6: 08 61        	ld	a0, 0(a0)
   1f7b8: 23 b8 ad 00  	sd	a0, 16(s11)
   1f7bc: 09 65        	lui	a0, 2
   1f7be: 1b 05 05 42  	addiw	a0, a0, 1056
   1f7c2: 0a 95        	add	a0, a0, sp
   1f7c4: 08 61        	ld	a0, 0(a0)
   1f7c6: 23 b4 ad 00  	sd	a0, 8(s11)
;             if (attr.form_id == FORM.implicit_const) {
   1f7ca: 13 05 10 02  	li	a0, 33
   1f7ce: e3 12 a4 f4  	bne	s0, a0, 0x1f712 <.LBB47_196+0x2298>
;                 result.attrs.items[i].value.Const.payload = @bitCast(u64, attr.payload);
   1f7d2: 03 35 01 30  	ld	a0, 768(sp)
   1f7d6: 63 e4 ab 00  	bltu	s7, a0, 0x1f7de <.LBB47_196+0x2364>
   1f7da: 6f 10 40 3c  	j	0x20b9e <.LBB47_196+0x3724>
   1f7de: 03 35 81 2f  	ld	a0, 760(sp)
   1f7e2: 26 95        	add	a0, a0, s1
   1f7e4: 83 45 85 01  	lbu	a1, 24(a0)
   1f7e8: 0d 46        	li	a2, 3
   1f7ea: 63 84 c5 00  	beq	a1, a2, 0x1f7f2 <.LBB47_196+0x2378>
   1f7ee: 6f 10 40 4c  	j	0x20cb2 <.LBB47_196+0x3838>
   1f7f2: 23 34 65 01  	sd	s6, 8(a0)
   1f7f6: 31 bf        	j	0x1f712 <.LBB47_196+0x2298>
;         return result;
   1f7f8: 09 65        	lui	a0, 2
   1f7fa: 1b 05 05 48  	addiw	a0, a0, 1152
   1f7fe: 0a 95        	add	a0, a0, sp
   1f800: 8c 0d        	addi	a1, sp, 720
   1f802: 13 06 80 04  	li	a2, 72
   1f806: 97 50 00 00  	auipc	ra, 5
   1f80a: e7 80 e0 a6  	jalr	-1426(ra)
;             compile_unit_die.* = (try di.parseDie(allocator, in, abbrev_table, is_64)) orelse
   1f80e: 09 65        	lui	a0, 2
   1f810: 1b 05 05 48  	addiw	a0, a0, 1152
   1f814: b3 05 a1 00  	add	a1, sp, a0
   1f818: 13 06 80 04  	li	a2, 72
   1f81c: 6e 69        	ld	s2, 216(sp)
   1f81e: 4a 85        	mv	a0, s2
   1f820: 97 50 00 00  	auipc	ra, 5
   1f824: e7 80 40 a5  	jalr	-1452(ra)
;             if (compile_unit_die.tag_id != TAG.compile_unit) return badDwarf();
   1f828: 03 35 09 02  	ld	a0, 32(s2)
   1f82c: c5 45        	li	a1, 17
   1f82e: 63 04 b5 00  	beq	a0, a1, 0x1f836 <.LBB47_196+0x23bc>
   1f832: 6f 10 80 10  	j	0x2093a <.LBB47_196+0x34c0>
;             var compile_unit: CompileUnit = .{
   1f836: 4e 65        	ld	a0, 208(sp)
   1f838: 89 65        	lui	a1, 2
   1f83a: 9b 85 85 51  	addiw	a1, a1, 1304
   1f83e: 8a 95        	add	a1, a1, sp
   1f840: 23 90 a5 00  	sh	a0, 0(a1)
   1f844: 09 65        	lui	a0, 2
   1f846: 1b 05 a5 51  	addiw	a0, a0, 1306
   1f84a: 0a 95        	add	a0, a0, sp
   1f84c: 23 00 85 01  	sb	s8, 0(a0)
   1f850: 09 65        	lui	a0, 2
   1f852: 1b 05 05 4e  	addiw	a0, a0, 1248
   1f856: 0a 95        	add	a0, a0, sp
   1f858: 23 38 05 00  	sd	zero, 16(a0)
   1f85c: 23 34 05 00  	sd	zero, 8(a0)
   1f860: 23 30 05 00  	sd	zero, 0(a0)
   1f864: 09 65        	lui	a0, 2
   1f866: 1b 05 85 4d  	addiw	a0, a0, 1240
   1f86a: 0a 95        	add	a0, a0, sp
   1f86c: 23 30 25 01  	sd	s2, 0(a0)
;         for (self.attrs.items) |*attr| {
   1f870: 83 35 09 03  	ld	a1, 48(s2)
   1f874: 9d c9        	beqz	a1, 0x1f8aa <.LBB47_196+0x2430>
   1f876: 03 35 89 02  	ld	a0, 40(s2)
;         for (self.attrs.items) |*attr| {
   1f87a: 41 05        	addi	a0, a0, 16
   1f87c: ae 86        	mv	a3, a1
   1f87e: 2a 86        	mv	a2, a0
   1f880: 13 0b a0 0a  	li	s6, 170
   1f884: 52 6a        	ld	s4, 272(sp)
   1f886: a1 4b        	li	s7, 8
   1f888: 13 0c 80 04  	li	s8, 72
   1f88c: c9 44        	li	s1, 18
   1f88e: 93 07 20 07  	li	a5, 114
;             if (attr.id == id) return &attr.value;
   1f892: 03 37 06 ff  	ld	a4, -16(a2)
   1f896: 63 0d f7 02  	beq	a4, a5, 0x1f8d0 <.LBB47_196+0x2456>
;         for (self.attrs.items) |*attr| {
   1f89a: fd 16        	addi	a3, a3, -1
   1f89c: 13 06 06 02  	addi	a2, a2, 32
   1f8a0: ed fa        	bnez	a3, 0x1f892 <.LBB47_196+0x2418>
   1f8a2: 01 46        	li	a2, 0
   1f8a4: 93 07 30 07  	li	a5, 115
   1f8a8: b9 a0        	j	0x1f8f6 <.LBB47_196+0x247c>
   1f8aa: 01 45        	li	a0, 0
   1f8ac: 89 65        	lui	a1, 2
   1f8ae: 9b 85 85 4f  	addiw	a1, a1, 1272
   1f8b2: 8a 95        	add	a1, a1, sp
   1f8b4: 23 b8 05 00  	sd	zero, 16(a1)
   1f8b8: 23 b4 05 00  	sd	zero, 8(a1)
   1f8bc: 23 b0 05 00  	sd	zero, 0(a1)
   1f8c0: 13 0b a0 0a  	li	s6, 170
   1f8c4: 52 6a        	ld	s4, 272(sp)
   1f8c6: a1 4b        	li	s7, 8
   1f8c8: 13 0c 80 04  	li	s8, 72
   1f8cc: c9 44        	li	s1, 18
   1f8ce: f5 a8        	j	0x1f9ca <.LBB47_196+0x2550>
;         switch (fv) {
   1f8d0: 83 46 86 00  	lbu	a3, 8(a2)
   1f8d4: 19 47        	li	a4, 6
   1f8d6: 93 07 30 07  	li	a5, 115
   1f8da: 63 8c e6 00  	beq	a3, a4, 0x1f8f2 <.LBB47_196+0x2478>
   1f8de: 0d 47        	li	a4, 3
   1f8e0: 63 84 e6 00  	beq	a3, a4, 0x1f8e8 <.LBB47_196+0x246e>
   1f8e4: 6f 10 a0 28  	j	0x20b6e <.LBB47_196+0x36f4>
   1f8e8: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1f8ec: 99 c2        	beqz	a3, 0x1f8f2 <.LBB47_196+0x2478>
   1f8ee: 6f 10 60 27  	j	0x20b64 <.LBB47_196+0x36ea>
   1f8f2: 03 36 86 ff  	ld	a2, -8(a2)
   1f8f6: 89 66        	lui	a3, 2
   1f8f8: 9b 86 86 4f  	addiw	a3, a3, 1272
   1f8fc: 8a 96        	add	a3, a3, sp
   1f8fe: 90 e2        	sd	a2, 0(a3)
   1f900: ae 86        	mv	a3, a1
   1f902: 2a 86        	mv	a2, a0
;             if (attr.id == id) return &attr.value;
   1f904: 03 37 06 ff  	ld	a4, -16(a2)
   1f908: 63 0a f7 00  	beq	a4, a5, 0x1f91c <.LBB47_196+0x24a2>
;         for (self.attrs.items) |*attr| {
   1f90c: fd 16        	addi	a3, a3, -1
   1f90e: 13 06 06 02  	addi	a2, a2, 32
   1f912: ed fa        	bnez	a3, 0x1f904 <.LBB47_196+0x248a>
   1f914: 01 46        	li	a2, 0
   1f916: 93 07 40 07  	li	a5, 116
   1f91a: 25 a0        	j	0x1f942 <.LBB47_196+0x24c8>
;         switch (fv) {
   1f91c: 83 46 86 00  	lbu	a3, 8(a2)
   1f920: 19 47        	li	a4, 6
   1f922: 93 07 40 07  	li	a5, 116
   1f926: 63 8c e6 00  	beq	a3, a4, 0x1f93e <.LBB47_196+0x24c4>
   1f92a: 0d 47        	li	a4, 3
   1f92c: 63 84 e6 00  	beq	a3, a4, 0x1f934 <.LBB47_196+0x24ba>
   1f930: 6f 10 e0 23  	j	0x20b6e <.LBB47_196+0x36f4>
   1f934: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1f938: 99 c2        	beqz	a3, 0x1f93e <.LBB47_196+0x24c4>
   1f93a: 6f 10 a0 22  	j	0x20b64 <.LBB47_196+0x36ea>
   1f93e: 03 36 86 ff  	ld	a2, -8(a2)
   1f942: 89 66        	lui	a3, 2
   1f944: 9b 86 06 50  	addiw	a3, a3, 1280
   1f948: 8a 96        	add	a3, a3, sp
   1f94a: 90 e2        	sd	a2, 0(a3)
   1f94c: ae 86        	mv	a3, a1
   1f94e: 2a 86        	mv	a2, a0
;             if (attr.id == id) return &attr.value;
   1f950: 03 37 06 ff  	ld	a4, -16(a2)
   1f954: 63 08 f7 00  	beq	a4, a5, 0x1f964 <.LBB47_196+0x24ea>
;         for (self.attrs.items) |*attr| {
   1f958: fd 16        	addi	a3, a3, -1
   1f95a: 13 06 06 02  	addi	a2, a2, 32
   1f95e: ed fa        	bnez	a3, 0x1f950 <.LBB47_196+0x24d6>
   1f960: 01 46        	li	a2, 0
   1f962: 15 a0        	j	0x1f986 <.LBB47_196+0x250c>
;         switch (fv) {
   1f964: 83 46 86 00  	lbu	a3, 8(a2)
   1f968: 19 47        	li	a4, 6
   1f96a: 63 8c e6 00  	beq	a3, a4, 0x1f982 <.LBB47_196+0x2508>
   1f96e: 0d 47        	li	a4, 3
   1f970: 63 84 e6 00  	beq	a3, a4, 0x1f978 <.LBB47_196+0x24fe>
   1f974: 6f 10 a0 1f  	j	0x20b6e <.LBB47_196+0x36f4>
   1f978: 83 46 06 00  	lbu	a3, 0(a2)
;         if (self.signed) return badDwarf();
   1f97c: 99 c2        	beqz	a3, 0x1f982 <.LBB47_196+0x2508>
   1f97e: 6f 10 60 1e  	j	0x20b64 <.LBB47_196+0x36ea>
   1f982: 03 36 86 ff  	ld	a2, -8(a2)
   1f986: 89 66        	lui	a3, 2
   1f988: 9b 86 86 50  	addiw	a3, a3, 1288
   1f98c: 8a 96        	add	a3, a3, sp
   1f98e: 90 e2        	sd	a2, 0(a3)
   1f990: 93 06 c0 08  	li	a3, 140
;             if (attr.id == id) return &attr.value;
   1f994: 03 36 05 ff  	ld	a2, -16(a0)
   1f998: 63 08 d6 00  	beq	a2, a3, 0x1f9a8 <.LBB47_196+0x252e>
;         for (self.attrs.items) |*attr| {
   1f99c: fd 15        	addi	a1, a1, -1
   1f99e: 13 05 05 02  	addi	a0, a0, 32
   1f9a2: ed f9        	bnez	a1, 0x1f994 <.LBB47_196+0x251a>
   1f9a4: 01 45        	li	a0, 0
   1f9a6: 15 a0        	j	0x1f9ca <.LBB47_196+0x2550>
;         switch (fv) {
   1f9a8: 83 45 85 00  	lbu	a1, 8(a0)
   1f9ac: 19 46        	li	a2, 6
   1f9ae: 63 8c c5 00  	beq	a1, a2, 0x1f9c6 <.LBB47_196+0x254c>
   1f9b2: 0d 46        	li	a2, 3
   1f9b4: 63 84 c5 00  	beq	a1, a2, 0x1f9bc <.LBB47_196+0x2542>
   1f9b8: 6f 10 60 1b  	j	0x20b6e <.LBB47_196+0x36f4>
   1f9bc: 83 45 05 00  	lbu	a1, 0(a0)
;         if (self.signed) return badDwarf();
   1f9c0: 99 c1        	beqz	a1, 0x1f9c6 <.LBB47_196+0x254c>
   1f9c2: 6f 10 20 1a  	j	0x20b64 <.LBB47_196+0x36ea>
   1f9c6: 03 35 85 ff  	ld	a0, -8(a0)
   1f9ca: 89 65        	lui	a1, 2
   1f9cc: 9b 85 05 51  	addiw	a1, a1, 1296
   1f9d0: 8a 95        	add	a1, a1, sp
   1f9d2: 88 e1        	sd	a0, 0(a1)
;                 if (compile_unit_die.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| {
   1f9d4: 09 65        	lui	a0, 2
   1f9d6: 1b 05 05 57  	addiw	a0, a0, 1392
   1f9da: 0a 95        	add	a0, a0, sp
   1f9dc: 85 65        	lui	a1, 1
   1f9de: 9b 85 05 2d  	addiw	a1, a1, 720
   1f9e2: b3 06 b1 00  	add	a3, sp, a1
   1f9e6: 89 65        	lui	a1, 2
   1f9e8: 9b 85 85 4d  	addiw	a1, a1, 1240
   1f9ec: 33 07 b1 00  	add	a4, sp, a1
   1f9f0: 72 64        	ld	s0, 280(sp)
   1f9f2: a2 85        	mv	a1, s0
   1f9f4: 4a 86        	mv	a2, s2
   1f9f6: 97 80 ff ff  	auipc	ra, 1048568
   1f9fa: e7 80 e0 d8  	jalr	-626(ra)
   1f9fe: 09 65        	lui	a0, 2
   1fa00: 1b 05 85 57  	addiw	a0, a0, 1400
   1fa04: 0a 95        	add	a0, a0, sp
   1fa06: 83 5c 05 00  	lhu	s9, 0(a0)
   1fa0a: 4d 45        	li	a0, 19
   1fa0c: 63 84 ac 04  	beq	s9, a0, 0x1fa54 <.LBB47_196+0x25da>
   1fa10: 63 84 0c 00  	beqz	s9, 0x1fa18 <.LBB47_196+0x259e>
   1fa14: 6f 10 e0 19  	j	0x20bb2 <.LBB47_196+0x3738>
;         for (self.attrs.items) |*attr| {
   1fa18: 03 36 09 03  	ld	a2, 48(s2)
   1fa1c: 0d c2        	beqz	a2, 0x1fa3e <.LBB47_196+0x25c4>
   1fa1e: 83 35 89 02  	ld	a1, 40(s2)
   1fa22: 09 65        	lui	a0, 2
   1fa24: 1b 05 05 57  	addiw	a0, a0, 1392
   1fa28: 0a 95        	add	a0, a0, sp
   1fa2a: 08 61        	ld	a0, 0(a0)
;         for (self.attrs.items) |*attr| {
   1fa2c: c1 05        	addi	a1, a1, 16
;             if (attr.id == id) return &attr.value;
   1fa2e: 83 b6 05 ff  	ld	a3, -16(a1)
   1fa32: 63 8b 96 0a  	beq	a3, s1, 0x1fae8 <.LBB47_196+0x266e>
;         for (self.attrs.items) |*attr| {
   1fa36: 7d 16        	addi	a2, a2, -1
   1fa38: 93 85 05 02  	addi	a1, a1, 32
   1fa3c: 6d fa        	bnez	a2, 0x1fa2e <.LBB47_196+0x25b4>
   1fa3e: 09 65        	lui	a0, 2
   1fa40: 1b 05 05 4e  	addiw	a0, a0, 1248
   1fa44: 0a 95        	add	a0, a0, sp
;                         break :x null;
   1fa46: 23 38 05 00  	sd	zero, 16(a0)
   1fa4a: 23 34 05 00  	sd	zero, 8(a0)
   1fa4e: 23 30 05 00  	sd	zero, 0(a0)
   1fa52: e9 a8        	j	0x1fb2c <.LBB47_196+0x26b2>
   1fa54: 09 65        	lui	a0, 2
   1fa56: 1b 05 05 4e  	addiw	a0, a0, 1248
   1fa5a: 0a 95        	add	a0, a0, sp
;                     break :x null;
   1fa5c: 23 38 05 00  	sd	zero, 16(a0)
   1fa60: 23 34 05 00  	sd	zero, 8(a0)
   1fa64: 23 30 05 00  	sd	zero, 0(a0)
   1fa68: 2a 65        	ld	a0, 136(sp)
   1fa6a: 08 e0        	sd	a0, 0(s0)
   1fa6c: c1 a0        	j	0x1fb2c <.LBB47_196+0x26b2>
;             var bytes: [num_bytes]u8 = undefined;
   1fa6e: 0a 65        	ld	a0, 128(sp)
   1fa70: 89 65        	lui	a1, 2
   1fa72: 9b 85 85 3c  	addiw	a1, a1, 968
   1fa76: 8a 95        	add	a1, a1, sp
   1fa78: 88 c1        	sw	a0, 0(a1)
   1fa7a: 91 45        	li	a1, 4
;                 const amt = try self.read(buffer[index..]);
   1fa7c: 33 06 9d 00  	add	a2, s10, s1
   1fa80: b3 86 95 40  	sub	a3, a1, s1
;             return readFn(self.context, buffer);
   1fa84: 88 0d        	addi	a0, sp, 720
   1fa86: a2 85        	mv	a1, s0
   1fa88: 97 20 00 00  	auipc	ra, 2
   1fa8c: e7 80 00 c3  	jalr	-976(ra)
   1fa90: 03 35 01 2d  	ld	a0, 720(sp)
;                 if (amt == 0) break;
   1fa94: e3 00 05 00  	beqz	a0, 0x20294 <.LBB47_196+0x2e1a>
;                 index += amt;
   1fa98: 26 95        	add	a0, a0, s1
   1fa9a: e3 63 95 44  	bltu	a0, s1, 0x206e0 <.LBB47_196+0x3266>
   1fa9e: aa 84        	mv	s1, a0
   1faa0: 91 45        	li	a1, 4
;             while (index < len) {
   1faa2: e3 6d b5 fc  	bltu	a0, a1, 0x1fa7c <.LBB47_196+0x2602>
;             return bytes;
   1faa6: 09 65        	lui	a0, 2
   1faa8: 1b 05 85 3c  	addiw	a0, a0, 968
   1faac: 0a 95        	add	a0, a0, sp
   1faae: 03 65 05 00  	lwu	a0, 0(a0)
;     if (endian == native_endian) {
   1fab2: 93 75 1b 00  	andi	a1, s6, 1
   1fab6: 95 e1        	bnez	a1, 0x1fada <.LBB47_196+0x2660>
   1fab8: 93 55 85 00  	srli	a1, a0, 8
   1fabc: 41 66        	lui	a2, 16
   1fabe: 1b 06 06 f0  	addiw	a2, a2, -256
   1fac2: f1 8d        	and	a1, a1, a2
   1fac4: 13 56 85 01  	srli	a2, a0, 24
   1fac8: d1 8d        	or	a1, a1, a2
   1faca: 13 16 85 00  	slli	a2, a0, 8
   1face: b7 06 ff 00  	lui	a3, 4080
   1fad2: 75 8e        	and	a2, a2, a3
   1fad4: 62 05        	slli	a0, a0, 24
   1fad6: 51 8d        	or	a0, a0, a2
   1fad8: 4d 8d        	or	a0, a0, a1
;                     try in.readInt(u32, di.endian);
   1fada: 02 15        	slli	a0, a0, 32
   1fadc: 93 54 05 02  	srli	s1, a0, 32
;             if (address_size != @sizeOf(usize)) return badDwarf();
   1fae0: e3 06 79 a7  	beq	s2, s7, 0x1f54c <.LBB47_196+0x20d2>
   1fae4: 6f 00 10 41  	j	0x206f4 <.LBB47_196+0x327a>
;                         const pc_end = switch (high_pc_value.*) {
   1fae8: 83 c6 85 00  	lbu	a3, 8(a1)
   1faec: 03 b6 85 ff  	ld	a2, -8(a1)
   1faf0: 89 ce        	beqz	a3, 0x1fb0a <.LBB47_196+0x2690>
   1faf2: 0d 47        	li	a4, 3
   1faf4: e3 93 e6 64  	bne	a3, a4, 0x2093a <.LBB47_196+0x34c0>
   1faf8: 83 c5 05 00  	lbu	a1, 0(a1)
;         if (self.signed) return badDwarf();
   1fafc: 85 89        	andi	a1, a1, 1
   1fafe: 99 c1        	beqz	a1, 0x1fb04 <.LBB47_196+0x268a>
   1fb00: 6f 10 e0 06  	j	0x20b6e <.LBB47_196+0x36f4>
;                                 break :b (low_pc + offset);
   1fb04: 2a 96        	add	a2, a2, a0
   1fb06: e3 6d a6 3c  	bltu	a2, a0, 0x206e0 <.LBB47_196+0x3266>
;                         break :x PcRange{
   1fb0a: 85 45        	li	a1, 1
   1fb0c: 89 66        	lui	a3, 2
   1fb0e: 9b 86 06 4f  	addiw	a3, a3, 1264
   1fb12: 8a 96        	add	a3, a3, sp
   1fb14: 23 80 b6 00  	sb	a1, 0(a3)
   1fb18: 89 65        	lui	a1, 2
   1fb1a: 9b 85 05 4e  	addiw	a1, a1, 1248
   1fb1e: 8a 95        	add	a1, a1, sp
   1fb20: 88 e1        	sd	a0, 0(a1)
   1fb22: 09 65        	lui	a0, 2
   1fb24: 1b 05 85 4e  	addiw	a0, a0, 1256
   1fb28: 0a 95        	add	a0, a0, sp
   1fb2a: 10 e1        	sd	a2, 0(a0)
;             const newlen = self.items.len + 1;
   1fb2c: 05 65        	lui	a0, 1
   1fb2e: 1b 05 05 3b  	addiw	a0, a0, 944
   1fb32: 0a 95        	add	a0, a0, sp
   1fb34: 08 61        	ld	a0, 0(a0)
   1fb36: 93 05 15 00  	addi	a1, a0, 1
   1fb3a: e3 83 05 3a  	beqz	a1, 0x206e0 <.LBB47_196+0x3266>
;             if (self.capacity >= new_capacity) return;
   1fb3e: 05 66        	lui	a2, 1
   1fb40: 1b 06 86 3b  	addiw	a2, a2, 952
   1fb44: 0a 96        	add	a2, a2, sp
   1fb46: 03 39 06 00  	ld	s2, 0(a2)
   1fb4a: 63 76 b9 1a  	bgeu	s2, a1, 0x1fcf6 <.LBB47_196+0x287c>
   1fb4e: ca 8b        	mv	s7, s2
   1fb50: 19 a0        	j	0x1fb56 <.LBB47_196+0x26dc>
;                 if (better_capacity >= new_capacity) break;
   1fb52: 63 fc bb 00  	bgeu	s7, a1, 0x1fb6a <.LBB47_196+0x26f0>
   1fb56: de 86        	mv	a3, s7
;                 better_capacity +|= better_capacity / 2 + 8;
   1fb58: 13 d6 1b 00  	srli	a2, s7, 1
   1fb5c: 5e 96        	add	a2, a2, s7
   1fb5e: 21 06        	addi	a2, a2, 8
   1fb60: fd 5b        	li	s7, -1
   1fb62: e3 68 d6 fe  	bltu	a2, a3, 0x1fb52 <.LBB47_196+0x26d8>
   1fb66: b2 8b        	mv	s7, a2
   1fb68: ed b7        	j	0x1fb52 <.LBB47_196+0x26d8>
;             if (self.capacity >= new_capacity) return;
   1fb6a: 63 75 79 19  	bgeu	s2, s7, 0x1fcf4 <.LBB47_196+0x287a>
;             const old_memory = self.allocatedSlice();
   1fb6e: 05 65        	lui	a0, 1
   1fb70: 1b 05 85 3a  	addiw	a0, a0, 936
   1fb74: 0a 95        	add	a0, a0, sp
   1fb76: 0c 61        	ld	a1, 0(a0)
   1fb78: 32 66        	ld	a2, 264(sp)
;             if (allocator.resize(old_memory, new_capacity)) {
   1fb7a: 08 62        	ld	a0, 0(a2)
   1fb7c: 14 66        	ld	a3, 8(a2)
   1fb7e: 90 0d        	addi	a2, sp, 720
   1fb80: 09 67        	lui	a4, 2
   1fb82: 1b 07 07 3d  	addiw	a4, a4, 976
   1fb86: 0a 97        	add	a4, a4, sp
   1fb88: 10 e3        	sd	a2, 0(a4)
   1fb8a: 13 06 00 02  	li	a2, 32
   1fb8e: 09 67        	lui	a4, 2
   1fb90: 1b 07 87 3d  	addiw	a4, a4, 984
   1fb94: 0a 97        	add	a4, a4, sp
   1fb96: 10 e3        	sd	a2, 0(a4)
   1fb98: 09 66        	lui	a2, 2
   1fb9a: 1b 06 86 3c  	addiw	a2, a2, 968
   1fb9e: 0a 96        	add	a2, a2, sp
   1fba0: 23 30 06 00  	sd	zero, 0(a2)
   1fba4: 33 06 89 03  	mul	a2, s2, s8
   1fba8: b3 3d 89 03  	mulhu	s11, s2, s8
;     if (old_mem.len == 0) {
   1fbac: ae e9        	sd	a1, 208(sp)
   1fbae: b2 f8        	sd	a2, 112(sp)
   1fbb0: 63 09 09 02  	beqz	s2, 0x1fbe2 <.LBB47_196+0x2768>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1fbb4: e3 96 0d 32  	bnez	s11, 0x206e0 <.LBB47_196+0x3266>
;     const ov = @mulWithOverflow(a, b);
   1fbb8: 33 b7 8b 03  	mulhu	a4, s7, s8
;     if (ov[1] != 0) return error.Overflow;
   1fbbc: 19 c3        	beqz	a4, 0x1fbc2 <.LBB47_196+0x2748>
   1fbbe: 6f 10 00 05  	j	0x20c0e <.LBB47_196+0x3794>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   1fbc2: 80 66        	ld	s0, 8(a3)
   1fbc4: b3 84 8b 03  	mul	s1, s7, s8
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   1fbc8: 8d 46        	li	a3, 3
   1fbca: 26 87        	mv	a4, s1
   1fbcc: ce 77        	ld	a5, 240(sp)
   1fbce: 02 94        	jalr	s0
   1fbd0: 05 89        	andi	a0, a0, 1
;             if (allocator.resize(old_memory, new_capacity)) {
   1fbd2: 63 15 05 10  	bnez	a0, 0x1fcdc <.LBB47_196+0x2862>
   1fbd6: 13 04 80 04  	li	s0, 72
   1fbda: 32 65        	ld	a0, 264(sp)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   1fbdc: 14 65        	ld	a3, 8(a0)
   1fbde: 08 61        	ld	a0, 0(a0)
   1fbe0: 11 a8        	j	0x1fbf4 <.LBB47_196+0x277a>
;     const ov = @mulWithOverflow(a, b);
   1fbe2: 33 b6 8b 03  	mulhu	a2, s7, s8
;     if (ov[1] != 0) return error.Overflow;
   1fbe6: 19 c2        	beqz	a2, 0x1fbec <.LBB47_196+0x2772>
   1fbe8: 6f 10 60 03  	j	0x20c1e <.LBB47_196+0x37a4>
   1fbec: 13 04 80 04  	li	s0, 72
   1fbf0: b3 84 8b 03  	mul	s1, s7, s8
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   1fbf4: 98 62        	ld	a4, 0(a3)
   1fbf6: 0d 46        	li	a2, 3
   1fbf8: a6 85        	mv	a1, s1
   1fbfa: ce 76        	ld	a3, 240(sp)
   1fbfc: 02 97        	jalr	a4
   1fbfe: 19 e1        	bnez	a0, 0x1fc04 <.LBB47_196+0x278a>
   1fc00: 6f 10 80 02  	j	0x20c28 <.LBB47_196+0x37ae>
   1fc04: 2a 8c        	mv	s8, a0
;     @memset(byte_ptr, undefined, byte_count);
   1fc06: 93 05 a0 0a  	li	a1, 170
   1fc0a: 26 86        	mv	a2, s1
   1fc0c: 97 40 00 00  	auipc	ra, 4
   1fc10: e7 80 e0 68  	jalr	1678(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   1fc14: 13 75 7c 00  	andi	a0, s8, 7
   1fc18: 13 35 15 00  	seqz	a0, a0
   1fc1c: 93 b5 14 00  	seqz	a1, s1
   1fc20: 4d 8d        	or	a0, a0, a1
   1fc22: 19 e1        	bnez	a0, 0x1fc28 <.LBB47_196+0x27ae>
   1fc24: 6f c0 ff f5  	j	0x1cb82 <debug.printSourceAtAddress__anon_4137+0x286>
;     if (bytes.len == 0) {
   1fc28: 89 cc        	beqz	s1, 0x1fc42 <.LBB47_196+0x27c8>
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   1fc2a: 66 75        	ld	a0, 120(sp)
   1fc2c: 33 b5 a4 02  	mulhu	a0, s1, a0
   1fc30: 93 5b 65 00  	srli	s7, a0, 6
   1fc34: 33 85 8b 02  	mul	a0, s7, s0
   1fc38: 33 85 a4 40  	sub	a0, s1, a0
   1fc3c: 09 c5        	beqz	a0, 0x1fc46 <.LBB47_196+0x27cc>
   1fc3e: 6f 10 20 0c  	j	0x20d00 <.LBB47_196+0x3886>
   1fc42: 81 4b        	li	s7, 0
   1fc44: 2e 6c        	ld	s8, 200(sp)
;                 mem.copy(T, new_memory, self.items);
   1fc46: 05 65        	lui	a0, 1
   1fc48: 1b 05 05 3b  	addiw	a0, a0, 944
   1fc4c: 0a 95        	add	a0, a0, sp
   1fc4e: 03 3a 05 00  	ld	s4, 0(a0)
;     if (!ok) unreachable; // assertion failure
   1fc52: 63 f4 4b 01  	bgeu	s7, s4, 0x1fc5a <.LBB47_196+0x27e0>
   1fc56: 6f c0 1f e8  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (source) |s, i|
   1fc5a: 63 07 0a 02  	beqz	s4, 0x1fc88 <.LBB47_196+0x280e>
   1fc5e: 05 65        	lui	a0, 1
   1fc60: 1b 05 85 3a  	addiw	a0, a0, 936
   1fc64: 0a 95        	add	a0, a0, sp
   1fc66: 04 61        	ld	s1, 0(a0)
   1fc68: 62 84        	mv	s0, s8
;         dest[i] = s;
   1fc6a: 13 06 80 04  	li	a2, 72
   1fc6e: 22 85        	mv	a0, s0
   1fc70: a6 85        	mv	a1, s1
   1fc72: 97 40 00 00  	auipc	ra, 4
   1fc76: e7 80 80 63  	jalr	1592(ra)
;     for (source) |s, i|
   1fc7a: 7d 1a        	addi	s4, s4, -1
   1fc7c: 13 04 84 04  	addi	s0, s0, 72
   1fc80: 93 84 84 04  	addi	s1, s1, 72
   1fc84: e3 13 0a fe  	bnez	s4, 0x1fc6a <.LBB47_196+0x27f0>
   1fc88: 32 65        	ld	a0, 264(sp)
;                 allocator.free(old_memory);
   1fc8a: 00 61        	ld	s0, 0(a0)
   1fc8c: 83 3c 85 00  	ld	s9, 8(a0)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   1fc90: 63 08 09 00  	beqz	s2, 0x1fca0 <.LBB47_196+0x2826>
   1fc94: 52 6a        	ld	s4, 272(sp)
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   1fc96: e3 95 0d 24  	bnez	s11, 0x206e0 <.LBB47_196+0x3266>
   1fc9a: ce 64        	ld	s1, 208(sp)
   1fc9c: 46 79        	ld	s2, 112(sp)
   1fc9e: 19 a0        	j	0x1fca4 <.LBB47_196+0x282a>
   1fca0: a1 44        	li	s1, 8
   1fca2: 52 6a        	ld	s4, 272(sp)
;     if (bytes_len == 0) return;
   1fca4: 63 04 09 02  	beqz	s2, 0x1fccc <.LBB47_196+0x2852>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   1fca8: 63 8b 04 ba  	beqz	s1, 0x1f05e <.LBB47_196+0x1be4>
;     @memset(non_const_ptr, undefined, bytes_len);
   1fcac: 93 05 a0 0a  	li	a1, 170
   1fcb0: 26 85        	mv	a0, s1
   1fcb2: 4a 86        	mv	a2, s2
   1fcb4: 97 40 00 00  	auipc	ra, 4
   1fcb8: e7 80 60 5e  	jalr	1510(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   1fcbc: 83 b7 0c 01  	ld	a5, 16(s9)
   1fcc0: 8d 46        	li	a3, 3
   1fcc2: 22 85        	mv	a0, s0
   1fcc4: a6 85        	mv	a1, s1
   1fcc6: 4a 86        	mv	a2, s2
   1fcc8: 4e 77        	ld	a4, 240(sp)
   1fcca: 82 97        	jalr	a5
;                 self.items.ptr = new_memory.ptr;
   1fccc: 05 65        	lui	a0, 1
   1fcce: 1b 05 85 3a  	addiw	a0, a0, 936
   1fcd2: 0a 95        	add	a0, a0, sp
   1fcd4: 23 30 85 01  	sd	s8, 0(a0)
   1fcd8: 13 0c 80 04  	li	s8, 72
   1fcdc: 05 65        	lui	a0, 1
   1fcde: 1b 05 85 3b  	addiw	a0, a0, 952
   1fce2: 0a 95        	add	a0, a0, sp
   1fce4: 23 30 75 01  	sd	s7, 0(a0)
;             assert(self.items.len < self.capacity);
   1fce8: 05 65        	lui	a0, 1
   1fcea: 1b 05 05 3b  	addiw	a0, a0, 944
   1fcee: 0a 95        	add	a0, a0, sp
   1fcf0: 08 61        	ld	a0, 0(a0)
   1fcf2: 5e 89        	mv	s2, s7
   1fcf4: a1 4b        	li	s7, 8
;     if (!ok) unreachable; // assertion failure
   1fcf6: 63 64 25 01  	bltu	a0, s2, 0x1fcfe <.LBB47_196+0x2884>
   1fcfa: 6f c0 df dd  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;             self.items.len += 1;
   1fcfe: 93 05 15 00  	addi	a1, a0, 1
   1fd02: 05 66        	lui	a2, 1
   1fd04: 1b 06 06 3b  	addiw	a2, a2, 944
   1fd08: 0a 96        	add	a2, a2, sp
   1fd0a: 0c e2        	sd	a1, 0(a2)
;             return &self.items[self.items.len - 1];
   1fd0c: 85 65        	lui	a1, 1
   1fd0e: 9b 85 85 3a  	addiw	a1, a1, 936
   1fd12: 8a 95        	add	a1, a1, sp
   1fd14: 8c 61        	ld	a1, 0(a1)
   1fd16: 33 05 85 03  	mul	a0, a0, s8
   1fd1a: 2e 95        	add	a0, a0, a1
;             new_item_ptr.* = item;
   1fd1c: 89 65        	lui	a1, 2
   1fd1e: 9b 85 85 4d  	addiw	a1, a1, 1240
   1fd22: 8a 95        	add	a1, a1, sp
   1fd24: 13 06 80 04  	li	a2, 72
   1fd28: 97 40 00 00  	auipc	ra, 4
   1fd2c: e7 80 c0 54  	jalr	1356(ra)
;             this_unit_offset += next_offset;
   1fd30: 12 65        	ld	a0, 256(sp)
   1fd32: b3 05 aa 00  	add	a1, s4, a0
   1fd36: e3 e5 45 1b  	bltu	a1, s4, 0x206e0 <.LBB47_196+0x3266>
;         while (this_unit_offset < try seekable.getEndPos()) {
   1fd3a: 09 65        	lui	a0, 2
   1fd3c: 1b 05 85 38  	addiw	a0, a0, 904
   1fd40: 0a 95        	add	a0, a0, sp
   1fd42: 08 61        	ld	a0, 0(a0)
   1fd44: 2e 8a        	mv	s4, a1
   1fd46: 63 e3 a5 c4  	bltu	a1, a0, 0x1f18c <.LBB47_196+0x1d12>
   1fd4a: 72 6c        	ld	s8, 280(sp)
   1fd4c: 0a 7a        	ld	s4, 160(sp)
   1fd4e: ea 6a        	ld	s5, 152(sp)
   1fd50: aa 7d        	ld	s11, 168(sp)
   1fd52: 4e 7d        	ld	s10, 240(sp)
;         return ModuleDebugInfo{
   1fd54: 88 03        	addi	a0, sp, 448
   1fd56: 85 65        	lui	a1, 1
   1fd58: 9b 85 05 2d  	addiw	a1, a1, 720
   1fd5c: 8a 95        	add	a1, a1, sp
   1fd5e: 13 06 00 11  	li	a2, 272
   1fd62: 97 40 00 00  	auipc	ra, 4
   1fd66: e7 80 20 51  	jalr	1298(ra)
   1fd6a: 0e 64        	ld	s0, 192(sp)
;         obj_di.* = try readElfDebugInfo(self.allocator, elf_file);
   1fd6c: 13 05 84 00  	addi	a0, s0, 8
   1fd70: 8c 03        	addi	a1, sp, 448
   1fd72: 13 06 00 11  	li	a2, 272
   1fd76: 97 40 00 00  	auipc	ra, 4
   1fd7a: e7 80 e0 4f  	jalr	1278(ra)
   1fd7e: 0e 75        	ld	a0, 224(sp)
   1fd80: 23 3c a4 10  	sd	a0, 280(s0)
   1fd84: 2e 75        	ld	a0, 232(sp)
   1fd86: 23 30 a4 12  	sd	a0, 288(s0)
   1fd8a: ca 65        	ld	a1, 144(sp)
;         obj_di.base_address = ctx.base_address;
   1fd8c: 0c e0        	sd	a1, 0(s0)
;             return self.containsAdapted(key, ctx);
   1fd8e: 66 65        	ld	a0, 88(sp)
   1fd90: 97 30 00 00  	auipc	ra, 3
   1fd94: e7 80 a0 32  	jalr	810(ra)
   1fd98: 05 89        	andi	a0, a0, 1
   1fd9a: 19 c1        	beqz	a0, 0x1fda0 <.LBB47_196+0x2926>
   1fd9c: 6f c0 bf d3  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;             if (new_count > self.available) {
   1fda0: 32 65        	ld	a0, 264(sp)
   1fda2: 48 4d        	lw	a0, 28(a0)
   1fda4: e3 0c 05 06  	beqz	a0, 0x2061c <.LBB47_196+0x31a2>
;             self.putAssumeCapacityNoClobberContext(key, value, ctx);
   1fda8: 66 65        	ld	a0, 88(sp)
   1fdaa: ca 65        	ld	a1, 144(sp)
   1fdac: 0e 64        	ld	s0, 192(sp)
   1fdae: 22 86        	mv	a2, s0
   1fdb0: 97 30 00 00  	auipc	ra, 3
   1fdb4: e7 80 a0 de  	jalr	-534(ra)
;         return obj_di;
   1fdb8: 6e 75        	ld	a0, 248(sp)
   1fdba: 23 30 ac 00  	sd	a0, 0(s8)
;             const relocated_address = address - self.base_address;
   1fdbe: 08 60        	ld	a0, 0(s0)
   1fdc0: 33 85 aa 40  	sub	a0, s5, a0
   1fdc4: 2a e2        	sd	a0, 256(sp)
   1fdc6: e3 ed aa 10  	bltu	s5, a0, 0x206e0 <.LBB47_196+0x3266>
   1fdca: a2 84        	mv	s1, s0
;         for (di.compile_unit_list.items) |*compile_unit| {
   1fdcc: 68 74        	ld	a0, 232(s0)
   1fdce: 2a e5        	sd	a0, 136(sp)
   1fdd0: 63 05 05 42  	beqz	a0, 0x201fa <.LBB47_196+0x2d80>
   1fdd4: 81 45        	li	a1, 0
   1fdd6: 13 85 84 00  	addi	a0, s1, 8
   1fdda: 2a e9        	sd	a0, 144(sp)
   1fddc: 13 0d 50 05  	li	s10, 85
   1fde0: 37 55 02 00  	lui	a0, 37
   1fde4: 03 35 85 38  	ld	a0, 904(a0)
   1fde8: 2a ea        	sd	a0, 272(sp)
   1fdea: a1 4c        	li	s9, 8
   1fdec: 09 65        	lui	a0, 2
   1fdee: 1b 05 05 48  	addiw	a0, a0, 1152
   1fdf2: b3 0a a1 00  	add	s5, sp, a0
   1fdf6: 41 65        	lui	a0, 16
   1fdf8: 1b 05 05 f0  	addiw	a0, a0, -256
   1fdfc: aa f5        	sd	a0, 232(sp)
   1fdfe: a6 e1        	sd	s1, 192(sp)
   1fe00: 01 a8        	j	0x1fe10 <.LBB47_196+0x2996>
   1fe02: da eb        	sd	s6, 464(sp)
   1fe04: 8e 64        	ld	s1, 192(sp)
   1fe06: ca 75        	ld	a1, 176(sp)
   1fe08: 85 05        	addi	a1, a1, 1
;         for (di.compile_unit_list.items) |*compile_unit| {
   1fe0a: 2a 65        	ld	a0, 136(sp)
   1fe0c: 63 87 a5 3e  	beq	a1, a0, 0x201fa <.LBB47_196+0x2d80>
   1fe10: e8 74        	ld	a0, 232(s1)
   1fe12: e3 f6 a5 58  	bgeu	a1, a0, 0x20b9e <.LBB47_196+0x3724>
   1fe16: e8 70        	ld	a0, 224(s1)
   1fe18: 2e f9        	sd	a1, 176(sp)
   1fe1a: 13 06 80 04  	li	a2, 72
   1fe1e: b3 85 c5 02  	mul	a1, a1, a2
   1fe22: 2e 95        	add	a0, a0, a1
   1fe24: 2a fd        	sd	a0, 184(sp)
;             if (compile_unit.pc_range) |range| {
   1fe26: 03 45 85 01  	lbu	a0, 24(a0)
   1fe2a: 19 cd        	beqz	a0, 0x1fe48 <.LBB47_196+0x29ce>
   1fe2c: 6a 75        	ld	a0, 184(sp)
   1fe2e: 21 05        	addi	a0, a0, 8
   1fe30: 0c 61        	ld	a1, 0(a0)
   1fe32: 08 65        	ld	a0, 8(a0)
   1fe34: 12 66        	ld	a2, 256(sp)
;                 if (target_address >= range.start and target_address < range.end) return compile_unit;
   1fe36: b3 35 b6 00  	sltu	a1, a2, a1
   1fe3a: 93 c5 15 00  	xori	a1, a1, 1
   1fe3e: 33 35 a6 00  	sltu	a0, a2, a0
   1fe42: 6d 8d        	and	a0, a0, a1
   1fe44: 63 19 05 36  	bnez	a0, 0x201b6 <.LBB47_196+0x2d3c>
   1fe48: 8e 64        	ld	s1, 192(sp)
;             if (di.debug_ranges) |debug_ranges| {
   1fe4a: a8 74        	ld	a0, 104(s1)
   1fe4c: 89 65        	lui	a1, 2
   1fe4e: 9b 85 05 42  	addiw	a1, a1, 1056
   1fe52: 33 04 b1 00  	add	s0, sp, a1
   1fe56: 45 d9        	beqz	a0, 0x1fe06 <.LBB47_196+0x298c>
;                 if (compile_unit.die.getAttrSecOffset(AT.ranges)) |ranges_offset| {
   1fe58: ea 75        	ld	a1, 184(sp)
   1fe5a: 90 61        	ld	a2, 0(a1)
;         for (self.attrs.items) |*attr| {
   1fe5c: 14 7a        	ld	a3, 48(a2)
   1fe5e: 89 ce        	beqz	a3, 0x1fe78 <.LBB47_196+0x29fe>
   1fe60: 0c 76        	ld	a1, 40(a2)
   1fe62: 03 ba 04 07  	ld	s4, 112(s1)
;         for (self.attrs.items) |*attr| {
   1fe66: c1 05        	addi	a1, a1, 16
;             if (attr.id == id) return &attr.value;
   1fe68: 03 b7 05 ff  	ld	a4, -16(a1)
   1fe6c: 63 0f a7 01  	beq	a4, s10, 0x1fe8a <.LBB47_196+0x2a10>
;         for (self.attrs.items) |*attr| {
   1fe70: fd 16        	addi	a3, a3, -1
   1fe72: 93 85 05 02  	addi	a1, a1, 32
   1fe76: ed fa        	bnez	a3, 0x1fe68 <.LBB47_196+0x29ee>
   1fe78: 72 64        	ld	s0, 280(sp)
;         const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
   1fe7a: 22 85        	mv	a0, s0
   1fe7c: 97 40 00 00  	auipc	ra, 4
   1fe80: e7 80 c0 d7  	jalr	-644(ra)
;                     continue;
   1fe84: 6e 75        	ld	a0, 248(sp)
   1fe86: 08 e0        	sd	a0, 0(s0)
   1fe88: bd bf        	j	0x1fe06 <.LBB47_196+0x298c>
;         switch (fv) {
   1fe8a: 83 c6 85 00  	lbu	a3, 8(a1)
   1fe8e: 19 47        	li	a4, 6
   1fe90: 63 89 e6 00  	beq	a3, a4, 0x1fea2 <.LBB47_196+0x2a28>
   1fe94: 0d 47        	li	a4, 3
   1fe96: e3 98 e6 20  	bne	a3, a4, 0x208a6 <.LBB47_196+0x342c>
   1fe9a: 83 c6 05 00  	lbu	a3, 0(a1)
;         if (self.signed) return badDwarf();
   1fe9e: e3 9f 06 1e  	bnez	a3, 0x2089c <.LBB47_196+0x3422>
   1fea2: 03 b9 85 ff  	ld	s2, -8(a1)
;                     var stream = io.fixedBufferStream(debug_ranges);
   1fea6: aa e3        	sd	a0, 448(sp)
   1fea8: d2 e7        	sd	s4, 456(sp)
   1feaa: 82 eb        	sd	zero, 464(sp)
;                     var base_address = compile_unit.die.getAttrAddr(di, AT.low_pc, compile_unit.*) catch |err| switch (err) {
   1feac: 09 65        	lui	a0, 2
   1feae: 1b 05 85 3c  	addiw	a0, a0, 968
   1feb2: 0a 95        	add	a0, a0, sp
   1feb4: f2 65        	ld	a1, 280(sp)
   1feb6: ca 66        	ld	a3, 144(sp)
   1feb8: 6a 77        	ld	a4, 184(sp)
   1feba: 97 80 ff ff  	auipc	ra, 1048568
   1febe: e7 80 a0 8c  	jalr	-1846(ra)
   1fec2: 09 65        	lui	a0, 2
   1fec4: 1b 05 05 3d  	addiw	a0, a0, 976
   1fec8: 0a 95        	add	a0, a0, sp
   1feca: 83 59 05 00  	lhu	s3, 0(a0)
   1fece: 63 8c 09 00  	beqz	s3, 0x1fee6 <.LBB47_196+0x2a6c>
   1fed2: 4d 45        	li	a0, 19
   1fed4: e3 95 a9 1e  	bne	s3, a0, 0x208be <.LBB47_196+0x3444>
   1fed8: 81 4d        	li	s11, 0
;                         else => return err,
   1feda: 72 65        	ld	a0, 280(sp)
   1fedc: ee 75        	ld	a1, 248(sp)
   1fede: 0c e1        	sd	a1, 0(a0)
   1fee0: 63 7b 2a 01  	bgeu	s4, s2, 0x1fef6 <.LBB47_196+0x2a7c>
   1fee4: 11 a8        	j	0x1fef8 <.LBB47_196+0x2a7e>
;                     var base_address = compile_unit.die.getAttrAddr(di, AT.low_pc, compile_unit.*) catch |err| switch (err) {
   1fee6: 09 65        	lui	a0, 2
   1fee8: 1b 05 85 3c  	addiw	a0, a0, 968
   1feec: 0a 95        	add	a0, a0, sp
   1feee: 83 3d 05 00  	ld	s11, 0(a0)
   1fef2: 63 63 2a 01  	bltu	s4, s2, 0x1fef8 <.LBB47_196+0x2a7e>
   1fef6: 4a 8a        	mv	s4, s2
   1fef8: d2 eb        	sd	s4, 464(sp)
;                         const begin_addr = try in.readInt(usize, di.endian);
   1fefa: 03 89 04 11  	lb	s2, 272(s1)
   1fefe: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1ff00: 52 65        	ld	a0, 272(sp)
   1ff02: 89 65        	lui	a1, 2
   1ff04: 9b 85 05 42  	addiw	a1, a1, 1056
   1ff08: 8a 95        	add	a1, a1, sp
   1ff0a: 88 e1        	sd	a0, 0(a1)
;                 const amt = try self.read(buffer[index..]);
   1ff0c: 33 06 94 00  	add	a2, s0, s1
   1ff10: b3 86 9c 40  	sub	a3, s9, s1
;             return readFn(self.context, buffer);
   1ff14: 09 65        	lui	a0, 2
   1ff16: 1b 05 05 48  	addiw	a0, a0, 1152
   1ff1a: 0a 95        	add	a0, a0, sp
   1ff1c: 8c 03        	addi	a1, sp, 448
   1ff1e: 97 10 00 00  	auipc	ra, 1
   1ff22: e7 80 a0 79  	jalr	1946(ra)
   1ff26: 09 65        	lui	a0, 2
   1ff28: 1b 05 05 48  	addiw	a0, a0, 1152
   1ff2c: 0a 95        	add	a0, a0, sp
   1ff2e: 08 61        	ld	a0, 0(a0)
;                 if (amt == 0) break;
   1ff30: 63 0c 05 22  	beqz	a0, 0x20168 <.LBB47_196+0x2cee>
;                 index += amt;
   1ff34: 26 95        	add	a0, a0, s1
   1ff36: 63 65 95 7a  	bltu	a0, s1, 0x206e0 <.LBB47_196+0x3266>
   1ff3a: aa 84        	mv	s1, a0
;             while (index < len) {
   1ff3c: e3 68 95 fd  	bltu	a0, s9, 0x1ff0c <.LBB47_196+0x2a92>
;             return bytes;
   1ff40: 09 65        	lui	a0, 2
   1ff42: 1b 05 05 42  	addiw	a0, a0, 1056
   1ff46: 0a 95        	add	a0, a0, sp
   1ff48: 03 3c 05 00  	ld	s8, 0(a0)
   1ff4c: 93 05 f0 0f  	li	a1, 255
   1ff50: 13 96 85 01  	slli	a2, a1, 24
   1ff54: 93 96 85 02  	slli	a3, a1, 40
;     if (endian == native_endian) {
   1ff58: 13 75 19 00  	andi	a0, s2, 1
   1ff5c: 13 97 05 03  	slli	a4, a1, 48
   1ff60: b2 ed        	sd	a2, 216(sp)
   1ff62: b6 e9        	sd	a3, 208(sp)
   1ff64: ba e5        	sd	a4, 200(sp)
   1ff66: 31 e1        	bnez	a0, 0x1ffaa <.LBB47_196+0x2b30>
   1ff68: 13 55 8c 01  	srli	a0, s8, 24
   1ff6c: b7 05 ff 00  	lui	a1, 4080
   1ff70: 6d 8d        	and	a0, a0, a1
   1ff72: 93 55 8c 00  	srli	a1, s8, 8
   1ff76: f1 8d        	and	a1, a1, a2
   1ff78: 4d 8d        	or	a0, a0, a1
   1ff7a: 93 55 8c 02  	srli	a1, s8, 40
   1ff7e: 2e 76        	ld	a2, 232(sp)
   1ff80: f1 8d        	and	a1, a1, a2
   1ff82: 13 56 8c 03  	srli	a2, s8, 56
   1ff86: d1 8d        	or	a1, a1, a2
   1ff88: 4d 8d        	or	a0, a0, a1
   1ff8a: 93 15 8c 01  	slli	a1, s8, 24
   1ff8e: f5 8d        	and	a1, a1, a3
   1ff90: 1b 56 8c 01  	srliw	a2, s8, 24
   1ff94: 02 16        	slli	a2, a2, 32
   1ff96: d1 8d        	or	a1, a1, a2
   1ff98: 13 16 8c 02  	slli	a2, s8, 40
   1ff9c: 79 8e        	and	a2, a2, a4
   1ff9e: 93 16 8c 03  	slli	a3, s8, 56
   1ffa2: 55 8e        	or	a2, a2, a3
   1ffa4: d1 8d        	or	a1, a1, a2
   1ffa6: 33 ec a5 00  	or	s8, a1, a0
   1ffaa: 3e 69        	ld	s2, 456(sp)
   1ffac: 1e 6a        	ld	s4, 448(sp)
   1ffae: de 69        	ld	s3, 464(sp)
;                         const end_addr = try in.readInt(usize, di.endian);
   1ffb0: 0e 65        	ld	a0, 192(sp)
   1ffb2: 03 05 05 11  	lb	a0, 272(a0)
   1ffb6: aa f1        	sd	a0, 224(sp)
   1ffb8: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   1ffba: 52 65        	ld	a0, 272(sp)
   1ffbc: 89 65        	lui	a1, 2
   1ffbe: 9b 85 05 48  	addiw	a1, a1, 1152
   1ffc2: 8a 95        	add	a1, a1, sp
   1ffc4: 88 e1        	sd	a0, 0(a1)
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   1ffc6: 33 05 39 41  	sub	a0, s2, s3
   1ffca: 63 6b a9 70  	bltu	s2, a0, 0x206e0 <.LBB47_196+0x3266>
;                 const amt = try self.read(buffer[index..]);
   1ffce: 33 84 9c 40  	sub	s0, s9, s1
   1ffd2: 63 63 a4 00  	bltu	s0, a0, 0x1ffd8 <.LBB47_196+0x2b5e>
   1ffd6: 2a 84        	mv	s0, a0
;             const end = self.pos + size;
   1ffd8: 33 8b 89 00  	add	s6, s3, s0
   1ffdc: 63 62 3b 71  	bltu	s6, s3, 0x206e0 <.LBB47_196+0x3266>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   1ffe0: e3 6f 69 3b  	bltu	s2, s6, 0x20b9e <.LBB47_196+0x3724>
   1ffe4: 33 05 3b 41  	sub	a0, s6, s3
;     if (!ok) unreachable; // assertion failure
   1ffe8: 63 74 a4 00  	bgeu	s0, a0, 0x1fff0 <.LBB47_196+0x2b76>
   1ffec: 6f c0 bf ae  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (source) |s, i|
   1fff0: 63 0f 3b 01  	beq	s6, s3, 0x2000e <.LBB47_196+0x2b94>
   1fff4: 05 45        	li	a0, 1
   1fff6: 22 86        	mv	a2, s0
;     for (source) |s, i|
   1fff8: 63 63 85 00  	bltu	a0, s0, 0x1fffe <.LBB47_196+0x2b84>
   1fffc: 05 46        	li	a2, 1
   1fffe: 33 85 9a 00  	add	a0, s5, s1
   20002: b3 05 3a 01  	add	a1, s4, s3
;         dest[i] = s;
   20006: 97 40 00 00  	auipc	ra, 4
   2000a: e7 80 e0 26  	jalr	622(ra)
;                 if (amt == 0) break;
   2000e: 63 0d 04 14  	beqz	s0, 0x20168 <.LBB47_196+0x2cee>
;                 index += amt;
   20012: 33 85 84 00  	add	a0, s1, s0
   20016: 63 65 95 6c  	bltu	a0, s1, 0x206e0 <.LBB47_196+0x3266>
   2001a: da 89        	mv	s3, s6
   2001c: aa 84        	mv	s1, a0
;             while (index < len) {
   2001e: e3 64 95 fb  	bltu	a0, s9, 0x1ffc6 <.LBB47_196+0x2b4c>
;             return bytes;
   20022: 09 65        	lui	a0, 2
   20024: 1b 05 05 48  	addiw	a0, a0, 1152
   20028: 0a 95        	add	a0, a0, sp
   2002a: 08 61        	ld	a0, 0(a0)
;     if (endian == native_endian) {
   2002c: 8e 75        	ld	a1, 224(sp)
   2002e: 93 fb 15 00  	andi	s7, a1, 1
   20032: 63 94 0b 04  	bnez	s7, 0x2007a <.LBB47_196+0x2c00>
   20036: 93 55 85 01  	srli	a1, a0, 24
   2003a: 37 06 ff 00  	lui	a2, 4080
   2003e: f1 8d        	and	a1, a1, a2
   20040: 13 56 85 00  	srli	a2, a0, 8
   20044: ee 66        	ld	a3, 216(sp)
   20046: 75 8e        	and	a2, a2, a3
   20048: d1 8d        	or	a1, a1, a2
   2004a: 13 56 85 02  	srli	a2, a0, 40
   2004e: ae 76        	ld	a3, 232(sp)
   20050: 75 8e        	and	a2, a2, a3
   20052: 93 56 85 03  	srli	a3, a0, 56
   20056: 55 8e        	or	a2, a2, a3
   20058: d1 8d        	or	a1, a1, a2
   2005a: 13 16 85 01  	slli	a2, a0, 24
   2005e: ce 66        	ld	a3, 208(sp)
   20060: 75 8e        	and	a2, a2, a3
   20062: 9b 56 85 01  	srliw	a3, a0, 24
   20066: 82 16        	slli	a3, a3, 32
   20068: 55 8e        	or	a2, a2, a3
   2006a: 93 16 85 02  	slli	a3, a0, 40
   2006e: 2e 67        	ld	a4, 200(sp)
   20070: f9 8e        	and	a3, a3, a4
   20072: 62 15        	slli	a0, a0, 56
   20074: 55 8d        	or	a0, a0, a3
   20076: 51 8d        	or	a0, a0, a2
   20078: 4d 8d        	or	a0, a0, a1
;                         if (begin_addr == 0 and end_addr == 0) {
   2007a: b3 65 ac 00  	or	a1, s8, a0
   2007e: e3 82 05 d8  	beqz	a1, 0x1fe02 <.LBB47_196+0x2988>
;                         if (begin_addr == math.maxInt(usize)) {
   20082: fd 55        	li	a1, -1
   20084: 63 00 bc 02  	beq	s8, a1, 0x200a4 <.LBB47_196+0x2c2a>
;                         if (target_address >= base_address + begin_addr and target_address < base_address + end_addr) {
   20088: b3 85 8d 01  	add	a1, s11, s8
   2008c: 63 ea b5 65  	bltu	a1, s11, 0x206e0 <.LBB47_196+0x3266>
   20090: 12 66        	ld	a2, 256(sp)
   20092: 63 6a b6 00  	bltu	a2, a1, 0x200a6 <.LBB47_196+0x2c2c>
   20096: 6e 95        	add	a0, a0, s11
   20098: 63 64 b5 65  	bltu	a0, s11, 0x206e0 <.LBB47_196+0x3266>
   2009c: 92 65        	ld	a1, 256(sp)
   2009e: 63 f4 a5 00  	bgeu	a1, a0, 0x200a6 <.LBB47_196+0x2c2c>
   200a2: 11 aa        	j	0x201b6 <.LBB47_196+0x2d3c>
   200a4: aa 8d        	mv	s11, a0
   200a6: 81 44        	li	s1, 0
;             var bytes: [num_bytes]u8 = undefined;
   200a8: 52 65        	ld	a0, 272(sp)
   200aa: 89 65        	lui	a1, 2
   200ac: 9b 85 05 48  	addiw	a1, a1, 1152
   200b0: 8a 95        	add	a1, a1, sp
   200b2: 88 e1        	sd	a0, 0(a1)
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   200b4: 33 05 69 41  	sub	a0, s2, s6
   200b8: 63 64 a9 62  	bltu	s2, a0, 0x206e0 <.LBB47_196+0x3266>
;                 const amt = try self.read(buffer[index..]);
   200bc: 33 84 9c 40  	sub	s0, s9, s1
   200c0: 63 63 a4 00  	bltu	s0, a0, 0x200c6 <.LBB47_196+0x2c4c>
   200c4: 2a 84        	mv	s0, a0
;             const end = self.pos + size;
   200c6: b3 09 8b 00  	add	s3, s6, s0
   200ca: 63 eb 69 61  	bltu	s3, s6, 0x206e0 <.LBB47_196+0x3266>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   200ce: e3 68 39 2d  	bltu	s2, s3, 0x20b9e <.LBB47_196+0x3724>
   200d2: 33 85 69 41  	sub	a0, s3, s6
;     if (!ok) unreachable; // assertion failure
   200d6: 63 74 a4 00  	bgeu	s0, a0, 0x200de <.LBB47_196+0x2c64>
   200da: 6f c0 df 9f  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;     for (source) |s, i|
   200de: 63 8f 69 01  	beq	s3, s6, 0x200fc <.LBB47_196+0x2c82>
   200e2: 05 45        	li	a0, 1
   200e4: 22 86        	mv	a2, s0
;     for (source) |s, i|
   200e6: 63 63 85 00  	bltu	a0, s0, 0x200ec <.LBB47_196+0x2c72>
   200ea: 05 46        	li	a2, 1
   200ec: 33 85 9a 00  	add	a0, s5, s1
   200f0: b3 05 6a 01  	add	a1, s4, s6
;         dest[i] = s;
   200f4: 97 40 00 00  	auipc	ra, 4
   200f8: e7 80 00 18  	jalr	384(ra)
;                 if (amt == 0) break;
   200fc: 35 c4        	beqz	s0, 0x20168 <.LBB47_196+0x2cee>
;                 index += amt;
   200fe: 33 85 84 00  	add	a0, s1, s0
   20102: 63 6f 95 5c  	bltu	a0, s1, 0x206e0 <.LBB47_196+0x3266>
   20106: 4e 8b        	mv	s6, s3
   20108: aa 84        	mv	s1, a0
;             while (index < len) {
   2010a: e3 65 95 fb  	bltu	a0, s9, 0x200b4 <.LBB47_196+0x2c3a>
;             return bytes;
   2010e: 09 65        	lui	a0, 2
   20110: 1b 05 05 48  	addiw	a0, a0, 1152
   20114: 0a 95        	add	a0, a0, sp
   20116: 03 3c 05 00  	ld	s8, 0(a0)
;     if (endian == native_endian) {
   2011a: e3 9f 0b e8  	bnez	s7, 0x1ffb8 <.LBB47_196+0x2b3e>
   2011e: 13 55 8c 01  	srli	a0, s8, 24
   20122: b7 05 ff 00  	lui	a1, 4080
   20126: 6d 8d        	and	a0, a0, a1
   20128: 93 55 8c 00  	srli	a1, s8, 8
   2012c: 6e 66        	ld	a2, 216(sp)
   2012e: f1 8d        	and	a1, a1, a2
   20130: 4d 8d        	or	a0, a0, a1
   20132: 93 55 8c 02  	srli	a1, s8, 40
   20136: 2e 76        	ld	a2, 232(sp)
   20138: f1 8d        	and	a1, a1, a2
   2013a: 13 56 8c 03  	srli	a2, s8, 56
   2013e: d1 8d        	or	a1, a1, a2
   20140: 4d 8d        	or	a0, a0, a1
   20142: 93 15 8c 01  	slli	a1, s8, 24
   20146: 4e 66        	ld	a2, 208(sp)
   20148: f1 8d        	and	a1, a1, a2
   2014a: 1b 56 8c 01  	srliw	a2, s8, 24
   2014e: 02 16        	slli	a2, a2, 32
   20150: d1 8d        	or	a1, a1, a2
   20152: 13 16 8c 02  	slli	a2, s8, 40
   20156: ae 66        	ld	a3, 200(sp)
   20158: 75 8e        	and	a2, a2, a3
   2015a: 93 16 8c 03  	slli	a3, s8, 56
   2015e: 55 8e        	or	a2, a2, a3
   20160: d1 8d        	or	a1, a1, a2
   20162: 33 ec a5 00  	or	s8, a1, a0
   20166: 89 bd        	j	0x1ffb8 <.LBB47_196+0x2b3e>
   20168: f2 64        	ld	s1, 280(sp)
   2016a: 26 85        	mv	a0, s1
   2016c: 97 40 00 00  	auipc	ra, 4
   20170: e7 80 c0 a8  	jalr	-1396(ra)
   20174: 26 85        	mv	a0, s1
   20176: 97 40 00 00  	auipc	ra, 4
   2017a: e7 80 20 a8  	jalr	-1406(ra)
   2017e: 26 85        	mv	a0, s1
   20180: 97 40 00 00  	auipc	ra, 4
   20184: e7 80 80 a7  	jalr	-1416(ra)
   20188: 26 85        	mv	a0, s1
   2018a: 97 40 00 00  	auipc	ra, 4
   2018e: e7 80 e0 a6  	jalr	-1426(ra)
   20192: 26 85        	mv	a0, s1
   20194: 97 40 00 00  	auipc	ra, 4
   20198: e7 80 40 a6  	jalr	-1436(ra)
   2019c: 93 09 10 03  	li	s3, 49
;             return getSymbolFromDwarf(allocator, relocated_address, &self.dwarf);
   201a0: 26 85        	mv	a0, s1
   201a2: 97 40 00 00  	auipc	ra, 4
   201a6: e7 80 60 a5  	jalr	-1450(ra)
;     const symbol_info = try module.getSymbolAtAddress(debug_info.allocator, address);
   201aa: 26 85        	mv	a0, s1
   201ac: 97 40 00 00  	auipc	ra, 4
   201b0: e7 80 c0 a4  	jalr	-1460(ra)
   201b4: 21 a9        	j	0x205cc <.LBB47_196+0x3152>
   201b6: 0e 67        	ld	a4, 192(sp)
;         for (di.func_list.items) |*func| {
   201b8: 03 35 07 10  	ld	a0, 256(a4)
   201bc: 63 01 05 10  	beqz	a0, 0x202be <.LBB47_196+0x2e44>
   201c0: 6c 7f        	ld	a1, 248(a4)
;         for (di.func_list.items) |*func| {
   201c2: c1 05        	addi	a1, a1, 16
   201c4: f2 64        	ld	s1, 280(sp)
   201c6: ce 7b        	ld	s7, 240(sp)
   201c8: 92 67        	ld	a5, 256(sp)
   201ca: 29 a0        	j	0x201d4 <.LBB47_196+0x2d5a>
   201cc: 7d 15        	addi	a0, a0, -1
   201ce: 93 85 85 02  	addi	a1, a1, 40
   201d2: 65 c5        	beqz	a0, 0x202ba <.LBB47_196+0x2e40>
;             if (func.pc_range) |range| {
   201d4: 03 c6 05 00  	lbu	a2, 0(a1)
   201d8: 75 da        	beqz	a2, 0x201cc <.LBB47_196+0x2d52>
   201da: 03 b6 05 ff  	ld	a2, -16(a1)
   201de: 83 b6 85 ff  	ld	a3, -8(a1)
;                 if (address >= range.start and address < range.end) {
   201e2: 33 b6 c7 00  	sltu	a2, a5, a2
   201e6: 13 46 16 00  	xori	a2, a2, 1
   201ea: b3 b6 d7 00  	sltu	a3, a5, a3
   201ee: 75 8e        	and	a2, a2, a3
   201f0: 71 de        	beqz	a2, 0x201cc <.LBB47_196+0x2d52>
;                     return func.name;
   201f2: 83 bc 85 00  	ld	s9, 8(a1)
   201f6: 88 69        	ld	a0, 16(a1)
   201f8: f1 a0        	j	0x202c4 <.LBB47_196+0x2e4a>
   201fa: f2 64        	ld	s1, 280(sp)
   201fc: 26 85        	mv	a0, s1
   201fe: 97 40 00 00  	auipc	ra, 4
   20202: e7 80 a0 9f  	jalr	-1542(ra)
   20206: 26 85        	mv	a0, s1
   20208: 97 40 00 00  	auipc	ra, 4
   2020c: e7 80 00 9f  	jalr	-1552(ra)
   20210: 01 45        	li	a0, 0
;             return SymbolInfo{};
   20212: 23 34 01 2e  	sd	zero, 744(sp)
   20216: 23 30 01 2e  	sd	zero, 736(sp)
   2021a: 23 3c 01 2c  	sd	zero, 728(sp)
   2021e: b7 15 01 00  	lui	a1, 17
   20222: 93 85 85 d6  	addi	a1, a1, -664
   20226: 03 86 75 04  	lb	a2, 71(a1)
   2022a: 83 86 65 04  	lb	a3, 70(a1)
   2022e: 03 c7 55 04  	lbu	a4, 69(a1)
   20232: 23 38 01 2c  	sd	zero, 720(sp)
   20236: 89 67        	lui	a5, 2
   20238: 9b 87 67 38  	addiw	a5, a5, 902
   2023c: 8a 97        	add	a5, a5, sp
   2023e: 23 80 c7 00  	sb	a2, 0(a5)
   20242: 13 96 86 00  	slli	a2, a3, 8
   20246: 59 8e        	or	a2, a2, a4
   20248: 89 66        	lui	a3, 2
   2024a: 9b 86 46 38  	addiw	a3, a3, 900
   2024e: 8a 96        	add	a3, a3, sp
   20250: 23 90 c6 00  	sh	a2, 0(a3)
   20254: 03 c6 25 04  	lbu	a2, 66(a1)
   20258: 83 c6 15 04  	lbu	a3, 65(a1)
   2025c: 03 87 45 04  	lb	a4, 68(a1)
   20260: 83 c5 35 04  	lbu	a1, 67(a1)
   20264: 22 06        	slli	a2, a2, 8
   20266: 55 8e        	or	a2, a2, a3
   20268: 93 16 87 00  	slli	a3, a4, 8
   2026c: d5 8d        	or	a1, a1, a3
   2026e: c2 05        	slli	a1, a1, 16
   20270: d1 8d        	or	a1, a1, a2
   20272: 09 66        	lui	a2, 2
   20274: 1b 06 06 38  	addiw	a2, a2, 896
   20278: 0a 96        	add	a2, a2, sp
   2027a: 0c c2        	sw	a1, 0(a2)
   2027c: ee 75        	ld	a1, 248(sp)
   2027e: 8c e0        	sd	a1, 0(s1)
   20280: b7 25 01 00  	lui	a1, 18
   20284: 13 8b 65 bf  	addi	s6, a1, -1034
   20288: 8d 4d        	li	s11, 3
   2028a: 05 49        	li	s2, 1
   2028c: 0d 4a        	li	s4, 3
   2028e: da 8c        	mv	s9, s6
   20290: ce 7b        	ld	s7, 240(sp)
   20292: b9 aa        	j	0x203f0 <.LBB47_196+0x2f76>
   20294: 72 64        	ld	s0, 280(sp)
   20296: 22 85        	mv	a0, s0
   20298: 97 40 00 00  	auipc	ra, 4
   2029c: e7 80 00 96  	jalr	-1696(ra)
   202a0: 22 85        	mv	a0, s0
   202a2: 97 40 00 00  	auipc	ra, 4
   202a6: e7 80 60 95  	jalr	-1706(ra)
   202aa: 22 85        	mv	a0, s0
   202ac: 97 40 00 00  	auipc	ra, 4
   202b0: e7 80 c0 94  	jalr	-1716(ra)
   202b4: 93 0c 10 03  	li	s9, 49
   202b8: a5 ac        	j	0x20530 <.LBB47_196+0x30b6>
   202ba: 81 4c        	li	s9, 0
   202bc: 21 a0        	j	0x202c4 <.LBB47_196+0x2e4a>
   202be: 81 4c        	li	s9, 0
   202c0: f2 64        	ld	s1, 280(sp)
   202c2: ce 7b        	ld	s7, 240(sp)
   202c4: 0d 4a        	li	s4, 3
;             .symbol_name = nosuspend di.getSymbolName(address) orelse "???",
   202c6: 63 84 0c 00  	beqz	s9, 0x202ce <.LBB47_196+0x2e54>
   202ca: 2a 8a        	mv	s4, a0
   202cc: 29 a0        	j	0x202d6 <.LBB47_196+0x2e5c>
   202ce: 37 25 01 00  	lui	a0, 18
   202d2: 93 0c 65 bf  	addi	s9, a0, -1034
   202d6: ea 78        	ld	a7, 184(sp)
;             .compile_unit_name = compile_unit.die.getAttrString(di, DW.AT.name, di.debug_str, compile_unit.*) catch |err| switch (err) {
   202d8: 03 b6 08 00  	ld	a2, 0(a7)
   202dc: 1c 77        	ld	a5, 40(a4)
   202de: 03 38 07 03  	ld	a6, 48(a4)
   202e2: 09 65        	lui	a0, 2
   202e4: 1b 05 85 4d  	addiw	a0, a0, 1240
   202e8: 0a 95        	add	a0, a0, sp
   202ea: 0d 47        	li	a4, 3
   202ec: a6 85        	mv	a1, s1
   202ee: ca 66        	ld	a3, 144(sp)
   202f0: 97 70 ff ff  	auipc	ra, 1048567
   202f4: e7 80 60 12  	jalr	294(ra)
   202f8: 09 65        	lui	a0, 2
   202fa: 1b 05 85 4e  	addiw	a0, a0, 1256
   202fe: 0a 95        	add	a0, a0, sp
   20300: 03 55 05 00  	lhu	a0, 0(a0)
   20304: 93 05 20 03  	li	a1, 50
   20308: 63 04 b5 02  	beq	a0, a1, 0x20330 <.LBB47_196+0x2eb6>
   2030c: cd 45        	li	a1, 19
;             .compile_unit_name = compile_unit.die.getAttrString(di, DW.AT.name, di.debug_str, compile_unit.*) catch |err| switch (err) {
   2030e: 63 01 b5 02  	beq	a0, a1, 0x20330 <.LBB47_196+0x2eb6>
   20312: e3 1a 05 1a  	bnez	a0, 0x20cc6 <.LBB47_196+0x384c>
   20316: 09 65        	lui	a0, 2
   20318: 1b 05 85 4d  	addiw	a0, a0, 1240
   2031c: 0a 95        	add	a0, a0, sp
   2031e: 03 3b 05 00  	ld	s6, 0(a0)
   20322: 09 65        	lui	a0, 2
   20324: 1b 05 05 4e  	addiw	a0, a0, 1248
   20328: 0a 95        	add	a0, a0, sp
   2032a: 83 3d 05 00  	ld	s11, 0(a0)
   2032e: 01 a8        	j	0x2033e <.LBB47_196+0x2ec4>
   20330: 6e 75        	ld	a0, 248(sp)
   20332: 88 e0        	sd	a0, 0(s1)
   20334: 37 25 01 00  	lui	a0, 18
   20338: 13 0b 65 bf  	addi	s6, a0, -1034
   2033c: 8d 4d        	li	s11, 3
;             .line_info = nosuspend di.getLineNumberInfo(allocator, compile_unit.*, address) catch |err| switch (err) {
   2033e: 05 65        	lui	a0, 1
   20340: 1b 05 05 2d  	addiw	a0, a0, 720
   20344: 0a 95        	add	a0, a0, sp
   20346: a6 85        	mv	a1, s1
   20348: 4a 66        	ld	a2, 144(sp)
   2034a: b2 66        	ld	a3, 264(sp)
   2034c: 6a 77        	ld	a4, 184(sp)
   2034e: 92 67        	ld	a5, 256(sp)
   20350: 97 a0 ff ff  	auipc	ra, 1048570
   20354: e7 80 a0 48  	jalr	1162(ra)
   20358: 05 65        	lui	a0, 1
   2035a: 1b 05 05 2f  	addiw	a0, a0, 752
   2035e: 0a 95        	add	a0, a0, sp
   20360: 83 59 05 00  	lhu	s3, 0(a0)
   20364: 13 05 20 03  	li	a0, 50
   20368: 63 86 a9 04  	beq	s3, a0, 0x203b4 <.LBB47_196+0x2f3a>
   2036c: 4d 45        	li	a0, 19
;             .line_info = nosuspend di.getLineNumberInfo(allocator, compile_unit.*, address) catch |err| switch (err) {
   2036e: 63 83 a9 04  	beq	s3, a0, 0x203b4 <.LBB47_196+0x2f3a>
   20372: 63 91 09 56  	bnez	s3, 0x208d4 <.LBB47_196+0x345a>
   20376: 01 49        	li	s2, 0
;             .line_info = nosuspend di.getLineNumberInfo(allocator, compile_unit.*, address) catch |err| switch (err) {
   20378: 05 65        	lui	a0, 1
   2037a: 1b 05 85 2e  	addiw	a0, a0, 744
   2037e: 0a 95        	add	a0, a0, sp
   20380: 08 61        	ld	a0, 0(a0)
   20382: 85 65        	lui	a1, 1
   20384: 9b 85 05 2e  	addiw	a1, a1, 736
   20388: 8a 95        	add	a1, a1, sp
   2038a: 8c 61        	ld	a1, 0(a1)
   2038c: 05 66        	lui	a2, 1
   2038e: 1b 06 86 2d  	addiw	a2, a2, 728
   20392: 0a 96        	add	a2, a2, sp
   20394: 10 62        	ld	a2, 0(a2)
   20396: 85 66        	lui	a3, 1
   20398: 9b 86 06 2d  	addiw	a3, a3, 720
   2039c: 8a 96        	add	a3, a3, sp
   2039e: 94 62        	ld	a3, 0(a3)
   203a0: 23 34 a1 2e  	sd	a0, 744(sp)
   203a4: 23 30 b1 2e  	sd	a1, 736(sp)
   203a8: 23 3c c1 2c  	sd	a2, 728(sp)
   203ac: 23 38 d1 2c  	sd	a3, 720(sp)
   203b0: 05 45        	li	a0, 1
   203b2: 3d a8        	j	0x203f0 <.LBB47_196+0x2f76>
   203b4: 01 45        	li	a0, 0
;             .line_info = nosuspend di.getLineNumberInfo(allocator, compile_unit.*, address) catch |err| switch (err) {
   203b6: 23 34 01 2e  	sd	zero, 744(sp)
   203ba: 23 30 01 2e  	sd	zero, 736(sp)
   203be: 23 3c 01 2c  	sd	zero, 728(sp)
   203c2: 23 38 01 2c  	sd	zero, 720(sp)
   203c6: 89 65        	lui	a1, 2
   203c8: 9b 85 05 38  	addiw	a1, a1, 896
   203cc: 8a 95        	add	a1, a1, sp
   203ce: 23 a0 05 00  	sw	zero, 0(a1)
   203d2: 89 65        	lui	a1, 2
   203d4: 9b 85 45 38  	addiw	a1, a1, 900
   203d8: 8a 95        	add	a1, a1, sp
   203da: 23 90 05 00  	sh	zero, 0(a1)
   203de: 89 65        	lui	a1, 2
   203e0: 9b 85 65 38  	addiw	a1, a1, 902
   203e4: 8a 95        	add	a1, a1, sp
   203e6: 23 80 05 00  	sb	zero, 0(a1)
;                 else => return err,
   203ea: ee 75        	ld	a1, 248(sp)
   203ec: 8c e0        	sd	a1, 0(s1)
   203ee: 05 49        	li	s2, 1
;             return getSymbolFromDwarf(allocator, relocated_address, &self.dwarf);
   203f0: 83 35 01 2d  	ld	a1, 720(sp)
   203f4: 03 36 81 2d  	ld	a2, 728(sp)
   203f8: 83 36 01 2e  	ld	a3, 736(sp)
   203fc: 2e f6        	sd	a1, 296(sp)
   203fe: 32 fa        	sd	a2, 304(sp)
   20400: 36 fe        	sd	a3, 312(sp)
   20402: 83 35 81 2e  	ld	a1, 744(sp)
   20406: 09 66        	lui	a2, 2
   20408: 1b 06 06 38  	addiw	a2, a2, 896
   2040c: 0a 96        	add	a2, a2, sp
   2040e: 10 42        	lw	a2, 0(a2)
   20410: 89 66        	lui	a3, 2
   20412: 9b 86 46 38  	addiw	a3, a3, 900
   20416: 8a 96        	add	a3, a3, sp
   20418: 83 96 06 00  	lh	a3, 0(a3)
   2041c: 09 67        	lui	a4, 2
   2041e: 1b 07 67 38  	addiw	a4, a4, 902
   20422: 0a 97        	add	a4, a4, sp
   20424: 03 07 07 00  	lb	a4, 0(a4)
   20428: ae e2        	sd	a1, 320(sp)
   2042a: 23 20 c1 12  	sw	a2, 288(sp)
   2042e: 23 12 d1 12  	sh	a3, 292(sp)
   20432: 23 03 e1 12  	sb	a4, 294(sp)
;     const symbol_info = try module.getSymbolAtAddress(debug_info.allocator, address);
   20436: e6 e6        	sd	s9, 328(sp)
   20438: d2 ea        	sd	s4, 336(sp)
   2043a: da ee        	sd	s6, 344(sp)
   2043c: ee f2        	sd	s11, 352(sp)
   2043e: b2 75        	ld	a1, 296(sp)
   20440: 52 76        	ld	a2, 304(sp)
   20442: f2 76        	ld	a3, 312(sp)
   20444: 16 67        	ld	a4, 320(sp)
   20446: ae f6        	sd	a1, 360(sp)
   20448: b2 fa        	sd	a2, 368(sp)
   2044a: b6 fe        	sd	a3, 376(sp)
   2044c: 3a e3        	sd	a4, 384(sp)
   2044e: 83 05 01 12  	lb	a1, 288(sp)
   20452: 03 06 11 12  	lb	a2, 289(sp)
   20456: 83 06 21 12  	lb	a3, 290(sp)
   2045a: 23 04 a1 18  	sb	a0, 392(sp)
   2045e: a3 04 b1 18  	sb	a1, 393(sp)
   20462: 23 05 c1 18  	sb	a2, 394(sp)
   20466: a3 05 d1 18  	sb	a3, 395(sp)
   2046a: 03 05 31 12  	lb	a0, 291(sp)
   2046e: 83 05 41 12  	lb	a1, 292(sp)
   20472: 03 06 51 12  	lb	a2, 293(sp)
   20476: 83 06 61 12  	lb	a3, 294(sp)
   2047a: 23 06 a1 18  	sb	a0, 396(sp)
   2047e: a3 06 b1 18  	sb	a1, 397(sp)
   20482: 23 07 c1 18  	sb	a2, 398(sp)
   20486: a3 07 d1 18  	sb	a3, 399(sp)
   2048a: f6 7a        	ld	s5, 376(sp)
   2048c: 1a 64        	ld	s0, 384(sp)
   2048e: b0 12        	addi	a2, sp, 360
;         symbol_info.compile_unit_name,
   20490: 26 85        	mv	a0, s1
   20492: aa 75        	ld	a1, 168(sp)
   20494: ea 66        	ld	a3, 152(sp)
   20496: 66 87        	mv	a4, s9
   20498: d2 87        	mv	a5, s4
   2049a: 5a 88        	mv	a6, s6
   2049c: ee 88        	mv	a7, s11
   2049e: 8a 73        	ld	t2, 160(sp)
   204a0: 97 90 ff ff  	auipc	ra, 1048569
   204a4: e7 80 c0 86  	jalr	-1940(ra)
;         if (self.line_info) |li| {
   204a8: 93 75 19 00  	andi	a1, s2, 1
;         symbol_info.compile_unit_name,
   204ac: 2a 8b        	mv	s6, a0
   204ae: a1 e1        	bnez	a1, 0x204ee <.LBB47_196+0x3074>
   204b0: 09 e4        	bnez	s0, 0x204ba <.LBB47_196+0x3040>
   204b2: 37 55 02 00  	lui	a0, 37
   204b6: 83 3a 85 38  	ld	s5, 904(a0)
   204ba: 15 c8        	beqz	s0, 0x204ee <.LBB47_196+0x3074>
   204bc: 63 94 0a 00  	bnez	s5, 0x204c4 <.LBB47_196+0x304a>
   204c0: 6f e0 ff b9  	j	0x1f05e <.LBB47_196+0x1be4>
   204c4: 32 65        	ld	a0, 264(sp)
   204c6: 03 3a 05 00  	ld	s4, 0(a0)
   204ca: 03 39 85 00  	ld	s2, 8(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   204ce: 93 05 a0 0a  	li	a1, 170
   204d2: 56 85        	mv	a0, s5
   204d4: 22 86        	mv	a2, s0
   204d6: 97 40 00 00  	auipc	ra, 4
   204da: e7 80 40 dc  	jalr	-572(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   204de: 83 37 09 01  	ld	a5, 16(s2)
   204e2: 52 85        	mv	a0, s4
   204e4: d6 85        	mv	a1, s5
   204e6: 22 86        	mv	a2, s0
   204e8: 81 46        	li	a3, 0
   204ea: 5e 87        	mv	a4, s7
   204ec: 82 97        	jalr	a5
;     return printLineInfo(
   204ee: 13 15 0b 03  	slli	a0, s6, 48
   204f2: 41 91        	srli	a0, a0, 48
   204f4: 81 49        	li	s3, 0
   204f6: 79 c9        	beqz	a0, 0x205cc <.LBB47_196+0x3152>
   204f8: 26 85        	mv	a0, s1
   204fa: 97 30 00 00  	auipc	ra, 3
   204fe: e7 80 e0 6f  	jalr	1790(ra)
   20502: da 89        	mv	s3, s6
   20504: e1 a0        	j	0x205cc <.LBB47_196+0x3152>
   20506: 72 64        	ld	s0, 280(sp)
   20508: 22 85        	mv	a0, s0
   2050a: 97 30 00 00  	auipc	ra, 3
   2050e: e7 80 e0 6e  	jalr	1774(ra)
   20512: 72 65        	ld	a0, 280(sp)
   20514: 97 30 00 00  	auipc	ra, 3
   20518: e7 80 40 6e  	jalr	1764(ra)
   2051c: 32 65        	ld	a0, 264(sp)
;             errdefer allocator.destroy(compile_unit_die);
   2051e: 0c 65        	ld	a1, 8(a0)
   20520: 08 61        	ld	a0, 0(a0)
   20522: 9c 69        	ld	a5, 16(a1)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20524: 13 06 80 04  	li	a2, 72
   20528: 8d 46        	li	a3, 3
   2052a: ee 65        	ld	a1, 216(sp)
   2052c: 4e 77        	ld	a4, 240(sp)
   2052e: 82 97        	jalr	a5
   20530: 72 6c        	ld	s8, 280(sp)
   20532: 62 85        	mv	a0, s8
   20534: 97 30 00 00  	auipc	ra, 3
   20538: e7 80 40 6c  	jalr	1732(ra)
   2053c: 62 85        	mv	a0, s8
   2053e: 97 30 00 00  	auipc	ra, 3
   20542: e7 80 a0 6b  	jalr	1722(ra)
   20546: 0a 7a        	ld	s4, 160(sp)
   20548: ea 6a        	ld	s5, 152(sp)
   2054a: aa 7d        	ld	s11, 168(sp)
   2054c: 4e 7d        	ld	s10, 240(sp)
   2054e: 62 85        	mv	a0, s8
   20550: 97 30 00 00  	auipc	ra, 3
   20554: e7 80 80 6a  	jalr	1704(ra)
   20558: 32 65        	ld	a0, 264(sp)
   2055a: 0c 65        	ld	a1, 8(a0)
   2055c: 08 61        	ld	a0, 0(a0)
   2055e: 9c 69        	ld	a5, 16(a1)
   20560: 13 06 80 12  	li	a2, 296
   20564: 8d 46        	li	a3, 3
   20566: 8e 65        	ld	a1, 192(sp)
   20568: 6a 87        	mv	a4, s10
   2056a: 82 97        	jalr	a5
   2056c: 62 85        	mv	a0, s8
   2056e: 97 30 00 00  	auipc	ra, 3
   20572: e7 80 a0 68  	jalr	1674(ra)
   20576: e6 89        	mv	s3, s9
;             return self.lookupModuleDl(address);
   20578: 62 85        	mv	a0, s8
   2057a: 97 30 00 00  	auipc	ra, 3
   2057e: e7 80 e0 67  	jalr	1662(ra)
;     const module = debug_info.getModuleForAddress(address) catch |err| switch (err) {
   20582: 13 95 09 03  	slli	a0, s3, 48
   20586: 41 91        	srli	a0, a0, 48
   20588: cd 45        	li	a1, 19
   2058a: 63 06 b5 00  	beq	a0, a1, 0x20596 <.LBB47_196+0x311c>
   2058e: 93 05 20 03  	li	a1, 50
   20592: 63 1f b5 06  	bne	a0, a1, 0x20610 <.LBB47_196+0x3196>
;             return printLineInfo(
   20596: 37 15 01 00  	lui	a0, 17
   2059a: 13 06 85 db  	addi	a2, a0, -584
   2059e: 37 25 01 00  	lui	a0, 18
   205a2: 13 07 65 bf  	addi	a4, a0, -1034
   205a6: 8d 47        	li	a5, 3
   205a8: 8d 48        	li	a7, 3
   205aa: 62 85        	mv	a0, s8
   205ac: ee 85        	mv	a1, s11
   205ae: d6 86        	mv	a3, s5
   205b0: 3a 88        	mv	a6, a4
   205b2: d2 83        	mv	t2, s4
   205b4: 97 80 ff ff  	auipc	ra, 1048568
   205b8: e7 80 80 75  	jalr	1880(ra)
   205bc: aa 89        	mv	s3, a0
   205be: 42 15        	slli	a0, a0, 48
   205c0: 41 91        	srli	a0, a0, 48
   205c2: 39 e5        	bnez	a0, 0x20610 <.LBB47_196+0x3196>
   205c4: 81 49        	li	s3, 0
;             return printLineInfo(
   205c6: 6e 75        	ld	a0, 248(sp)
   205c8: 23 30 ac 00  	sd	a0, 0(s8)
   205cc: 4e 85        	mv	a0, s3
   205ce: 89 65        	lui	a1, 2
   205d0: 9b 85 05 e0  	addiw	a1, a1, -512
   205d4: 2e 91        	add	sp, sp, a1
   205d6: 83 30 81 7e  	ld	ra, 2024(sp)
   205da: 03 34 01 7e  	ld	s0, 2016(sp)
   205de: 83 34 81 7d  	ld	s1, 2008(sp)
   205e2: 03 39 01 7d  	ld	s2, 2000(sp)
   205e6: 83 39 81 7c  	ld	s3, 1992(sp)
   205ea: 03 3a 01 7c  	ld	s4, 1984(sp)
   205ee: 83 3a 81 7b  	ld	s5, 1976(sp)
   205f2: 03 3b 01 7b  	ld	s6, 1968(sp)
   205f6: 83 3b 81 7a  	ld	s7, 1960(sp)
   205fa: 03 3c 01 7a  	ld	s8, 1952(sp)
   205fe: 83 3c 81 79  	ld	s9, 1944(sp)
   20602: 03 3d 01 79  	ld	s10, 1936(sp)
   20606: 83 3d 81 78  	ld	s11, 1928(sp)
   2060a: 13 01 01 7f  	addi	sp, sp, 2032
   2060e: 82 80        	ret
   20610: 62 85        	mv	a0, s8
   20612: 97 30 00 00  	auipc	ra, 3
   20616: e7 80 60 5e  	jalr	1510(ra)
   2061a: 4d bf        	j	0x205cc <.LBB47_196+0x3152>
;             const max_load = (self.capacity() * max_load_percentage) / 100;
   2061c: 66 65        	ld	a0, 88(sp)
   2061e: 97 30 00 00  	auipc	ra, 3
   20622: e7 80 80 a7  	jalr	-1416(ra)
   20626: 95 45        	li	a1, 5
   20628: 92 15        	slli	a1, a1, 36
   2062a: 02 15        	slli	a0, a0, 32
   2062c: 37 56 02 00  	lui	a2, 37
   20630: 03 36 86 3b  	ld	a2, 952(a2)
   20634: b3 35 b5 02  	mulhu	a1, a0, a1
;             assert(max_load >= self.available);
   20638: 32 65        	ld	a0, 264(sp)
   2063a: 03 65 c5 01  	lwu	a0, 28(a0)
;             const max_load = (self.capacity() * max_load_percentage) / 100;
   2063e: 89 81        	srli	a1, a1, 2
   20640: b3 b5 c5 02  	mulhu	a1, a1, a2
   20644: 89 81        	srli	a1, a1, 2
   20646: 63 f4 a5 00  	bgeu	a1, a0, 0x2064e <.LBB47_196+0x31d4>
   2064a: 6f c0 cf c8  	j	0x1cad6 <debug.printSourceAtAddress__anon_4137+0x1da>
;             return @truncate(Size, max_load - self.available);
   2064e: 3b 85 a5 40  	subw	a0, a1, a0
;                 try self.grow(allocator, capacityForSize(self.load() + new_count), ctx);
   20652: 05 25        	addiw	a0, a0, 1
   20654: 51 c5        	beqz	a0, 0x206e0 <.LBB47_196+0x3266>
   20656: 85 65        	lui	a1, 1
   20658: 9b 85 05 2d  	addiw	a1, a1, 720
   2065c: 8a 95        	add	a1, a1, sp
   2065e: 23 3c b1 2c  	sd	a1, 728(sp)
   20662: 93 05 00 02  	li	a1, 32
   20666: 23 30 b1 2e  	sd	a1, 736(sp)
;             var new_cap = @truncate(u32, (@as(u64, size) * 100) / max_load_percentage + 1);
   2066a: e5 45        	li	a1, 25
   2066c: 8a 15        	slli	a1, a1, 34
   2066e: 37 56 02 00  	lui	a2, 37
   20672: 03 36 86 3a  	ld	a2, 936(a2)
   20676: 02 15        	slli	a0, a0, 32
   20678: 33 35 b5 02  	mulhu	a0, a0, a1
   2067c: 23 38 01 2c  	sd	zero, 720(sp)
   20680: 33 35 c5 02  	mulhu	a0, a0, a2
   20684: 19 81        	srli	a0, a0, 6
   20686: 1b 06 15 00  	addiw	a2, a0, 1
;             new_cap = math.ceilPowerOfTwo(u32, new_cap) catch unreachable;
   2068a: 09 65        	lui	a0, 2
   2068c: 1b 05 85 4d  	addiw	a0, a0, 1240
   20690: 0a 95        	add	a0, a0, sp
   20692: 8c 0d        	addi	a1, sp, 720
   20694: 97 30 00 00  	auipc	ra, 3
   20698: e7 80 60 b4  	jalr	-1210(ra)
   2069c: 09 65        	lui	a0, 2
   2069e: 1b 05 c5 4d  	addiw	a0, a0, 1244
   206a2: 0a 95        	add	a0, a0, sp
   206a4: 03 55 05 00  	lhu	a0, 0(a0)
   206a8: 63 1b 05 5e  	bnez	a0, 0x20c9e <.LBB47_196+0x3824>
;                 try self.grow(allocator, capacityForSize(self.load() + new_count), ctx);
   206ac: 09 65        	lui	a0, 2
   206ae: 1b 05 85 4d  	addiw	a0, a0, 1240
   206b2: 0a 95        	add	a0, a0, sp
   206b4: 14 41        	lw	a3, 0(a0)
   206b6: 32 65        	ld	a0, 264(sp)
   206b8: 13 06 05 02  	addi	a2, a0, 32
   206bc: 62 85        	mv	a0, s8
   206be: e6 65        	ld	a1, 88(sp)
   206c0: 97 40 00 00  	auipc	ra, 4
   206c4: e7 80 20 93  	jalr	-1742(ra)
   206c8: aa 8c        	mv	s9, a0
   206ca: 42 15        	slli	a0, a0, 48
   206cc: 41 91        	srli	a0, a0, 48
   206ce: 63 0d 05 ec  	beqz	a0, 0x1fda8 <.LBB47_196+0x292e>
   206d2: 62 85        	mv	a0, s8
   206d4: 97 30 00 00  	auipc	ra, 3
   206d8: e7 80 40 52  	jalr	1316(ra)
   206dc: 6f e0 5f 9f  	j	0x1f0d0 <.LBB47_196+0x1c56>
   206e0: 37 15 01 00  	lui	a0, 17
   206e4: 13 05 95 5d  	addi	a0, a0, 1497
   206e8: c1 45        	li	a1, 16
   206ea: 81 46        	li	a3, 0
   206ec: 97 30 00 00  	auipc	ra, 3
   206f0: e7 80 e0 c8  	jalr	-882(ra)
   206f4: 72 65        	ld	a0, 280(sp)
   206f6: 97 30 00 00  	auipc	ra, 3
   206fa: e7 80 20 50  	jalr	1282(ra)
   206fe: 93 0c 20 03  	li	s9, 50
   20702: 3d b5        	j	0x20530 <.LBB47_196+0x30b6>
   20704: 72 6c        	ld	s8, 280(sp)
   20706: 2d a1        	j	0x20b30 <.LBB47_196+0x36b6>
   20708: 93 0c 20 03  	li	s9, 50
   2070c: 6f e0 af e4  	j	0x1ed56 <.LBB47_196+0x18dc>
;     return error.InvalidDebugInfo;
   20710: 62 85        	mv	a0, s8
   20712: 97 30 00 00  	auipc	ra, 3
   20716: e7 80 60 4e  	jalr	1254(ra)
;         var it = self.state.buffer_list.first;
   2071a: 09 65        	lui	a0, 2
   2071c: 1b 05 05 30  	addiw	a0, a0, 768
   20720: 0a 95        	add	a0, a0, sp
   20722: 03 39 05 00  	ld	s2, 0(a0)
   20726: 93 0c 20 03  	li	s9, 50
;         while (it) |node| {
   2072a: 63 14 09 00  	bnez	s2, 0x20732 <.LBB47_196+0x32b8>
   2072e: 6f e0 2f d8  	j	0x1ecb0 <.LBB47_196+0x1836>
   20732: 37 55 02 00  	lui	a0, 37
   20736: 83 3a 85 38  	ld	s5, 904(a0)
   2073a: aa 7d        	ld	s11, 168(sp)
   2073c: 29 a0        	j	0x20746 <.LBB47_196+0x32cc>
;         while (it) |node| {
   2073e: 63 14 09 00  	bnez	s2, 0x20746 <.LBB47_196+0x32cc>
   20742: 6f e0 8f f6  	j	0x1eeaa <.LBB47_196+0x1a30>
;             self.child_allocator.free(node.data);
   20746: 03 35 09 01  	ld	a0, 16(s2)
   2074a: 81 44        	li	s1, 0
   2074c: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   2074e: 01 c5        	beqz	a0, 0x20756 <.LBB47_196+0x32dc>
   20750: 03 34 89 00  	ld	s0, 8(s2)
   20754: aa 84        	mv	s1, a0
   20756: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   2075a: f5 d0        	beqz	s1, 0x2073e <.LBB47_196+0x32c4>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   2075c: 19 e0        	bnez	s0, 0x20762 <.LBB47_196+0x32e8>
   2075e: 6f e0 1f 90  	j	0x1f05e <.LBB47_196+0x1be4>
   20762: 09 65        	lui	a0, 2
   20764: 1b 05 05 2f  	addiw	a0, a0, 752
   20768: 0a 95        	add	a0, a0, sp
   2076a: 03 3a 05 00  	ld	s4, 0(a0)
   2076e: 09 65        	lui	a0, 2
   20770: 1b 05 85 2f  	addiw	a0, a0, 760
   20774: 0a 95        	add	a0, a0, sp
   20776: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   2077a: 93 05 a0 0a  	li	a1, 170
   2077e: 22 85        	mv	a0, s0
   20780: 26 86        	mv	a2, s1
   20782: 97 40 00 00  	auipc	ra, 4
   20786: e7 80 80 b1  	jalr	-1256(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   2078a: 83 37 0b 01  	ld	a5, 16(s6)
   2078e: 52 85        	mv	a0, s4
   20790: a2 85        	mv	a1, s0
   20792: 26 86        	mv	a2, s1
   20794: 81 46        	li	a3, 0
   20796: 6a 87        	mv	a4, s10
   20798: 82 97        	jalr	a5
   2079a: 55 b7        	j	0x2073e <.LBB47_196+0x32c4>
;         var it = self.state.buffer_list.first;
   2079c: 09 65        	lui	a0, 2
   2079e: 1b 05 05 30  	addiw	a0, a0, 768
   207a2: 0a 95        	add	a0, a0, sp
   207a4: 03 39 05 00  	ld	s2, 0(a0)
;         while (it) |node| {
   207a8: e3 05 09 d8  	beqz	s2, 0x20532 <.LBB47_196+0x30b8>
   207ac: 37 55 02 00  	lui	a0, 37
   207b0: 83 3a 85 38  	ld	s5, 904(a0)
   207b4: 89 a0        	j	0x207f6 <.LBB47_196+0x337c>
   207b6: 09 65        	lui	a0, 2
   207b8: 1b 05 05 2f  	addiw	a0, a0, 752
   207bc: 0a 95        	add	a0, a0, sp
   207be: 03 3a 05 00  	ld	s4, 0(a0)
   207c2: 09 65        	lui	a0, 2
   207c4: 1b 05 85 2f  	addiw	a0, a0, 760
   207c8: 0a 95        	add	a0, a0, sp
   207ca: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   207ce: 93 05 a0 0a  	li	a1, 170
   207d2: 22 85        	mv	a0, s0
   207d4: 26 86        	mv	a2, s1
   207d6: 97 40 00 00  	auipc	ra, 4
   207da: e7 80 40 ac  	jalr	-1340(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   207de: 83 37 0b 01  	ld	a5, 16(s6)
   207e2: 52 85        	mv	a0, s4
   207e4: a2 85        	mv	a1, s0
   207e6: 26 86        	mv	a2, s1
   207e8: 81 46        	li	a3, 0
   207ea: 6a 87        	mv	a4, s10
   207ec: 82 97        	jalr	a5
;         while (it) |node| {
   207ee: 63 14 09 00  	bnez	s2, 0x207f6 <.LBB47_196+0x337c>
   207f2: 6f e0 df 8f  	j	0x1f0ee <.LBB47_196+0x1c74>
;             self.child_allocator.free(node.data);
   207f6: 03 35 09 01  	ld	a0, 16(s2)
   207fa: 81 44        	li	s1, 0
   207fc: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   207fe: 01 c5        	beqz	a0, 0x20806 <.LBB47_196+0x338c>
   20800: 03 34 89 00  	ld	s0, 8(s2)
   20804: aa 84        	mv	s1, a0
   20806: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   2080a: f5 d0        	beqz	s1, 0x207ee <.LBB47_196+0x3374>
   2080c: 4d f4        	bnez	s0, 0x207b6 <.LBB47_196+0x333c>
   2080e: 6f e0 1f 85  	j	0x1f05e <.LBB47_196+0x1be4>
;     return error.InvalidDebugInfo;
   20812: 62 85        	mv	a0, s8
   20814: 97 30 00 00  	auipc	ra, 3
   20818: e7 80 40 3e  	jalr	996(ra)
;         var it = self.state.buffer_list.first;
   2081c: 09 65        	lui	a0, 2
   2081e: 1b 05 05 30  	addiw	a0, a0, 768
   20822: 0a 95        	add	a0, a0, sp
   20824: 03 39 05 00  	ld	s2, 0(a0)
   20828: 93 0c 20 03  	li	s9, 50
   2082c: 63 14 09 00  	bnez	s2, 0x20834 <.LBB47_196+0x33ba>
   20830: 6f e0 0f c8  	j	0x1ecb0 <.LBB47_196+0x1836>
   20834: 37 55 02 00  	lui	a0, 37
   20838: 83 3a 85 38  	ld	s5, 904(a0)
   2083c: aa 7d        	ld	s11, 168(sp)
   2083e: 89 a0        	j	0x20880 <.LBB47_196+0x3406>
   20840: 09 65        	lui	a0, 2
   20842: 1b 05 05 2f  	addiw	a0, a0, 752
   20846: 0a 95        	add	a0, a0, sp
   20848: 03 3a 05 00  	ld	s4, 0(a0)
   2084c: 09 65        	lui	a0, 2
   2084e: 1b 05 85 2f  	addiw	a0, a0, 760
   20852: 0a 95        	add	a0, a0, sp
   20854: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   20858: 93 05 a0 0a  	li	a1, 170
   2085c: 22 85        	mv	a0, s0
   2085e: 26 86        	mv	a2, s1
   20860: 97 40 00 00  	auipc	ra, 4
   20864: e7 80 a0 a3  	jalr	-1478(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20868: 83 37 0b 01  	ld	a5, 16(s6)
   2086c: 52 85        	mv	a0, s4
   2086e: a2 85        	mv	a1, s0
   20870: 26 86        	mv	a2, s1
   20872: 81 46        	li	a3, 0
   20874: 6a 87        	mv	a4, s10
   20876: 82 97        	jalr	a5
;         while (it) |node| {
   20878: 63 14 09 00  	bnez	s2, 0x20880 <.LBB47_196+0x3406>
   2087c: 6f e0 ef e2  	j	0x1eeaa <.LBB47_196+0x1a30>
;             self.child_allocator.free(node.data);
   20880: 03 35 09 01  	ld	a0, 16(s2)
   20884: 81 44        	li	s1, 0
   20886: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   20888: 01 c5        	beqz	a0, 0x20890 <.LBB47_196+0x3416>
   2088a: 03 34 89 00  	ld	s0, 8(s2)
   2088e: aa 84        	mv	s1, a0
   20890: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   20894: f5 d0        	beqz	s1, 0x20878 <.LBB47_196+0x33fe>
   20896: 4d f4        	bnez	s0, 0x20840 <.LBB47_196+0x33c6>
   20898: 6f e0 6f fc  	j	0x1f05e <.LBB47_196+0x1be4>
;     return error.InvalidDebugInfo;
   2089c: 72 65        	ld	a0, 280(sp)
   2089e: 97 30 00 00  	auipc	ra, 3
   208a2: e7 80 a0 35  	jalr	858(ra)
   208a6: f2 64        	ld	s1, 280(sp)
   208a8: 26 85        	mv	a0, s1
   208aa: 97 30 00 00  	auipc	ra, 3
   208ae: e7 80 e0 34  	jalr	846(ra)
   208b2: 26 85        	mv	a0, s1
   208b4: 97 30 00 00  	auipc	ra, 3
   208b8: e7 80 40 34  	jalr	836(ra)
   208bc: 81 b2        	j	0x201fc <.LBB47_196+0x2d82>
   208be: f2 64        	ld	s1, 280(sp)
   208c0: 26 85        	mv	a0, s1
   208c2: 97 30 00 00  	auipc	ra, 3
   208c6: e7 80 60 33  	jalr	822(ra)
   208ca: 13 05 20 03  	li	a0, 50
;     if (nosuspend di.findCompileUnit(address)) |compile_unit| {
   208ce: e3 81 a9 94  	beq	s3, a0, 0x20210 <.LBB47_196+0x2d96>
   208d2: ce 7b        	ld	s7, 240(sp)
   208d4: 26 85        	mv	a0, s1
   208d6: 97 30 00 00  	auipc	ra, 3
   208da: e7 80 20 32  	jalr	802(ra)
   208de: e3 91 09 8c  	bnez	s3, 0x201a0 <.LBB47_196+0x2d26>
   208e2: 91 be        	j	0x20436 <.LBB47_196+0x2fbc>
   208e4: 72 65        	ld	a0, 280(sp)
   208e6: d9 b2        	j	0x202ac <.LBB47_196+0x2e32>
   208e8: 93 0c 20 03  	li	s9, 50
   208ec: 6f e0 0f ba  	j	0x1ec8c <.LBB47_196+0x1812>
   208f0: 72 64        	ld	s0, 280(sp)
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   208f2: 22 85        	mv	a0, s0
   208f4: 97 30 00 00  	auipc	ra, 3
   208f8: e7 80 40 30  	jalr	772(ra)
;     const slice = try self.allocAdvancedWithRetAddr(T, null, 1, @returnAddress());
   208fc: 22 85        	mv	a0, s0
   208fe: 97 30 00 00  	auipc	ra, 3
   20902: e7 80 a0 2f  	jalr	762(ra)
   20906: 95 ae        	j	0x20c7a <.LBB47_196+0x3800>
;         if (abbrev_code == 0) return null;
   20908: 09 65        	lui	a0, 2
   2090a: 1b 05 05 48  	addiw	a0, a0, 1152
   2090e: 0a 95        	add	a0, a0, sp
   20910: 13 06 80 04  	li	a2, 72
   20914: 81 45        	li	a1, 0
   20916: 97 40 00 00  	auipc	ra, 4
   2091a: e7 80 40 98  	jalr	-1660(ra)
;     return error.InvalidDebugInfo;
   2091e: 72 65        	ld	a0, 280(sp)
   20920: 97 30 00 00  	auipc	ra, 3
   20924: e7 80 80 2d  	jalr	728(ra)
   20928: 32 65        	ld	a0, 264(sp)
;             errdefer allocator.destroy(compile_unit_die);
   2092a: 0c 65        	ld	a1, 8(a0)
   2092c: 08 61        	ld	a0, 0(a0)
   2092e: 9c 69        	ld	a5, 16(a1)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20930: 13 06 80 04  	li	a2, 72
   20934: 8d 46        	li	a3, 3
   20936: ee 65        	ld	a1, 216(sp)
   20938: b1 ac        	j	0x20b94 <.LBB47_196+0x371a>
   2093a: 72 65        	ld	a0, 280(sp)
   2093c: 81 a4        	j	0x20b7c <.LBB47_196+0x3702>
   2093e: 93 0c 20 03  	li	s9, 50
   20942: 6f e0 cf d4  	j	0x1ee8e <.LBB47_196+0x1a14>
;     return error.InvalidDebugInfo;
   20946: 62 85        	mv	a0, s8
   20948: 97 30 00 00  	auipc	ra, 3
   2094c: e7 80 00 2b  	jalr	688(ra)
;         var it = self.state.buffer_list.first;
   20950: 09 65        	lui	a0, 2
   20952: 1b 05 05 30  	addiw	a0, a0, 768
   20956: 0a 95        	add	a0, a0, sp
   20958: 03 39 05 00  	ld	s2, 0(a0)
   2095c: 93 0c 20 03  	li	s9, 50
;         while (it) |node| {
   20960: 63 14 09 00  	bnez	s2, 0x20968 <.LBB47_196+0x34ee>
   20964: 6f e0 cf b4  	j	0x1ecb0 <.LBB47_196+0x1836>
   20968: 37 55 02 00  	lui	a0, 37
   2096c: 83 3a 85 38  	ld	s5, 904(a0)
   20970: 89 a0        	j	0x209b2 <.LBB47_196+0x3538>
   20972: 09 65        	lui	a0, 2
   20974: 1b 05 05 2f  	addiw	a0, a0, 752
   20978: 0a 95        	add	a0, a0, sp
   2097a: 03 3a 05 00  	ld	s4, 0(a0)
   2097e: 09 65        	lui	a0, 2
   20980: 1b 05 85 2f  	addiw	a0, a0, 760
   20984: 0a 95        	add	a0, a0, sp
   20986: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   2098a: 93 05 a0 0a  	li	a1, 170
   2098e: 22 85        	mv	a0, s0
   20990: 26 86        	mv	a2, s1
   20992: 97 40 00 00  	auipc	ra, 4
   20996: e7 80 80 90  	jalr	-1784(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   2099a: 83 37 0b 01  	ld	a5, 16(s6)
   2099e: 52 85        	mv	a0, s4
   209a0: a2 85        	mv	a1, s0
   209a2: 26 86        	mv	a2, s1
   209a4: 81 46        	li	a3, 0
   209a6: 6a 87        	mv	a4, s10
   209a8: 82 97        	jalr	a5
;         while (it) |node| {
   209aa: 63 14 09 00  	bnez	s2, 0x209b2 <.LBB47_196+0x3538>
   209ae: 6f e0 2f b0  	j	0x1ecb0 <.LBB47_196+0x1836>
;             self.child_allocator.free(node.data);
   209b2: 03 35 09 01  	ld	a0, 16(s2)
   209b6: 81 44        	li	s1, 0
   209b8: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   209ba: 01 c5        	beqz	a0, 0x209c2 <.LBB47_196+0x3548>
   209bc: 03 34 89 00  	ld	s0, 8(s2)
   209c0: aa 84        	mv	s1, a0
   209c2: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   209c6: f5 d0        	beqz	s1, 0x209aa <.LBB47_196+0x3530>
   209c8: 4d f4        	bnez	s0, 0x20972 <.LBB47_196+0x34f8>
   209ca: 6f e0 4f e9  	j	0x1f05e <.LBB47_196+0x1be4>
;         var it = self.state.buffer_list.first;
   209ce: 09 65        	lui	a0, 2
   209d0: 1b 05 05 30  	addiw	a0, a0, 768
   209d4: 0a 95        	add	a0, a0, sp
   209d6: 03 39 05 00  	ld	s2, 0(a0)
;         while (it) |node| {
   209da: e3 0c 09 b4  	beqz	s2, 0x20532 <.LBB47_196+0x30b8>
   209de: 37 55 02 00  	lui	a0, 37
   209e2: 83 3a 85 38  	ld	s5, 904(a0)
   209e6: 29 a0        	j	0x209f0 <.LBB47_196+0x3576>
;         while (it) |node| {
   209e8: 63 14 09 00  	bnez	s2, 0x209f0 <.LBB47_196+0x3576>
   209ec: 6f e0 2f f0  	j	0x1f0ee <.LBB47_196+0x1c74>
;             self.child_allocator.free(node.data);
   209f0: 03 35 09 01  	ld	a0, 16(s2)
   209f4: 81 44        	li	s1, 0
   209f6: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   209f8: 01 c5        	beqz	a0, 0x20a00 <.LBB47_196+0x3586>
   209fa: 03 34 89 00  	ld	s0, 8(s2)
   209fe: aa 84        	mv	s1, a0
   20a00: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   20a04: f5 d0        	beqz	s1, 0x209e8 <.LBB47_196+0x356e>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   20a06: 19 e0        	bnez	s0, 0x20a0c <.LBB47_196+0x3592>
   20a08: 6f e0 6f e5  	j	0x1f05e <.LBB47_196+0x1be4>
   20a0c: 09 65        	lui	a0, 2
   20a0e: 1b 05 05 2f  	addiw	a0, a0, 752
   20a12: 0a 95        	add	a0, a0, sp
   20a14: 03 3a 05 00  	ld	s4, 0(a0)
   20a18: 09 65        	lui	a0, 2
   20a1a: 1b 05 85 2f  	addiw	a0, a0, 760
   20a1e: 0a 95        	add	a0, a0, sp
   20a20: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   20a24: 93 05 a0 0a  	li	a1, 170
   20a28: 22 85        	mv	a0, s0
   20a2a: 26 86        	mv	a2, s1
   20a2c: 97 40 00 00  	auipc	ra, 4
   20a30: e7 80 e0 86  	jalr	-1938(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20a34: 83 37 0b 01  	ld	a5, 16(s6)
   20a38: 52 85        	mv	a0, s4
   20a3a: a2 85        	mv	a1, s0
   20a3c: 26 86        	mv	a2, s1
   20a3e: 81 46        	li	a3, 0
   20a40: 6a 87        	mv	a4, s10
   20a42: 82 97        	jalr	a5
   20a44: 55 b7        	j	0x209e8 <.LBB47_196+0x356e>
;     return error.InvalidDebugInfo;
   20a46: 62 85        	mv	a0, s8
   20a48: 97 30 00 00  	auipc	ra, 3
   20a4c: e7 80 00 1b  	jalr	432(ra)
;         var it = self.state.buffer_list.first;
   20a50: 09 65        	lui	a0, 2
   20a52: 1b 05 05 30  	addiw	a0, a0, 768
   20a56: 0a 95        	add	a0, a0, sp
   20a58: 03 39 05 00  	ld	s2, 0(a0)
   20a5c: 93 0c 20 03  	li	s9, 50
;         while (it) |node| {
   20a60: 63 14 09 00  	bnez	s2, 0x20a68 <.LBB47_196+0x35ee>
   20a64: 6f e0 cf a4  	j	0x1ecb0 <.LBB47_196+0x1836>
   20a68: 37 55 02 00  	lui	a0, 37
   20a6c: 83 3a 85 38  	ld	s5, 904(a0)
   20a70: 29 a0        	j	0x20a7a <.LBB47_196+0x3600>
;         while (it) |node| {
   20a72: 63 14 09 00  	bnez	s2, 0x20a7a <.LBB47_196+0x3600>
   20a76: 6f e0 af a3  	j	0x1ecb0 <.LBB47_196+0x1836>
;             self.child_allocator.free(node.data);
   20a7a: 03 35 09 01  	ld	a0, 16(s2)
   20a7e: 81 44        	li	s1, 0
   20a80: 56 84        	mv	s0, s5
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   20a82: 01 c5        	beqz	a0, 0x20a8a <.LBB47_196+0x3610>
   20a84: 03 34 89 00  	ld	s0, 8(s2)
   20a88: aa 84        	mv	s1, a0
   20a8a: 03 39 09 00  	ld	s2, 0(s2)
;     if (bytes_len == 0) return;
   20a8e: f5 d0        	beqz	s1, 0x20a72 <.LBB47_196+0x35f8>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   20a90: 19 e0        	bnez	s0, 0x20a96 <.LBB47_196+0x361c>
   20a92: 6f e0 cf dc  	j	0x1f05e <.LBB47_196+0x1be4>
   20a96: 09 65        	lui	a0, 2
   20a98: 1b 05 05 2f  	addiw	a0, a0, 752
   20a9c: 0a 95        	add	a0, a0, sp
   20a9e: 03 3a 05 00  	ld	s4, 0(a0)
   20aa2: 09 65        	lui	a0, 2
   20aa4: 1b 05 85 2f  	addiw	a0, a0, 760
   20aa8: 0a 95        	add	a0, a0, sp
   20aaa: 03 3b 05 00  	ld	s6, 0(a0)
;     @memset(non_const_ptr, undefined, bytes_len);
   20aae: 93 05 a0 0a  	li	a1, 170
   20ab2: 22 85        	mv	a0, s0
   20ab4: 26 86        	mv	a2, s1
   20ab6: 97 30 00 00  	auipc	ra, 3
   20aba: e7 80 40 7e  	jalr	2020(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20abe: 83 37 0b 01  	ld	a5, 16(s6)
   20ac2: 52 85        	mv	a0, s4
   20ac4: a2 85        	mv	a1, s0
   20ac6: 26 86        	mv	a2, s1
   20ac8: 81 46        	li	a3, 0
   20aca: 6a 87        	mv	a4, s10
   20acc: 82 97        	jalr	a5
   20ace: 55 b7        	j	0x20a72 <.LBB47_196+0x35f8>
   20ad0: 62 85        	mv	a0, s8
   20ad2: 97 30 00 00  	auipc	ra, 3
   20ad6: e7 80 60 12  	jalr	294(ra)
   20ada: 62 85        	mv	a0, s8
   20adc: 97 30 00 00  	auipc	ra, 3
   20ae0: e7 80 c0 11  	jalr	284(ra)
   20ae4: 62 85        	mv	a0, s8
   20ae6: 97 30 00 00  	auipc	ra, 3
   20aea: e7 80 20 11  	jalr	274(ra)
   20aee: 93 0c 20 03  	li	s9, 50
   20af2: 6f e0 ef 9a  	j	0x1eca0 <.LBB47_196+0x1826>
;     if (ov[1] != 0) return error.Overflow;
   20af6: 09 65        	lui	a0, 2
   20af8: 1b 05 05 57  	addiw	a0, a0, 1392
   20afc: 0a 95        	add	a0, a0, sp
   20afe: 97 30 00 00  	auipc	ra, 3
   20b02: e7 80 a0 0f  	jalr	250(ra)
   20b06: 72 65        	ld	a0, 280(sp)
   20b08: 97 30 00 00  	auipc	ra, 3
   20b0c: e7 80 00 0f  	jalr	240(ra)
   20b10: 72 6c        	ld	s8, 280(sp)
   20b12: 62 85        	mv	a0, s8
   20b14: 97 30 00 00  	auipc	ra, 3
   20b18: e7 80 40 0e  	jalr	228(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   20b1c: 62 85        	mv	a0, s8
   20b1e: 97 30 00 00  	auipc	ra, 3
   20b22: e7 80 a0 0d  	jalr	218(ra)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   20b26: 62 85        	mv	a0, s8
   20b28: 97 30 00 00  	auipc	ra, 3
   20b2c: e7 80 00 0d  	jalr	208(ra)
   20b30: 62 85        	mv	a0, s8
   20b32: 97 30 00 00  	auipc	ra, 3
   20b36: e7 80 60 0c  	jalr	198(ra)
   20b3a: 62 85        	mv	a0, s8
   20b3c: 97 30 00 00  	auipc	ra, 3
   20b40: e7 80 c0 0b  	jalr	188(ra)
   20b44: 62 85        	mv	a0, s8
   20b46: 97 30 00 00  	auipc	ra, 3
   20b4a: e7 80 20 0b  	jalr	178(ra)
   20b4e: c5 4c        	li	s9, 17
   20b50: 4e 7d        	ld	s10, 240(sp)
   20b52: 6f e0 ef 94  	j	0x1eca0 <.LBB47_196+0x1826>
   20b56: 72 64        	ld	s0, 280(sp)
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   20b58: 22 85        	mv	a0, s0
   20b5a: 97 30 00 00  	auipc	ra, 3
   20b5e: e7 80 e0 09  	jalr	158(ra)
   20b62: 5d b2        	j	0x20508 <.LBB47_196+0x308e>
   20b64: 72 65        	ld	a0, 280(sp)
   20b66: 97 30 00 00  	auipc	ra, 3
   20b6a: e7 80 20 09  	jalr	146(ra)
   20b6e: 72 64        	ld	s0, 280(sp)
   20b70: 22 85        	mv	a0, s0
   20b72: 97 30 00 00  	auipc	ra, 3
   20b76: e7 80 60 08  	jalr	134(ra)
   20b7a: 22 85        	mv	a0, s0
   20b7c: 97 30 00 00  	auipc	ra, 3
   20b80: e7 80 c0 07  	jalr	124(ra)
   20b84: 32 65        	ld	a0, 264(sp)
   20b86: 0c 65        	ld	a1, 8(a0)
   20b88: 08 61        	ld	a0, 0(a0)
   20b8a: 9c 69        	ld	a5, 16(a1)
   20b8c: 13 06 80 04  	li	a2, 72
   20b90: 8d 46        	li	a3, 3
   20b92: ca 85        	mv	a1, s2
   20b94: 4e 77        	ld	a4, 240(sp)
   20b96: 82 97        	jalr	a5
   20b98: 93 0c 20 03  	li	s9, 50
   20b9c: 51 ba        	j	0x20530 <.LBB47_196+0x30b6>
   20b9e: 37 15 01 00  	lui	a0, 17
   20ba2: 13 05 35 6e  	addi	a0, a0, 1763
   20ba6: cd 45        	li	a1, 19
   20ba8: 81 46        	li	a3, 0
   20baa: 97 20 00 00  	auipc	ra, 2
   20bae: e7 80 00 7d  	jalr	2000(ra)
   20bb2: 32 65        	ld	a0, 264(sp)
;             errdefer allocator.destroy(compile_unit_die);
   20bb4: 0c 65        	ld	a1, 8(a0)
   20bb6: 08 61        	ld	a0, 0(a0)
   20bb8: 9c 69        	ld	a5, 16(a1)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20bba: 13 06 80 04  	li	a2, 72
   20bbe: 8d 46        	li	a3, 3
   20bc0: ca 85        	mv	a1, s2
   20bc2: 4e 7d        	ld	s10, 240(sp)
   20bc4: 6a 87        	mv	a4, s10
   20bc6: 82 97        	jalr	a5
   20bc8: 72 6c        	ld	s8, 280(sp)
;                     if (err != error.MissingDebugInfo) return err;
   20bca: 62 85        	mv	a0, s8
   20bcc: 97 30 00 00  	auipc	ra, 3
   20bd0: e7 80 c0 02  	jalr	44(ra)
   20bd4: 0a 7a        	ld	s4, 160(sp)
   20bd6: ea 6a        	ld	s5, 152(sp)
   20bd8: aa 7d        	ld	s11, 168(sp)
   20bda: 62 85        	mv	a0, s8
   20bdc: 97 30 00 00  	auipc	ra, 3
   20be0: e7 80 c0 01  	jalr	28(ra)
   20be4: 63 88 0c 96  	beqz	s9, 0x1fd54 <.LBB47_196+0x28da>
   20be8: 9d b2        	j	0x2054e <.LBB47_196+0x30d4>
   20bea: 72 6c        	ld	s8, 280(sp)
   20bec: 39 a0        	j	0x20bfa <.LBB47_196+0x3780>
   20bee: 72 6c        	ld	s8, 280(sp)
;     return error.InvalidDebugInfo;
   20bf0: 62 85        	mv	a0, s8
   20bf2: 97 30 00 00  	auipc	ra, 3
   20bf6: e7 80 60 00  	jalr	6(ra)
   20bfa: 62 85        	mv	a0, s8
   20bfc: 97 30 00 00  	auipc	ra, 3
   20c00: e7 80 c0 ff  	jalr	-4(ra)
   20c04: 93 0c 20 03  	li	s9, 50
   20c08: 4e 7d        	ld	s10, 240(sp)
   20c0a: 6f e0 6f 89  	j	0x1eca0 <.LBB47_196+0x1826>
;     if (ov[1] != 0) return error.Overflow;
   20c0e: 09 65        	lui	a0, 2
   20c10: 1b 05 85 3c  	addiw	a0, a0, 968
   20c14: 0a 95        	add	a0, a0, sp
   20c16: 97 30 00 00  	auipc	ra, 3
   20c1a: e7 80 20 fe  	jalr	-30(ra)
   20c1e: 72 65        	ld	a0, 280(sp)
   20c20: 97 30 00 00  	auipc	ra, 3
   20c24: e7 80 80 fd  	jalr	-40(ra)
   20c28: 72 64        	ld	s0, 280(sp)
   20c2a: 22 85        	mv	a0, s0
   20c2c: 97 30 00 00  	auipc	ra, 3
   20c30: e7 80 c0 fc  	jalr	-52(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   20c34: 22 85        	mv	a0, s0
   20c36: 97 30 00 00  	auipc	ra, 3
   20c3a: e7 80 20 fc  	jalr	-62(ra)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   20c3e: 22 85        	mv	a0, s0
   20c40: 97 30 00 00  	auipc	ra, 3
   20c44: e7 80 80 fb  	jalr	-72(ra)
;             return self.ensureTotalCapacityPrecise(allocator, better_capacity);
   20c48: 22 85        	mv	a0, s0
   20c4a: 97 30 00 00  	auipc	ra, 3
   20c4e: e7 80 e0 fa  	jalr	-82(ra)
;             try self.ensureTotalCapacity(allocator, newlen);
   20c52: 22 85        	mv	a0, s0
   20c54: 97 30 00 00  	auipc	ra, 3
   20c58: e7 80 40 fa  	jalr	-92(ra)
;             const new_item_ptr = try self.addOne(allocator);
   20c5c: 22 85        	mv	a0, s0
   20c5e: 97 30 00 00  	auipc	ra, 3
   20c62: e7 80 a0 f9  	jalr	-102(ra)
   20c66: 32 65        	ld	a0, 264(sp)
;             errdefer allocator.destroy(compile_unit_die);
   20c68: 0c 65        	ld	a1, 8(a0)
   20c6a: 08 61        	ld	a0, 0(a0)
   20c6c: 9c 69        	ld	a5, 16(a1)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   20c6e: 13 06 80 04  	li	a2, 72
   20c72: 8d 46        	li	a3, 3
   20c74: ee 65        	ld	a1, 216(sp)
   20c76: 4e 77        	ld	a4, 240(sp)
   20c78: 82 97        	jalr	a5
   20c7a: c5 4c        	li	s9, 17
   20c7c: 55 b8        	j	0x20530 <.LBB47_196+0x30b6>
;             const name = mem.sliceTo(header_strings[shdr.sh_name..], 0);
   20c7e: 37 15 01 00  	lui	a0, 17
   20c82: 13 05 45 5b  	addi	a0, a0, 1460
   20c86: 93 05 40 02  	li	a1, 36
   20c8a: 81 46        	li	a3, 0
   20c8c: 97 20 00 00  	auipc	ra, 2
   20c90: e7 80 e0 6e  	jalr	1774(ra)
;                         if (r_debug.r_version != 1) return error.InvalidExe;
   20c94: 62 85        	mv	a0, s8
   20c96: 97 30 00 00  	auipc	ra, 3
   20c9a: e7 80 20 f6  	jalr	-158(ra)
   20c9e: 37 15 01 00  	lui	a0, 17
   20ca2: 13 05 25 71  	addi	a0, a0, 1810
   20ca6: dd 45        	li	a1, 23
   20ca8: 81 46        	li	a3, 0
   20caa: 97 20 00 00  	auipc	ra, 2
   20cae: e7 80 00 6d  	jalr	1744(ra)
;                 result.attrs.items[i].value.Const.payload = @bitCast(u64, attr.payload);
   20cb2: 37 25 01 00  	lui	a0, 18
   20cb6: 13 05 a5 aa  	addi	a0, a0, -1366
   20cba: f9 45        	li	a1, 30
   20cbc: 81 46        	li	a3, 0
   20cbe: 97 20 00 00  	auipc	ra, 2
   20cc2: e7 80 c0 6b  	jalr	1724(ra)
   20cc6: 37 25 01 00  	lui	a0, 18
   20cca: 13 05 a5 99  	addi	a0, a0, -1638
   20cce: dd 45        	li	a1, 23
   20cd0: 81 46        	li	a3, 0
   20cd2: 97 20 00 00  	auipc	ra, 2
   20cd6: e7 80 80 6a  	jalr	1704(ra)
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   20cda: 37 25 01 00  	lui	a0, 18
   20cde: 13 05 25 9b  	addi	a0, a0, -1614
   20ce2: e5 45        	li	a1, 25
   20ce4: 81 46        	li	a3, 0
   20ce6: 97 20 00 00  	auipc	ra, 2
   20cea: e7 80 40 69  	jalr	1684(ra)
;         const hdr = @ptrCast(*const elf.Ehdr, &mapped_mem[0]);
   20cee: 37 15 01 00  	lui	a0, 17
   20cf2: 13 05 35 6e  	addi	a0, a0, 1763
   20cf6: cd 45        	li	a1, 19
   20cf8: 97 20 00 00  	auipc	ra, 2
   20cfc: e7 80 20 68  	jalr	1666(ra)
   20d00: 37 15 01 00  	lui	a0, 17
   20d04: 13 05 d5 74  	addi	a0, a0, 1869
   20d08: 93 05 10 02  	li	a1, 33
   20d0c: 81 46        	li	a3, 0
   20d0e: 97 20 00 00  	auipc	ra, 2
   20d12: e7 80 c0 66  	jalr	1644(ra)

0000000000020d16 <debug.updateSegfaultHandler>:
; pub fn updateSegfaultHandler(act: ?*const os.Sigaction) error{OperationNotSupported}!void {
   20d16: 79 71        	addi	sp, sp, -48
   20d18: 06 f4        	sd	ra, 40(sp)
   20d1a: 22 f0        	sd	s0, 32(sp)
   20d1c: 37 56 02 00  	lui	a2, 37
   20d20: 03 36 06 3c  	ld	a2, 960(a2)
   20d24: 2e 87        	mv	a4, a1
   20d26: 2a 84        	mv	s0, a0
;     var ksa: k_sigaction = undefined;
   20d28: 32 ec        	sd	a2, 24(sp)
   20d2a: 32 e8        	sd	a2, 16(sp)
   20d2c: 32 e4        	sd	a2, 8(sp)
   20d2e: 32 e0        	sd	a2, 0(sp)
;     if (act) |new| {
   20d30: 8d c1        	beqz	a1, 0x20d52 <debug.updateSegfaultHandler+0x3c>
;             .handler = new.handler.handler,
   20d32: 08 63        	ld	a0, 0(a4)
   20d34: 2a e0        	sd	a0, 0(sp)
;             .flags = new.flags | SA.RESTORER,
   20d36: 03 65 87 08  	lwu	a0, 136(a4)
   20d3a: b7 05 00 04  	lui	a1, 16384
   20d3e: 4d 8d        	or	a0, a0, a1
   20d40: 2a e4        	sd	a0, 8(sp)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   20d42: 37 35 02 00  	lui	a0, 35
   20d46: 13 05 c5 08  	addi	a0, a0, 140
   20d4a: 2a e8        	sd	a0, 16(sp)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   20d4c: 08 67        	ld	a0, 8(a4)
   20d4e: 2a ec        	sd	a0, 24(sp)
   20d50: 8a 85        	mv	a1, sp
;     return asm volatile ("ecall"
   20d52: 93 08 60 08  	li	a7, 134
   20d56: 2d 45        	li	a0, 11
   20d58: a1 46        	li	a3, 8
   20d5a: 7d 76        	lui	a2, 1048575
   20d5c: 9b 07 16 00  	addiw	a5, a2, 1
   20d60: 01 46        	li	a2, 0
   20d62: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20d66: 63 78 f5 0e  	bgeu	a0, a5, 0x20e56 <debug.updateSegfaultHandler+0x140>
   20d6a: 37 55 02 00  	lui	a0, 37
   20d6e: 03 35 05 3c  	ld	a0, 960(a0)
;     var ksa: k_sigaction = undefined;
   20d72: 2a ec        	sd	a0, 24(sp)
   20d74: 2a e8        	sd	a0, 16(sp)
   20d76: 2a e4        	sd	a0, 8(sp)
   20d78: 2a e0        	sd	a0, 0(sp)
;     if (act) |new| {
   20d7a: 15 c3        	beqz	a4, 0x20d9e <debug.updateSegfaultHandler+0x88>
;             .handler = new.handler.handler,
   20d7c: 08 63        	ld	a0, 0(a4)
   20d7e: 2a e0        	sd	a0, 0(sp)
;             .flags = new.flags | SA.RESTORER,
   20d80: 03 65 87 08  	lwu	a0, 136(a4)
   20d84: b7 05 00 04  	lui	a1, 16384
   20d88: 4d 8d        	or	a0, a0, a1
   20d8a: 2a e4        	sd	a0, 8(sp)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   20d8c: 37 35 02 00  	lui	a0, 35
   20d90: 13 05 c5 08  	addi	a0, a0, 140
   20d94: 2a e8        	sd	a0, 16(sp)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   20d96: 08 67        	ld	a0, 8(a4)
   20d98: 2a ec        	sd	a0, 24(sp)
   20d9a: 8a 85        	mv	a1, sp
   20d9c: 11 a0        	j	0x20da0 <debug.updateSegfaultHandler+0x8a>
   20d9e: 81 45        	li	a1, 0
;     return asm volatile ("ecall"
   20da0: 93 08 60 08  	li	a7, 134
   20da4: 11 45        	li	a0, 4
   20da6: a1 46        	li	a3, 8
   20da8: 7d 76        	lui	a2, 1048575
   20daa: 9b 07 16 00  	addiw	a5, a2, 1
   20dae: 01 46        	li	a2, 0
   20db0: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20db4: 63 71 f5 0a  	bgeu	a0, a5, 0x20e56 <debug.updateSegfaultHandler+0x140>
   20db8: 37 55 02 00  	lui	a0, 37
   20dbc: 03 35 05 3c  	ld	a0, 960(a0)
;     var ksa: k_sigaction = undefined;
   20dc0: 2a ec        	sd	a0, 24(sp)
   20dc2: 2a e8        	sd	a0, 16(sp)
   20dc4: 2a e4        	sd	a0, 8(sp)
   20dc6: 2a e0        	sd	a0, 0(sp)
;     if (act) |new| {
   20dc8: 15 c3        	beqz	a4, 0x20dec <debug.updateSegfaultHandler+0xd6>
;             .handler = new.handler.handler,
   20dca: 08 63        	ld	a0, 0(a4)
   20dcc: 2a e0        	sd	a0, 0(sp)
;             .flags = new.flags | SA.RESTORER,
   20dce: 03 65 87 08  	lwu	a0, 136(a4)
   20dd2: b7 05 00 04  	lui	a1, 16384
   20dd6: 4d 8d        	or	a0, a0, a1
   20dd8: 2a e4        	sd	a0, 8(sp)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   20dda: 37 35 02 00  	lui	a0, 35
   20dde: 13 05 c5 08  	addi	a0, a0, 140
   20de2: 2a e8        	sd	a0, 16(sp)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   20de4: 08 67        	ld	a0, 8(a4)
   20de6: 2a ec        	sd	a0, 24(sp)
   20de8: 8a 85        	mv	a1, sp
   20dea: 11 a0        	j	0x20dee <debug.updateSegfaultHandler+0xd8>
   20dec: 81 45        	li	a1, 0
;     return asm volatile ("ecall"
   20dee: 93 08 60 08  	li	a7, 134
   20df2: 1d 45        	li	a0, 7
   20df4: a1 46        	li	a3, 8
   20df6: 7d 76        	lui	a2, 1048575
   20df8: 9b 07 16 00  	addiw	a5, a2, 1
   20dfc: 01 46        	li	a2, 0
   20dfe: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20e02: 63 7a f5 04  	bgeu	a0, a5, 0x20e56 <debug.updateSegfaultHandler+0x140>
   20e06: 37 55 02 00  	lui	a0, 37
   20e0a: 03 35 05 3c  	ld	a0, 960(a0)
;     var ksa: k_sigaction = undefined;
   20e0e: 2a ec        	sd	a0, 24(sp)
   20e10: 2a e8        	sd	a0, 16(sp)
   20e12: 2a e4        	sd	a0, 8(sp)
   20e14: 2a e0        	sd	a0, 0(sp)
;     if (act) |new| {
   20e16: 15 c3        	beqz	a4, 0x20e3a <debug.updateSegfaultHandler+0x124>
;             .handler = new.handler.handler,
   20e18: 08 63        	ld	a0, 0(a4)
   20e1a: 2a e0        	sd	a0, 0(sp)
;             .flags = new.flags | SA.RESTORER,
   20e1c: 03 65 87 08  	lwu	a0, 136(a4)
   20e20: b7 05 00 04  	lui	a1, 16384
   20e24: 4d 8d        	or	a0, a0, a1
   20e26: 2a e4        	sd	a0, 8(sp)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   20e28: 37 35 02 00  	lui	a0, 35
   20e2c: 13 05 c5 08  	addi	a0, a0, 140
   20e30: 2a e8        	sd	a0, 16(sp)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   20e32: 08 67        	ld	a0, 8(a4)
   20e34: 2a ec        	sd	a0, 24(sp)
   20e36: 8a 85        	mv	a1, sp
   20e38: 11 a0        	j	0x20e3c <debug.updateSegfaultHandler+0x126>
   20e3a: 81 45        	li	a1, 0
   20e3c: 01 47        	li	a4, 0
;     return asm volatile ("ecall"
   20e3e: 93 08 60 08  	li	a7, 134
   20e42: 21 45        	li	a0, 8
   20e44: a1 46        	li	a3, 8
   20e46: 7d 76        	lui	a2, 1048575
   20e48: 9b 07 16 00  	addiw	a5, a2, 1
   20e4c: 01 46        	li	a2, 0
   20e4e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20e52: 63 69 f5 02  	bltu	a0, a5, 0x20e84 <debug.updateSegfaultHandler+0x16e>
   20e56: 3b 05 a0 40  	negw	a0, a0
   20e5a: 42 15        	slli	a0, a0, 48
   20e5c: 41 91        	srli	a0, a0, 48
   20e5e: d9 45        	li	a1, 22
   20e60: 63 06 b5 00  	beq	a0, a1, 0x20e6c <debug.updateSegfaultHandler+0x156>
   20e64: 93 05 60 02  	li	a1, 38
   20e68: 63 13 b5 02  	bne	a0, a1, 0x20e8e <debug.updateSegfaultHandler+0x178>
   20e6c: 22 85        	mv	a0, s0
   20e6e: 97 30 00 00  	auipc	ra, 3
   20e72: e7 80 a0 d8  	jalr	-630(ra)
   20e76: 22 85        	mv	a0, s0
   20e78: 97 30 00 00  	auipc	ra, 3
   20e7c: e7 80 00 d8  	jalr	-640(ra)
   20e80: 13 07 80 03  	li	a4, 56
   20e84: 3a 85        	mv	a0, a4
   20e86: a2 70        	ld	ra, 40(sp)
   20e88: 02 74        	ld	s0, 32(sp)
   20e8a: 45 61        	addi	sp, sp, 48
   20e8c: 82 80        	ret
   20e8e: 37 25 01 00  	lui	a0, 18
   20e92: 13 05 b5 a7  	addi	a0, a0, -1413
   20e96: e1 45        	li	a1, 24
   20e98: 81 46        	li	a3, 0
   20e9a: 97 20 00 00  	auipc	ra, 2
   20e9e: e7 80 00 4e  	jalr	1248(ra)

0000000000020ea2 <os.raise>:
; pub fn raise(sig: u8) RaiseError!void {
   20ea2: 35 71        	addi	sp, sp, -160
   20ea4: 06 ed        	sd	ra, 152(sp)
   20ea6: 22 e9        	sd	s0, 144(sp)
   20ea8: 26 e5        	sd	s1, 136(sp)
   20eaa: ae 84        	mv	s1, a1
   20eac: 2a 84        	mv	s0, a0
;         var set: sigset_t = undefined;
   20eae: 28 00        	addi	a0, sp, 8
   20eb0: 93 05 a0 0a  	li	a1, 170
   20eb4: 13 06 00 08  	li	a2, 128
   20eb8: 97 30 00 00  	auipc	ra, 3
   20ebc: e7 80 20 3e  	jalr	994(ra)
;     return asm volatile ("ecall"
   20ec0: 37 15 01 00  	lui	a0, 17
   20ec4: 93 05 85 09  	addi	a1, a0, 152
   20ec8: 93 08 70 08  	li	a7, 135
   20ecc: 30 00        	addi	a2, sp, 8
   20ece: a1 46        	li	a3, 8
   20ed0: 7d 75        	lui	a0, 1048575
   20ed2: 9b 07 15 00  	addiw	a5, a0, 1
   20ed6: 01 45        	li	a0, 0
   20ed8: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20edc: 63 7e f5 04  	bgeu	a0, a5, 0x20f38 <os.raise+0x96>
;     return asm volatile ("ecall"
   20ee0: 93 08 20 0b  	li	a7, 178
   20ee4: 73 00 00 00  	ecall	
;     return syscall2(.tkill, @bitCast(usize, @as(isize, tid)), @bitCast(usize, @as(isize, sig)));
   20ee8: 01 25        	sext.w	a0, a0
   20eea: 93 f5 f4 0f  	andi	a1, s1, 255
;     return asm volatile ("ecall"
   20eee: 93 08 20 08  	li	a7, 130
   20ef2: 73 00 00 00  	ecall	
   20ef6: 2a 87        	mv	a4, a0
;     return asm volatile ("ecall"
   20ef8: 93 08 70 08  	li	a7, 135
   20efc: 09 45        	li	a0, 2
   20efe: 2c 00        	addi	a1, sp, 8
   20f00: a1 46        	li	a3, 8
   20f02: 01 46        	li	a2, 0
   20f04: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20f08: 63 78 f5 02  	bgeu	a0, a5, 0x20f38 <os.raise+0x96>
   20f0c: 7d 75        	lui	a0, 1048575
   20f0e: 05 25        	addiw	a0, a0, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   20f10: 63 78 a7 00  	bgeu	a4, a0, 0x20f20 <os.raise+0x7e>
   20f14: 01 45        	li	a0, 0
   20f16: ea 60        	ld	ra, 152(sp)
   20f18: 4a 64        	ld	s0, 144(sp)
   20f1a: aa 64        	ld	s1, 136(sp)
   20f1c: 0d 61        	addi	sp, sp, 160
   20f1e: 82 80        	ret
;     return error.Unexpected;
   20f20: 22 85        	mv	a0, s0
   20f22: 97 30 00 00  	auipc	ra, 3
   20f26: e7 80 60 cd  	jalr	-810(ra)
;             else => |err| return unexpectedErrno(err),
   20f2a: 22 85        	mv	a0, s0
   20f2c: 97 30 00 00  	auipc	ra, 3
   20f30: e7 80 c0 cc  	jalr	-820(ra)
   20f34: 35 45        	li	a0, 13
   20f36: c5 b7        	j	0x20f16 <os.raise+0x74>
   20f38: 3b 05 a0 40  	negw	a0, a0
   20f3c: 42 15        	slli	a0, a0, 48
   20f3e: 41 91        	srli	a0, a0, 48
   20f40: b9 45        	li	a1, 14
   20f42: 63 03 b5 00  	beq	a0, a1, 0x20f48 <os.raise+0xa6>
   20f46: d9 45        	li	a1, 22
   20f48: 37 25 01 00  	lui	a0, 18
   20f4c: 13 05 b5 a7  	addi	a0, a0, -1413
   20f50: e1 45        	li	a1, 24
   20f52: 81 46        	li	a3, 0
   20f54: 97 20 00 00  	auipc	ra, 2
   20f58: e7 80 60 42  	jalr	1062(ra)

0000000000020f5c <debug.handleSegfaultPosix>:
; fn handleSegfaultPosix(sig: i32, info: *const os.siginfo_t, ctx_ptr: ?*const anyopaque) callconv(.C) noreturn {
   20f5c: 13 01 01 d0  	addi	sp, sp, -768
   20f60: 23 3c 11 2e  	sd	ra, 760(sp)
   20f64: 23 38 81 2e  	sd	s0, 752(sp)
   20f68: 23 34 91 2e  	sd	s1, 744(sp)
   20f6c: 23 30 21 2f  	sd	s2, 736(sp)
   20f70: 23 3c 31 2d  	sd	s3, 728(sp)
   20f74: 23 38 41 2d  	sd	s4, 720(sp)
   20f78: ae 84        	mv	s1, a1
   20f7a: 2a 84        	mv	s0, a0
   20f7c: 0a 85        	mv	a0, sp
   20f7e: 2a e6        	sd	a0, 264(sp)
   20f80: 13 05 00 02  	li	a0, 32
   20f84: 2a ea        	sd	a0, 272(sp)
   20f86: 02 e2        	sd	zero, 256(sp)
   20f88: 0c 12        	addi	a1, sp, 288
   20f8a: 23 34 b1 22  	sd	a1, 552(sp)
   20f8e: 23 38 a1 22  	sd	a0, 560(sp)
   20f92: 23 30 01 22  	sd	zero, 544(sp)
;     var act = os.Sigaction{
   20f96: 28 1c        	addi	a0, sp, 568
   20f98: 13 06 80 09  	li	a2, 152
   20f9c: 81 45        	li	a1, 0
   20f9e: 97 30 00 00  	auipc	ra, 3
   20fa2: e7 80 c0 2f  	jalr	764(ra)
;     updateSegfaultHandler(&act) catch {};
   20fa6: 08 14        	addi	a0, sp, 544
   20fa8: 2c 1c        	addi	a1, sp, 568
   20faa: 97 00 00 00  	auipc	ra, 0
   20fae: e7 80 c0 d6  	jalr	-660(ra)
;         .linux => @ptrToInt(info.fields.sigfault.addr),
   20fb2: 84 68        	ld	s1, 16(s1)
   20fb4: 09 45        	li	a0, 2
   20fb6: 9d 45        	li	a1, 7
;         const stderr = io.getStdErr().writer();
   20fb8: 23 2c a1 10  	sw	a0, 280(sp)
;         _ = switch (sig) {
   20fbc: 63 c9 85 08  	blt	a1, s0, 0x2104e <debug.handleSegfaultPosix+0xf2>
   20fc0: 11 45        	li	a0, 4
;         _ = switch (sig) {
   20fc2: 63 0f a4 10  	beq	s0, a0, 0x210e0 <debug.handleSegfaultPosix+0x184>
   20fc6: 1d 45        	li	a0, 7
;         _ = switch (sig) {
   20fc8: 63 13 a4 42  	bne	s0, a0, 0x213ee <debug.handleSegfaultPosix+0x492>
   20fcc: 01 44        	li	s0, 0
   20fce: 61 49        	li	s2, 24
   20fd0: 37 25 01 00  	lui	a0, 18
   20fd4: 93 09 15 d2  	addi	s3, a0, -735
   20fd8: 5d 4a        	li	s4, 23
   20fda: 63 75 24 3f  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
;                 index += try self.write(bytes[index..]);
   20fde: b3 86 89 00  	add	a3, s3, s0
   20fe2: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   20fe6: 08 12        	addi	a0, sp, 288
   20fe8: 0c 02        	addi	a1, sp, 256
   20fea: 09 46        	li	a2, 2
   20fec: 97 30 ff ff  	auipc	ra, 1048563
   20ff0: e7 80 00 e7  	jalr	-400(ra)
   20ff4: 03 55 81 12  	lhu	a0, 296(sp)
   20ff8: 63 1e 05 38  	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   20ffc: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   20ffe: 22 95        	add	a0, a0, s0
   21000: 63 6d 85 3c  	bltu	a0, s0, 0x213da <debug.handleSegfaultPosix+0x47e>
   21004: 2a 84        	mv	s0, a0
   21006: e3 1a 45 fd  	bne	a0, s4, 0x20fda <debug.handleSegfaultPosix+0x7e>
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   2100a: 08 12        	addi	a0, sp, 288
   2100c: 93 05 a0 0a  	li	a1, 170
   21010: 13 06 10 04  	li	a2, 65
   21014: 00 12        	addi	s0, sp, 288
   21016: 97 30 00 00  	auipc	ra, 3
   2101a: e7 80 40 28  	jalr	644(ra)
   2101e: 01 45        	li	a0, 0
   21020: a9 45        	li	a1, 10
   21022: 3d 46        	li	a2, 15
   21024: 19 a8        	j	0x2103a <debug.handleSegfaultPosix+0xde>
   21026: b3 04 a4 00  	add	s1, s0, a0
   2102a: 3d 9f        	addw	a4, a4, a5
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   2102c: 23 80 e4 04  	sb	a4, 64(s1)
;             a /= base;
   21030: 93 d4 46 00  	srli	s1, a3, 4
;             if (a == 0) break;
   21034: 7d 15        	addi	a0, a0, -1
   21036: 63 7b d6 1a  	bgeu	a2, a3, 0x211ec <debug.handleSegfaultPosix+0x290>
   2103a: a6 86        	mv	a3, s1
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   2103c: 13 f7 f4 00  	andi	a4, s1, 15
   21040: 93 07 00 03  	li	a5, 48
   21044: e3 61 b7 fe  	bltu	a4, a1, 0x21026 <debug.handleSegfaultPosix+0xca>
   21048: 93 07 70 05  	li	a5, 87
   2104c: e9 bf        	j	0x21026 <debug.handleSegfaultPosix+0xca>
   2104e: 21 45        	li	a0, 8
;         _ = switch (sig) {
   21050: 63 0b a4 10  	beq	s0, a0, 0x21166 <debug.handleSegfaultPosix+0x20a>
   21054: 2d 45        	li	a0, 11
;         _ = switch (sig) {
   21056: 63 1c a4 38  	bne	s0, a0, 0x213ee <debug.handleSegfaultPosix+0x492>
   2105a: 01 44        	li	s0, 0
   2105c: 13 09 10 02  	li	s2, 33
   21060: 37 25 01 00  	lui	a0, 18
   21064: 93 09 c5 cf  	addi	s3, a0, -772
   21068: 13 0a 00 02  	li	s4, 32
;                 index += try self.write(bytes[index..]);
   2106c: 63 7c 24 35  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   21070: b3 86 89 00  	add	a3, s3, s0
   21074: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   21078: 08 12        	addi	a0, sp, 288
   2107a: 0c 02        	addi	a1, sp, 256
   2107c: 09 46        	li	a2, 2
   2107e: 97 30 ff ff  	auipc	ra, 1048563
   21082: e7 80 e0 dd  	jalr	-546(ra)
   21086: 03 55 81 12  	lhu	a0, 296(sp)
   2108a: 63 15 05 30  	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   2108e: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   21090: 22 95        	add	a0, a0, s0
   21092: 63 64 85 34  	bltu	a0, s0, 0x213da <debug.handleSegfaultPosix+0x47e>
   21096: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   21098: e3 1a 45 fd  	bne	a0, s4, 0x2106c <debug.handleSegfaultPosix+0x110>
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   2109c: 08 12        	addi	a0, sp, 288
   2109e: 93 05 a0 0a  	li	a1, 170
   210a2: 13 06 10 04  	li	a2, 65
   210a6: 00 12        	addi	s0, sp, 288
   210a8: 97 30 00 00  	auipc	ra, 3
   210ac: e7 80 20 1f  	jalr	498(ra)
   210b0: 01 45        	li	a0, 0
   210b2: a9 45        	li	a1, 10
   210b4: 3d 46        	li	a2, 15
   210b6: 19 a8        	j	0x210cc <debug.handleSegfaultPosix+0x170>
   210b8: b3 04 a4 00  	add	s1, s0, a0
   210bc: 3d 9f        	addw	a4, a4, a5
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   210be: 23 80 e4 04  	sb	a4, 64(s1)
;             a /= base;
   210c2: 93 d4 46 00  	srli	s1, a3, 4
;             if (a == 0) break;
   210c6: 7d 15        	addi	a0, a0, -1
   210c8: 63 75 d6 18  	bgeu	a2, a3, 0x21252 <debug.handleSegfaultPosix+0x2f6>
   210cc: a6 86        	mv	a3, s1
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   210ce: 13 f7 f4 00  	andi	a4, s1, 15
   210d2: 93 07 00 03  	li	a5, 48
;     return switch (digit) {
   210d6: e3 61 b7 fe  	bltu	a4, a1, 0x210b8 <debug.handleSegfaultPosix+0x15c>
   210da: 93 07 70 05  	li	a5, 87
   210de: e9 bf        	j	0x210b8 <debug.handleSegfaultPosix+0x15c>
   210e0: 01 44        	li	s0, 0
   210e2: 13 09 20 02  	li	s2, 34
   210e6: 37 25 01 00  	lui	a0, 18
   210ea: 93 09 45 d6  	addi	s3, a0, -668
   210ee: 13 0a 10 02  	li	s4, 33
;                 index += try self.write(bytes[index..]);
   210f2: 63 79 24 2d  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   210f6: b3 86 89 00  	add	a3, s3, s0
   210fa: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   210fe: 08 12        	addi	a0, sp, 288
   21100: 0c 02        	addi	a1, sp, 256
   21102: 09 46        	li	a2, 2
   21104: 97 30 ff ff  	auipc	ra, 1048563
   21108: e7 80 80 d5  	jalr	-680(ra)
   2110c: 03 55 81 12  	lhu	a0, 296(sp)
   21110: 63 12 05 28  	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   21114: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   21116: 22 95        	add	a0, a0, s0
   21118: 63 61 85 2c  	bltu	a0, s0, 0x213da <debug.handleSegfaultPosix+0x47e>
   2111c: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   2111e: e3 1a 45 fd  	bne	a0, s4, 0x210f2 <debug.handleSegfaultPosix+0x196>
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   21122: 08 12        	addi	a0, sp, 288
   21124: 93 05 a0 0a  	li	a1, 170
   21128: 13 06 10 04  	li	a2, 65
   2112c: 00 12        	addi	s0, sp, 288
   2112e: 97 30 00 00  	auipc	ra, 3
   21132: e7 80 c0 16  	jalr	364(ra)
   21136: 01 45        	li	a0, 0
   21138: a9 45        	li	a1, 10
   2113a: 3d 46        	li	a2, 15
   2113c: 19 a8        	j	0x21152 <debug.handleSegfaultPosix+0x1f6>
   2113e: b3 04 a4 00  	add	s1, s0, a0
   21142: 3d 9f        	addw	a4, a4, a5
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   21144: 23 80 e4 04  	sb	a4, 64(s1)
;             a /= base;
   21148: 93 d4 46 00  	srli	s1, a3, 4
;             if (a == 0) break;
   2114c: 7d 15        	addi	a0, a0, -1
   2114e: 63 74 d6 16  	bgeu	a2, a3, 0x212b6 <debug.handleSegfaultPosix+0x35a>
   21152: a6 86        	mv	a3, s1
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   21154: 13 f7 f4 00  	andi	a4, s1, 15
   21158: 93 07 00 03  	li	a5, 48
;     return switch (digit) {
   2115c: e3 61 b7 fe  	bltu	a4, a1, 0x2113e <debug.handleSegfaultPosix+0x1e2>
   21160: 93 07 70 05  	li	a5, 87
   21164: e9 bf        	j	0x2113e <debug.handleSegfaultPosix+0x1e2>
   21166: 01 44        	li	s0, 0
   21168: 13 09 30 02  	li	s2, 35
   2116c: 37 25 01 00  	lui	a0, 18
   21170: 93 09 d5 d3  	addi	s3, a0, -707
   21174: 13 0a 20 02  	li	s4, 34
;                 index += try self.write(bytes[index..]);
   21178: 63 76 24 25  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   2117c: b3 86 89 00  	add	a3, s3, s0
   21180: 33 07 8a 40  	sub	a4, s4, s0
;             return writeFn(self.context, bytes);
   21184: 08 12        	addi	a0, sp, 288
   21186: 0c 02        	addi	a1, sp, 256
   21188: 09 46        	li	a2, 2
   2118a: 97 30 ff ff  	auipc	ra, 1048563
   2118e: e7 80 20 cd  	jalr	-814(ra)
   21192: 03 55 81 12  	lhu	a0, 296(sp)
   21196: 63 1f 05 1e  	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   2119a: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   2119c: 22 95        	add	a0, a0, s0
   2119e: 63 6e 85 22  	bltu	a0, s0, 0x213da <debug.handleSegfaultPosix+0x47e>
   211a2: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   211a4: e3 1a 45 fd  	bne	a0, s4, 0x21178 <debug.handleSegfaultPosix+0x21c>
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   211a8: 08 12        	addi	a0, sp, 288
   211aa: 93 05 a0 0a  	li	a1, 170
   211ae: 13 06 10 04  	li	a2, 65
   211b2: 00 12        	addi	s0, sp, 288
   211b4: 97 30 00 00  	auipc	ra, 3
   211b8: e7 80 60 0e  	jalr	230(ra)
   211bc: 01 45        	li	a0, 0
   211be: a9 45        	li	a1, 10
   211c0: 3d 46        	li	a2, 15
   211c2: 19 a8        	j	0x211d8 <debug.handleSegfaultPosix+0x27c>
   211c4: b3 04 a4 00  	add	s1, s0, a0
   211c8: 3d 9f        	addw	a4, a4, a5
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   211ca: 23 80 e4 04  	sb	a4, 64(s1)
;             a /= base;
   211ce: 93 d4 46 00  	srli	s1, a3, 4
;             if (a == 0) break;
   211d2: 7d 15        	addi	a0, a0, -1
   211d4: 63 72 d6 14  	bgeu	a2, a3, 0x21318 <debug.handleSegfaultPosix+0x3bc>
   211d8: a6 86        	mv	a3, s1
;             buf[index] = digitToChar(@intCast(u8, digit), case);
   211da: 13 f7 f4 00  	andi	a4, s1, 15
   211de: 93 07 00 03  	li	a5, 48
;     return switch (digit) {
   211e2: e3 61 b7 fe  	bltu	a4, a1, 0x211c4 <debug.handleSegfaultPosix+0x268>
   211e6: 93 07 70 05  	li	a5, 87
   211ea: e9 bf        	j	0x211c4 <debug.handleSegfaultPosix+0x268>
;     return formatBuf(buf[index..], options, writer);
   211ec: 33 06 a0 40  	neg	a2, a0
   211f0: 0c 12        	addi	a1, sp, 288
   211f2: 2e 95        	add	a0, a0, a1
   211f4: 93 05 15 04  	addi	a1, a0, 65
   211f8: 37 15 01 00  	lui	a0, 17
   211fc: 93 06 85 11  	addi	a3, a0, 280
   21200: 08 02        	addi	a0, sp, 256
   21202: 38 0a        	addi	a4, sp, 280
   21204: 97 10 00 00  	auipc	ra, 1
   21208: e7 80 c0 b2  	jalr	-1236(ra)
   2120c: 42 15        	slli	a0, a0, 48
   2120e: 41 91        	srli	a0, a0, 48
   21210: 63 18 05 16  	bnez	a0, 0x21380 <debug.handleSegfaultPosix+0x424>
   21214: 01 44        	li	s0, 0
   21216: 09 49        	li	s2, 2
   21218: 37 25 01 00  	lui	a0, 18
   2121c: 93 09 15 d2  	addi	s3, a0, -735
   21220: 85 44        	li	s1, 1
   21222: 63 71 24 1b  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
;                 index += try self.write(bytes[index..]);
   21226: 33 85 89 00  	add	a0, s3, s0
   2122a: 93 06 a5 01  	addi	a3, a0, 26
   2122e: 33 87 84 40  	sub	a4, s1, s0
;             return writeFn(self.context, bytes);
   21232: 08 12        	addi	a0, sp, 288
   21234: 0c 02        	addi	a1, sp, 256
   21236: 09 46        	li	a2, 2
   21238: 97 30 ff ff  	auipc	ra, 1048563
   2123c: e7 80 40 c2  	jalr	-988(ra)
   21240: 03 55 81 12  	lhu	a0, 296(sp)
   21244: 63 18 05 14  	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   21248: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   2124a: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   2124c: e3 1b 94 fc  	bne	s0, s1, 0x21222 <debug.handleSegfaultPosix+0x2c6>
   21250: 25 a2        	j	0x21378 <debug.handleSegfaultPosix+0x41c>
;     return formatBuf(buf[index..], options, writer);
   21252: 33 06 a0 40  	neg	a2, a0
   21256: 0c 12        	addi	a1, sp, 288
   21258: 2e 95        	add	a0, a0, a1
   2125a: 93 05 15 04  	addi	a1, a0, 65
   2125e: 37 15 01 00  	lui	a0, 17
   21262: 93 06 85 11  	addi	a3, a0, 280
   21266: 08 02        	addi	a0, sp, 256
   21268: 38 0a        	addi	a4, sp, 280
   2126a: 97 10 00 00  	auipc	ra, 1
   2126e: e7 80 60 ac  	jalr	-1338(ra)
   21272: 42 15        	slli	a0, a0, 48
   21274: 41 91        	srli	a0, a0, 48
   21276: 63 15 05 10  	bnez	a0, 0x21380 <debug.handleSegfaultPosix+0x424>
   2127a: 01 44        	li	s0, 0
   2127c: 09 49        	li	s2, 2
   2127e: 37 25 01 00  	lui	a0, 18
   21282: 93 09 c5 cf  	addi	s3, a0, -772
   21286: 85 44        	li	s1, 1
;                 index += try self.write(bytes[index..]);
   21288: 63 7e 24 13  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   2128c: 33 85 89 00  	add	a0, s3, s0
   21290: 93 06 35 02  	addi	a3, a0, 35
   21294: 33 87 84 40  	sub	a4, s1, s0
;             return writeFn(self.context, bytes);
   21298: 08 12        	addi	a0, sp, 288
   2129a: 0c 02        	addi	a1, sp, 256
   2129c: 09 46        	li	a2, 2
   2129e: 97 30 ff ff  	auipc	ra, 1048563
   212a2: e7 80 e0 bb  	jalr	-1090(ra)
   212a6: 03 55 81 12  	lhu	a0, 296(sp)
   212aa: 6d e5        	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   212ac: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   212ae: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   212b0: e3 1c 94 fc  	bne	s0, s1, 0x21288 <debug.handleSegfaultPosix+0x32c>
   212b4: d1 a0        	j	0x21378 <debug.handleSegfaultPosix+0x41c>
;     return formatBuf(buf[index..], options, writer);
   212b6: 33 06 a0 40  	neg	a2, a0
   212ba: 0c 12        	addi	a1, sp, 288
   212bc: 2e 95        	add	a0, a0, a1
   212be: 93 05 15 04  	addi	a1, a0, 65
   212c2: 37 15 01 00  	lui	a0, 17
   212c6: 93 06 85 11  	addi	a3, a0, 280
   212ca: 08 02        	addi	a0, sp, 256
   212cc: 38 0a        	addi	a4, sp, 280
   212ce: 97 10 00 00  	auipc	ra, 1
   212d2: e7 80 20 a6  	jalr	-1438(ra)
   212d6: 42 15        	slli	a0, a0, 48
   212d8: 41 91        	srli	a0, a0, 48
   212da: 5d e1        	bnez	a0, 0x21380 <debug.handleSegfaultPosix+0x424>
   212dc: 01 44        	li	s0, 0
   212de: 09 49        	li	s2, 2
   212e0: 37 25 01 00  	lui	a0, 18
   212e4: 93 09 45 d6  	addi	s3, a0, -668
   212e8: 85 44        	li	s1, 1
;                 index += try self.write(bytes[index..]);
   212ea: 63 7d 24 0d  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   212ee: 33 85 89 00  	add	a0, s3, s0
   212f2: 93 06 45 02  	addi	a3, a0, 36
   212f6: 33 87 84 40  	sub	a4, s1, s0
;             return writeFn(self.context, bytes);
   212fa: 08 12        	addi	a0, sp, 288
   212fc: 0c 02        	addi	a1, sp, 256
   212fe: 09 46        	li	a2, 2
   21300: 97 30 ff ff  	auipc	ra, 1048563
   21304: e7 80 c0 b5  	jalr	-1188(ra)
   21308: 03 55 81 12  	lhu	a0, 296(sp)
   2130c: 41 e5        	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   2130e: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   21310: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   21312: e3 1c 94 fc  	bne	s0, s1, 0x212ea <debug.handleSegfaultPosix+0x38e>
   21316: 8d a0        	j	0x21378 <debug.handleSegfaultPosix+0x41c>
;     return formatBuf(buf[index..], options, writer);
   21318: 33 06 a0 40  	neg	a2, a0
   2131c: 0c 12        	addi	a1, sp, 288
   2131e: 2e 95        	add	a0, a0, a1
   21320: 93 05 15 04  	addi	a1, a0, 65
   21324: 37 15 01 00  	lui	a0, 17
   21328: 93 06 85 11  	addi	a3, a0, 280
   2132c: 08 02        	addi	a0, sp, 256
   2132e: 38 0a        	addi	a4, sp, 280
   21330: 97 10 00 00  	auipc	ra, 1
   21334: e7 80 00 a0  	jalr	-1536(ra)
   21338: 42 15        	slli	a0, a0, 48
   2133a: 41 91        	srli	a0, a0, 48
   2133c: 31 e1        	bnez	a0, 0x21380 <debug.handleSegfaultPosix+0x424>
   2133e: 01 44        	li	s0, 0
   21340: 09 49        	li	s2, 2
   21342: 37 25 01 00  	lui	a0, 18
   21346: 93 09 d5 d3  	addi	s3, a0, -707
   2134a: 85 44        	li	s1, 1
;                 index += try self.write(bytes[index..]);
   2134c: 63 7c 24 07  	bgeu	s0, s2, 0x213c4 <debug.handleSegfaultPosix+0x468>
   21350: 33 85 89 00  	add	a0, s3, s0
   21354: 93 06 55 02  	addi	a3, a0, 37
   21358: 33 87 84 40  	sub	a4, s1, s0
;             return writeFn(self.context, bytes);
   2135c: 08 12        	addi	a0, sp, 288
   2135e: 0c 02        	addi	a1, sp, 256
   21360: 09 46        	li	a2, 2
   21362: 97 30 ff ff  	auipc	ra, 1048563
   21366: e7 80 a0 af  	jalr	-1286(ra)
   2136a: 03 55 81 12  	lhu	a0, 296(sp)
   2136e: 1d e1        	bnez	a0, 0x21394 <debug.handleSegfaultPosix+0x438>
   21370: 12 75        	ld	a0, 288(sp)
;                 index += try self.write(bytes[index..]);
   21372: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   21374: e3 1c 94 fc  	bne	s0, s1, 0x2134c <debug.handleSegfaultPosix+0x3f0>
   21378: 97 30 00 00  	auipc	ra, 3
   2137c: e7 80 60 a7  	jalr	-1418(ra)
   21380: 08 02        	addi	a0, sp, 256
   21382: 97 30 00 00  	auipc	ra, 3
   21386: e7 80 60 87  	jalr	-1930(ra)
   2138a: 08 02        	addi	a0, sp, 256
   2138c: 97 30 00 00  	auipc	ra, 3
   21390: e7 80 c0 86  	jalr	-1940(ra)
   21394: 08 02        	addi	a0, sp, 256
   21396: 97 30 00 00  	auipc	ra, 3
   2139a: e7 80 20 86  	jalr	-1950(ra)
   2139e: 08 02        	addi	a0, sp, 256
   213a0: 97 30 00 00  	auipc	ra, 3
   213a4: e7 80 80 85  	jalr	-1960(ra)
   213a8: 08 02        	addi	a0, sp, 256
   213aa: 97 30 00 00  	auipc	ra, 3
   213ae: e7 80 e0 84  	jalr	-1970(ra)
   213b2: 08 02        	addi	a0, sp, 256
   213b4: 97 30 00 00  	auipc	ra, 3
   213b8: e7 80 40 84  	jalr	-1980(ra)
   213bc: 97 30 00 00  	auipc	ra, 3
   213c0: e7 80 20 a3  	jalr	-1486(ra)
   213c4: 37 15 01 00  	lui	a0, 17
   213c8: 13 05 45 5b  	addi	a0, a0, 1460
   213cc: 93 05 40 02  	li	a1, 36
   213d0: 81 46        	li	a3, 0
   213d2: 97 20 00 00  	auipc	ra, 2
   213d6: e7 80 80 fa  	jalr	-88(ra)
   213da: 37 15 01 00  	lui	a0, 17
   213de: 13 05 95 5d  	addi	a0, a0, 1497
   213e2: c1 45        	li	a1, 16
   213e4: 81 46        	li	a3, 0
   213e6: 97 20 00 00  	auipc	ra, 2
   213ea: e7 80 40 f9  	jalr	-108(ra)
;             else => unreachable,
   213ee: 37 25 01 00  	lui	a0, 18
   213f2: 13 05 b5 a7  	addi	a0, a0, -1413
   213f6: e1 45        	li	a1, 24
   213f8: 81 46        	li	a3, 0
   213fa: 97 20 00 00  	auipc	ra, 2
   213fe: e7 80 00 f8  	jalr	-128(ra)

0000000000021402 <fs.file.File.supportsAnsiEscapeCodes>:
;     pub fn supportsAnsiEscapeCodes(self: File) bool {
   21402: 01 11        	addi	sp, sp, -32
   21404: 06 ec        	sd	ra, 24(sp)
   21406: 22 e8        	sd	s0, 16(sp)
   21408: 2a 88        	mv	a6, a0
;         if (self.isTty()) {
   2140a: 18 41        	lw	a4, 0(a0)
   2140c: 37 55 02 00  	lui	a0, 37
   21410: 83 37 85 3c  	ld	a5, 968(a0)
   21414: 15 65        	lui	a0, 5
   21416: 9b 05 35 41  	addiw	a1, a0, 1043
   2141a: 7d 75        	lui	a0, 1048575
   2141c: 1b 04 15 00  	addiw	s0, a0, 1
   21420: 41 65        	lui	a0, 16
   21422: 9b 06 c5 ff  	addiw	a3, a0, -4
   21426: f5 48        	li	a7, 29
;             var wsz: linux.winsize = undefined;
   21428: 3e e4        	sd	a5, 8(sp)
;     return asm volatile ("ecall"
   2142a: 30 00        	addi	a2, sp, 8
   2142c: 3a 85        	mv	a0, a4
   2142e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   21432: 63 68 85 00  	bltu	a0, s0, 0x21442 <fs.file.File.supportsAnsiEscapeCodes+0x40>
;             switch (linux.getErrno(rc)) {
   21436: 42 15        	slli	a0, a0, 48
   21438: 41 91        	srli	a0, a0, 48
   2143a: e3 07 d5 fe  	beq	a0, a3, 0x21428 <fs.file.File.supportsAnsiEscapeCodes+0x26>
   2143e: 01 44        	li	s0, 0
   21440: ad a0        	j	0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;             if (self.handle == os.STDOUT_FILENO or self.handle == os.STDERR_FILENO) {
   21442: 03 25 08 00  	lw	a0, 0(a6)
   21446: 7d 35        	addiw	a0, a0, -1
   21448: 05 44        	li	s0, 1
   2144a: 63 60 a4 06  	bltu	s0, a0, 0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;     return getenv(mem.sliceTo(key, 0));
   2144e: 37 25 01 00  	lui	a0, 18
   21452: 13 05 c5 be  	addi	a0, a0, -1044
   21456: 91 45        	li	a1, 4
   21458: 97 10 00 00  	auipc	ra, 1
   2145c: e7 80 e0 08  	jalr	142(ra)
;                 if (os.getenvZ("TERM")) |term| {
   21460: 33 36 a0 00  	snez	a2, a0
   21464: f1 15        	addi	a1, a1, -4
   21466: 93 b5 15 00  	seqz	a1, a1
   2146a: f1 8d        	and	a1, a1, a2
   2146c: 9d cd        	beqz	a1, 0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;     if (a.ptr == b.ptr) return true;
   2146e: b7 25 01 00  	lui	a1, 18
   21472: 93 85 f5 ba  	addi	a1, a1, -1105
   21476: e3 04 b5 fc  	beq	a0, a1, 0x2143e <fs.file.File.supportsAnsiEscapeCodes+0x3c>
;     for (a) |item, index| {
   2147a: 83 45 05 00  	lbu	a1, 0(a0)
   2147e: 13 06 40 06  	li	a2, 100
;         if (b[index] != item) return false;
   21482: 63 94 c5 02  	bne	a1, a2, 0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;     for (a) |item, index| {
   21486: 83 45 15 00  	lbu	a1, 1(a0)
   2148a: 13 06 50 07  	li	a2, 117
;         if (b[index] != item) return false;
   2148e: 63 9e c5 00  	bne	a1, a2, 0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;     for (a) |item, index| {
   21492: 83 45 25 00  	lbu	a1, 2(a0)
   21496: 13 06 d0 06  	li	a2, 109
;         if (b[index] != item) return false;
   2149a: 63 98 c5 00  	bne	a1, a2, 0x214aa <fs.file.File.supportsAnsiEscapeCodes+0xa8>
;     for (a) |item, index| {
   2149e: 03 45 35 00  	lbu	a0, 3(a0)
;         if (b[index] != item) return false;
   214a2: 13 05 e5 f9  	addi	a0, a0, -98
   214a6: 33 34 a0 00  	snez	s0, a0
   214aa: 22 85        	mv	a0, s0
   214ac: e2 60        	ld	ra, 24(sp)
   214ae: 42 64        	ld	s0, 16(sp)
   214b0: 05 61        	addi	sp, sp, 32
   214b2: 82 80        	ret

00000000000214b4 <fs.Dir.openFileZ>:
;     pub fn openFileZ(self: Dir, sub_path: [*:0]const u8, flags: File.OpenFlags) File.OpenError!File {
   214b4: 79 71        	addi	sp, sp, -48
;         if (!flags.allow_ctty) {
   214b6: 06 f4        	sd	ra, 40(sp)
   214b8: 22 f0        	sd	s0, 32(sp)
   214ba: 26 ec        	sd	s1, 24(sp)
   214bc: 4a e8        	sd	s2, 16(sp)
   214be: 4e e4        	sd	s3, 8(sp)
   214c0: 83 47 37 00  	lbu	a5, 3(a4)
   214c4: 36 88        	mv	a6, a3
   214c6: 2e 89        	mv	s2, a1
   214c8: aa 89        	mv	s3, a0
   214ca: 37 85 08 00  	lui	a0, 136
;         if (!flags.allow_ctty) {
   214ce: 99 e3        	bnez	a5, 0x214d4 <fs.Dir.openFileZ+0x20>
   214d0: 1b 05 05 10  	addiw	a0, a0, 256
;         os_flags |= switch (flags.mode) {
   214d4: 83 46 07 00  	lbu	a3, 0(a4)
   214d8: 81 ca        	beqz	a3, 0x214e8 <fs.Dir.openFileZ+0x34>
   214da: 85 45        	li	a1, 1
;         os_flags |= switch (flags.mode) {
   214dc: 63 87 b6 00  	beq	a3, a1, 0x214ea <fs.Dir.openFileZ+0x36>
   214e0: 89 45        	li	a1, 2
;         os_flags |= switch (flags.mode) {
   214e2: 63 84 b6 00  	beq	a3, a1, 0x214ea <fs.Dir.openFileZ+0x36>
   214e6: 8d a8        	j	0x21558 <.LBB52_11+0x22>
   214e8: b6 85        	mv	a1, a3
;         os_flags |= switch (flags.mode) {
   214ea: b3 e2 a5 00  	or	t0, a1, a0
   214ee: 9b 07 06 00  	sext.w	a5, a2
   214f2: 7d 75        	lui	a0, 1048575
   214f4: 1b 04 15 00  	addiw	s0, a0, 1
   214f8: 11 43        	li	t1, 4
   214fa: 93 08 80 03  	li	a7, 56
   214fe: 81 46        	li	a3, 0
;     return asm volatile ("ecall"
   21500: 3e 85        	mv	a0, a5
   21502: c2 85        	mv	a1, a6
   21504: 16 86        	mv	a2, t0
   21506: 73 00 00 00  	ecall	
   2150a: aa 84        	mv	s1, a0
   2150c: 63 67 85 02  	bltu	a0, s0, 0x2153a <.LBB52_11+0x4>
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   21510: 3b 05 90 40  	negw	a0, s1
   21514: 42 15        	slli	a0, a0, 48
   21516: 41 91        	srli	a0, a0, 48
   21518: e3 04 65 fe  	beq	a0, t1, 0x21500 <fs.Dir.openFileZ+0x4c>
   2151c: 7d 15        	addi	a0, a0, -1
   2151e: 93 05 e0 05  	li	a1, 94
   21522: 63 e6 a5 0e  	bltu	a1, a0, 0x2160e <.LBB52_42>
   21526: 0a 05        	slli	a0, a0, 2
   21528: b7 05 01 00  	lui	a1, 16
   2152c: 93 85 85 67  	addi	a1, a1, 1656
   21530: 2e 95        	add	a0, a0, a1
   21532: 08 41        	lw	a0, 0(a0)
   21534: 02 85        	jr	a0

0000000000021536 <.LBB52_11>:
   21536: 15 44        	li	s0, 5
   21538: cd a0        	j	0x2161a <.LBB52_42+0xc>
;             .SUCCESS => return @intCast(fd_t, rc),
   2153a: 13 d5 f4 01  	srli	a0, s1, 31
   2153e: 63 13 05 16  	bnez	a0, 0x216a4 <.LBB52_52+0x14>
;             if (!has_flock_open_flags and flags.lock != .None) {
   21542: 83 45 17 00  	lbu	a1, 1(a4)
   21546: a5 c9        	beqz	a1, 0x215b6 <.LBB52_11+0x80>
;                 const lock_nonblocking = if (flags.lock_nonblocking) os.LOCK.NB else @as(i32, 0);
   21548: 03 45 27 00  	lbu	a0, 2(a4)
   2154c: 05 46        	li	a2, 1
;                 try os.flock(fd, switch (flags.lock) {
   2154e: 63 8f c5 00  	beq	a1, a2, 0x2156c <.LBB52_11+0x36>
   21552: 09 46        	li	a2, 2
;                 try os.flock(fd, switch (flags.lock) {
   21554: 63 8d c5 00  	beq	a1, a2, 0x2156e <.LBB52_11+0x38>
   21558: 37 25 01 00  	lui	a0, 18
   2155c: 13 05 a5 99  	addi	a0, a0, -1638
   21560: dd 45        	li	a1, 23
   21562: 81 46        	li	a3, 0
   21564: 97 20 00 00  	auipc	ra, 2
   21568: e7 80 60 e1  	jalr	-490(ra)
   2156c: 2e 86        	mv	a2, a1
   2156e: 0a 05        	slli	a0, a0, 2
   21570: b3 65 a6 00  	or	a1, a2, a0
   21574: 7d 75        	lui	a0, 1048575
   21576: 1b 06 15 00  	addiw	a2, a0, 1
   2157a: 91 46        	li	a3, 4
   2157c: 93 08 00 02  	li	a7, 32
;     return asm volatile ("ecall"
   21580: 26 85        	mv	a0, s1
   21582: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   21586: 63 68 c5 02  	bltu	a0, a2, 0x215b6 <.LBB52_11+0x80>
   2158a: 33 04 a0 40  	neg	s0, a0
   2158e: 13 15 04 03  	slli	a0, s0, 48
   21592: 41 91        	srli	a0, a0, 48
;         switch (errno(rc)) {
   21594: e3 06 d5 fe  	beq	a0, a3, 0x21580 <.LBB52_11+0x4a>
   21598: 93 05 40 02  	li	a1, 36
;         switch (errno(rc)) {
   2159c: 63 d2 a5 0a  	bge	a1, a0, 0x21640 <.LBB52_42+0x32>
   215a0: 93 05 50 02  	li	a1, 37
;         switch (errno(rc)) {
   215a4: 63 0e b5 0a  	beq	a0, a1, 0x21660 <.LBB52_42+0x52>
   215a8: 93 05 f0 05  	li	a1, 95
;         switch (errno(rc)) {
   215ac: 63 13 b5 0a  	bne	a0, a1, 0x21652 <.LBB52_42+0x44>
   215b0: 13 04 50 02  	li	s0, 37
   215b4: 7d a0        	j	0x21662 <.LBB52_42+0x54>
;         return File{
   215b6: 23 92 09 00  	sh	zero, 4(s3)
   215ba: 23 a0 99 00  	sw	s1, 0(s3)
   215be: 95 a8        	j	0x21632 <.LBB52_42+0x24>

00000000000215c0 <.LBB52_26>:
   215c0: 09 44        	li	s0, 2
   215c2: a1 a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215c4 <.LBB52_27>:
   215c4: 61 44        	li	s0, 24
   215c6: 91 a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215c8 <.LBB52_28>:
   215c8: 2d 44        	li	s0, 11
   215ca: 81 a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215cc <.LBB52_29>:
   215cc: 1d 44        	li	s0, 7
   215ce: b1 a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215d0 <.LBB52_30>:
   215d0: 13 04 40 02  	li	s0, 36
   215d4: 99 a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215d6 <.LBB52_31>:
   215d6: 5d 44        	li	s0, 23
   215d8: 89 a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215da <.LBB52_32>:
   215da: 13 04 10 02  	li	s0, 33
   215de: 35 a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215e0 <.LBB52_33>:
   215e0: 13 04 30 02  	li	s0, 35
   215e4: 1d a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215e6 <.LBB52_34>:
   215e6: 13 04 20 02  	li	s0, 34
   215ea: 05 a8        	j	0x2161a <.LBB52_42+0xc>

00000000000215ec <.LBB52_35>:
   215ec: 13 04 00 02  	li	s0, 32
   215f0: 2d a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215f2 <.LBB52_36>:
   215f2: 7d 44        	li	s0, 31
   215f4: 1d a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215f6 <.LBB52_37>:
   215f6: 13 04 60 02  	li	s0, 38
   215fa: 05 a0        	j	0x2161a <.LBB52_42+0xc>

00000000000215fc <.LBB52_38>:
   215fc: 11 44        	li	s0, 4
   215fe: 31 a8        	j	0x2161a <.LBB52_42+0xc>

0000000000021600 <.LBB52_39>:
   21600: 69 44        	li	s0, 26
   21602: 21 a8        	j	0x2161a <.LBB52_42+0xc>

0000000000021604 <.LBB52_40>:
   21604: 79 44        	li	s0, 30
   21606: 11 a8        	j	0x2161a <.LBB52_42+0xc>

0000000000021608 <.LBB52_41>:
   21608: 13 04 50 02  	li	s0, 37
   2160c: 39 a0        	j	0x2161a <.LBB52_42+0xc>

000000000002160e <.LBB52_42>:
;     return error.Unexpected;
   2160e: 4a 85        	mv	a0, s2
   21610: 97 20 00 00  	auipc	ra, 2
   21614: e7 80 80 5e  	jalr	1512(ra)
   21618: 35 44        	li	s0, 13
   2161a: 4a 85        	mv	a0, s2
   2161c: 97 20 00 00  	auipc	ra, 2
   21620: e7 80 c0 5d  	jalr	1500(ra)
   21624: 4a 85        	mv	a0, s2
   21626: 97 20 00 00  	auipc	ra, 2
   2162a: e7 80 20 5d  	jalr	1490(ra)
   2162e: 23 92 89 00  	sh	s0, 4(s3)
   21632: a2 70        	ld	ra, 40(sp)
   21634: 02 74        	ld	s0, 32(sp)
   21636: e2 64        	ld	s1, 24(sp)
   21638: 42 69        	ld	s2, 16(sp)
   2163a: a2 69        	ld	s3, 8(sp)
   2163c: 45 61        	addi	sp, sp, 48
   2163e: 82 80        	ret
   21640: ad 45        	li	a1, 11
;         switch (errno(rc)) {
   21642: 63 00 b5 02  	beq	a0, a1, 0x21662 <.LBB52_42+0x54>
   21646: a5 45        	li	a1, 9
;         switch (errno(rc)) {
   21648: 63 04 b5 04  	beq	a0, a1, 0x21690 <.LBB52_52>
   2164c: d9 45        	li	a1, 22
;         switch (errno(rc)) {
   2164e: 63 01 b5 04  	beq	a0, a1, 0x21690 <.LBB52_52>
;     return error.Unexpected;
   21652: 4a 85        	mv	a0, s2
   21654: 97 20 00 00  	auipc	ra, 2
   21658: e7 80 40 5a  	jalr	1444(ra)
   2165c: 35 44        	li	s0, 13
   2165e: 11 a0        	j	0x21662 <.LBB52_42+0x54>
   21660: 1d 44        	li	s0, 7
   21662: 4a 85        	mv	a0, s2
   21664: 97 20 00 00  	auipc	ra, 2
   21668: e7 80 40 59  	jalr	1428(ra)
;     return asm volatile ("ecall"
   2166c: 93 08 90 03  	li	a7, 57
   21670: 26 85        	mv	a0, s1
   21672: 73 00 00 00  	ecall	
   21676: fd 75        	lui	a1, 1048575
   21678: 85 25        	addiw	a1, a1, 1
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2167a: b3 35 b5 00  	sltu	a1, a0, a1
   2167e: 42 15        	slli	a0, a0, 48
   21680: 41 91        	srli	a0, a0, 48
   21682: 41 66        	lui	a2, 16
   21684: 5d 36        	addiw	a2, a2, -9
   21686: 31 8d        	xor	a0, a0, a2
   21688: 33 35 a0 00  	snez	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2168c: 4d 8d        	or	a0, a0, a1
   2168e: 59 f9        	bnez	a0, 0x21624 <.LBB52_42+0x16>

0000000000021690 <.LBB52_52>:
   21690: 37 25 01 00  	lui	a0, 18
   21694: 13 05 b5 a7  	addi	a0, a0, -1413
   21698: e1 45        	li	a1, 24
   2169a: 81 46        	li	a3, 0
   2169c: 97 20 00 00  	auipc	ra, 2
   216a0: e7 80 e0 cd  	jalr	-802(ra)
;             .SUCCESS => return @intCast(fd_t, rc),
   216a4: 37 15 01 00  	lui	a0, 17
   216a8: 13 05 95 68  	addi	a0, a0, 1673
   216ac: ed 45        	li	a1, 27
   216ae: 81 46        	li	a3, 0
   216b0: 97 20 00 00  	auipc	ra, 2
   216b4: e7 80 a0 cc  	jalr	-822(ra)

00000000000216b8 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read>:
;             const size = std.math.min(dest.len, self.buffer.len - self.pos);
   216b8: 83 b8 85 00  	ld	a7, 8(a1)
   216bc: 9c 69        	ld	a5, 16(a1)
   216be: 33 87 f8 40  	sub	a4, a7, a5
   216c2: 63 e8 e8 04  	bltu	a7, a4, 0x21712 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x5a>
   216c6: 63 e3 e6 00  	bltu	a3, a4, 0x216cc <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x14>
   216ca: ba 86        	mv	a3, a4
;             const end = self.pos + size;
   216cc: 33 88 d7 00  	add	a6, a5, a3
   216d0: 63 61 f8 04  	bltu	a6, a5, 0x21712 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x5a>
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   216d4: 63 e9 08 05  	bltu	a7, a6, 0x21726 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x6e>
   216d8: 33 07 f8 40  	sub	a4, a6, a5
;     if (!ok) unreachable; // assertion failure
   216dc: 63 ef e6 04  	bltu	a3, a4, 0x2173a <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x82>
;     for (source) |s, i|
   216e0: 63 03 f8 02  	beq	a6, a5, 0x21706 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x4e>
   216e4: 83 b8 05 00  	ld	a7, 0(a1)
   216e8: 85 42        	li	t0, 1
   216ea: 36 83        	mv	t1, a3
;     for (source) |s, i|
   216ec: 63 e3 d2 00  	bltu	t0, a3, 0x216f2 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x3a>
   216f0: 05 43        	li	t1, 1
   216f2: c6 97        	add	a5, a5, a7
;     for (source) |s, i|
   216f4: 03 87 07 00  	lb	a4, 0(a5)
;         dest[i] = s;
   216f8: 23 00 e6 00  	sb	a4, 0(a2)
;     for (source) |s, i|
   216fc: 85 07        	addi	a5, a5, 1
   216fe: 7d 13        	addi	t1, t1, -1
   21700: 05 06        	addi	a2, a2, 1
   21702: e3 19 03 fe  	bnez	t1, 0x216f4 <io.fixed_buffer_stream.FixedBufferStream([]const u8).read+0x3c>
;             self.pos = end;
   21706: 23 b8 05 01  	sd	a6, 16(a1)
;             return size;
   2170a: 14 e1        	sd	a3, 0(a0)
   2170c: 23 14 05 00  	sh	zero, 8(a0)
   21710: 82 80        	ret
   21712: 37 15 01 00  	lui	a0, 17
   21716: 13 05 95 5d  	addi	a0, a0, 1497
   2171a: c1 45        	li	a1, 16
   2171c: 81 46        	li	a3, 0
   2171e: 97 20 00 00  	auipc	ra, 2
   21722: e7 80 c0 c5  	jalr	-932(ra)
;             mem.copy(u8, dest[0..size], self.buffer[self.pos..end]);
   21726: 37 15 01 00  	lui	a0, 17
   2172a: 13 05 35 6e  	addi	a0, a0, 1763
   2172e: cd 45        	li	a1, 19
   21730: 81 46        	li	a3, 0
   21732: 97 20 00 00  	auipc	ra, 2
   21736: e7 80 80 c4  	jalr	-952(ra)
;     if (!ok) unreachable; // assertion failure
   2173a: 37 25 01 00  	lui	a0, 18
   2173e: 13 05 b5 a7  	addi	a0, a0, -1413
   21742: e1 45        	li	a1, 24
   21744: 81 46        	li	a3, 0
   21746: 97 20 00 00  	auipc	ra, 2
   2174a: e7 80 40 c3  	jalr	-972(ra)

000000000002174e <leb128.readULEB128__anon_6058>:
; pub fn readULEB128(comptime T: type, reader: anytype) !T {
   2174e: 39 71        	addi	sp, sp, -64
   21750: 06 fc        	sd	ra, 56(sp)
   21752: 22 f8        	sd	s0, 48(sp)
   21754: 26 f4        	sd	s1, 40(sp)
   21756: 4a f0        	sd	s2, 32(sp)
   21758: 4e ec        	sd	s3, 24(sp)
   2175a: b2 84        	mv	s1, a2
;         const byte = try reader.readByte();
   2175c: 18 62        	ld	a4, 0(a2)
   2175e: 2e 89        	mv	s2, a1
   21760: aa 89        	mv	s3, a0
   21762: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   21766: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   2176a: 28 00        	addi	a0, sp, 8
   2176c: 13 06 71 00  	addi	a2, sp, 7
   21770: 85 46        	li	a3, 1
   21772: ba 85        	mv	a1, a4
   21774: 97 00 00 00  	auipc	ra, 0
   21778: e7 80 40 f4  	jalr	-188(ra)
   2177c: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   2177e: 63 0a 05 1c  	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   21782: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   21786: 13 74 f5 07  	andi	s0, a0, 127
;         if (byte & 0x80 == 0) break;
   2178a: 63 59 05 1a  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   2178e: 8c 60        	ld	a1, 0(s1)
   21790: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   21794: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   21798: 28 00        	addi	a0, sp, 8
   2179a: 13 06 71 00  	addi	a2, sp, 7
   2179e: 85 46        	li	a3, 1
   217a0: 97 00 00 00  	auipc	ra, 0
   217a4: e7 80 80 f1  	jalr	-232(ra)
   217a8: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   217aa: 63 04 05 1a  	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   217ae: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   217b2: 93 75 f5 07  	andi	a1, a0, 127
   217b6: 9e 05        	slli	a1, a1, 7
;         value |= ov[0];
   217b8: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   217ba: 63 51 05 18  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   217be: 8c 60        	ld	a1, 0(s1)
   217c0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   217c4: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   217c8: 28 00        	addi	a0, sp, 8
   217ca: 13 06 71 00  	addi	a2, sp, 7
   217ce: 85 46        	li	a3, 1
   217d0: 97 00 00 00  	auipc	ra, 0
   217d4: e7 80 80 ee  	jalr	-280(ra)
   217d8: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   217da: 63 0c 05 16  	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   217de: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   217e2: 93 75 f5 07  	andi	a1, a0, 127
   217e6: ba 05        	slli	a1, a1, 14
;         value |= ov[0];
   217e8: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   217ea: 63 59 05 14  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   217ee: 8c 60        	ld	a1, 0(s1)
   217f0: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   217f4: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   217f8: 28 00        	addi	a0, sp, 8
   217fa: 13 06 71 00  	addi	a2, sp, 7
   217fe: 85 46        	li	a3, 1
   21800: 97 00 00 00  	auipc	ra, 0
   21804: e7 80 80 eb  	jalr	-328(ra)
   21808: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   2180a: 63 04 05 14  	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   2180e: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   21812: 93 75 f5 07  	andi	a1, a0, 127
   21816: d6 05        	slli	a1, a1, 21
;         value |= ov[0];
   21818: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   2181a: 63 51 05 12  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   2181e: 8c 60        	ld	a1, 0(s1)
   21820: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   21824: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   21828: 28 00        	addi	a0, sp, 8
   2182a: 13 06 71 00  	addi	a2, sp, 7
   2182e: 85 46        	li	a3, 1
   21830: 97 00 00 00  	auipc	ra, 0
   21834: e7 80 80 e8  	jalr	-376(ra)
   21838: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   2183a: 63 0c 05 10  	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   2183e: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   21842: 93 75 f5 07  	andi	a1, a0, 127
   21846: f2 05        	slli	a1, a1, 28
;         value |= ov[0];
   21848: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   2184a: 63 59 05 0e  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   2184e: 8c 60        	ld	a1, 0(s1)
   21850: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   21854: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   21858: 28 00        	addi	a0, sp, 8
   2185a: 13 06 71 00  	addi	a2, sp, 7
   2185e: 85 46        	li	a3, 1
   21860: 97 00 00 00  	auipc	ra, 0
   21864: e7 80 80 e5  	jalr	-424(ra)
   21868: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   2186a: 65 c5        	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   2186c: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   21870: 93 75 f5 07  	andi	a1, a0, 127
   21874: 8e 15        	slli	a1, a1, 35
;         value |= ov[0];
   21876: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   21878: 63 52 05 0c  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   2187c: 8c 60        	ld	a1, 0(s1)
   2187e: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   21882: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   21886: 28 00        	addi	a0, sp, 8
   21888: 13 06 71 00  	addi	a2, sp, 7
   2188c: 85 46        	li	a3, 1
   2188e: 97 00 00 00  	auipc	ra, 0
   21892: e7 80 a0 e2  	jalr	-470(ra)
   21896: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   21898: 4d cd        	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   2189a: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   2189e: 93 75 f5 07  	andi	a1, a0, 127
   218a2: aa 15        	slli	a1, a1, 42
;         value |= ov[0];
   218a4: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   218a6: 63 5b 05 08  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   218aa: 8c 60        	ld	a1, 0(s1)
   218ac: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   218b0: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   218b4: 28 00        	addi	a0, sp, 8
   218b6: 13 06 71 00  	addi	a2, sp, 7
   218ba: 85 46        	li	a3, 1
   218bc: 97 00 00 00  	auipc	ra, 0
   218c0: e7 80 c0 df  	jalr	-516(ra)
   218c4: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   218c6: 51 c5        	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   218c8: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   218cc: 93 75 f5 07  	andi	a1, a0, 127
   218d0: c6 15        	slli	a1, a1, 49
;         value |= ov[0];
   218d2: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   218d4: 63 54 05 06  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   218d8: 8c 60        	ld	a1, 0(s1)
   218da: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   218de: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   218e2: 28 00        	addi	a0, sp, 8
   218e4: 13 06 71 00  	addi	a2, sp, 7
   218e8: 85 46        	li	a3, 1
   218ea: 97 00 00 00  	auipc	ra, 0
   218ee: e7 80 e0 dc  	jalr	-562(ra)
   218f2: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   218f4: 39 cd        	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   218f6: 03 05 71 00  	lb	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   218fa: 93 75 f5 07  	andi	a1, a0, 127
   218fe: e2 15        	slli	a1, a1, 56
;         value |= ov[0];
   21900: 4d 8c        	or	s0, s0, a1
;         if (byte & 0x80 == 0) break;
   21902: 63 5d 05 02  	bgez	a0, 0x2193c <leb128.readULEB128__anon_6058+0x1ee>
;         const byte = try reader.readByte();
   21906: 8c 60        	ld	a1, 0(s1)
   21908: 13 05 a0 0a  	li	a0, 170
;             var result: [1]u8 = undefined;
   2190c: a3 03 a1 00  	sb	a0, 7(sp)
;             return readFn(self.context, buffer);
   21910: 28 00        	addi	a0, sp, 8
   21912: 13 06 71 00  	addi	a2, sp, 7
   21916: 85 46        	li	a3, 1
   21918: 97 00 00 00  	auipc	ra, 0
   2191c: e7 80 00 da  	jalr	-608(ra)
   21920: 22 65        	ld	a0, 8(sp)
;             if (amt_read < 1) return error.EndOfStream;
   21922: 05 c9        	beqz	a0, 0x21952 <leb128.readULEB128__anon_6058+0x204>
;             return result[0];
   21924: 03 45 71 00  	lbu	a0, 7(sp)
;         const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);
   21928: 93 75 e5 07  	andi	a1, a0, 126
;         if (ov[1] != 0) return error.Overflow;
   2192c: b1 e1        	bnez	a1, 0x21970 <leb128.readULEB128__anon_6058+0x222>
   2192e: 93 15 85 03  	slli	a1, a0, 56
   21932: e1 95        	srai	a1, a1, 56
;         if (byte & 0x80 == 0) break;
   21934: 63 ce 05 02  	bltz	a1, 0x21970 <leb128.readULEB128__anon_6058+0x222>
   21938: 7e 15        	slli	a0, a0, 63
   2193a: 49 8c        	or	s0, s0, a0
;     return @truncate(T, value);
   2193c: 23 b0 89 00  	sd	s0, 0(s3)
   21940: 23 94 09 00  	sh	zero, 8(s3)
   21944: e2 70        	ld	ra, 56(sp)
   21946: 42 74        	ld	s0, 48(sp)
   21948: a2 74        	ld	s1, 40(sp)
   2194a: 02 79        	ld	s2, 32(sp)
   2194c: e2 69        	ld	s3, 24(sp)
   2194e: 21 61        	addi	sp, sp, 64
   21950: 82 80        	ret
;             if (amt_read < 1) return error.EndOfStream;
   21952: 4a 85        	mv	a0, s2
   21954: 97 20 00 00  	auipc	ra, 2
   21958: e7 80 40 2a  	jalr	676(ra)
;         const byte = try reader.readByte();
   2195c: 4a 85        	mv	a0, s2
   2195e: 97 20 00 00  	auipc	ra, 2
   21962: e7 80 a0 29  	jalr	666(ra)
   21966: 13 05 10 03  	li	a0, 49
   2196a: 23 94 a9 00  	sh	a0, 8(s3)
   2196e: d9 bf        	j	0x21944 <leb128.readULEB128__anon_6058+0x1f6>
   21970: 4a 85        	mv	a0, s2
   21972: 97 20 00 00  	auipc	ra, 2
   21976: e7 80 60 28  	jalr	646(ra)
   2197a: 13 05 00 03  	li	a0, 48
   2197e: 23 b4 a9 00  	sd	a0, 8(s3)
   21982: 23 b0 09 00  	sd	zero, 0(s3)
   21986: 7d bf        	j	0x21944 <leb128.readULEB128__anon_6058+0x1f6>

0000000000021988 <dwarf.readAllocBytes__anon_6065>:
; fn readAllocBytes(allocator: mem.Allocator, in_stream: anytype, size: usize) ![]u8 {
   21988: 5d 71        	addi	sp, sp, -80
   2198a: 86 e4        	sd	ra, 72(sp)
   2198c: a2 e0        	sd	s0, 64(sp)
   2198e: 26 fc        	sd	s1, 56(sp)
   21990: 4a f8        	sd	s2, 48(sp)
   21992: 4e f4        	sd	s3, 40(sp)
   21994: 52 f0        	sd	s4, 32(sp)
   21996: 56 ec        	sd	s5, 24(sp)
   21998: 5a e8        	sd	s6, 16(sp)
   2199a: 86 89        	mv	s3, ra
   2199c: ba 84        	mv	s1, a4
   2199e: 36 8b        	mv	s6, a3
   219a0: 32 8a        	mv	s4, a2
   219a2: 2e 89        	mv	s2, a1
   219a4: aa 8a        	mv	s5, a0
;     if (n == 0) {
   219a6: 05 c7        	beqz	a4, 0x219ce <dwarf.readAllocBytes__anon_6065+0x46>
;     const buf = try allocator.alloc(u8, size);
   219a8: 83 35 8a 00  	ld	a1, 8(s4)
   219ac: 03 35 0a 00  	ld	a0, 0(s4)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   219b0: 98 61        	ld	a4, 0(a1)
   219b2: a6 85        	mv	a1, s1
   219b4: 01 46        	li	a2, 0
   219b6: ce 86        	mv	a3, s3
   219b8: 02 97        	jalr	a4
   219ba: 49 c9        	beqz	a0, 0x21a4c <dwarf.readAllocBytes__anon_6065+0xc4>
   219bc: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   219be: 93 05 a0 0a  	li	a1, 170
   219c2: 26 86        	mv	a2, s1
   219c4: 97 30 00 00  	auipc	ra, 3
   219c8: e7 80 60 8d  	jalr	-1834(ra)
   219cc: 11 a0        	j	0x219d0 <dwarf.readAllocBytes__anon_6065+0x48>
   219ce: 7d 54        	li	s0, -1
;     if ((try nosuspend in_stream.read(buf)) < size) return error.EndOfFile;
   219d0: 83 35 0b 00  	ld	a1, 0(s6)
;             return readFn(self.context, buffer);
   219d4: 0a 85        	mv	a0, sp
   219d6: 22 86        	mv	a2, s0
   219d8: a6 86        	mv	a3, s1
   219da: 97 00 00 00  	auipc	ra, 0
   219de: e7 80 e0 cd  	jalr	-802(ra)
   219e2: 02 65        	ld	a0, 0(sp)
   219e4: 63 62 95 02  	bltu	a0, s1, 0x21a08 <dwarf.readAllocBytes__anon_6065+0x80>
;     return buf;
   219e8: 23 b0 8a 00  	sd	s0, 0(s5)
   219ec: 23 b4 9a 00  	sd	s1, 8(s5)
   219f0: 23 98 0a 00  	sh	zero, 16(s5)
   219f4: a6 60        	ld	ra, 72(sp)
   219f6: 06 64        	ld	s0, 64(sp)
   219f8: e2 74        	ld	s1, 56(sp)
   219fa: 42 79        	ld	s2, 48(sp)
   219fc: a2 79        	ld	s3, 40(sp)
   219fe: 02 7a        	ld	s4, 32(sp)
   21a00: e2 6a        	ld	s5, 24(sp)
   21a02: 42 6b        	ld	s6, 16(sp)
   21a04: 61 61        	addi	sp, sp, 80
   21a06: 82 80        	ret
;     errdefer allocator.free(buf);
   21a08: 03 3b 8a 00  	ld	s6, 8(s4)
   21a0c: 03 3a 0a 00  	ld	s4, 0(s4)
;     @memset(non_const_ptr, undefined, bytes_len);
   21a10: 93 05 a0 0a  	li	a1, 170
   21a14: 22 85        	mv	a0, s0
   21a16: 26 86        	mv	a2, s1
   21a18: 97 30 00 00  	auipc	ra, 3
   21a1c: e7 80 20 88  	jalr	-1918(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   21a20: 83 37 0b 01  	ld	a5, 16(s6)
   21a24: 52 85        	mv	a0, s4
   21a26: a2 85        	mv	a1, s0
   21a28: 26 86        	mv	a2, s1
   21a2a: 81 46        	li	a3, 0
   21a2c: 4e 87        	mv	a4, s3
   21a2e: 82 97        	jalr	a5
;     if ((try nosuspend in_stream.read(buf)) < size) return error.EndOfFile;
   21a30: 4a 85        	mv	a0, s2
   21a32: 97 20 00 00  	auipc	ra, 2
   21a36: e7 80 60 1c  	jalr	454(ra)
   21a3a: 13 05 60 03  	li	a0, 54
   21a3e: 23 b8 aa 00  	sd	a0, 16(s5)
   21a42: 23 b4 0a 00  	sd	zero, 8(s5)
   21a46: 23 b0 0a 00  	sd	zero, 0(s5)
   21a4a: 6d b7        	j	0x219f4 <dwarf.readAllocBytes__anon_6065+0x6c>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   21a4c: 4a 85        	mv	a0, s2
   21a4e: 97 20 00 00  	auipc	ra, 2
   21a52: e7 80 a0 1a  	jalr	426(ra)
;     return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());
   21a56: 4a 85        	mv	a0, s2
   21a58: 97 20 00 00  	auipc	ra, 2
   21a5c: e7 80 00 1a  	jalr	416(ra)
;     const buf = try allocator.alloc(u8, size);
   21a60: 4a 85        	mv	a0, s2
   21a62: 97 20 00 00  	auipc	ra, 2
   21a66: e7 80 60 19  	jalr	406(ra)
   21a6a: 45 45        	li	a0, 17
   21a6c: 23 98 aa 00  	sh	a0, 16(s5)
   21a70: 51 b7        	j	0x219f4 <dwarf.readAllocBytes__anon_6065+0x6c>

0000000000021a72 <dwarf.readAllocBytes__anon_6077>:
; fn readAllocBytes(allocator: mem.Allocator, in_stream: anytype, size: usize) ![]u8 {
   21a72: 5d 71        	addi	sp, sp, -80
   21a74: 86 e4        	sd	ra, 72(sp)
   21a76: a2 e0        	sd	s0, 64(sp)
   21a78: 26 fc        	sd	s1, 56(sp)
   21a7a: 4a f8        	sd	s2, 48(sp)
   21a7c: 4e f4        	sd	s3, 40(sp)
   21a7e: 52 f0        	sd	s4, 32(sp)
   21a80: 56 ec        	sd	s5, 24(sp)
   21a82: 5a e8        	sd	s6, 16(sp)
   21a84: 86 89        	mv	s3, ra
   21a86: ba 84        	mv	s1, a4
   21a88: 36 8b        	mv	s6, a3
   21a8a: 32 8a        	mv	s4, a2
   21a8c: 2e 89        	mv	s2, a1
   21a8e: aa 8a        	mv	s5, a0
;     if (n == 0) {
   21a90: 05 c7        	beqz	a4, 0x21ab8 <dwarf.readAllocBytes__anon_6077+0x46>
;     const buf = try allocator.alloc(u8, size);
   21a92: 83 35 8a 00  	ld	a1, 8(s4)
   21a96: 03 35 0a 00  	ld	a0, 0(s4)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   21a9a: 98 61        	ld	a4, 0(a1)
   21a9c: a6 85        	mv	a1, s1
   21a9e: 01 46        	li	a2, 0
   21aa0: ce 86        	mv	a3, s3
   21aa2: 02 97        	jalr	a4
   21aa4: 49 c9        	beqz	a0, 0x21b36 <dwarf.readAllocBytes__anon_6077+0xc4>
   21aa6: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   21aa8: 93 05 a0 0a  	li	a1, 170
   21aac: 26 86        	mv	a2, s1
   21aae: 97 20 00 00  	auipc	ra, 2
   21ab2: e7 80 c0 7e  	jalr	2028(ra)
   21ab6: 11 a0        	j	0x21aba <dwarf.readAllocBytes__anon_6077+0x48>
   21ab8: 7d 54        	li	s0, -1
;             return readFn(self.context, buffer);
   21aba: 83 35 0b 00  	ld	a1, 0(s6)
   21abe: 0a 85        	mv	a0, sp
   21ac0: 22 86        	mv	a2, s0
   21ac2: a6 86        	mv	a3, s1
   21ac4: 97 00 00 00  	auipc	ra, 0
   21ac8: e7 80 40 bf  	jalr	-1036(ra)
   21acc: 02 65        	ld	a0, 0(sp)
   21ace: 63 62 95 02  	bltu	a0, s1, 0x21af2 <dwarf.readAllocBytes__anon_6077+0x80>
;     return buf;
   21ad2: 23 b0 8a 00  	sd	s0, 0(s5)
   21ad6: 23 b4 9a 00  	sd	s1, 8(s5)
   21ada: 23 98 0a 00  	sh	zero, 16(s5)
   21ade: a6 60        	ld	ra, 72(sp)
   21ae0: 06 64        	ld	s0, 64(sp)
   21ae2: e2 74        	ld	s1, 56(sp)
   21ae4: 42 79        	ld	s2, 48(sp)
   21ae6: a2 79        	ld	s3, 40(sp)
   21ae8: 02 7a        	ld	s4, 32(sp)
   21aea: e2 6a        	ld	s5, 24(sp)
   21aec: 42 6b        	ld	s6, 16(sp)
   21aee: 61 61        	addi	sp, sp, 80
   21af0: 82 80        	ret
;     errdefer allocator.free(buf);
   21af2: 03 3b 8a 00  	ld	s6, 8(s4)
   21af6: 03 3a 0a 00  	ld	s4, 0(s4)
;     @memset(non_const_ptr, undefined, bytes_len);
   21afa: 93 05 a0 0a  	li	a1, 170
   21afe: 22 85        	mv	a0, s0
   21b00: 26 86        	mv	a2, s1
   21b02: 97 20 00 00  	auipc	ra, 2
   21b06: e7 80 80 79  	jalr	1944(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   21b0a: 83 37 0b 01  	ld	a5, 16(s6)
   21b0e: 52 85        	mv	a0, s4
   21b10: a2 85        	mv	a1, s0
   21b12: 26 86        	mv	a2, s1
   21b14: 81 46        	li	a3, 0
   21b16: 4e 87        	mv	a4, s3
   21b18: 82 97        	jalr	a5
;     if ((try nosuspend in_stream.read(buf)) < size) return error.EndOfFile;
   21b1a: 4a 85        	mv	a0, s2
   21b1c: 97 20 00 00  	auipc	ra, 2
   21b20: e7 80 c0 0d  	jalr	220(ra)
   21b24: 13 05 60 03  	li	a0, 54
   21b28: 23 b8 aa 00  	sd	a0, 16(s5)
   21b2c: 23 b4 0a 00  	sd	zero, 8(s5)
   21b30: 23 b0 0a 00  	sd	zero, 0(s5)
   21b34: 6d b7        	j	0x21ade <dwarf.readAllocBytes__anon_6077+0x6c>
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   21b36: 4a 85        	mv	a0, s2
   21b38: 97 20 00 00  	auipc	ra, 2
   21b3c: e7 80 00 0c  	jalr	192(ra)
;     return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());
   21b40: 4a 85        	mv	a0, s2
   21b42: 97 20 00 00  	auipc	ra, 2
   21b46: e7 80 60 0b  	jalr	182(ra)
;     const buf = try allocator.alloc(u8, size);
   21b4a: 4a 85        	mv	a0, s2
   21b4c: 97 20 00 00  	auipc	ra, 2
   21b50: e7 80 c0 0a  	jalr	172(ra)
   21b54: 45 45        	li	a0, 17
   21b56: 23 98 aa 00  	sh	a0, 16(s5)
   21b5a: 51 b7        	j	0x21ade <dwarf.readAllocBytes__anon_6077+0x6c>

0000000000021b5c <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne>:
;         pub fn addOne(self: *Self) Allocator.Error!*T {
   21b5c: 79 71        	addi	sp, sp, -48
;             try self.ensureTotalCapacity(self.items.len + 1);
   21b5e: 06 f4        	sd	ra, 40(sp)
   21b60: 22 f0        	sd	s0, 32(sp)
   21b62: 26 ec        	sd	s1, 24(sp)
   21b64: 4a e8        	sd	s2, 16(sp)
   21b66: 4e e4        	sd	s3, 8(sp)
   21b68: 14 66        	ld	a3, 8(a2)
   21b6a: 13 87 16 00  	addi	a4, a3, 1
   21b6e: 51 c3        	beqz	a4, 0x21bf2 <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x96>
   21b70: b2 84        	mv	s1, a2
   21b72: aa 89        	mv	s3, a0
;             if (self.capacity >= new_capacity) return;
   21b74: 10 6a        	ld	a2, 16(a2)
   21b76: 63 7c e6 02  	bgeu	a2, a4, 0x21bae <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x52>
   21b7a: 2e 89        	mv	s2, a1
   21b7c: 19 a0        	j	0x21b82 <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x26>
;                 if (better_capacity >= new_capacity) break;
   21b7e: 63 7c e6 00  	bgeu	a2, a4, 0x21b96 <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x3a>
   21b82: b2 85        	mv	a1, a2
;                 better_capacity +|= better_capacity / 2 + 8;
   21b84: 13 55 16 00  	srli	a0, a2, 1
   21b88: 32 95        	add	a0, a0, a2
   21b8a: 21 05        	addi	a0, a0, 8
   21b8c: 7d 56        	li	a2, -1
   21b8e: e3 68 b5 fe  	bltu	a0, a1, 0x21b7e <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x22>
   21b92: 2a 86        	mv	a2, a0
   21b94: ed b7        	j	0x21b7e <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x22>
;             return self.ensureTotalCapacityPrecise(better_capacity);
   21b96: 4a 85        	mv	a0, s2
   21b98: a6 85        	mv	a1, s1
   21b9a: 97 10 00 00  	auipc	ra, 1
   21b9e: e7 80 c0 2b  	jalr	700(ra)
   21ba2: 2a 84        	mv	s0, a0
   21ba4: 42 15        	slli	a0, a0, 48
   21ba6: 41 91        	srli	a0, a0, 48
   21ba8: 15 e9        	bnez	a0, 0x21bdc <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x80>
;             assert(self.items.len < self.capacity);
   21baa: 94 64        	ld	a3, 8(s1)
   21bac: 90 68        	ld	a2, 16(s1)
   21bae: 63 fc c6 04  	bgeu	a3, a2, 0x21c06 <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0xaa>
   21bb2: 01 44        	li	s0, 0
;             self.items.len += 1;
   21bb4: 13 85 16 00  	addi	a0, a3, 1
;             return &self.items[self.items.len - 1];
   21bb8: 8c 60        	ld	a1, 0(s1)
;             self.items.len += 1;
   21bba: 88 e4        	sd	a0, 8(s1)
   21bbc: 13 05 80 03  	li	a0, 56
;             return &self.items[self.items.len - 1];
   21bc0: 33 85 a6 02  	mul	a0, a3, a0
   21bc4: 2e 95        	add	a0, a0, a1
;             return self.addOneAssumeCapacity();
   21bc6: 23 b0 a9 00  	sd	a0, 0(s3)
   21bca: 23 94 89 00  	sh	s0, 8(s3)
   21bce: a2 70        	ld	ra, 40(sp)
   21bd0: 02 74        	ld	s0, 32(sp)
   21bd2: e2 64        	ld	s1, 24(sp)
   21bd4: 42 69        	ld	s2, 16(sp)
   21bd6: a2 69        	ld	s3, 8(sp)
   21bd8: 45 61        	addi	sp, sp, 48
   21bda: 82 80        	ret
;             return self.ensureTotalCapacityPrecise(better_capacity);
   21bdc: 4a 85        	mv	a0, s2
   21bde: 97 20 00 00  	auipc	ra, 2
   21be2: e7 80 a0 01  	jalr	26(ra)
;             try self.ensureTotalCapacity(self.items.len + 1);
   21be6: 4a 85        	mv	a0, s2
   21be8: 97 20 00 00  	auipc	ra, 2
   21bec: e7 80 00 01  	jalr	16(ra)
   21bf0: e9 bf        	j	0x21bca <array_list.ArrayListAligned(dwarf.FileEntry,null).addOne+0x6e>
   21bf2: 37 15 01 00  	lui	a0, 17
   21bf6: 13 05 95 5d  	addi	a0, a0, 1497
   21bfa: c1 45        	li	a1, 16
   21bfc: 81 46        	li	a3, 0
   21bfe: 97 10 00 00  	auipc	ra, 1
   21c02: e7 80 c0 77  	jalr	1916(ra)
;     if (!ok) unreachable; // assertion failure
   21c06: 37 25 01 00  	lui	a0, 18
   21c0a: 13 05 b5 a7  	addi	a0, a0, -1413
   21c0e: e1 45        	li	a1, 24
   21c10: 81 46        	li	a3, 0
   21c12: 97 10 00 00  	auipc	ra, 1
   21c16: e7 80 80 76  	jalr	1896(ra)

0000000000021c1a <fmt.format__anon_6257>:
; ) !void {
   21c1a: 1d 71        	addi	sp, sp, -96
   21c1c: 86 ec        	sd	ra, 88(sp)
   21c1e: a2 e8        	sd	s0, 80(sp)
   21c20: a6 e4        	sd	s1, 72(sp)
   21c22: ca e0        	sd	s2, 64(sp)
   21c24: 4e fc        	sd	s3, 56(sp)
   21c26: 52 f8        	sd	s4, 48(sp)
   21c28: 56 f4        	sd	s5, 40(sp)
   21c2a: 5a f0        	sd	s6, 32(sp)
   21c2c: 5e ec        	sd	s7, 24(sp)
   21c2e: 62 e8        	sd	s8, 16(sp)
   21c30: b2 89        	mv	s3, a2
   21c32: 2e 89        	mv	s2, a1
   21c34: 2a 8a        	mv	s4, a0
   21c36: 01 44        	li	s0, 0
;             try writer.writeAll(fmt[start_index..end_index]);
   21c38: 03 ab 05 00  	lw	s6, 0(a1)
   21c3c: f5 4a        	li	s5, 29
   21c3e: 37 25 01 00  	lui	a0, 18
   21c42: 13 0c 65 d9  	addi	s8, a0, -618
   21c46: f1 4b        	li	s7, 28
;                 index += try self.write(bytes[index..]);
   21c48: 63 7f 54 0b  	bgeu	s0, s5, 0x21d06 <fmt.format__anon_6257+0xec>
   21c4c: b3 06 8c 00  	add	a3, s8, s0
   21c50: 33 87 8b 40  	sub	a4, s7, s0
;             return writeFn(self.context, bytes);
   21c54: 0a 85        	mv	a0, sp
   21c56: d2 85        	mv	a1, s4
   21c58: 5a 86        	mv	a2, s6
   21c5a: 97 20 ff ff  	auipc	ra, 1048562
   21c5e: e7 80 20 20  	jalr	514(ra)
   21c62: 83 54 81 00  	lhu	s1, 8(sp)
   21c66: c1 e0        	bnez	s1, 0x21ce6 <fmt.format__anon_6257+0xcc>
   21c68: 02 65        	ld	a0, 0(sp)
;                 index += try self.write(bytes[index..]);
   21c6a: 22 95        	add	a0, a0, s0
   21c6c: 63 68 85 0a  	bltu	a0, s0, 0x21d1c <fmt.format__anon_6257+0x102>
   21c70: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   21c72: e3 1b 75 fd  	bne	a0, s7, 0x21c48 <fmt.format__anon_6257+0x2e>
;         try formatType(
   21c76: 83 b5 09 00  	ld	a1, 0(s3)
   21c7a: 03 b6 89 00  	ld	a2, 8(s3)
;                             return formatBuf(value, options, writer);
   21c7e: 37 15 01 00  	lui	a0, 17
   21c82: 93 06 85 11  	addi	a3, a0, 280
   21c86: 52 85        	mv	a0, s4
   21c88: 4a 87        	mv	a4, s2
   21c8a: 97 00 00 00  	auipc	ra, 0
   21c8e: e7 80 60 0a  	jalr	166(ra)
   21c92: aa 84        	mv	s1, a0
   21c94: 42 15        	slli	a0, a0, 48
   21c96: 41 91        	srli	a0, a0, 48
   21c98: 21 ed        	bnez	a0, 0x21cf0 <fmt.format__anon_6257+0xd6>
;             try writer.writeAll(fmt[start_index..end_index]);
   21c9a: 03 29 09 00  	lw	s2, 0(s2)
   21c9e: b7 25 01 00  	lui	a1, 18
   21ca2: 13 84 55 db  	addi	s0, a1, -587
   21ca6: 19 ed        	bnez	a0, 0x21cc4 <fmt.format__anon_6257+0xaa>
;             return writeFn(self.context, bytes);
   21ca8: 0a 85        	mv	a0, sp
   21caa: 05 47        	li	a4, 1
   21cac: d2 85        	mv	a1, s4
   21cae: 4a 86        	mv	a2, s2
   21cb0: a2 86        	mv	a3, s0
   21cb2: 97 20 ff ff  	auipc	ra, 1048562
   21cb6: e7 80 a0 1a  	jalr	426(ra)
   21cba: 83 54 81 00  	lhu	s1, 8(sp)
   21cbe: 85 e4        	bnez	s1, 0x21ce6 <fmt.format__anon_6257+0xcc>
   21cc0: 02 65        	ld	a0, 0(sp)
   21cc2: 7d d1        	beqz	a0, 0x21ca8 <fmt.format__anon_6257+0x8e>
   21cc4: 85 45        	li	a1, 1
   21cc6: 63 10 b5 04  	bne	a0, a1, 0x21d06 <fmt.format__anon_6257+0xec>
   21cca: 81 44        	li	s1, 0
   21ccc: 26 85        	mv	a0, s1
   21cce: e6 60        	ld	ra, 88(sp)
   21cd0: 46 64        	ld	s0, 80(sp)
   21cd2: a6 64        	ld	s1, 72(sp)
   21cd4: 06 69        	ld	s2, 64(sp)
   21cd6: e2 79        	ld	s3, 56(sp)
   21cd8: 42 7a        	ld	s4, 48(sp)
   21cda: a2 7a        	ld	s5, 40(sp)
   21cdc: 02 7b        	ld	s6, 32(sp)
   21cde: e2 6b        	ld	s7, 24(sp)
   21ce0: 42 6c        	ld	s8, 16(sp)
   21ce2: 25 61        	addi	sp, sp, 96
   21ce4: 82 80        	ret
   21ce6: 52 85        	mv	a0, s4
   21ce8: 97 20 00 00  	auipc	ra, 2
   21cec: e7 80 00 f1  	jalr	-240(ra)
   21cf0: 52 85        	mv	a0, s4
   21cf2: 97 20 00 00  	auipc	ra, 2
   21cf6: e7 80 60 f0  	jalr	-250(ra)
   21cfa: 52 85        	mv	a0, s4
   21cfc: 97 20 00 00  	auipc	ra, 2
   21d00: e7 80 c0 ef  	jalr	-260(ra)
   21d04: e1 b7        	j	0x21ccc <fmt.format__anon_6257+0xb2>
   21d06: 37 15 01 00  	lui	a0, 17
   21d0a: 13 05 45 5b  	addi	a0, a0, 1460
   21d0e: 93 05 40 02  	li	a1, 36
   21d12: 81 46        	li	a3, 0
   21d14: 97 10 00 00  	auipc	ra, 1
   21d18: e7 80 60 66  	jalr	1638(ra)
;                 index += try self.write(bytes[index..]);
   21d1c: 37 15 01 00  	lui	a0, 17
   21d20: 13 05 95 5d  	addi	a0, a0, 1497
   21d24: c1 45        	li	a1, 16
   21d26: 81 46        	li	a3, 0
   21d28: 97 10 00 00  	auipc	ra, 1
   21d2c: e7 80 20 65  	jalr	1618(ra)

0000000000021d30 <fmt.formatBuf__anon_6294>:
; ) !void {
   21d30: 25 71        	addi	sp, sp, -416
   21d32: 06 ef        	sd	ra, 408(sp)
   21d34: 22 eb        	sd	s0, 400(sp)
   21d36: 26 e7        	sd	s1, 392(sp)
   21d38: 4a e3        	sd	s2, 384(sp)
   21d3a: ce fe        	sd	s3, 376(sp)
   21d3c: d2 fa        	sd	s4, 368(sp)
   21d3e: d6 f6        	sd	s5, 360(sp)
   21d40: da f2        	sd	s6, 352(sp)
   21d42: de ee        	sd	s7, 344(sp)
   21d44: e2 ea        	sd	s8, 336(sp)
   21d46: e6 e6        	sd	s9, 328(sp)
   21d48: ea e2        	sd	s10, 320(sp)
   21d4a: 6e fe        	sd	s11, 312(sp)
   21d4c: 36 8a        	mv	s4, a3
;     if (options.width) |min_width| {
   21d4e: 83 c6 86 01  	lbu	a3, 24(a3)
   21d52: 3a 89        	mv	s2, a4
   21d54: b2 8b        	mv	s7, a2
   21d56: ae 8a        	mv	s5, a1
   21d58: aa 89        	mv	s3, a0
;     if (options.width) |min_width| {
   21d5a: 63 86 06 20  	beqz	a3, 0x21f66 <fmt.formatBuf__anon_6294+0x236>
   21d5e: 03 3c 0a 01  	ld	s8, 16(s4)
;     while (i < s.len) {
   21d62: 63 87 0b 20  	beqz	s7, 0x21f70 <fmt.formatBuf__anon_6294+0x240>
   21d66: 01 45        	li	a0, 0
   21d68: 01 47        	li	a4, 0
   21d6a: 83 b5 09 00  	ld	a1, 0(s3)
   21d6e: 2e e0        	sd	a1, 0(sp)
   21d70: b7 25 01 00  	lui	a1, 18
   21d74: 03 c8 25 e3  	lbu	a6, -462(a1)
   21d78: b7 25 01 00  	lui	a1, 18
   21d7c: 83 c8 65 e3  	lbu	a7, -458(a1)
   21d80: b7 25 01 00  	lui	a1, 18
   21d84: 83 cd a5 e3  	lbu	s11, -454(a1)
   21d88: b7 25 01 00  	lui	a1, 18
   21d8c: 83 cf a5 e2  	lbu	t6, -470(a1)
   21d90: 85 40        	li	ra, 1
   21d92: 89 4c        	li	s9, 2
   21d94: 93 03 00 fc  	li	t2, -64
   21d98: 8d 42        	li	t0, 3
   21d9a: 01 53        	li	t1, -32
   21d9c: 13 0d 00 08  	li	s10, 128
   21da0: b9 65        	lui	a1, 14
   21da2: 1b 8e 05 80  	addiw	t3, a1, -2048
   21da6: b7 55 02 00  	lui	a1, 37
   21daa: 03 bf 05 3d  	ld	t5, 976(a1)
   21dae: 9d 4e        	li	t4, 7
   21db0: 39 a0        	j	0x21dbe <fmt.formatBuf__anon_6294+0x8e>
;             len += 1;
   21db2: 85 06        	addi	a3, a3, 1
   21db4: 63 8a 06 40  	beqz	a3, 0x221c8 <fmt.formatBuf__anon_6294+0x498>
   21db8: 36 87        	mv	a4, a3
   21dba: 63 7c 75 1b  	bgeu	a0, s7, 0x21f72 <fmt.formatBuf__anon_6294+0x242>
;         while (i + N <= s.len) : (i += N) {
   21dbe: 13 06 85 00  	addi	a2, a0, 8
   21dc2: 63 64 a6 3c  	bltu	a2, a0, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
   21dc6: ba 86        	mv	a3, a4
;         while (i + N <= s.len) : (i += N) {
   21dc8: 63 ec cb 04  	bltu	s7, a2, 0x21e20 <fmt.formatBuf__anon_6294+0xf0>
;             const v = mem.readIntNative(usize, s[i..][0..N]);
   21dcc: 63 e9 ab 3c  	bltu	s7, a0, 0x2219e <fmt.formatBuf__anon_6294+0x46e>
   21dd0: 33 87 ab 40  	sub	a4, s7, a0
   21dd4: 63 f0 ee 3e  	bgeu	t4, a4, 0x221b4 <fmt.formatBuf__anon_6294+0x484>
   21dd8: 33 87 aa 00  	add	a4, s5, a0
;             const v = mem.readIntNative(usize, s[i..][0..N]);
   21ddc: 83 44 17 00  	lbu	s1, 1(a4)
   21de0: 83 45 07 00  	lbu	a1, 0(a4)
   21de4: 83 47 37 00  	lbu	a5, 3(a4)
   21de8: 03 44 27 00  	lbu	s0, 2(a4)
   21dec: a2 04        	slli	s1, s1, 8
   21dee: c5 8d        	or	a1, a1, s1
   21df0: a2 07        	slli	a5, a5, 8
   21df2: c1 8f        	or	a5, a5, s0
   21df4: c2 07        	slli	a5, a5, 16
   21df6: dd 8d        	or	a1, a1, a5
   21df8: 83 47 57 00  	lbu	a5, 5(a4)
   21dfc: 03 44 47 00  	lbu	s0, 4(a4)
   21e00: 83 44 77 00  	lbu	s1, 7(a4)
   21e04: 03 47 67 00  	lbu	a4, 6(a4)
   21e08: a2 07        	slli	a5, a5, 8
   21e0a: c1 8f        	or	a5, a5, s0
   21e0c: 13 94 84 00  	slli	s0, s1, 8
   21e10: 41 8f        	or	a4, a4, s0
   21e12: 42 07        	slli	a4, a4, 16
   21e14: 5d 8f        	or	a4, a4, a5
   21e16: 02 17        	slli	a4, a4, 32
   21e18: d9 8d        	or	a1, a1, a4
;             if (v & MASK != 0) break;
   21e1a: b3 f5 e5 01  	and	a1, a1, t5
   21e1e: a5 c9        	beqz	a1, 0x21e8e <fmt.formatBuf__anon_6294+0x15e>
;         if (i < s.len) {
   21e20: e3 7c 75 f9  	bgeu	a0, s7, 0x21db8 <fmt.formatBuf__anon_6294+0x88>
;             const n = try utf8ByteSequenceLength(s[i]);
   21e24: 33 87 aa 00  	add	a4, s5, a0
   21e28: 03 06 07 00  	lb	a2, 0(a4)
   21e2c: fe 84        	mv	s1, t6
;     return switch (first_byte) {
   21e2e: 63 52 06 02  	bgez	a2, 0x21e52 <fmt.formatBuf__anon_6294+0x122>
   21e32: 93 75 06 fe  	andi	a1, a2, -32
   21e36: ee 84        	mv	s1, s11
   21e38: 63 8d 75 00  	beq	a1, t2, 0x21e52 <fmt.formatBuf__anon_6294+0x122>
   21e3c: 93 75 06 ff  	andi	a1, a2, -16
   21e40: c6 84        	mv	s1, a7
   21e42: 63 88 65 00  	beq	a1, t1, 0x21e52 <fmt.formatBuf__anon_6294+0x122>
   21e46: 93 75 86 ff  	andi	a1, a2, -8
   21e4a: c2 84        	mv	s1, a6
   21e4c: c1 57        	li	a5, -16
   21e4e: 63 9d f5 0e  	bne	a1, a5, 0x21f48 <fmt.formatBuf__anon_6294+0x218>
;             if (i + n > s.len) return error.TruncatedInput;
   21e52: 9d 88        	andi	s1, s1, 7
   21e54: 26 95        	add	a0, a0, s1
   21e56: 63 ee ab 0e  	bltu	s7, a0, 0x21f52 <fmt.formatBuf__anon_6294+0x222>
;             switch (n) {
   21e5a: e3 8c 14 f4  	beq	s1, ra, 0x21db2 <fmt.formatBuf__anon_6294+0x82>
;     return switch (bytes.len) {
   21e5e: 63 ce 9c 02  	blt	s9, s1, 0x21e9a <fmt.formatBuf__anon_6294+0x16a>
   21e62: e3 88 14 f4  	beq	s1, ra, 0x21db2 <fmt.formatBuf__anon_6294+0x82>
   21e66: 63 9a 94 37  	bne	s1, s9, 0x221da <fmt.formatBuf__anon_6294+0x4aa>
;     assert(bytes[0] & 0b11100000 == 0b11000000);
   21e6a: 93 75 06 fe  	andi	a1, a2, -32
   21e6e: 63 96 75 36  	bne	a1, t2, 0x221da <fmt.formatBuf__anon_6294+0x4aa>
;     if (bytes[1] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21e72: 83 45 17 00  	lbu	a1, 1(a4)
   21e76: 93 f5 05 0c  	andi	a1, a1, 192
   21e7a: 93 85 05 f8  	addi	a1, a1, -128
   21e7e: b3 35 b0 00  	snez	a1, a1
   21e82: 79 8a        	andi	a2, a2, 30
   21e84: 13 36 16 00  	seqz	a2, a2
;     if (bytes[1] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21e88: d1 8d        	or	a1, a1, a2
   21e8a: 85 d5        	beqz	a1, 0x21db2 <fmt.formatBuf__anon_6294+0x82>
   21e8c: 4d a8        	j	0x21f3e <fmt.formatBuf__anon_6294+0x20e>
;             len += N;
   21e8e: 13 87 86 00  	addi	a4, a3, 8
   21e92: 32 85        	mv	a0, a2
   21e94: e3 75 d7 f2  	bgeu	a4, a3, 0x21dbe <fmt.formatBuf__anon_6294+0x8e>
   21e98: cd ac        	j	0x2218a <fmt.formatBuf__anon_6294+0x45a>
;     return switch (bytes.len) {
   21e9a: 63 80 54 06  	beq	s1, t0, 0x21efa <fmt.formatBuf__anon_6294+0x1ca>
   21e9e: 91 45        	li	a1, 4
   21ea0: 63 9d b4 32  	bne	s1, a1, 0x221da <fmt.formatBuf__anon_6294+0x4aa>
;     assert(bytes[0] & 0b11111000 == 0b11110000);
   21ea4: 93 75 86 ff  	andi	a1, a2, -8
;     if (!ok) unreachable; // assertion failure
   21ea8: c1 57        	li	a5, -16
   21eaa: 63 98 f5 32  	bne	a1, a5, 0x221da <fmt.formatBuf__anon_6294+0x4aa>
;     if (bytes[1] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21eae: 83 44 17 00  	lbu	s1, 1(a4)
   21eb2: 93 f5 04 0c  	andi	a1, s1, 192
   21eb6: 63 94 a5 09  	bne	a1, s10, 0x21f3e <fmt.formatBuf__anon_6294+0x20e>
;     if (bytes[2] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21eba: 03 4b 27 00  	lbu	s6, 2(a4)
   21ebe: 93 75 0b 0c  	andi	a1, s6, 192
   21ec2: 63 9e a5 07  	bne	a1, s10, 0x21f3e <fmt.formatBuf__anon_6294+0x20e>
;     if (bytes[3] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21ec6: 83 45 37 00  	lbu	a1, 3(a4)
   21eca: 93 f5 05 0c  	andi	a1, a1, 192
   21ece: 63 98 a5 07  	bne	a1, s10, 0x21f3e <fmt.formatBuf__anon_6294+0x20e>
   21ed2: 93 75 f6 0f  	andi	a1, a2, 255
;     value <<= 6;
   21ed6: b2 05        	slli	a1, a1, 12
;     value |= bytes[1] & 0b00111111;
   21ed8: 13 f6 f4 03  	andi	a2, s1, 63
;     value <<= 6;
   21edc: 1a 06        	slli	a2, a2, 6
   21ede: d1 8d        	or	a1, a1, a2
;     value |= bytes[2] & 0b00111111;
   21ee0: 13 76 fb 03  	andi	a2, s6, 63
   21ee4: d1 8d        	or	a1, a1, a2
;     value <<= 6;
   21ee6: 9b 95 65 00  	slliw	a1, a1, 6
;     value |= bytes[3] & 0b00111111;
   21eea: 37 06 0f 00  	lui	a2, 240
   21eee: b1 9d        	addw	a1, a1, a2
   21ef0: ae 15        	slli	a1, a1, 43
   21ef2: ad 95        	srai	a1, a1, 43
   21ef4: e3 cf 05 ea  	bltz	a1, 0x21db2 <fmt.formatBuf__anon_6294+0x82>
   21ef8: 99 a0        	j	0x21f3e <fmt.formatBuf__anon_6294+0x20e>
;     assert(bytes[0] & 0b11110000 == 0b11100000);
   21efa: 93 75 06 ff  	andi	a1, a2, -16
;     if (!ok) unreachable; // assertion failure
   21efe: 63 9e 65 2c  	bne	a1, t1, 0x221da <fmt.formatBuf__anon_6294+0x4aa>
;     if (bytes[1] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21f02: 83 44 17 00  	lbu	s1, 1(a4)
   21f06: 93 f5 04 0c  	andi	a1, s1, 192
   21f0a: 63 9a a5 03  	bne	a1, s10, 0x21f3e <fmt.formatBuf__anon_6294+0x20e>
;     if (bytes[2] & 0b11000000 != 0b10000000) return error.Utf8ExpectedContinuation;
   21f0e: 83 45 27 00  	lbu	a1, 2(a4)
   21f12: 93 f5 05 0c  	andi	a1, a1, 192
   21f16: 63 94 a5 03  	bne	a1, s10, 0x21f3e <fmt.formatBuf__anon_6294+0x20e>
   21f1a: 93 75 f6 00  	andi	a1, a2, 15
;     value |= bytes[1] & 0b00111111;
   21f1e: 13 f6 04 02  	andi	a2, s1, 32
;     value <<= 6;
   21f22: b2 05        	slli	a1, a1, 12
   21f24: 1a 06        	slli	a2, a2, 6
   21f26: d1 8d        	or	a1, a1, a2
;     if (value < 0x800) return error.Utf8OverlongEncoding;
   21f28: 13 d6 b5 00  	srli	a2, a1, 11
   21f2c: 13 36 16 00  	seqz	a2, a2
   21f30: b3 c5 c5 01  	xor	a1, a1, t3
   21f34: 93 b5 15 00  	seqz	a1, a1
   21f38: d1 8d        	or	a1, a1, a2
   21f3a: e3 8c 05 e6  	beqz	a1, 0x21db2 <fmt.formatBuf__anon_6294+0x82>
   21f3e: 4e 85        	mv	a0, s3
   21f40: 97 20 00 00  	auipc	ra, 2
   21f44: e7 80 80 cb  	jalr	-840(ra)
   21f48: 4e 85        	mv	a0, s3
   21f4a: 97 20 00 00  	auipc	ra, 2
   21f4e: e7 80 e0 ca  	jalr	-850(ra)
   21f52: 4e 85        	mv	a0, s3
   21f54: 97 20 00 00  	auipc	ra, 2
   21f58: e7 80 40 ca  	jalr	-860(ra)
;         const width = unicode.utf8CountCodepoints(buf) catch buf.len;
   21f5c: 02 65        	ld	a0, 0(sp)
   21f5e: 23 b0 a9 00  	sd	a0, 0(s3)
   21f62: de 86        	mv	a3, s7
   21f64: 39 a0        	j	0x21f72 <fmt.formatBuf__anon_6294+0x242>
;         try writer.writeAll(buf);
   21f66: 03 25 09 00  	lw	a0, 0(s2)
   21f6a: 2a d4        	sw	a0, 40(sp)
   21f6c: 2c 10        	addi	a1, sp, 40
   21f6e: 59 a0        	j	0x21ff4 <fmt.formatBuf__anon_6294+0x2c4>
   21f70: 81 46        	li	a3, 0
;         const padding = if (width < min_width) min_width - width else 0;
   21f72: 33 05 dc 40  	sub	a0, s8, a3
   21f76: 81 44        	li	s1, 0
   21f78: 63 63 ac 00  	bltu	s8, a0, 0x21f7e <fmt.formatBuf__anon_6294+0x24e>
   21f7c: aa 84        	mv	s1, a0
;         if (padding == 0)
   21f7e: 63 f7 86 07  	bgeu	a3, s8, 0x21fec <fmt.formatBuf__anon_6294+0x2bc>
;         switch (options.alignment) {
   21f82: 03 45 0a 02  	lbu	a0, 32(s4)
   21f86: 45 c5        	beqz	a0, 0x2202e <fmt.formatBuf__anon_6294+0x2fe>
   21f88: 85 45        	li	a1, 1
;         switch (options.alignment) {
   21f8a: 63 09 b5 10  	beq	a0, a1, 0x2209c <fmt.formatBuf__anon_6294+0x36c>
   21f8e: 89 45        	li	a1, 2
;         switch (options.alignment) {
   21f90: 63 1f b5 24  	bne	a0, a1, 0x221ee <fmt.formatBuf__anon_6294+0x4be>
;                 try writer.writeByteNTimes(options.fill, padding);
   21f94: 03 2b 09 00  	lw	s6, 0(s2)
;         d.* = value;
   21f98: 83 05 1a 02  	lb	a1, 33(s4)
   21f9c: 08 18        	addi	a0, sp, 48
   21f9e: 13 06 00 10  	li	a2, 256
   21fa2: 13 0c 00 10  	li	s8, 256
   21fa6: 97 20 00 00  	auipc	ra, 2
   21faa: e7 80 40 2f  	jalr	756(ra)
   21fae: 26 8a        	mv	s4, s1
   21fb0: 63 e4 84 01  	bltu	s1, s8, 0x21fb8 <fmt.formatBuf__anon_6294+0x288>
   21fb4: 13 0a 00 10  	li	s4, 256
;                 try self.writeAll(bytes[0..to_write]);
   21fb8: 23 28 61 13  	sw	s6, 304(sp)
   21fbc: 0c 1a        	addi	a1, sp, 304
   21fbe: 10 18        	addi	a2, sp, 48
   21fc0: 4e 85        	mv	a0, s3
   21fc2: d2 86        	mv	a3, s4
   21fc4: 97 10 ff ff  	auipc	ra, 1048561
   21fc8: e7 80 40 02  	jalr	36(ra)
   21fcc: 2a 84        	mv	s0, a0
   21fce: 42 15        	slli	a0, a0, 48
   21fd0: 41 91        	srli	a0, a0, 48
   21fd2: 63 11 05 1a  	bnez	a0, 0x22174 <fmt.formatBuf__anon_6294+0x444>
;                 remaining -= to_write;
   21fd6: 33 85 44 41  	sub	a0, s1, s4
   21fda: 63 e8 a4 1a  	bltu	s1, a0, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
   21fde: aa 84        	mv	s1, a0
;             while (remaining > 0) {
   21fe0: 79 f5        	bnez	a0, 0x21fae <fmt.formatBuf__anon_6294+0x27e>
;                 try writer.writeAll(buf);
   21fe2: 03 25 09 00  	lw	a0, 0(s2)
   21fe6: 2a d0        	sw	a0, 32(sp)
   21fe8: 0c 10        	addi	a1, sp, 32
   21fea: 29 a0        	j	0x21ff4 <fmt.formatBuf__anon_6294+0x2c4>
;             return writer.writeAll(buf);
   21fec: 03 25 09 00  	lw	a0, 0(s2)
   21ff0: 2a c4        	sw	a0, 8(sp)
   21ff2: 2c 00        	addi	a1, sp, 8
   21ff4: 4e 85        	mv	a0, s3
   21ff6: 56 86        	mv	a2, s5
   21ff8: de 86        	mv	a3, s7
   21ffa: 97 10 ff ff  	auipc	ra, 1048561
   21ffe: e7 80 e0 fe  	jalr	-18(ra)
   22002: 93 15 05 03  	slli	a1, a0, 48
   22006: c1 91        	srli	a1, a1, 48
   22008: 01 44        	li	s0, 0
   2200a: 63 93 05 16  	bnez	a1, 0x22170 <fmt.formatBuf__anon_6294+0x440>
   2200e: 22 85        	mv	a0, s0
   22010: fa 60        	ld	ra, 408(sp)
   22012: 5a 64        	ld	s0, 400(sp)
   22014: ba 64        	ld	s1, 392(sp)
   22016: 1a 69        	ld	s2, 384(sp)
   22018: f6 79        	ld	s3, 376(sp)
   2201a: 56 7a        	ld	s4, 368(sp)
   2201c: b6 7a        	ld	s5, 360(sp)
   2201e: 16 7b        	ld	s6, 352(sp)
   22020: f6 6b        	ld	s7, 344(sp)
   22022: 56 6c        	ld	s8, 336(sp)
   22024: b6 6c        	ld	s9, 328(sp)
   22026: 16 6d        	ld	s10, 320(sp)
   22028: f2 7d        	ld	s11, 312(sp)
   2202a: 1d 61        	addi	sp, sp, 416
   2202c: 82 80        	ret
;                 try writer.writeAll(buf);
   2202e: 03 25 09 00  	lw	a0, 0(s2)
   22032: 2a c8        	sw	a0, 16(sp)
   22034: 0c 08        	addi	a1, sp, 16
   22036: 4e 85        	mv	a0, s3
   22038: 56 86        	mv	a2, s5
   2203a: de 86        	mv	a3, s7
   2203c: 97 10 ff ff  	auipc	ra, 1048561
   22040: e7 80 c0 fa  	jalr	-84(ra)
   22044: 2a 84        	mv	s0, a0
   22046: 42 15        	slli	a0, a0, 48
   22048: 41 91        	srli	a0, a0, 48
   2204a: 63 1a 05 12  	bnez	a0, 0x2217e <fmt.formatBuf__anon_6294+0x44e>
;                 try writer.writeByteNTimes(options.fill, padding);
   2204e: 83 2a 09 00  	lw	s5, 0(s2)
;         d.* = value;
   22052: 83 05 1a 02  	lb	a1, 33(s4)
   22056: 08 18        	addi	a0, sp, 48
   22058: 13 06 00 10  	li	a2, 256
   2205c: 13 0a 00 10  	li	s4, 256
   22060: 97 20 00 00  	auipc	ra, 2
   22064: e7 80 a0 23  	jalr	570(ra)
   22068: 26 89        	mv	s2, s1
   2206a: 63 e4 44 01  	bltu	s1, s4, 0x22072 <fmt.formatBuf__anon_6294+0x342>
   2206e: 13 09 00 10  	li	s2, 256
;                 try self.writeAll(bytes[0..to_write]);
   22072: 23 28 51 13  	sw	s5, 304(sp)
   22076: 0c 1a        	addi	a1, sp, 304
   22078: 10 18        	addi	a2, sp, 48
   2207a: 4e 85        	mv	a0, s3
   2207c: ca 86        	mv	a3, s2
   2207e: 97 10 ff ff  	auipc	ra, 1048561
   22082: e7 80 a0 f6  	jalr	-150(ra)
   22086: 2a 84        	mv	s0, a0
   22088: 42 15        	slli	a0, a0, 48
   2208a: 41 91        	srli	a0, a0, 48
   2208c: 65 e5        	bnez	a0, 0x22174 <fmt.formatBuf__anon_6294+0x444>
;                 remaining -= to_write;
   2208e: 33 85 24 41  	sub	a0, s1, s2
   22092: 63 ec a4 0e  	bltu	s1, a0, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
   22096: aa 84        	mv	s1, a0
;             while (remaining > 0) {
   22098: 61 f9        	bnez	a0, 0x22068 <fmt.formatBuf__anon_6294+0x338>
   2209a: c9 a8        	j	0x2216c <fmt.formatBuf__anon_6294+0x43c>
;                 const right_padding = (padding + 1) / 2;
   2209c: 13 8c 14 00  	addi	s8, s1, 1
   220a0: 63 05 0c 0e  	beqz	s8, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
;                 try writer.writeByteNTimes(options.fill, left_padding);
   220a4: 83 2c 09 00  	lw	s9, 0(s2)
;         d.* = value;
   220a8: 83 05 1a 02  	lb	a1, 33(s4)
   220ac: 08 18        	addi	a0, sp, 48
   220ae: 13 06 00 10  	li	a2, 256
   220b2: 97 20 00 00  	auipc	ra, 2
   220b6: e7 80 80 1e  	jalr	488(ra)
   220ba: 09 45        	li	a0, 2
;             while (remaining > 0) {
   220bc: 63 e0 a4 04  	bltu	s1, a0, 0x220fc <fmt.formatBuf__anon_6294+0x3cc>
;                 const left_padding = padding / 2;
   220c0: 85 80        	srli	s1, s1, 1
   220c2: 13 05 00 10  	li	a0, 256
   220c6: 26 8b        	mv	s6, s1
   220c8: 63 e4 a4 00  	bltu	s1, a0, 0x220d0 <fmt.formatBuf__anon_6294+0x3a0>
   220cc: 13 0b 00 10  	li	s6, 256
;                 try self.writeAll(bytes[0..to_write]);
   220d0: 23 28 91 13  	sw	s9, 304(sp)
   220d4: 0c 1a        	addi	a1, sp, 304
   220d6: 10 18        	addi	a2, sp, 48
   220d8: 4e 85        	mv	a0, s3
   220da: da 86        	mv	a3, s6
   220dc: 97 10 ff ff  	auipc	ra, 1048561
   220e0: e7 80 c0 f0  	jalr	-244(ra)
   220e4: 2a 84        	mv	s0, a0
   220e6: 42 15        	slli	a0, a0, 48
   220e8: 41 91        	srli	a0, a0, 48
   220ea: 49 e5        	bnez	a0, 0x22174 <fmt.formatBuf__anon_6294+0x444>
;                 remaining -= to_write;
   220ec: 33 85 64 41  	sub	a0, s1, s6
   220f0: 63 ed a4 08  	bltu	s1, a0, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
   220f4: aa 84        	mv	s1, a0
;             while (remaining > 0) {
   220f6: 71 f5        	bnez	a0, 0x220c2 <fmt.formatBuf__anon_6294+0x392>
;                 try writer.writeAll(buf);
   220f8: 83 2c 09 00  	lw	s9, 0(s2)
   220fc: 66 cc        	sw	s9, 24(sp)
   220fe: 2c 08        	addi	a1, sp, 24
   22100: 4e 85        	mv	a0, s3
   22102: 56 86        	mv	a2, s5
   22104: de 86        	mv	a3, s7
   22106: 97 10 ff ff  	auipc	ra, 1048561
   2210a: e7 80 20 ee  	jalr	-286(ra)
   2210e: 2a 84        	mv	s0, a0
   22110: 42 15        	slli	a0, a0, 48
   22112: 41 91        	srli	a0, a0, 48
   22114: 2d e5        	bnez	a0, 0x2217e <fmt.formatBuf__anon_6294+0x44e>
;                 try writer.writeByteNTimes(options.fill, right_padding);
   22116: 03 29 09 00  	lw	s2, 0(s2)
;         d.* = value;
   2211a: 83 05 1a 02  	lb	a1, 33(s4)
   2211e: 08 18        	addi	a0, sp, 48
   22120: 13 06 00 10  	li	a2, 256
   22124: 97 20 00 00  	auipc	ra, 2
   22128: e7 80 60 17  	jalr	374(ra)
   2212c: 09 45        	li	a0, 2
;             while (remaining > 0) {
   2212e: 63 6f ac 02  	bltu	s8, a0, 0x2216c <fmt.formatBuf__anon_6294+0x43c>
   22132: 93 54 1c 00  	srli	s1, s8, 1
   22136: 13 05 00 10  	li	a0, 256
   2213a: 26 8a        	mv	s4, s1
   2213c: 63 e4 a4 00  	bltu	s1, a0, 0x22144 <fmt.formatBuf__anon_6294+0x414>
   22140: 13 0a 00 10  	li	s4, 256
;                 try self.writeAll(bytes[0..to_write]);
   22144: 23 28 21 13  	sw	s2, 304(sp)
   22148: 0c 1a        	addi	a1, sp, 304
   2214a: 10 18        	addi	a2, sp, 48
   2214c: 4e 85        	mv	a0, s3
   2214e: d2 86        	mv	a3, s4
   22150: 97 10 ff ff  	auipc	ra, 1048561
   22154: e7 80 80 e9  	jalr	-360(ra)
   22158: 2a 84        	mv	s0, a0
   2215a: 42 15        	slli	a0, a0, 48
   2215c: 41 91        	srli	a0, a0, 48
   2215e: 19 e9        	bnez	a0, 0x22174 <fmt.formatBuf__anon_6294+0x444>
;                 remaining -= to_write;
   22160: 33 85 44 41  	sub	a0, s1, s4
   22164: 63 e3 a4 02  	bltu	s1, a0, 0x2218a <fmt.formatBuf__anon_6294+0x45a>
   22168: aa 84        	mv	s1, a0
;             while (remaining > 0) {
   2216a: 71 f5        	bnez	a0, 0x22136 <fmt.formatBuf__anon_6294+0x406>
   2216c: 01 44        	li	s0, 0
   2216e: 45 b5        	j	0x2200e <fmt.formatBuf__anon_6294+0x2de>
   22170: 2a 84        	mv	s0, a0
   22172: 31 a0        	j	0x2217e <fmt.formatBuf__anon_6294+0x44e>
   22174: 4e 85        	mv	a0, s3
   22176: 97 20 00 00  	auipc	ra, 2
   2217a: e7 80 20 a8  	jalr	-1406(ra)
   2217e: 4e 85        	mv	a0, s3
   22180: 97 20 00 00  	auipc	ra, 2
   22184: e7 80 80 a7  	jalr	-1416(ra)
   22188: 59 b5        	j	0x2200e <fmt.formatBuf__anon_6294+0x2de>
   2218a: 37 15 01 00  	lui	a0, 17
   2218e: 13 05 95 5d  	addi	a0, a0, 1497
   22192: c1 45        	li	a1, 16
   22194: 81 46        	li	a3, 0
   22196: 97 10 00 00  	auipc	ra, 1
   2219a: e7 80 40 1e  	jalr	484(ra)
;             const v = mem.readIntNative(usize, s[i..][0..N]);
   2219e: 37 15 01 00  	lui	a0, 17
   221a2: 13 05 45 5b  	addi	a0, a0, 1460
   221a6: 93 05 40 02  	li	a1, 36
   221aa: 81 46        	li	a3, 0
   221ac: 97 10 00 00  	auipc	ra, 1
   221b0: e7 80 e0 1c  	jalr	462(ra)
   221b4: 37 15 01 00  	lui	a0, 17
   221b8: 13 05 35 6e  	addi	a0, a0, 1763
   221bc: cd 45        	li	a1, 19
   221be: 81 46        	li	a3, 0
   221c0: 97 10 00 00  	auipc	ra, 1
   221c4: e7 80 a0 1b  	jalr	442(ra)
;             len += 1;
   221c8: 37 15 01 00  	lui	a0, 17
   221cc: 13 05 95 5d  	addi	a0, a0, 1497
   221d0: c1 45        	li	a1, 16
   221d2: 97 10 00 00  	auipc	ra, 1
   221d6: e7 80 80 1a  	jalr	424(ra)
   221da: 37 25 01 00  	lui	a0, 18
   221de: 13 05 b5 a7  	addi	a0, a0, -1413
   221e2: e1 45        	li	a1, 24
   221e4: 81 46        	li	a3, 0
   221e6: 97 10 00 00  	auipc	ra, 1
   221ea: e7 80 40 19  	jalr	404(ra)
;         switch (options.alignment) {
   221ee: 37 25 01 00  	lui	a0, 18
   221f2: 13 05 a5 99  	addi	a0, a0, -1638
   221f6: dd 45        	li	a1, 23
   221f8: 81 46        	li	a3, 0
   221fa: 97 10 00 00  	auipc	ra, 1
   221fe: e7 80 00 18  	jalr	384(ra)

0000000000022202 <debug.StackIterator.next_internal>:
;     fn next_internal(self: *StackIterator) ?usize {
   22202: 13 01 01 dc  	addi	sp, sp, -576
   22206: 23 3c 11 22  	sd	ra, 568(sp)
   2220a: 23 38 81 22  	sd	s0, 560(sp)
   2220e: ae 86        	mv	a3, a1
   22210: 8a 85        	mv	a1, sp
   22212: 2e e6        	sd	a1, 264(sp)
   22214: 93 05 00 02  	li	a1, 32
   22218: 2e ea        	sd	a1, 272(sp)
   2221a: 02 e2        	sd	zero, 256(sp)
;             math.sub(usize, self.fp, fp_offset) catch return null;
   2221c: 8c 6a        	ld	a1, 16(a3)
;     const ov = @subWithOverflow(a, b);
   2221e: 13 87 05 ff  	addi	a4, a1, -16
   22222: 2a 84        	mv	s0, a0
;     if (ov[1] != 0) return error.Overflow;
   22224: 63 e6 e5 06  	bltu	a1, a4, 0x22290 <debug.StackIterator.next_internal+0x8e>
;         if (fp == 0 or !mem.isAligned(fp, @alignOf(usize)) or !isValidMemory(fp))
   22228: 33 35 e0 00  	snez	a0, a4
   2222c: 93 75 87 ff  	andi	a1, a4, -8
   22230: b9 8d        	xor	a1, a1, a4
   22232: 93 b5 15 00  	seqz	a1, a1
   22236: 6d 8d        	and	a0, a0, a1
   22238: 3d cd        	beqz	a0, 0x222b6 <debug.StackIterator.next_internal+0xb4>
   2223a: 28 0a        	addi	a0, sp, 280
   2223c: 23 30 a1 22  	sd	a0, 544(sp)
   22240: 13 05 00 02  	li	a0, 32
   22244: 23 34 a1 22  	sd	a0, 552(sp)
   22248: fd 77        	lui	a5, 1048575
;         const aligned_address = address & ~@intCast(usize, (mem.page_size - 1));
   2224a: 33 75 f7 00  	and	a0, a4, a5
   2224e: 23 3c 01 20  	sd	zero, 536(sp)
;         const aligned_memory = @intToPtr([*]align(mem.page_size) u8, aligned_address)[0..mem.page_size];
   22252: 41 c9        	beqz	a0, 0x222e2 <debug.StackIterator.next_internal+0xe0>
;     return asm volatile ("ecall"
   22254: 93 08 30 0e  	li	a7, 227
   22258: 85 65        	lui	a1, 1
   2225a: 05 46        	li	a2, 1
   2225c: 85 27        	addiw	a5, a5, 1
   2225e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   22262: 63 7e f5 02  	bgeu	a0, a5, 0x2229e <debug.StackIterator.next_internal+0x9c>
;         const new_fp = math.add(usize, @intToPtr(*const usize, fp).*, fp_bias) catch return null;
   22266: 13 75 77 00  	andi	a0, a4, 7
   2226a: 51 e5        	bnez	a0, 0x222f6 <debug.StackIterator.next_internal+0xf4>
   2226c: 08 63        	ld	a0, 0(a4)
;         if (new_fp != 0 and new_fp < self.fp)
   2226e: 01 c5        	beqz	a0, 0x22276 <debug.StackIterator.next_internal+0x74>
   22270: 8c 6a        	ld	a1, 16(a3)
   22272: 63 62 b5 04  	bltu	a0, a1, 0x222b6 <debug.StackIterator.next_internal+0xb4>
;             math.add(usize, fp, pc_offset) catch return null,
   22276: 0c 67        	ld	a1, 8(a4)
;         self.fp = new_fp;
   22278: 88 ea        	sd	a0, 16(a3)
;         return new_pc;
   2227a: 0c e0        	sd	a1, 0(s0)
   2227c: 05 45        	li	a0, 1
   2227e: 23 04 a4 00  	sb	a0, 8(s0)
   22282: 83 30 81 23  	ld	ra, 568(sp)
   22286: 03 34 01 23  	ld	s0, 560(sp)
   2228a: 13 01 01 24  	addi	sp, sp, 576
   2228e: 82 80        	ret
;     if (ov[1] != 0) return error.Overflow;
   22290: 08 02        	addi	a0, sp, 256
   22292: 97 20 00 00  	auipc	ra, 2
   22296: e7 80 60 96  	jalr	-1690(ra)
;             math.sub(usize, self.fp, fp_offset) catch return null;
   2229a: 02 e2        	sd	zero, 256(sp)
   2229c: 29 a8        	j	0x222b6 <debug.StackIterator.next_internal+0xb4>
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2229e: 3b 05 a0 40  	negw	a0, a0
   222a2: 42 15        	slli	a0, a0, 48
   222a4: 41 91        	srli	a0, a0, 48
   222a6: b1 45        	li	a1, 12
;     switch (errno(system.msync(memory.ptr, memory.len, flags))) {
   222a8: 63 12 b5 02  	bne	a0, a1, 0x222cc <debug.StackIterator.next_internal+0xca>
;         .NOMEM => return error.UnmappedMemory, // Unsuccessful, provided pointer does not point mapped memory
   222ac: 28 0c        	addi	a0, sp, 536
   222ae: 97 20 00 00  	auipc	ra, 2
   222b2: e7 80 a0 94  	jalr	-1718(ra)
   222b6: 23 34 04 00  	sd	zero, 8(s0)
   222ba: 23 30 04 00  	sd	zero, 0(s0)
   222be: 83 30 81 23  	ld	ra, 568(sp)
   222c2: 03 34 01 23  	ld	s0, 560(sp)
   222c6: 13 01 01 24  	addi	sp, sp, 576
   222ca: 82 80        	ret
   222cc: d9 45        	li	a1, 22
   222ce: 37 25 01 00  	lui	a0, 18
   222d2: 13 05 b5 a7  	addi	a0, a0, -1413
   222d6: e1 45        	li	a1, 24
   222d8: 81 46        	li	a3, 0
   222da: 97 10 00 00  	auipc	ra, 1
   222de: e7 80 00 0a  	jalr	160(ra)
;         const aligned_memory = @intToPtr([*]align(mem.page_size) u8, aligned_address)[0..mem.page_size];
   222e2: 37 25 01 00  	lui	a0, 18
   222e6: 13 05 a5 86  	addi	a0, a0, -1942
   222ea: f9 45        	li	a1, 30
   222ec: 81 46        	li	a3, 0
   222ee: 97 10 00 00  	auipc	ra, 1
   222f2: e7 80 c0 08  	jalr	140(ra)
;         const new_fp = math.add(usize, @intToPtr(*const usize, fp).*, fp_bias) catch return null;
   222f6: 37 15 01 00  	lui	a0, 17
   222fa: 13 05 75 63  	addi	a0, a0, 1591
   222fe: cd 45        	li	a1, 19
   22300: 81 46        	li	a3, 0
   22302: 97 10 00 00  	auipc	ra, 1
   22306: e7 80 80 07  	jalr	120(ra)

000000000002230a <heap.PageAllocator.alloc>:
; fn alloc(_: *anyopaque, n: usize, log2_align: u8, ra: usize) ?[*]u8 {
   2230a: 4d 71        	addi	sp, sp, -336
   2230c: 86 e6        	sd	ra, 328(sp)
   2230e: a2 e2        	sd	s0, 320(sp)
   22310: 26 fe        	sd	s1, 312(sp)
   22312: 4a fa        	sd	s2, 304(sp)
   22314: 0a 85        	mv	a0, sp
   22316: 2a e6        	sd	a0, 264(sp)
   22318: 13 05 00 02  	li	a0, 32
   2231c: 2a ea        	sd	a0, 272(sp)
   2231e: 02 e2        	sd	zero, 256(sp)
;     if (!ok) unreachable; // assertion failure
   22320: bd cd        	beqz	a1, 0x2239e <heap.PageAllocator.alloc+0x94>
   22322: 7d 75        	lui	a0, 1048575
   22324: 1b 06 15 00  	addiw	a2, a0, 1
;     if (n > maxInt(usize) - (mem.page_size - 1)) return null;
   22328: 63 e4 c5 00  	bltu	a1, a2, 0x22330 <heap.PageAllocator.alloc+0x26>
   2232c: 01 45        	li	a0, 0
   2232e: 95 a0        	j	0x22392 <heap.PageAllocator.alloc+0x88>
   22330: 05 66        	lui	a2, 1
;     const hint = @atomicLoad(@TypeOf(std.heap.next_mmap_addr_hint), &std.heap.next_mmap_addr_hint, .Unordered);
   22332: b7 56 02 00  	lui	a3, 37
   22336: 03 b9 86 49  	ld	s2, 1176(a3)
   2233a: 1b 04 f6 ff  	addiw	s0, a2, -1
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   2233e: a2 95        	add	a1, a1, s0
;     return addr & ~(alignment - 1);
   22340: b3 f4 a5 00  	and	s1, a1, a0
;         os.MAP.PRIVATE | os.MAP.ANONYMOUS,
   22344: 28 0a        	addi	a0, sp, 280
   22346: 0c 02        	addi	a1, sp, 256
   22348: 0d 47        	li	a4, 3
   2234a: 93 07 20 02  	li	a5, 34
   2234e: 7d 58        	li	a6, -1
   22350: 4a 86        	mv	a2, s2
   22352: a6 86        	mv	a3, s1
   22354: 97 20 ff ff  	auipc	ra, 1048562
   22358: e7 80 e0 9a  	jalr	-1618(ra)
   2235c: 03 55 81 12  	lhu	a0, 296(sp)
   22360: 01 c5        	beqz	a0, 0x22368 <heap.PageAllocator.alloc+0x5e>
   22362: 01 45        	li	a0, 0
;     ) catch return null;
   22364: 02 e2        	sd	zero, 256(sp)
   22366: 35 a0        	j	0x22392 <heap.PageAllocator.alloc+0x88>
;         os.MAP.PRIVATE | os.MAP.ANONYMOUS,
   22368: 72 65        	ld	a0, 280(sp)
   2236a: fd 75        	lui	a1, 1048575
;     return addr & ~(alignment - 1);
   2236c: e9 8d        	and	a1, a1, a0
;     if (!ok) unreachable; // assertion failure
   2236e: 63 98 a5 02  	bne	a1, a0, 0x2239e <heap.PageAllocator.alloc+0x94>
;     const new_hint = @alignCast(mem.page_size, slice.ptr + aligned_len);
   22372: b3 05 95 00  	add	a1, a0, s1
   22376: 33 f6 85 00  	and	a2, a1, s0
   2237a: 05 ee        	bnez	a2, 0x223b2 <heap.PageAllocator.alloc+0xa8>
;     _ = @cmpxchgStrong(@TypeOf(std.heap.next_mmap_addr_hint), &std.heap.next_mmap_addr_hint, hint, new_hint, .Monotonic, .Monotonic);
   2237c: 37 56 02 00  	lui	a2, 37
   22380: 13 06 86 49  	addi	a2, a2, 1176
   22384: af 36 06 10  	lr.d	a3, (a2)
   22388: 63 95 26 01  	bne	a3, s2, 0x22392 <heap.PageAllocator.alloc+0x88>
   2238c: 2f 37 b6 18  	sc.d	a4, a1, (a2)
   22390: 75 fb        	bnez	a4, 0x22384 <heap.PageAllocator.alloc+0x7a>
   22392: b6 60        	ld	ra, 328(sp)
   22394: 16 64        	ld	s0, 320(sp)
   22396: f2 74        	ld	s1, 312(sp)
   22398: 52 79        	ld	s2, 304(sp)
   2239a: 71 61        	addi	sp, sp, 336
   2239c: 82 80        	ret
   2239e: 37 25 01 00  	lui	a0, 18
   223a2: 13 05 b5 a7  	addi	a0, a0, -1413
   223a6: e1 45        	li	a1, 24
   223a8: 81 46        	li	a3, 0
   223aa: 97 10 00 00  	auipc	ra, 1
   223ae: e7 80 00 fd  	jalr	-48(ra)
;     const new_hint = @alignCast(mem.page_size, slice.ptr + aligned_len);
   223b2: 37 15 01 00  	lui	a0, 17
   223b6: 13 05 75 63  	addi	a0, a0, 1591
   223ba: cd 45        	li	a1, 19
   223bc: 81 46        	li	a3, 0
   223be: 97 10 00 00  	auipc	ra, 1
   223c2: e7 80 c0 fb  	jalr	-68(ra)

00000000000223c6 <heap.PageAllocator.resize>:
; ) bool {
   223c6: 05 65        	lui	a0, 1
   223c8: 9b 06 f5 ff  	addiw	a3, a0, -1
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   223cc: 33 05 d7 00  	add	a0, a4, a3
   223d0: 63 6b e5 04  	bltu	a0, a4, 0x22426 <heap.PageAllocator.resize+0x60>
   223d4: 33 07 d6 00  	add	a4, a2, a3
   223d8: 63 67 c7 04  	bltu	a4, a2, 0x22426 <heap.PageAllocator.resize+0x60>
   223dc: 7d 76        	lui	a2, 1048575
   223de: b3 76 c5 00  	and	a3, a0, a2
;     return addr & ~(alignment - 1);
   223e2: 71 8f        	and	a4, a4, a2
   223e4: 05 46        	li	a2, 1
;     if (new_size_aligned == buf_aligned_len)
   223e6: 63 8e e6 02  	beq	a3, a4, 0x22422 <heap.PageAllocator.resize+0x5c>
;     if (new_size_aligned < buf_aligned_len) {
   223ea: 63 f5 e6 02  	bgeu	a3, a4, 0x22414 <heap.PageAllocator.resize+0x4e>
;         const ptr = @alignCast(mem.page_size, buf_unaligned.ptr + new_size_aligned);
   223ee: 33 85 d5 00  	add	a0, a1, a3
   223f2: 93 15 45 03  	slli	a1, a0, 52
   223f6: d1 91        	srli	a1, a1, 52
   223f8: b9 ed        	bnez	a1, 0x22456 <heap.PageAllocator.resize+0x90>
;         os.munmap(ptr[0 .. buf_aligned_len - new_size_aligned]);
   223fa: b3 05 d7 40  	sub	a1, a4, a3
   223fe: 63 64 b7 02  	bltu	a4, a1, 0x22426 <heap.PageAllocator.resize+0x60>
;     return asm volatile ("ecall"
   22402: 93 08 70 0d  	li	a7, 215
   22406: fd 76        	lui	a3, 1048575
   22408: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2240c: 63 e6 a6 00  	bltu	a3, a0, 0x22418 <heap.PageAllocator.resize+0x52>
   22410: 01 45        	li	a0, 0
   22412: 29 a0        	j	0x2241c <heap.PageAllocator.resize+0x56>
   22414: 01 46        	li	a2, 0
   22416: 31 a0        	j	0x22422 <heap.PageAllocator.resize+0x5c>
   22418: 33 05 a0 40  	neg	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2241c: 42 15        	slli	a0, a0, 48
   2241e: 41 91        	srli	a0, a0, 48
;     switch (errno(system.munmap(memory.ptr, memory.len))) {
   22420: 09 ed        	bnez	a0, 0x2243a <heap.PageAllocator.resize+0x74>
   22422: 32 85        	mv	a0, a2
   22424: 82 80        	ret
   22426: 37 15 01 00  	lui	a0, 17
   2242a: 13 05 95 5d  	addi	a0, a0, 1497
   2242e: c1 45        	li	a1, 16
   22430: 81 46        	li	a3, 0
   22432: 97 10 00 00  	auipc	ra, 1
   22436: e7 80 80 f4  	jalr	-184(ra)
   2243a: b1 45        	li	a1, 12
;     switch (errno(system.munmap(memory.ptr, memory.len))) {
   2243c: 63 03 b5 00  	beq	a0, a1, 0x22442 <heap.PageAllocator.resize+0x7c>
   22440: d9 45        	li	a1, 22
   22442: 37 25 01 00  	lui	a0, 18
   22446: 13 05 b5 a7  	addi	a0, a0, -1413
   2244a: e1 45        	li	a1, 24
   2244c: 81 46        	li	a3, 0
   2244e: 97 10 00 00  	auipc	ra, 1
   22452: e7 80 c0 f2  	jalr	-212(ra)
;         const ptr = @alignCast(mem.page_size, buf_unaligned.ptr + new_size_aligned);
   22456: 37 15 01 00  	lui	a0, 17
   2245a: 13 05 75 63  	addi	a0, a0, 1591
   2245e: cd 45        	li	a1, 19
   22460: 81 46        	li	a3, 0
   22462: 97 10 00 00  	auipc	ra, 1
   22466: e7 80 80 f1  	jalr	-232(ra)

000000000002246a <heap.PageAllocator.free>:
; fn free(_: *anyopaque, slice: []u8, log2_buf_align: u8, return_address: usize) void {
   2246a: 05 65        	lui	a0, 1
   2246c: 7d 35        	addiw	a0, a0, -1
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   2246e: 32 95        	add	a0, a0, a2
   22470: 63 67 c5 04  	bltu	a0, a2, 0x224be <heap.PageAllocator.free+0x54>
;         const ptr = @alignCast(mem.page_size, slice.ptr);
   22474: 13 96 45 03  	slli	a2, a1, 52
   22478: 51 92        	srli	a2, a2, 52
   2247a: 21 ee        	bnez	a2, 0x224d2 <heap.PageAllocator.free+0x68>
   2247c: fd 76        	lui	a3, 1048575
;     return addr & ~(alignment - 1);
   2247e: 33 76 d5 00  	and	a2, a0, a3
;     return asm volatile ("ecall"
   22482: 93 08 70 0d  	li	a7, 215
   22486: 2e 85        	mv	a0, a1
   22488: b2 85        	mv	a1, a2
   2248a: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2248e: 63 e4 a6 00  	bltu	a3, a0, 0x22496 <heap.PageAllocator.free+0x2c>
   22492: 01 45        	li	a0, 0
   22494: 19 a0        	j	0x2249a <heap.PageAllocator.free+0x30>
   22496: 33 05 a0 40  	neg	a0, a0
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2249a: 42 15        	slli	a0, a0, 48
   2249c: 41 91        	srli	a0, a0, 48
;     switch (errno(system.munmap(memory.ptr, memory.len))) {
   2249e: 11 e1        	bnez	a0, 0x224a2 <heap.PageAllocator.free+0x38>
;         os.munmap(ptr[0..buf_aligned_len]);
   224a0: 82 80        	ret
   224a2: b1 45        	li	a1, 12
;     switch (errno(system.munmap(memory.ptr, memory.len))) {
   224a4: 63 03 b5 00  	beq	a0, a1, 0x224aa <heap.PageAllocator.free+0x40>
   224a8: d9 45        	li	a1, 22
   224aa: 37 25 01 00  	lui	a0, 18
   224ae: 13 05 b5 a7  	addi	a0, a0, -1413
   224b2: e1 45        	li	a1, 24
   224b4: 81 46        	li	a3, 0
   224b6: 97 10 00 00  	auipc	ra, 1
   224ba: e7 80 40 ec  	jalr	-316(ra)
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   224be: 37 15 01 00  	lui	a0, 17
   224c2: 13 05 95 5d  	addi	a0, a0, 1497
   224c6: c1 45        	li	a1, 16
   224c8: 81 46        	li	a3, 0
   224ca: 97 10 00 00  	auipc	ra, 1
   224ce: e7 80 00 eb  	jalr	-336(ra)
;         const ptr = @alignCast(mem.page_size, slice.ptr);
   224d2: 37 15 01 00  	lui	a0, 17
   224d6: 13 05 75 63  	addi	a0, a0, 1591
   224da: cd 45        	li	a1, 19
   224dc: 81 46        	li	a3, 0
   224de: 97 10 00 00  	auipc	ra, 1
   224e2: e7 80 c0 e9  	jalr	-356(ra)

00000000000224e6 <os.getenv>:
;     for (environ) |ptr| {
   224e6: 37 56 02 00  	lui	a2, 37
   224ea: 83 38 06 45  	ld	a7, 1104(a2)
   224ee: 63 8a 08 0c  	beqz	a7, 0x225c2 <os.getenv+0xdc>
   224f2: 37 56 02 00  	lui	a2, 37
   224f6: 03 38 86 44  	ld	a6, 1096(a2)
;     for (a) |item, index| {
   224fa: c9 c9        	beqz	a1, 0x2258c <os.getenv+0xa6>
   224fc: 81 42        	li	t0, 0
   224fe: 93 03 d0 03  	li	t2, 61
   22502: 7d 53        	li	t1, -1
   22504: 21 a0        	j	0x2250c <os.getenv+0x26>
   22506: 85 02        	addi	t0, t0, 1
;     for (environ) |ptr| {
   22508: 63 8d 12 0b  	beq	t0, a7, 0x225c2 <os.getenv+0xdc>
   2250c: 13 96 32 00  	slli	a2, t0, 3
   22510: 42 96        	add	a2, a2, a6
   22512: 10 62        	ld	a2, 0(a2)
   22514: 01 47        	li	a4, 0
;         while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
   22516: b3 06 e6 00  	add	a3, a2, a4
   2251a: 83 c6 06 00  	lbu	a3, 0(a3)
   2251e: 63 8c 76 00  	beq	a3, t2, 0x22536 <os.getenv+0x50>
   22522: 91 ca        	beqz	a3, 0x22536 <os.getenv+0x50>
   22524: 63 0a 67 0a  	beq	a4, t1, 0x225d8 <os.getenv+0xf2>
   22528: 05 07        	addi	a4, a4, 1
   2252a: b3 06 e6 00  	add	a3, a2, a4
   2252e: 83 c6 06 00  	lbu	a3, 0(a3)
   22532: e3 98 76 fe  	bne	a3, t2, 0x22522 <os.getenv+0x3c>
;     if (a.len != b.len) return false;
   22536: e3 98 e5 fc  	bne	a1, a4, 0x22506 <os.getenv+0x20>
;     if (a.ptr == b.ptr) return true;
   2253a: 63 03 a6 02  	beq	a2, a0, 0x22560 <os.getenv+0x7a>
   2253e: 01 47        	li	a4, 0
   22540: 63 86 e5 0a  	beq	a1, a4, 0x225ec <os.getenv+0x106>
;     for (a) |item, index| {
   22544: b3 06 e5 00  	add	a3, a0, a4
   22548: 83 c6 06 00  	lbu	a3, 0(a3)
;         if (b[index] != item) return false;
   2254c: b3 07 e6 00  	add	a5, a2, a4
   22550: 83 c7 07 00  	lbu	a5, 0(a5)
   22554: e3 99 d7 fa  	bne	a5, a3, 0x22506 <os.getenv+0x20>
   22558: 05 07        	addi	a4, a4, 1
;     for (a) |item, index| {
   2255a: e3 93 e5 fe  	bne	a1, a4, 0x22540 <os.getenv+0x5a>
   2255e: 32 85        	mv	a0, a2
;         while (ptr[end_i] != 0) : (end_i += 1) {}
   22560: 33 06 b5 00  	add	a2, a0, a1
   22564: 83 46 06 00  	lbu	a3, 0(a2)
   22568: 2e 86        	mv	a2, a1
   2256a: 89 ca        	beqz	a3, 0x2257c <os.getenv+0x96>
   2256c: 2e 86        	mv	a2, a1
;         while (ptr[end_i] != 0) : (end_i += 1) {}
   2256e: 05 06        	addi	a2, a2, 1
   22570: 25 c6        	beqz	a2, 0x225d8 <os.getenv+0xf2>
   22572: b3 06 c5 00  	add	a3, a0, a2
   22576: 83 c6 06 00  	lbu	a3, 0(a3)
   2257a: f5 fa        	bnez	a3, 0x2256e <os.getenv+0x88>
;         const this_value = ptr[line_i + 1 .. end_i];
   2257c: 85 05        	addi	a1, a1, 1
   2257e: a9 cd        	beqz	a1, 0x225d8 <os.getenv+0xf2>
   22580: 63 60 b6 08  	bltu	a2, a1, 0x22600 <os.getenv+0x11a>
   22584: 2e 95        	add	a0, a0, a1
   22586: b3 05 b6 40  	sub	a1, a2, a1
   2258a: 82 80        	ret
   2258c: 13 06 d0 03  	li	a2, 61
   22590: fd 56        	li	a3, -1
;     for (environ) |ptr| {
   22592: 13 95 35 00  	slli	a0, a1, 3
   22596: 42 95        	add	a0, a0, a6
   22598: 08 61        	ld	a0, 0(a0)
   2259a: 01 47        	li	a4, 0
;         while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
   2259c: b3 07 e5 00  	add	a5, a0, a4
   225a0: 83 c7 07 00  	lbu	a5, 0(a5)
   225a4: 99 cb        	beqz	a5, 0x225ba <os.getenv+0xd4>
   225a6: 63 8a c7 00  	beq	a5, a2, 0x225ba <os.getenv+0xd4>
   225aa: 63 07 d7 02  	beq	a4, a3, 0x225d8 <os.getenv+0xf2>
   225ae: 05 07        	addi	a4, a4, 1
   225b0: b3 07 e5 00  	add	a5, a0, a4
   225b4: 83 c7 07 00  	lbu	a5, 0(a5)
   225b8: fd f7        	bnez	a5, 0x225a6 <os.getenv+0xc0>
;     if (a.len != b.len) return false;
   225ba: 19 c7        	beqz	a4, 0x225c8 <os.getenv+0xe2>
   225bc: 85 05        	addi	a1, a1, 1
;     for (environ) |ptr| {
   225be: e3 9a 15 fd  	bne	a1, a7, 0x22592 <os.getenv+0xac>
   225c2: 01 45        	li	a0, 0
   225c4: 81 45        	li	a1, 0
   225c6: 82 80        	ret
   225c8: 81 45        	li	a1, 0
;         while (ptr[end_i] != 0) : (end_i += 1) {}
   225ca: 33 06 b5 00  	add	a2, a0, a1
   225ce: 83 46 06 00  	lbu	a3, 0(a2)
   225d2: 2e 86        	mv	a2, a1
   225d4: c1 fe        	bnez	a3, 0x2256c <os.getenv+0x86>
   225d6: 5d b7        	j	0x2257c <os.getenv+0x96>
   225d8: 37 15 01 00  	lui	a0, 17
   225dc: 13 05 95 5d  	addi	a0, a0, 1497
   225e0: c1 45        	li	a1, 16
   225e2: 81 46        	li	a3, 0
   225e4: 97 10 00 00  	auipc	ra, 1
   225e8: e7 80 60 d9  	jalr	-618(ra)
;         if (b[index] != item) return false;
   225ec: 37 15 01 00  	lui	a0, 17
   225f0: 13 05 35 6e  	addi	a0, a0, 1763
   225f4: cd 45        	li	a1, 19
   225f6: 81 46        	li	a3, 0
   225f8: 97 10 00 00  	auipc	ra, 1
   225fc: e7 80 20 d8  	jalr	-638(ra)
;         const this_value = ptr[line_i + 1 .. end_i];
   22600: 37 15 01 00  	lui	a0, 17
   22604: 13 05 45 5b  	addi	a0, a0, 1460
   22608: 93 05 40 02  	li	a1, 36
   2260c: 81 46        	li	a3, 0
   2260e: 97 10 00 00  	auipc	ra, 1
   22612: e7 80 c0 d6  	jalr	-660(ra)

0000000000022616 <heap.arena_allocator.ArenaAllocator.alloc>:
;     fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 {
   22616: 19 71        	addi	sp, sp, -128
   22618: 86 fc        	sd	ra, 120(sp)
   2261a: a2 f8        	sd	s0, 112(sp)
   2261c: a6 f4        	sd	s1, 104(sp)
   2261e: ca f0        	sd	s2, 96(sp)
   22620: ce ec        	sd	s3, 88(sp)
   22622: d2 e8        	sd	s4, 80(sp)
   22624: d6 e4        	sd	s5, 72(sp)
   22626: da e0        	sd	s6, 64(sp)
   22628: 5e fc        	sd	s7, 56(sp)
   2262a: 62 f8        	sd	s8, 48(sp)
   2262c: 66 f4        	sd	s9, 40(sp)
   2262e: 6a f0        	sd	s10, 32(sp)
   22630: 6e ec        	sd	s11, 24(sp)
   22632: aa 8a        	mv	s5, a0
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   22634: 1d 89        	andi	a0, a0, 7
   22636: 63 1f 05 16  	bnez	a0, 0x227b4 <heap.arena_allocator.ArenaAllocator.alloc+0x19e>
   2263a: 2e 8a        	mv	s4, a1
;         const ptr_align = @as(usize, 1) << @intCast(Allocator.Log2Align, log2_ptr_align);
   2263c: 13 75 f6 0f  	andi	a0, a2, 255
   22640: 93 05 00 04  	li	a1, 64
   22644: 63 72 b5 18  	bgeu	a0, a1, 0x227c8 <heap.arena_allocator.ArenaAllocator.alloc+0x1b2>
   22648: 06 89        	mv	s2, ra
;         var cur_node = if (self.state.buffer_list.first) |first_node|
   2264a: 03 bb 0a 01  	ld	s6, 16(s5)
   2264e: 05 45        	li	a0, 1
;         const ptr_align = @as(usize, 1) << @intCast(Allocator.Log2Align, log2_ptr_align);
   22650: 33 14 c5 00  	sll	s0, a0, a2
   22654: b3 09 8a 00  	add	s3, s4, s0
;         var cur_node = if (self.state.buffer_list.first) |first_node|
   22658: 63 1d 0b 00  	bnez	s6, 0x22672 <heap.arena_allocator.ArenaAllocator.alloc+0x5c>
;             (self.createNode(0, n + ptr_align) orelse return null);
   2265c: 63 e5 49 19  	bltu	s3, s4, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
   22660: 56 85        	mv	a0, s5
   22662: 81 45        	li	a1, 0
   22664: 4e 86        	mv	a2, s3
   22666: 97 00 00 00  	auipc	ra, 0
   2266a: e7 80 80 1a  	jalr	424(ra)
   2266e: 2a 8b        	mv	s6, a0
   22670: 75 cd        	beqz	a0, 0x2276c <heap.arena_allocator.ArenaAllocator.alloc+0x156>
;             const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   22672: 03 3c 0b 01  	ld	s8, 16(s6)
   22676: 61 45        	li	a0, 24
   22678: 63 69 ac 10  	bltu	s8, a0, 0x2278a <heap.arena_allocator.ArenaAllocator.alloc+0x174>
   2267c: 83 3b 8b 00  	ld	s7, 8(s6)
   22680: 93 0c f4 ff  	addi	s9, s0, -1
   22684: 33 75 94 01  	and	a0, s0, s9
   22688: 33 35 a0 00  	snez	a0, a0
   2268c: 93 35 14 00  	seqz	a1, s0
   22690: c9 8d        	or	a1, a1, a0
   22692: 13 85 8b 01  	addi	a0, s7, 24
;     return alignment > 0 and std.math.isPowerOfTwo(alignment);
   22696: 63 93 05 14  	bnez	a1, 0x227dc <heap.arena_allocator.ArenaAllocator.alloc+0x1c6>
   2269a: 93 0d 0b 01  	addi	s11, s6, 16
   2269e: 33 0d 80 40  	neg	s10, s0
   226a2: b3 b5 49 01  	sltu	a1, s3, s4
   226a6: 2e e4        	sd	a1, 8(sp)
   226a8: 31 a8        	j	0x226c4 <heap.arena_allocator.ArenaAllocator.alloc+0xae>
;                 cur_node.data.len = bigger_buf_size;
   226aa: 23 b0 9d 00  	sd	s1, 0(s11)
;             const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   226ae: 83 3b 8b 00  	ld	s7, 8(s6)
   226b2: 03 3c 0b 01  	ld	s8, 16(s6)
   226b6: 93 0d 0b 01  	addi	s11, s6, 16
   226ba: 13 85 8b 01  	addi	a0, s7, 24
   226be: dd 45        	li	a1, 23
   226c0: 63 f5 85 0d  	bgeu	a1, s8, 0x2278a <heap.arena_allocator.ArenaAllocator.alloc+0x174>
;             const addr = @ptrToInt(cur_buf.ptr) + self.state.end_index;
   226c4: 83 b5 8a 01  	ld	a1, 24(s5)
   226c8: 33 06 b5 00  	add	a2, a0, a1
   226cc: 63 6d a6 10  	bltu	a2, a0, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   226d0: b3 06 96 01  	add	a3, a2, s9
   226d4: 63 e9 c6 10  	bltu	a3, a2, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
;     return addr & ~(alignment - 1);
   226d8: b3 f6 a6 01  	and	a3, a3, s10
;             const adjusted_index = self.state.end_index + (adjusted_addr - addr);
   226dc: 33 86 c6 40  	sub	a2, a3, a2
   226e0: 63 e3 c6 10  	bltu	a3, a2, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
   226e4: 2e 96        	add	a2, a2, a1
   226e6: 63 60 b6 10  	bltu	a2, a1, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
;             const new_end_index = adjusted_index + n;
   226ea: b3 05 46 01  	add	a1, a2, s4
   226ee: 63 ec c5 0e  	bltu	a1, a2, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
   226f2: 13 04 8c fe  	addi	s0, s8, -24
;             if (new_end_index <= cur_buf.len) {
   226f6: 63 78 b4 06  	bgeu	s0, a1, 0x22766 <heap.arena_allocator.ArenaAllocator.alloc+0x150>
;             const bigger_buf_size = @sizeOf(BufNode) + new_end_index;
   226fa: 93 84 85 01  	addi	s1, a1, 24
   226fe: 63 e4 b4 0e  	bltu	s1, a1, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
;     if (new_n == 0) {
   22702: 9d c8        	beqz	s1, 0x22738 <heap.arena_allocator.ArenaAllocator.alloc+0x122>
;     return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());
   22704: 83 b5 8a 00  	ld	a1, 8(s5)
   22708: 03 b5 0a 00  	ld	a0, 0(s5)
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   2270c: 03 b8 85 00  	ld	a6, 8(a1)
   22710: de 85        	mv	a1, s7
   22712: 62 86        	mv	a2, s8
   22714: 81 46        	li	a3, 0
   22716: 26 87        	mv	a4, s1
   22718: ca 87        	mv	a5, s2
   2271a: 02 98        	jalr	a6
   2271c: 05 89        	andi	a0, a0, 1
;             if (self.child_allocator.resize(cur_node.data, bigger_buf_size)) {
   2271e: 51 f5        	bnez	a0, 0x226aa <heap.arena_allocator.ArenaAllocator.alloc+0x94>
;                 cur_node = self.createNode(cur_buf.len, n + ptr_align) orelse return null;
   22720: 22 65        	ld	a0, 8(sp)
   22722: 71 e1        	bnez	a0, 0x227e6 <heap.arena_allocator.ArenaAllocator.alloc+0x1d0>
   22724: 56 85        	mv	a0, s5
   22726: a2 85        	mv	a1, s0
   22728: 4e 86        	mv	a2, s3
   2272a: 97 00 00 00  	auipc	ra, 0
   2272e: e7 80 40 0e  	jalr	228(ra)
   22732: 2a 8b        	mv	s6, a0
   22734: 2d fd        	bnez	a0, 0x226ae <heap.arena_allocator.ArenaAllocator.alloc+0x98>
   22736: 1d a8        	j	0x2276c <heap.arena_allocator.ArenaAllocator.alloc+0x156>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   22738: 63 84 0b 06  	beqz	s7, 0x227a0 <heap.arena_allocator.ArenaAllocator.alloc+0x18a>
;         self.free(old_mem);
   2273c: 03 b4 8a 00  	ld	s0, 8(s5)
   22740: 03 b5 0a 00  	ld	a0, 0(s5)
;     @memset(non_const_ptr, undefined, bytes_len);
   22744: 2a e8        	sd	a0, 16(sp)
   22746: 93 05 a0 0a  	li	a1, 170
   2274a: 5e 85        	mv	a0, s7
   2274c: 62 86        	mv	a2, s8
   2274e: 97 20 00 00  	auipc	ra, 2
   22752: e7 80 c0 b4  	jalr	-1204(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   22756: 1c 68        	ld	a5, 16(s0)
   22758: 42 65        	ld	a0, 16(sp)
   2275a: de 85        	mv	a1, s7
   2275c: 62 86        	mv	a2, s8
   2275e: 81 46        	li	a3, 0
   22760: 4a 87        	mv	a4, s2
   22762: 82 97        	jalr	a5
   22764: 99 b7        	j	0x226aa <heap.arena_allocator.ArenaAllocator.alloc+0x94>
;                 const result = cur_buf[adjusted_index..new_end_index];
   22766: 32 95        	add	a0, a0, a2
;                 self.state.end_index = new_end_index;
   22768: 23 bc ba 00  	sd	a1, 24(s5)
   2276c: e6 70        	ld	ra, 120(sp)
   2276e: 46 74        	ld	s0, 112(sp)
   22770: a6 74        	ld	s1, 104(sp)
   22772: 06 79        	ld	s2, 96(sp)
   22774: e6 69        	ld	s3, 88(sp)
   22776: 46 6a        	ld	s4, 80(sp)
   22778: a6 6a        	ld	s5, 72(sp)
   2277a: 06 6b        	ld	s6, 64(sp)
   2277c: e2 7b        	ld	s7, 56(sp)
   2277e: 42 7c        	ld	s8, 48(sp)
   22780: a2 7c        	ld	s9, 40(sp)
   22782: 02 7d        	ld	s10, 32(sp)
   22784: e2 6d        	ld	s11, 24(sp)
   22786: 09 61        	addi	sp, sp, 128
   22788: 82 80        	ret
;             const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   2278a: 37 15 01 00  	lui	a0, 17
   2278e: 13 05 45 5b  	addi	a0, a0, 1460
   22792: 93 05 40 02  	li	a1, 36
   22796: 81 46        	li	a3, 0
   22798: 97 10 00 00  	auipc	ra, 1
   2279c: e7 80 20 be  	jalr	-1054(ra)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   227a0: 37 25 01 00  	lui	a0, 18
   227a4: 13 05 a5 86  	addi	a0, a0, -1942
   227a8: f9 45        	li	a1, 30
   227aa: 81 46        	li	a3, 0
   227ac: 97 10 00 00  	auipc	ra, 1
   227b0: e7 80 e0 bc  	jalr	-1074(ra)
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   227b4: 37 15 01 00  	lui	a0, 17
   227b8: 13 05 75 63  	addi	a0, a0, 1591
   227bc: cd 45        	li	a1, 19
   227be: 81 46        	li	a3, 0
   227c0: 97 10 00 00  	auipc	ra, 1
   227c4: e7 80 a0 bb  	jalr	-1094(ra)
;         const ptr_align = @as(usize, 1) << @intCast(Allocator.Log2Align, log2_ptr_align);
   227c8: 37 15 01 00  	lui	a0, 17
   227cc: 13 05 95 68  	addi	a0, a0, 1673
   227d0: ed 45        	li	a1, 27
   227d2: 81 46        	li	a3, 0
   227d4: 97 10 00 00  	auipc	ra, 1
   227d8: e7 80 60 ba  	jalr	-1114(ra)
;             const addr = @ptrToInt(cur_buf.ptr) + self.state.end_index;
   227dc: 83 b5 8a 01  	ld	a1, 24(s5)
   227e0: aa 95        	add	a1, a1, a0
   227e2: 63 fc a5 00  	bgeu	a1, a0, 0x227fa <heap.arena_allocator.ArenaAllocator.alloc+0x1e4>
   227e6: 37 15 01 00  	lui	a0, 17
   227ea: 13 05 95 5d  	addi	a0, a0, 1497
   227ee: c1 45        	li	a1, 16
   227f0: 81 46        	li	a3, 0
   227f2: 97 10 00 00  	auipc	ra, 1
   227f6: e7 80 80 b8  	jalr	-1144(ra)
;     if (!ok) unreachable; // assertion failure
   227fa: 37 25 01 00  	lui	a0, 18
   227fe: 13 05 b5 a7  	addi	a0, a0, -1413
   22802: e1 45        	li	a1, 24
   22804: 81 46        	li	a3, 0
   22806: 97 10 00 00  	auipc	ra, 1
   2280a: e7 80 40 b7  	jalr	-1164(ra)

000000000002280e <heap.arena_allocator.ArenaAllocator.createNode>:
;     fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) ?*BufNode {
   2280e: 01 11        	addi	sp, sp, -32
;         const actual_min_size = minimum_size + (@sizeOf(BufNode) + 16);
   22810: 06 ec        	sd	ra, 24(sp)
   22812: 22 e8        	sd	s0, 16(sp)
   22814: 26 e4        	sd	s1, 8(sp)
   22816: 93 06 86 02  	addi	a3, a2, 40
   2281a: 63 e6 c6 04  	bltu	a3, a2, 0x22866 <heap.arena_allocator.ArenaAllocator.createNode+0x58>
   2281e: 2a 84        	mv	s0, a0
;         const big_enough_len = prev_len + actual_min_size;
   22820: 33 85 d5 00  	add	a0, a1, a3
   22824: 63 61 b5 04  	bltu	a0, a1, 0x22866 <heap.arena_allocator.ArenaAllocator.createNode+0x58>
;         const len = big_enough_len + big_enough_len / 2;
   22828: 93 55 15 00  	srli	a1, a0, 1
   2282c: b3 04 b5 00  	add	s1, a0, a1
   22830: 63 eb a4 02  	bltu	s1, a0, 0x22866 <heap.arena_allocator.ArenaAllocator.createNode+0x58>
;         const ptr = self.child_allocator.rawAlloc(len, log2_align, @returnAddress()) orelse
   22834: 0c 64        	ld	a1, 8(s0)
   22836: 08 60        	ld	a0, 0(s0)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   22838: 98 61        	ld	a4, 0(a1)
   2283a: 0d 46        	li	a2, 3
   2283c: a6 85        	mv	a1, s1
   2283e: 86 86        	mv	a3, ra
   22840: 02 97        	jalr	a4
   22842: 09 cd        	beqz	a0, 0x2285c <heap.arena_allocator.ArenaAllocator.createNode+0x4e>
;         const buf_node = @ptrCast(*BufNode, @alignCast(@alignOf(BufNode), ptr));
   22844: 93 75 75 00  	andi	a1, a0, 7
   22848: 8d e9        	bnez	a1, 0x2287a <heap.arena_allocator.ArenaAllocator.createNode+0x6c>
;             .data = ptr[0..len],
   2284a: 08 e5        	sd	a0, 8(a0)
   2284c: 04 e9        	sd	s1, 16(a0)
   2284e: 23 30 05 00  	sd	zero, 0(a0)
;             new_node.next = list.first;
   22852: 0c 68        	ld	a1, 16(s0)
   22854: 0c e1        	sd	a1, 0(a0)
;             list.first = new_node;
   22856: 08 e8        	sd	a0, 16(s0)
;         self.state.end_index = 0;
   22858: 23 3c 04 00  	sd	zero, 24(s0)
   2285c: e2 60        	ld	ra, 24(sp)
   2285e: 42 64        	ld	s0, 16(sp)
   22860: a2 64        	ld	s1, 8(sp)
   22862: 05 61        	addi	sp, sp, 32
   22864: 82 80        	ret
   22866: 37 15 01 00  	lui	a0, 17
   2286a: 13 05 95 5d  	addi	a0, a0, 1497
   2286e: c1 45        	li	a1, 16
   22870: 81 46        	li	a3, 0
   22872: 97 10 00 00  	auipc	ra, 1
   22876: e7 80 80 b0  	jalr	-1272(ra)
;         const buf_node = @ptrCast(*BufNode, @alignCast(@alignOf(BufNode), ptr));
   2287a: 37 15 01 00  	lui	a0, 17
   2287e: 13 05 75 63  	addi	a0, a0, 1591
   22882: cd 45        	li	a1, 19
   22884: 81 46        	li	a3, 0
   22886: 97 10 00 00  	auipc	ra, 1
   2288a: e7 80 40 af  	jalr	-1292(ra)

000000000002288e <heap.arena_allocator.ArenaAllocator.resize>:
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   2288e: 93 76 75 00  	andi	a3, a0, 7
   22892: c9 e2        	bnez	a3, 0x22914 <heap.arena_allocator.ArenaAllocator.resize+0x86>
;         const cur_node = self.state.buffer_list.first orelse return false;
   22894: 14 69        	ld	a3, 16(a0)
   22896: b1 c2        	beqz	a3, 0x228da <heap.arena_allocator.ArenaAllocator.resize+0x4c>
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   22898: 03 b8 06 01  	ld	a6, 16(a3)
   2289c: dd 47        	li	a5, 23
   2289e: 63 f5 07 09  	bgeu	a5, a6, 0x22928 <heap.arena_allocator.ArenaAllocator.resize+0x9a>
   228a2: 94 66        	ld	a3, 8(a3)
;         if (@ptrToInt(cur_buf.ptr) + self.state.end_index != @ptrToInt(buf.ptr) + buf.len) {
   228a4: 83 38 85 01  	ld	a7, 24(a0)
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   228a8: e1 06        	addi	a3, a3, 24
;         if (@ptrToInt(cur_buf.ptr) + self.state.end_index != @ptrToInt(buf.ptr) + buf.len) {
   228aa: b3 87 16 01  	add	a5, a3, a7
   228ae: 63 e9 d7 04  	bltu	a5, a3, 0x22900 <heap.arena_allocator.ArenaAllocator.resize+0x72>
   228b2: b3 86 c5 00  	add	a3, a1, a2
   228b6: 63 e5 b6 04  	bltu	a3, a1, 0x22900 <heap.arena_allocator.ArenaAllocator.resize+0x72>
   228ba: 63 92 d7 02  	bne	a5, a3, 0x228de <heap.arena_allocator.ArenaAllocator.resize+0x50>
;         if (buf.len >= new_len) {
   228be: 63 75 e6 02  	bgeu	a2, a4, 0x228e8 <heap.arena_allocator.ArenaAllocator.resize+0x5a>
   228c2: 93 06 88 fe  	addi	a3, a6, -24
;         } else if (cur_buf.len - self.state.end_index >= new_len - buf.len) {
   228c6: b3 85 16 41  	sub	a1, a3, a7
   228ca: 63 eb b6 02  	bltu	a3, a1, 0x22900 <heap.arena_allocator.ArenaAllocator.resize+0x72>
   228ce: 33 06 c7 40  	sub	a2, a4, a2
   228d2: 63 67 c7 02  	bltu	a4, a2, 0x22900 <heap.arena_allocator.ArenaAllocator.resize+0x72>
   228d6: 63 f1 c5 02  	bgeu	a1, a2, 0x228f8 <heap.arena_allocator.ArenaAllocator.resize+0x6a>
   228da: 01 45        	li	a0, 0
   228dc: 82 80        	ret
;             return new_len <= buf.len;
   228de: 33 35 e6 00  	sltu	a0, a2, a4
   228e2: 13 45 15 00  	xori	a0, a0, 1
   228e6: 82 80        	ret
;             self.state.end_index -= buf.len - new_len;
   228e8: b3 05 c7 40  	sub	a1, a4, a2
   228ec: c6 95        	add	a1, a1, a7
   228ee: 63 e9 b8 00  	bltu	a7, a1, 0x22900 <heap.arena_allocator.ArenaAllocator.resize+0x72>
   228f2: 0c ed        	sd	a1, 24(a0)
   228f4: 05 45        	li	a0, 1
   228f6: 82 80        	ret
;             self.state.end_index += new_len - buf.len;
   228f8: b3 85 c8 00  	add	a1, a7, a2
   228fc: e3 fb 15 ff  	bgeu	a1, a7, 0x228f2 <heap.arena_allocator.ArenaAllocator.resize+0x64>
   22900: 37 15 01 00  	lui	a0, 17
   22904: 13 05 95 5d  	addi	a0, a0, 1497
   22908: c1 45        	li	a1, 16
   2290a: 81 46        	li	a3, 0
   2290c: 97 10 00 00  	auipc	ra, 1
   22910: e7 80 e0 a6  	jalr	-1426(ra)
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   22914: 37 15 01 00  	lui	a0, 17
   22918: 13 05 75 63  	addi	a0, a0, 1591
   2291c: cd 45        	li	a1, 19
   2291e: 81 46        	li	a3, 0
   22920: 97 10 00 00  	auipc	ra, 1
   22924: e7 80 a0 a5  	jalr	-1446(ra)
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   22928: 37 15 01 00  	lui	a0, 17
   2292c: 13 05 45 5b  	addi	a0, a0, 1460
   22930: 93 05 40 02  	li	a1, 36
   22934: 81 46        	li	a3, 0
   22936: 97 10 00 00  	auipc	ra, 1
   2293a: e7 80 40 a4  	jalr	-1468(ra)

000000000002293e <heap.arena_allocator.ArenaAllocator.free>:
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   2293e: 93 76 75 00  	andi	a3, a0, 7
   22942: a9 e6        	bnez	a3, 0x2298c <heap.arena_allocator.ArenaAllocator.free+0x4e>
;         const cur_node = self.state.buffer_list.first orelse return;
   22944: 14 69        	ld	a3, 16(a0)
   22946: 85 ca        	beqz	a3, 0x22976 <heap.arena_allocator.ArenaAllocator.free+0x38>
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   22948: 98 6a        	ld	a4, 16(a3)
   2294a: dd 47        	li	a5, 23
   2294c: 63 fa e7 04  	bgeu	a5, a4, 0x229a0 <heap.arena_allocator.ArenaAllocator.free+0x62>
   22950: 98 66        	ld	a4, 8(a3)
;         if (@ptrToInt(cur_buf.ptr) + self.state.end_index == @ptrToInt(buf.ptr) + buf.len) {
   22952: 14 6d        	ld	a3, 24(a0)
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   22954: 93 07 87 01  	addi	a5, a4, 24
;         if (@ptrToInt(cur_buf.ptr) + self.state.end_index == @ptrToInt(buf.ptr) + buf.len) {
   22958: 33 87 d7 00  	add	a4, a5, a3
   2295c: 63 6e f7 00  	bltu	a4, a5, 0x22978 <heap.arena_allocator.ArenaAllocator.free+0x3a>
   22960: b3 87 c5 00  	add	a5, a1, a2
   22964: 63 ea b7 00  	bltu	a5, a1, 0x22978 <heap.arena_allocator.ArenaAllocator.free+0x3a>
   22968: 63 17 f7 00  	bne	a4, a5, 0x22976 <heap.arena_allocator.ArenaAllocator.free+0x38>
;             self.state.end_index -= buf.len;
   2296c: b3 85 c6 40  	sub	a1, a3, a2
   22970: 63 e4 b6 00  	bltu	a3, a1, 0x22978 <heap.arena_allocator.ArenaAllocator.free+0x3a>
   22974: 0c ed        	sd	a1, 24(a0)
   22976: 82 80        	ret
   22978: 37 15 01 00  	lui	a0, 17
   2297c: 13 05 95 5d  	addi	a0, a0, 1497
   22980: c1 45        	li	a1, 16
   22982: 81 46        	li	a3, 0
   22984: 97 10 00 00  	auipc	ra, 1
   22988: e7 80 60 9f  	jalr	-1546(ra)
;         const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));
   2298c: 37 15 01 00  	lui	a0, 17
   22990: 13 05 75 63  	addi	a0, a0, 1591
   22994: cd 45        	li	a1, 19
   22996: 81 46        	li	a3, 0
   22998: 97 10 00 00  	auipc	ra, 1
   2299c: e7 80 20 9e  	jalr	-1566(ra)
;         const cur_buf = cur_node.data[@sizeOf(BufNode)..];
   229a0: 37 15 01 00  	lui	a0, 17
   229a4: 13 05 45 5b  	addi	a0, a0, 1460
   229a8: 93 05 40 02  	li	a1, 36
   229ac: 81 46        	li	a3, 0
   229ae: 97 10 00 00  	auipc	ra, 1
   229b2: e7 80 c0 9c  	jalr	-1588(ra)

00000000000229b6 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise>:
;         pub fn ensureTotalCapacityPrecise(self: *Self, allocator: Allocator, new_capacity: usize) Allocator.Error!void {
   229b6: 49 71        	addi	sp, sp, -368
;             if (self.capacity >= new_capacity) return;
   229b8: 86 f6        	sd	ra, 360(sp)
   229ba: a2 f2        	sd	s0, 352(sp)
   229bc: a6 ee        	sd	s1, 344(sp)
   229be: ca ea        	sd	s2, 336(sp)
   229c0: ce e6        	sd	s3, 328(sp)
   229c2: d2 e2        	sd	s4, 320(sp)
   229c4: 56 fe        	sd	s5, 312(sp)
   229c6: 5a fa        	sd	s6, 304(sp)
   229c8: 5e f6        	sd	s7, 296(sp)
   229ca: 62 f2        	sd	s8, 288(sp)
   229cc: 66 ee        	sd	s9, 280(sp)
   229ce: 83 bc 05 01  	ld	s9, 16(a1)
   229d2: 63 fb dc 04  	bgeu	s9, a3, 0x22a28 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x72>
   229d6: ae 8b        	mv	s7, a1
   229d8: 86 89        	mv	s3, ra
   229da: b6 84        	mv	s1, a3
   229dc: 32 8c        	mv	s8, a2
   229de: 2a 8b        	mv	s6, a0
;             const old_memory = self.allocatedSlice();
   229e0: 03 b9 05 00  	ld	s2, 0(a1)
;             if (allocator.resize(old_memory, new_capacity)) {
   229e4: 08 62        	ld	a0, 0(a2)
   229e6: 0c 66        	ld	a1, 8(a2)
   229e8: 0a 86        	mv	a2, sp
   229ea: 32 e6        	sd	a2, 264(sp)
   229ec: 13 06 00 02  	li	a2, 32
   229f0: 32 ea        	sd	a2, 272(sp)
   229f2: 02 e2        	sd	zero, 256(sp)
   229f4: 13 9a 5c 00  	slli	s4, s9, 5
;     if (old_mem.len == 0) {
   229f8: 63 8a 0c 02  	beqz	s9, 0x22a2c <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x76>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   229fc: 13 56 5a 00  	srli	a2, s4, 5
   22a00: 63 15 96 15  	bne	a2, s9, 0x22b4a <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x194>
;     const ov = @mulWithOverflow(a, b);
   22a04: 13 94 54 00  	slli	s0, s1, 5
   22a08: 13 56 54 00  	srli	a2, s0, 5
;     if (ov[1] != 0) return error.Overflow;
   22a0c: 63 14 96 10  	bne	a2, s1, 0x22b14 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x15e>
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   22a10: 03 b8 85 00  	ld	a6, 8(a1)
   22a14: 8d 46        	li	a3, 3
   22a16: ca 85        	mv	a1, s2
   22a18: 52 86        	mv	a2, s4
   22a1a: 22 87        	mv	a4, s0
   22a1c: ce 87        	mv	a5, s3
   22a1e: 02 98        	jalr	a6
   22a20: 05 89        	andi	a0, a0, 1
;             if (allocator.resize(old_memory, new_capacity)) {
   22a22: 01 cd        	beqz	a0, 0x22a3a <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x84>
   22a24: 01 45        	li	a0, 0
   22a26: c1 a8        	j	0x22af6 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x140>
   22a28: 01 45        	li	a0, 0
   22a2a: c1 a8        	j	0x22afa <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x144>
;     const ov = @mulWithOverflow(a, b);
   22a2c: 13 94 54 00  	slli	s0, s1, 5
   22a30: 13 56 54 00  	srli	a2, s0, 5
;     if (ov[1] != 0) return error.Overflow;
   22a34: 63 07 96 00  	beq	a2, s1, 0x22a42 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x8c>
   22a38: dd a0        	j	0x22b1e <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x168>
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   22a3a: 83 35 8c 00  	ld	a1, 8(s8)
   22a3e: 03 35 0c 00  	ld	a0, 0(s8)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   22a42: 98 61        	ld	a4, 0(a1)
   22a44: 0d 46        	li	a2, 3
   22a46: a2 85        	mv	a1, s0
   22a48: ce 86        	mv	a3, s3
   22a4a: 02 97        	jalr	a4
   22a4c: 71 cd        	beqz	a0, 0x22b28 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x172>
   22a4e: aa 8a        	mv	s5, a0
;     @memset(byte_ptr, undefined, byte_count);
   22a50: 93 05 a0 0a  	li	a1, 170
   22a54: 22 86        	mv	a2, s0
   22a56: 97 20 00 00  	auipc	ra, 2
   22a5a: e7 80 40 84  	jalr	-1980(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   22a5e: 13 f5 7a 00  	andi	a0, s5, 7
   22a62: 13 35 15 00  	seqz	a0, a0
   22a66: 93 35 14 00  	seqz	a1, s0
   22a6a: 4d 8d        	or	a0, a0, a1
   22a6c: 6d c9        	beqz	a0, 0x22b5e <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x1a8>
;     if (bytes.len == 0) {
   22a6e: 01 c4        	beqz	s0, 0x22a76 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0xc0>
   22a70: 93 54 54 00  	srli	s1, s0, 5
   22a74: 31 a0        	j	0x22a80 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0xca>
   22a76: 37 55 02 00  	lui	a0, 37
   22a7a: 83 3a 85 3d  	ld	s5, 984(a0)
   22a7e: 81 44        	li	s1, 0
;                 mem.copy(T, new_memory, self.items);
   22a80: 03 b5 8b 00  	ld	a0, 8(s7)
;     if (!ok) unreachable; // assertion failure
   22a84: 63 e7 a4 0e  	bltu	s1, a0, 0x22b72 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x1bc>
;     for (source) |s, i|
   22a88: 15 c1        	beqz	a0, 0x22aac <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0xf6>
   22a8a: 83 b5 0b 00  	ld	a1, 0(s7)
   22a8e: 56 86        	mv	a2, s5
;         dest[i] = s;
   22a90: 94 6d        	ld	a3, 24(a1)
   22a92: 98 69        	ld	a4, 16(a1)
   22a94: 9c 65        	ld	a5, 8(a1)
   22a96: 80 61        	ld	s0, 0(a1)
   22a98: 14 ee        	sd	a3, 24(a2)
   22a9a: 18 ea        	sd	a4, 16(a2)
   22a9c: 1c e6        	sd	a5, 8(a2)
   22a9e: 00 e2        	sd	s0, 0(a2)
;     for (source) |s, i|
   22aa0: 93 85 05 02  	addi	a1, a1, 32
   22aa4: 7d 15        	addi	a0, a0, -1
   22aa6: 13 06 06 02  	addi	a2, a2, 32
   22aaa: 7d f1        	bnez	a0, 0x22a90 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0xda>
;                 allocator.free(old_memory);
   22aac: 03 3b 0c 00  	ld	s6, 0(s8)
   22ab0: 03 34 8c 00  	ld	s0, 8(s8)
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   22ab4: 63 89 0c 00  	beqz	s9, 0x22ac6 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x110>
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   22ab8: 13 55 5a 00  	srli	a0, s4, 5
   22abc: 63 17 95 09  	bne	a0, s9, 0x22b4a <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x194>
;     if (bytes_len == 0) return;
   22ac0: 63 17 0a 00  	bnez	s4, 0x22ace <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x118>
   22ac4: 35 a0        	j	0x22af0 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x13a>
   22ac6: 01 4a        	li	s4, 0
   22ac8: 21 49        	li	s2, 8
;     if (bytes_len == 0) return;
   22aca: 63 03 0a 02  	beqz	s4, 0x22af0 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x13a>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   22ace: 63 0c 09 0a  	beqz	s2, 0x22b86 <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x1d0>
;     @memset(non_const_ptr, undefined, bytes_len);
   22ad2: 93 05 a0 0a  	li	a1, 170
   22ad6: 4a 85        	mv	a0, s2
   22ad8: 52 86        	mv	a2, s4
   22ada: 97 10 00 00  	auipc	ra, 1
   22ade: e7 80 00 7c  	jalr	1984(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   22ae2: 1c 68        	ld	a5, 16(s0)
   22ae4: 8d 46        	li	a3, 3
   22ae6: 5a 85        	mv	a0, s6
   22ae8: ca 85        	mv	a1, s2
   22aea: 52 86        	mv	a2, s4
   22aec: 4e 87        	mv	a4, s3
   22aee: 82 97        	jalr	a5
   22af0: 01 45        	li	a0, 0
;                 self.items.ptr = new_memory.ptr;
   22af2: 23 b0 5b 01  	sd	s5, 0(s7)
   22af6: 23 b8 9b 00  	sd	s1, 16(s7)
   22afa: b6 70        	ld	ra, 360(sp)
   22afc: 16 74        	ld	s0, 352(sp)
   22afe: f6 64        	ld	s1, 344(sp)
   22b00: 56 69        	ld	s2, 336(sp)
   22b02: b6 69        	ld	s3, 328(sp)
   22b04: 16 6a        	ld	s4, 320(sp)
   22b06: f2 7a        	ld	s5, 312(sp)
   22b08: 52 7b        	ld	s6, 304(sp)
   22b0a: b2 7b        	ld	s7, 296(sp)
   22b0c: 12 7c        	ld	s8, 288(sp)
   22b0e: f2 6c        	ld	s9, 280(sp)
   22b10: 75 61        	addi	sp, sp, 368
   22b12: 82 80        	ret
;     if (ov[1] != 0) return error.Overflow;
   22b14: 08 02        	addi	a0, sp, 256
   22b16: 97 10 00 00  	auipc	ra, 1
   22b1a: e7 80 20 0e  	jalr	226(ra)
   22b1e: 5a 85        	mv	a0, s6
   22b20: 97 10 00 00  	auipc	ra, 1
   22b24: e7 80 80 0d  	jalr	216(ra)
   22b28: 5a 85        	mv	a0, s6
   22b2a: 97 10 00 00  	auipc	ra, 1
   22b2e: e7 80 e0 0c  	jalr	206(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   22b32: 5a 85        	mv	a0, s6
   22b34: 97 10 00 00  	auipc	ra, 1
   22b38: e7 80 40 0c  	jalr	196(ra)
;                 const new_memory = try allocator.alignedAlloc(T, alignment, new_capacity);
   22b3c: 5a 85        	mv	a0, s6
   22b3e: 97 10 00 00  	auipc	ra, 1
   22b42: e7 80 a0 0b  	jalr	186(ra)
   22b46: 45 45        	li	a0, 17
   22b48: 4d bf        	j	0x22afa <array_list.ArrayListAlignedUnmanaged(dwarf.Die.Attr,null).ensureTotalCapacityPrecise+0x144>
   22b4a: 37 15 01 00  	lui	a0, 17
   22b4e: 13 05 95 5d  	addi	a0, a0, 1497
   22b52: c1 45        	li	a1, 16
   22b54: 81 46        	li	a3, 0
   22b56: 97 10 00 00  	auipc	ra, 1
   22b5a: e7 80 40 82  	jalr	-2012(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   22b5e: 37 15 01 00  	lui	a0, 17
   22b62: 13 05 75 63  	addi	a0, a0, 1591
   22b66: cd 45        	li	a1, 19
   22b68: 81 46        	li	a3, 0
   22b6a: 97 10 00 00  	auipc	ra, 1
   22b6e: e7 80 00 81  	jalr	-2032(ra)
;     if (!ok) unreachable; // assertion failure
   22b72: 37 25 01 00  	lui	a0, 18
   22b76: 13 05 b5 a7  	addi	a0, a0, -1413
   22b7a: e1 45        	li	a1, 24
   22b7c: 81 46        	li	a3, 0
   22b7e: 97 00 00 00  	auipc	ra, 0
   22b82: e7 80 c0 7f  	jalr	2044(ra)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   22b86: 37 25 01 00  	lui	a0, 18
   22b8a: 13 05 a5 86  	addi	a0, a0, -1942
   22b8e: f9 45        	li	a1, 30
   22b90: 81 46        	li	a3, 0
   22b92: 97 00 00 00  	auipc	ra, 0
   22b96: e7 80 80 7e  	jalr	2024(ra)

0000000000022b9a <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext>:
;         pub fn putAssumeCapacityNoClobberContext(self: *Self, key: K, value: V, ctx: Context) void {
   22b9a: 79 71        	addi	sp, sp, -48
   22b9c: 06 f4        	sd	ra, 40(sp)
   22b9e: 22 f0        	sd	s0, 32(sp)
   22ba0: 26 ec        	sd	s1, 24(sp)
   22ba2: 4a e8        	sd	s2, 16(sp)
   22ba4: 4e e4        	sd	s3, 8(sp)
   22ba6: 32 89        	mv	s2, a2
   22ba8: ae 89        	mv	s3, a1
   22baa: 2a 84        	mv	s0, a0
;             return self.containsAdapted(key, ctx);
   22bac: 97 00 00 00  	auipc	ra, 0
   22bb0: e7 80 e0 50  	jalr	1294(ra)
   22bb4: 05 89        	andi	a0, a0, 1
;     if (!ok) unreachable; // assertion failure
   22bb6: 65 e9        	bnez	a0, 0x22ca6 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0x10c>
;             if (self.metadata == null) return 0;
   22bb8: 08 60        	ld	a0, 0(s0)
   22bba: 61 cd        	beqz	a0, 0x22c92 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xf8>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   22bbc: 93 75 75 00  	andi	a1, a0, 7
   22bc0: dd ed        	bnez	a1, 0x22c7e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xe4>
;             const mask = self.capacity() - 1;
   22bc2: 03 26 85 ff  	lw	a2, -8(a0)
   22bc6: 9b 05 f6 ff  	addiw	a1, a2, -1
   22bca: 63 64 b6 0c  	bltu	a2, a1, 0x22c92 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xf8>
   22bce: 13 d6 09 02  	srli	a2, s3, 32
   22bd2: b7 56 02 00  	lui	a3, 37
   22bd6: 83 b6 06 3e  	ld	a3, 992(a3)
   22bda: 37 57 02 00  	lui	a4, 37
   22bde: 03 37 87 3e  	ld	a4, 1000(a4)
   22be2: 93 97 09 02  	slli	a5, s3, 32
   22be6: 5d 8e        	or	a2, a2, a5
   22be8: 35 8e        	xor	a2, a2, a3
   22bea: b3 06 e6 02  	mul	a3, a2, a4
   22bee: b7 57 02 00  	lui	a5, 37
   22bf2: 83 b7 07 3f  	ld	a5, 1008(a5)
   22bf6: 33 36 e6 02  	mulhu	a2, a2, a4
   22bfa: 35 8e        	xor	a2, a2, a3
   22bfc: 13 46 86 00  	xori	a2, a2, 8
   22c00: b3 06 f6 02  	mul	a3, a2, a5
   22c04: 33 36 f6 02  	mulhu	a2, a2, a5
   22c08: 35 8e        	xor	a2, a2, a3
;             var idx = @truncate(usize, hash & mask);
   22c0a: 82 15        	slli	a1, a1, 32
   22c0c: 13 d7 05 02  	srli	a4, a1, 32
   22c10: b2 87        	mv	a5, a2
   22c12: b3 f5 e7 00  	and	a1, a5, a4
   22c16: b3 06 b5 00  	add	a3, a0, a1
;             while (metadata[0].isUsed()) {
   22c1a: 83 84 06 00  	lb	s1, 0(a3)
;                 idx = (idx + 1) & mask;
   22c1e: 93 87 15 00  	addi	a5, a1, 1
;             while (metadata[0].isUsed()) {
   22c22: e3 c8 04 fe  	bltz	s1, 0x22c12 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0x78>
;             assert(self.available > 0);
   22c26: 48 44        	lw	a0, 12(s0)
;     if (!ok) unreachable; // assertion failure
   22c28: 3d cd        	beqz	a0, 0x22ca6 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0x10c>
;             self.available -= 1;
   22c2a: 7d 35        	addiw	a0, a0, -1
   22c2c: 48 c4        	sw	a0, 12(s0)
;                 return @truncate(FingerPrint, hash >> (hash_bits - fp_bits));
   22c2e: 13 55 96 03  	srli	a0, a2, 57
;                 self.fingerprint = fp;
   22c32: 13 65 05 08  	ori	a0, a0, 128
   22c36: 23 80 a6 00  	sb	a0, 0(a3)
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   22c3a: 08 60        	ld	a0, 0(s0)
   22c3c: 3d cd        	beqz	a0, 0x22cba <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0x120>
   22c3e: 13 76 75 00  	andi	a2, a0, 7
   22c42: 15 ee        	bnez	a2, 0x22c7e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xe4>
;             return self.header().keys;
   22c44: 03 36 05 ff  	ld	a2, -16(a0)
;             self.keys()[idx] = key;
   22c48: 13 95 35 00  	slli	a0, a1, 3
   22c4c: b3 05 a6 00  	add	a1, a2, a0
   22c50: 23 b0 35 01  	sd	s3, 0(a1)
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   22c54: 0c 60        	ld	a1, 0(s0)
   22c56: b5 c1        	beqz	a1, 0x22cba <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0x120>
   22c58: 13 f6 75 00  	andi	a2, a1, 7
   22c5c: 0d e2        	bnez	a2, 0x22c7e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xe4>
;             return self.header().values;
   22c5e: 83 b5 85 fe  	ld	a1, -24(a1)
;             self.values()[idx] = value;
   22c62: 2e 95        	add	a0, a0, a1
   22c64: 23 30 25 01  	sd	s2, 0(a0)
;             self.size += 1;
   22c68: 08 44        	lw	a0, 8(s0)
   22c6a: 05 25        	addiw	a0, a0, 1
   22c6c: 1d c1        	beqz	a0, 0x22c92 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext+0xf8>
   22c6e: 08 c4        	sw	a0, 8(s0)
   22c70: a2 70        	ld	ra, 40(sp)
   22c72: 02 74        	ld	s0, 32(sp)
   22c74: e2 64        	ld	s1, 24(sp)
   22c76: 42 69        	ld	s2, 16(sp)
   22c78: a2 69        	ld	s3, 8(sp)
   22c7a: 45 61        	addi	sp, sp, 48
   22c7c: 82 80        	ret
   22c7e: 37 15 01 00  	lui	a0, 17
   22c82: 13 05 75 63  	addi	a0, a0, 1591
   22c86: cd 45        	li	a1, 19
   22c88: 81 46        	li	a3, 0
   22c8a: 97 00 00 00  	auipc	ra, 0
   22c8e: e7 80 00 6f  	jalr	1776(ra)
   22c92: 37 15 01 00  	lui	a0, 17
   22c96: 13 05 95 5d  	addi	a0, a0, 1497
   22c9a: c1 45        	li	a1, 16
   22c9c: 81 46        	li	a3, 0
   22c9e: 97 00 00 00  	auipc	ra, 0
   22ca2: e7 80 c0 6d  	jalr	1756(ra)
   22ca6: 37 25 01 00  	lui	a0, 18
   22caa: 13 05 b5 a7  	addi	a0, a0, -1413
   22cae: e1 45        	li	a1, 24
   22cb0: 81 46        	li	a3, 0
   22cb2: 97 00 00 00  	auipc	ra, 0
   22cb6: e7 80 80 6c  	jalr	1736(ra)
   22cba: 37 25 01 00  	lui	a0, 18
   22cbe: 13 05 25 9b  	addi	a0, a0, -1614
   22cc2: e5 45        	li	a1, 25
   22cc4: 81 46        	li	a3, 0
   22cc6: 97 00 00 00  	auipc	ra, 0
   22cca: e7 80 40 6b  	jalr	1716(ra)

0000000000022cce <fmt.formatValue__anon_6582>:
; ) !void {
   22cce: 19 71        	addi	sp, sp, -128
   22cd0: 86 fc        	sd	ra, 120(sp)
   22cd2: a2 f8        	sd	s0, 112(sp)
   22cd4: a6 f4        	sd	s1, 104(sp)
   22cd6: ca f0        	sd	s2, 96(sp)
   22cd8: ce ec        	sd	s3, 88(sp)
   22cda: d2 e8        	sd	s4, 80(sp)
   22cdc: d6 e4        	sd	s5, 72(sp)
   22cde: b6 89        	mv	s3, a3
   22ce0: 32 8a        	mv	s4, a2
   22ce2: ae 84        	mv	s1, a1
   22ce4: 2a 89        	mv	s2, a0
   22ce6: 93 0a 71 00  	addi	s5, sp, 7
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   22cea: 13 05 71 00  	addi	a0, sp, 7
   22cee: 93 05 a0 0a  	li	a1, 170
   22cf2: 13 06 10 04  	li	a2, 65
   22cf6: 13 04 10 04  	li	s0, 65
   22cfa: 97 10 00 00  	auipc	ra, 1
   22cfe: e7 80 00 5a  	jalr	1440(ra)
   22d02: 13 08 40 06  	li	a6, 100
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   22d06: 63 ef 04 07  	bltu	s1, a6, 0x22d84 <fmt.formatValue__anon_6582+0xb6>
   22d0a: 13 04 10 04  	li	s0, 65
   22d0e: 37 55 02 00  	lui	a0, 37
   22d12: 03 36 85 3f  	ld	a2, 1016(a0)
   22d16: 37 25 01 00  	lui	a0, 18
   22d1a: 93 06 25 c0  	addi	a3, a0, -1022
   22d1e: 93 08 00 27  	li	a7, 624
   22d22: 22 85        	mv	a0, s0
;             index -= 2;
   22d24: 79 14        	addi	s0, s0, -2
   22d26: 63 69 85 0e  	bltu	a0, s0, 0x22e18 <fmt.formatValue__anon_6582+0x14a>
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   22d2a: 13 d5 24 00  	srli	a0, s1, 2
   22d2e: 33 35 c5 02  	mulhu	a0, a0, a2
   22d32: 09 81        	srli	a0, a0, 2
   22d34: b3 07 05 03  	mul	a5, a0, a6
   22d38: b3 87 f4 40  	sub	a5, s1, a5
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   22d3c: 86 07        	slli	a5, a5, 1
   22d3e: b6 97        	add	a5, a5, a3
;     return ("0001020304050607080910111213141516171819" ++
   22d40: 83 85 17 00  	lb	a1, 1(a5)
   22d44: 83 c7 07 00  	lbu	a5, 0(a5)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   22d48: 33 87 8a 00  	add	a4, s5, s0
   22d4c: a3 00 b7 00  	sb	a1, 1(a4)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   22d50: 93 d5 44 00  	srli	a1, s1, 4
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   22d54: 23 00 f7 00  	sb	a5, 0(a4)
   22d58: aa 84        	mv	s1, a0
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   22d5a: e3 e4 b8 fc  	bltu	a7, a1, 0x22d22 <fmt.formatValue__anon_6582+0x54>
   22d5e: a5 45        	li	a1, 9
;         if (a < 10) {
   22d60: 63 e6 a5 02  	bltu	a1, a0, 0x22d8c <fmt.formatValue__anon_6582+0xbe>
;             index -= 1;
   22d64: 13 06 f4 ff  	addi	a2, s0, -1
   22d68: 63 68 c4 0a  	bltu	s0, a2, 0x22e18 <fmt.formatValue__anon_6582+0x14a>
   22d6c: 93 05 10 04  	li	a1, 65
;             buf[index] = '0' + @intCast(u8, a);
   22d70: 63 7e b6 0a  	bgeu	a2, a1, 0x22e2c <fmt.formatValue__anon_6582+0x15e>
   22d74: 1b 05 05 03  	addiw	a0, a0, 48
   22d78: 93 05 71 00  	addi	a1, sp, 7
   22d7c: b2 95        	add	a1, a1, a2
   22d7e: 23 80 a5 00  	sb	a0, 0(a1)
   22d82: 35 a8        	j	0x22dbe <fmt.formatValue__anon_6582+0xf0>
   22d84: 26 85        	mv	a0, s1
   22d86: a5 45        	li	a1, 9
;         if (a < 10) {
   22d88: e3 fe a5 fc  	bgeu	a1, a0, 0x22d64 <fmt.formatValue__anon_6582+0x96>
;             index -= 2;
   22d8c: 13 06 e4 ff  	addi	a2, s0, -2
   22d90: 63 64 c4 08  	bltu	s0, a2, 0x22e18 <fmt.formatValue__anon_6582+0x14a>
   22d94: 93 05 20 04  	li	a1, 66
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   22d98: 63 74 b6 0a  	bgeu	a2, a1, 0x22e40 <fmt.formatValue__anon_6582+0x172>
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   22d9c: 06 05        	slli	a0, a0, 1
   22d9e: b7 25 01 00  	lui	a1, 18
   22da2: 93 85 25 c0  	addi	a1, a1, -1022
   22da6: 2e 95        	add	a0, a0, a1
;     return ("0001020304050607080910111213141516171819" ++
   22da8: 83 05 15 00  	lb	a1, 1(a0)
   22dac: 03 45 05 00  	lbu	a0, 0(a0)
   22db0: 93 06 71 00  	addi	a3, sp, 7
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   22db4: b2 96        	add	a3, a3, a2
   22db6: a3 80 b6 00  	sb	a1, 1(a3)
   22dba: 23 80 a6 00  	sb	a0, 0(a3)
   22dbe: 13 05 71 00  	addi	a0, sp, 7
;     return formatBuf(buf[index..], options, writer);
   22dc2: b3 05 c5 00  	add	a1, a0, a2
   22dc6: 13 05 10 04  	li	a0, 65
   22dca: 33 06 c5 40  	sub	a2, a0, a2
   22dce: 4a 85        	mv	a0, s2
   22dd0: d2 86        	mv	a3, s4
   22dd2: 4e 87        	mv	a4, s3
   22dd4: 97 f0 ff ff  	auipc	ra, 1048575
   22dd8: e7 80 c0 f5  	jalr	-164(ra)
   22ddc: 2a 84        	mv	s0, a0
   22dde: 42 15        	slli	a0, a0, 48
   22de0: 41 91        	srli	a0, a0, 48
   22de2: 19 e9        	bnez	a0, 0x22df8 <fmt.formatValue__anon_6582+0x12a>
   22de4: 22 85        	mv	a0, s0
   22de6: e6 70        	ld	ra, 120(sp)
   22de8: 46 74        	ld	s0, 112(sp)
   22dea: a6 74        	ld	s1, 104(sp)
   22dec: 06 79        	ld	s2, 96(sp)
   22dee: e6 69        	ld	s3, 88(sp)
   22df0: 46 6a        	ld	s4, 80(sp)
   22df2: a6 6a        	ld	s5, 72(sp)
   22df4: 09 61        	addi	sp, sp, 128
   22df6: 82 80        	ret
;     return formatBuf(buf[index..], options, writer);
   22df8: 4a 85        	mv	a0, s2
   22dfa: 97 10 00 00  	auipc	ra, 1
   22dfe: e7 80 e0 df  	jalr	-514(ra)
;     return formatInt(int_value, radix, case, options, writer);
   22e02: 4a 85        	mv	a0, s2
   22e04: 97 10 00 00  	auipc	ra, 1
   22e08: e7 80 40 df  	jalr	-524(ra)
;         .Int, .ComptimeInt => return formatIntValue(value, fmt, options, writer),
   22e0c: 4a 85        	mv	a0, s2
   22e0e: 97 10 00 00  	auipc	ra, 1
   22e12: e7 80 a0 de  	jalr	-534(ra)
   22e16: f9 b7        	j	0x22de4 <fmt.formatValue__anon_6582+0x116>
   22e18: 37 15 01 00  	lui	a0, 17
   22e1c: 13 05 95 5d  	addi	a0, a0, 1497
   22e20: c1 45        	li	a1, 16
   22e22: 81 46        	li	a3, 0
   22e24: 97 00 00 00  	auipc	ra, 0
   22e28: e7 80 60 55  	jalr	1366(ra)
;             buf[index] = '0' + @intCast(u8, a);
   22e2c: 37 15 01 00  	lui	a0, 17
   22e30: 13 05 35 6e  	addi	a0, a0, 1763
   22e34: cd 45        	li	a1, 19
   22e36: 81 46        	li	a3, 0
   22e38: 97 00 00 00  	auipc	ra, 0
   22e3c: e7 80 20 54  	jalr	1346(ra)
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   22e40: 37 15 01 00  	lui	a0, 17
   22e44: 13 05 45 5b  	addi	a0, a0, 1460
   22e48: 93 05 40 02  	li	a1, 36
   22e4c: 81 46        	li	a3, 0
   22e4e: 97 00 00 00  	auipc	ra, 0
   22e52: e7 80 c0 52  	jalr	1324(ra)

0000000000022e56 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise>:
;         pub fn ensureTotalCapacityPrecise(self: *Self, new_capacity: usize) Allocator.Error!void {
   22e56: 0d 71        	addi	sp, sp, -352
;             if (self.capacity >= new_capacity) return;
   22e58: 86 ee        	sd	ra, 344(sp)
   22e5a: a2 ea        	sd	s0, 336(sp)
   22e5c: a6 e6        	sd	s1, 328(sp)
   22e5e: ca e2        	sd	s2, 320(sp)
   22e60: 4e fe        	sd	s3, 312(sp)
   22e62: 52 fa        	sd	s4, 304(sp)
   22e64: 56 f6        	sd	s5, 296(sp)
   22e66: 5a f2        	sd	s6, 288(sp)
   22e68: 5e ee        	sd	s7, 280(sp)
   22e6a: 83 bb 05 01  	ld	s7, 16(a1)
   22e6e: 63 ff cb 04  	bgeu	s7, a2, 0x22ecc <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x76>
   22e72: 2e 8b        	mv	s6, a1
   22e74: 86 89        	mv	s3, ra
   22e76: 32 84        	mv	s0, a2
   22e78: 2a 8a        	mv	s4, a0
;             const old_memory = self.allocatedSlice();
   22e7a: 03 b9 05 00  	ld	s2, 0(a1)
   22e7e: 0a 85        	mv	a0, sp
   22e80: 2a e6        	sd	a0, 264(sp)
   22e82: 13 05 00 02  	li	a0, 32
   22e86: 2a ea        	sd	a0, 272(sp)
   22e88: 02 e2        	sd	zero, 256(sp)
;     if (old_mem.len == 0) {
   22e8a: 63 83 0b 04  	beqz	s7, 0x22ed0 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x7a>
   22e8e: 93 05 80 03  	li	a1, 56
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   22e92: 33 b5 bb 02  	mulhu	a0, s7, a1
   22e96: 63 12 05 1a  	bnez	a0, 0x2303a <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1e4>
;     const ov = @mulWithOverflow(a, b);
   22e9a: 33 35 b4 02  	mulhu	a0, s0, a1
;     if (ov[1] != 0) return error.Overflow;
   22e9e: 63 13 05 16  	bnez	a0, 0x23004 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1ae>
;     return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());
   22ea2: 03 36 0b 02  	ld	a2, 32(s6)
   22ea6: 03 35 8b 01  	ld	a0, 24(s6)
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   22eaa: 03 38 86 00  	ld	a6, 8(a2)
   22eae: 33 86 bb 02  	mul	a2, s7, a1
   22eb2: b3 04 b4 02  	mul	s1, s0, a1
;     return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);
   22eb6: 8d 46        	li	a3, 3
   22eb8: ca 85        	mv	a1, s2
   22eba: 26 87        	mv	a4, s1
   22ebc: ce 87        	mv	a5, s3
   22ebe: 02 98        	jalr	a6
   22ec0: 05 89        	andi	a0, a0, 1
;             if (self.allocator.resize(old_memory, new_capacity)) {
   22ec2: 19 cd        	beqz	a0, 0x22ee0 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x8a>
   22ec4: 01 45        	li	a0, 0
;                 self.capacity = new_capacity;
   22ec6: 23 38 8b 00  	sd	s0, 16(s6)
   22eca: 15 a2        	j	0x22fee <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x198>
   22ecc: 01 45        	li	a0, 0
   22ece: 05 a2        	j	0x22fee <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x198>
   22ed0: 13 05 80 03  	li	a0, 56
;     const ov = @mulWithOverflow(a, b);
   22ed4: b3 35 a4 02  	mulhu	a1, s0, a0
;     if (ov[1] != 0) return error.Overflow;
   22ed8: 63 9b 05 12  	bnez	a1, 0x2300e <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1b8>
   22edc: b3 04 a4 02  	mul	s1, s0, a0
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   22ee0: 83 35 0b 02  	ld	a1, 32(s6)
   22ee4: 03 35 8b 01  	ld	a0, 24(s6)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   22ee8: 98 61        	ld	a4, 0(a1)
   22eea: 0d 46        	li	a2, 3
   22eec: a6 85        	mv	a1, s1
   22eee: ce 86        	mv	a3, s3
   22ef0: 02 97        	jalr	a4
   22ef2: 63 03 05 12  	beqz	a0, 0x23018 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1c2>
   22ef6: aa 8a        	mv	s5, a0
;     @memset(byte_ptr, undefined, byte_count);
   22ef8: 93 05 a0 0a  	li	a1, 170
   22efc: 26 86        	mv	a2, s1
   22efe: 97 10 00 00  	auipc	ra, 1
   22f02: e7 80 c0 39  	jalr	924(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   22f06: 13 f5 7a 00  	andi	a0, s5, 7
   22f0a: 13 35 15 00  	seqz	a0, a0
   22f0e: 93 b5 14 00  	seqz	a1, s1
   22f12: 4d 8d        	or	a0, a0, a1
   22f14: 63 0d 05 12  	beqz	a0, 0x2304e <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1f8>
;     if (bytes.len == 0) {
   22f18: a5 cc        	beqz	s1, 0x22f90 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x13a>
   22f1a: 37 55 02 00  	lui	a0, 37
   22f1e: 03 35 85 40  	ld	a0, 1032(a0)
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   22f22: 93 d5 34 00  	srli	a1, s1, 3
   22f26: 33 ba a5 02  	mulhu	s4, a1, a0
   22f2a: 13 05 80 03  	li	a0, 56
   22f2e: 33 05 aa 02  	mul	a0, s4, a0
   22f32: 33 85 a4 40  	sub	a0, s1, a0
   22f36: 63 16 05 12  	bnez	a0, 0x23062 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x20c>
;                 mem.copy(T, new_memory, self.items);
   22f3a: 03 35 8b 00  	ld	a0, 8(s6)
;     if (!ok) unreachable; // assertion failure
   22f3e: 63 62 aa 06  	bltu	s4, a0, 0x22fa2 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x14c>
;     for (source) |s, i|
   22f42: 05 cd        	beqz	a0, 0x22f7a <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x124>
   22f44: 83 35 0b 00  	ld	a1, 0(s6)
   22f48: 56 86        	mv	a2, s5
;         dest[i] = s;
   22f4a: 03 b8 05 00  	ld	a6, 0(a1)
   22f4e: 83 b8 85 00  	ld	a7, 8(a1)
   22f52: 9c 69        	ld	a5, 16(a1)
   22f54: 84 79        	ld	s1, 48(a1)
   22f56: 80 75        	ld	s0, 40(a1)
   22f58: 94 71        	ld	a3, 32(a1)
   22f5a: 98 6d        	ld	a4, 24(a1)
   22f5c: 04 fa        	sd	s1, 48(a2)
   22f5e: 00 f6        	sd	s0, 40(a2)
   22f60: 14 f2        	sd	a3, 32(a2)
   22f62: 18 ee        	sd	a4, 24(a2)
   22f64: 1c ea        	sd	a5, 16(a2)
   22f66: 23 34 16 01  	sd	a7, 8(a2)
   22f6a: 23 30 06 01  	sd	a6, 0(a2)
;     for (source) |s, i|
   22f6e: 93 85 85 03  	addi	a1, a1, 56
   22f72: 7d 15        	addi	a0, a0, -1
   22f74: 13 06 86 03  	addi	a2, a2, 56
   22f78: 69 f9        	bnez	a0, 0x22f4a <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0xf4>
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   22f7a: 63 8e 0b 02  	beqz	s7, 0x22fb6 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x160>
   22f7e: 13 05 80 03  	li	a0, 56
;     return @ptrCast(cast_target, slice)[0 .. slice.len * @sizeOf(meta.Elem(Slice))];
   22f82: b3 b5 ab 02  	mulhu	a1, s7, a0
   22f86: d5 e9        	bnez	a1, 0x2303a <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x1e4>
   22f88: 33 84 ab 02  	mul	s0, s7, a0
;     if (bytes_len == 0) return;
   22f8c: 05 e8        	bnez	s0, 0x22fbc <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x166>
   22f8e: 99 a8        	j	0x22fe4 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x18e>
   22f90: 37 55 02 00  	lui	a0, 37
   22f94: 83 3a 05 40  	ld	s5, 1024(a0)
   22f98: 01 4a        	li	s4, 0
;                 mem.copy(T, new_memory, self.items);
   22f9a: 03 35 8b 00  	ld	a0, 8(s6)
;     if (!ok) unreachable; // assertion failure
   22f9e: e3 72 aa fa  	bgeu	s4, a0, 0x22f42 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0xec>
   22fa2: 37 25 01 00  	lui	a0, 18
   22fa6: 13 05 b5 a7  	addi	a0, a0, -1413
   22faa: e1 45        	li	a1, 24
   22fac: 81 46        	li	a3, 0
   22fae: 97 00 00 00  	auipc	ra, 0
   22fb2: e7 80 c0 3c  	jalr	972(ra)
   22fb6: 01 44        	li	s0, 0
   22fb8: 21 49        	li	s2, 8
;     if (bytes_len == 0) return;
   22fba: 0d c4        	beqz	s0, 0x22fe4 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x18e>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   22fbc: 63 0e 09 0a  	beqz	s2, 0x23078 <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x222>
;     @memset(non_const_ptr, undefined, bytes_len);
   22fc0: 93 05 a0 0a  	li	a1, 170
   22fc4: 4a 85        	mv	a0, s2
   22fc6: 22 86        	mv	a2, s0
   22fc8: 97 10 00 00  	auipc	ra, 1
   22fcc: e7 80 20 2d  	jalr	722(ra)
;     self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());
   22fd0: 83 35 0b 02  	ld	a1, 32(s6)
   22fd4: 03 35 8b 01  	ld	a0, 24(s6)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   22fd8: 9c 69        	ld	a5, 16(a1)
   22fda: 8d 46        	li	a3, 3
   22fdc: ca 85        	mv	a1, s2
   22fde: 22 86        	mv	a2, s0
   22fe0: 4e 87        	mv	a4, s3
   22fe2: 82 97        	jalr	a5
   22fe4: 01 45        	li	a0, 0
;                 self.items.ptr = new_memory.ptr;
   22fe6: 23 30 5b 01  	sd	s5, 0(s6)
;                 self.capacity = new_memory.len;
   22fea: 23 38 4b 01  	sd	s4, 16(s6)
   22fee: f6 60        	ld	ra, 344(sp)
   22ff0: 56 64        	ld	s0, 336(sp)
   22ff2: b6 64        	ld	s1, 328(sp)
   22ff4: 16 69        	ld	s2, 320(sp)
   22ff6: f2 79        	ld	s3, 312(sp)
   22ff8: 52 7a        	ld	s4, 304(sp)
   22ffa: b2 7a        	ld	s5, 296(sp)
   22ffc: 12 7b        	ld	s6, 288(sp)
   22ffe: f2 6b        	ld	s7, 280(sp)
   23000: 35 61        	addi	sp, sp, 352
   23002: 82 80        	ret
;     if (ov[1] != 0) return error.Overflow;
   23004: 08 02        	addi	a0, sp, 256
   23006: 97 10 00 00  	auipc	ra, 1
   2300a: e7 80 20 bf  	jalr	-1038(ra)
   2300e: 52 85        	mv	a0, s4
   23010: 97 10 00 00  	auipc	ra, 1
   23014: e7 80 80 be  	jalr	-1048(ra)
   23018: 52 85        	mv	a0, s4
   2301a: 97 10 00 00  	auipc	ra, 1
   2301e: e7 80 e0 bd  	jalr	-1058(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   23022: 52 85        	mv	a0, s4
   23024: 97 10 00 00  	auipc	ra, 1
   23028: e7 80 40 bd  	jalr	-1068(ra)
;                 const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
   2302c: 52 85        	mv	a0, s4
   2302e: 97 10 00 00  	auipc	ra, 1
   23032: e7 80 a0 bc  	jalr	-1078(ra)
   23036: 45 45        	li	a0, 17
   23038: 5d bf        	j	0x22fee <array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacityPrecise+0x198>
   2303a: 37 15 01 00  	lui	a0, 17
   2303e: 13 05 95 5d  	addi	a0, a0, 1497
   23042: c1 45        	li	a1, 16
   23044: 81 46        	li	a3, 0
   23046: 97 00 00 00  	auipc	ra, 0
   2304a: e7 80 40 33  	jalr	820(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   2304e: 37 15 01 00  	lui	a0, 17
   23052: 13 05 75 63  	addi	a0, a0, 1591
   23056: cd 45        	li	a1, 19
   23058: 81 46        	li	a3, 0
   2305a: 97 00 00 00  	auipc	ra, 0
   2305e: e7 80 00 32  	jalr	800(ra)
;     return @ptrCast(cast_target, bytes)[0..@divExact(bytes.len, @sizeOf(T))];
   23062: 37 15 01 00  	lui	a0, 17
   23066: 13 05 d5 74  	addi	a0, a0, 1869
   2306a: 93 05 10 02  	li	a1, 33
   2306e: 81 46        	li	a3, 0
   23070: 97 00 00 00  	auipc	ra, 0
   23074: e7 80 a0 30  	jalr	778(ra)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   23078: 37 25 01 00  	lui	a0, 18
   2307c: 13 05 a5 86  	addi	a0, a0, -1942
   23080: f9 45        	li	a1, 30
   23082: 81 46        	li	a3, 0
   23084: 97 00 00 00  	auipc	ra, 0
   23088: e7 80 60 2f  	jalr	758(ra)

000000000002308c <os.linux.riscv64.restore_rt>:
;         : [number] "{x17}" (@enumToInt(SYS.rt_sigreturn)),
   2308c: 93 08 b0 08  	li	a7, 139
   23090: 73 00 00 00  	ecall	
;     return asm volatile ("ecall"
   23094: 82 80        	ret

0000000000023096 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).capacity>:
;             if (self.metadata == null) return 0;
   23096: 08 61        	ld	a0, 0(a0)
   23098: 11 c5        	beqz	a0, 0x230a4 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).capacity+0xe>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   2309a: 93 75 75 00  	andi	a1, a0, 7
   2309e: 81 e5        	bnez	a1, 0x230a6 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).capacity+0x10>
;             return self.header().capacity;
   230a0: 03 25 85 ff  	lw	a0, -8(a0)
   230a4: 82 80        	ret
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   230a6: 37 15 01 00  	lui	a0, 17
   230aa: 13 05 75 63  	addi	a0, a0, 1591
   230ae: cd 45        	li	a1, 19
   230b0: 81 46        	li	a3, 0
   230b2: 97 00 00 00  	auipc	ra, 0
   230b6: e7 80 80 2c  	jalr	712(ra)

00000000000230ba <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768>:
;         pub fn containsAdapted(self: *const Self, key: anytype, ctx: anytype) bool {
   230ba: 41 11        	addi	sp, sp, -16
;             return self.getIndex(key, ctx) != null;
   230bc: 10 45        	lw	a2, 8(a0)
;             if (self.size == 0) {
   230be: 65 c2        	beqz	a2, 0x2319e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xe4>
   230c0: 03 33 05 00  	ld	t1, 0(a0)
;             if (self.metadata == null) return 0;
   230c4: 63 07 03 0e  	beqz	t1, 0x231b2 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xf8>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   230c8: 13 76 73 00  	andi	a2, t1, 7
   230cc: 6d ee        	bnez	a2, 0x231c6 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0x10c>
;             const mask = self.capacity() - 1;
   230ce: 03 26 83 ff  	lw	a2, -8(t1)
   230d2: 9b 08 f6 ff  	addiw	a7, a2, -1
   230d6: 63 6e 16 0d  	bltu	a2, a7, 0x231b2 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xf8>
   230da: 13 d8 05 02  	srli	a6, a1, 32
   230de: b7 57 02 00  	lui	a5, 37
   230e2: 83 b7 07 41  	ld	a5, 1040(a5)
   230e6: b7 56 02 00  	lui	a3, 37
   230ea: 83 b6 86 41  	ld	a3, 1048(a3)
   230ee: 13 97 05 02  	slli	a4, a1, 32
   230f2: 33 67 07 01  	or	a4, a4, a6
   230f6: 3d 8f        	xor	a4, a4, a5
   230f8: 33 08 d7 02  	mul	a6, a4, a3
   230fc: b7 57 02 00  	lui	a5, 37
   23100: 83 b7 07 42  	ld	a5, 1056(a5)
   23104: b3 36 d7 02  	mulhu	a3, a4, a3
   23108: b3 c6 06 01  	xor	a3, a3, a6
   2310c: 93 c6 86 00  	xori	a3, a3, 8
   23110: 33 87 f6 02  	mul	a4, a3, a5
   23114: b3 b6 f6 02  	mulhu	a3, a3, a5
   23118: b3 c2 e6 00  	xor	t0, a3, a4
;             var idx = @truncate(usize, hash & mask);
   2311c: 13 97 08 02  	slli	a4, a7, 32
   23120: 93 58 07 02  	srli	a7, a4, 32
   23124: b3 f7 12 01  	and	a5, t0, a7
   23128: 33 07 f3 00  	add	a4, t1, a5
;             while (!metadata[0].isFree() and limit != 0) {
   2312c: 03 47 07 00  	lbu	a4, 0(a4)
   23130: b7 26 01 00  	lui	a3, 18
   23134: 13 88 06 e4  	addi	a6, a3, -448
;             while (!metadata[0].isFree() and limit != 0) {
   23138: 29 cf        	beqz	a4, 0x23192 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xd8>
   2313a: 93 d2 92 03  	srli	t0, t0, 57
   2313e: 05 a0        	j	0x2315e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xa4>
;                 idx = (idx + 1) & mask;
   23140: 93 86 17 00  	addi	a3, a5, 1
   23144: b3 f7 16 01  	and	a5, a3, a7
   23148: b3 06 f3 00  	add	a3, t1, a5
;             while (!metadata[0].isFree() and limit != 0) {
   2314c: 03 c7 06 00  	lbu	a4, 0(a3)
;                 limit -= 1;
   23150: 7d 36        	addiw	a2, a2, -1
;             while (!metadata[0].isFree() and limit != 0) {
   23152: b3 36 e0 00  	snez	a3, a4
   23156: 33 35 c0 00  	snez	a0, a2
;             while (!metadata[0].isFree() and limit != 0) {
   2315a: 75 8d        	and	a0, a0, a3
   2315c: 1d c9        	beqz	a0, 0x23192 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0xd8>
;                 return self.used == 1;
   2315e: 93 16 87 03  	slli	a3, a4, 56
   23162: e1 96        	srai	a3, a3, 56
   23164: 93 a6 06 00  	slti	a3, a3, 0
   23168: 13 77 f7 07  	andi	a4, a4, 127
   2316c: 33 c7 e2 00  	xor	a4, t0, a4
   23170: 13 37 17 00  	seqz	a4, a4
;                 if (metadata[0].isUsed() and metadata[0].fingerprint == fingerprint) {
   23174: f9 8e        	and	a3, a3, a4
   23176: e9 d6        	beqz	a3, 0x23140 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0x86>
;             return self.header().keys;
   23178: 83 36 03 ff  	ld	a3, -16(t1)
;                     const test_key = &self.keys()[idx];
   2317c: 13 97 37 00  	slli	a4, a5, 3
   23180: ba 96        	add	a3, a3, a4
;                     const eql = ctx.eql(key, test_key.*);
   23182: 94 62        	ld	a3, 0(a3)
;                     if (eql) {
   23184: e3 9e b6 fa  	bne	a3, a1, 0x23140 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).containsAdapted__anon_6768+0x86>
;                         return idx;
   23188: 3e e0        	sd	a5, 0(sp)
   2318a: 05 45        	li	a0, 1
   2318c: 23 04 a1 00  	sb	a0, 8(sp)
   23190: 0a 88        	mv	a6, sp
;             return null;
   23192: 03 45 88 00  	lbu	a0, 8(a6)
   23196: 33 35 a0 00  	snez	a0, a0
;             return self.getIndex(key, ctx) != null;
   2319a: 41 01        	addi	sp, sp, 16
   2319c: 82 80        	ret
   2319e: 37 25 01 00  	lui	a0, 18
   231a2: 13 08 05 e4  	addi	a6, a0, -448
;             return null;
   231a6: 03 45 88 00  	lbu	a0, 8(a6)
   231aa: 33 35 a0 00  	snez	a0, a0
;             return self.getIndex(key, ctx) != null;
   231ae: 41 01        	addi	sp, sp, 16
   231b0: 82 80        	ret
;             const mask = self.capacity() - 1;
   231b2: 37 15 01 00  	lui	a0, 17
   231b6: 13 05 95 5d  	addi	a0, a0, 1497
   231ba: c1 45        	li	a1, 16
   231bc: 81 46        	li	a3, 0
   231be: 97 00 00 00  	auipc	ra, 0
   231c2: e7 80 c0 1b  	jalr	444(ra)
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   231c6: 37 15 01 00  	lui	a0, 17
   231ca: 13 05 75 63  	addi	a0, a0, 1591
   231ce: cd 45        	li	a1, 19
   231d0: 81 46        	li	a3, 0
   231d2: 97 00 00 00  	auipc	ra, 0
   231d6: e7 80 80 1a  	jalr	424(ra)

00000000000231da <math.ceilPowerOfTwo__anon_6902>:
; pub fn ceilPowerOfTwo(comptime T: type, value: T) (error{Overflow}!T) {
   231da: 41 11        	addi	sp, sp, -16
   231dc: 06 e4        	sd	ra, 8(sp)
   231de: 22 e0        	sd	s0, 0(sp)
   231e0: 9b 06 06 00  	sext.w	a3, a2
;     if (!ok) unreachable; // assertion failure
   231e4: dd c6        	beqz	a3, 0x23292 <math.ceilPowerOfTwo__anon_6902+0xb8>
   231e6: 2a 84        	mv	s0, a0
;     return @as(PromotedType, 1) << @intCast(ShiftType, @typeInfo(T).Int.bits - @clz(value - 1));
   231e8: 1b 05 f6 ff  	addiw	a0, a2, -1
   231ec: 51 c1        	beqz	a0, 0x23270 <math.ceilPowerOfTwo__anon_6902+0x96>
   231ee: 1b 56 15 00  	srliw	a2, a0, 1
   231f2: 51 8d        	or	a0, a0, a2
   231f4: 1b 56 25 00  	srliw	a2, a0, 2
   231f8: 51 8d        	or	a0, a0, a2
   231fa: 1b 56 45 00  	srliw	a2, a0, 4
   231fe: 51 8d        	or	a0, a0, a2
   23200: 1b 56 85 00  	srliw	a2, a0, 8
   23204: 51 8d        	or	a0, a0, a2
   23206: 1b 56 05 01  	srliw	a2, a0, 16
   2320a: 51 8d        	or	a0, a0, a2
   2320c: 13 45 f5 ff  	not	a0, a0
   23210: 13 56 15 00  	srli	a2, a0, 1
   23214: b7 56 55 55  	lui	a3, 349525
   23218: 9b 86 56 55  	addiw	a3, a3, 1365
   2321c: 75 8e        	and	a2, a2, a3
   2321e: 11 9d        	subw	a0, a0, a2
   23220: 37 36 33 33  	lui	a2, 209715
   23224: 1b 06 36 33  	addiw	a2, a2, 819
   23228: b3 76 c5 00  	and	a3, a0, a2
   2322c: 09 81        	srli	a0, a0, 2
   2322e: 71 8d        	and	a0, a0, a2
   23230: 36 95        	add	a0, a0, a3
   23232: 13 56 45 00  	srli	a2, a0, 4
   23236: 32 95        	add	a0, a0, a2
   23238: 37 16 0f 0f  	lui	a2, 61681
   2323c: 1b 06 f6 f0  	addiw	a2, a2, -241
   23240: 71 8d        	and	a0, a0, a2
   23242: 37 06 01 01  	lui	a2, 4112
   23246: 1b 06 16 10  	addiw	a2, a2, 257
   2324a: 3b 05 c5 02  	mulw	a0, a0, a2
   2324e: 1b 55 85 01  	srliw	a0, a0, 24
;     if (overflowBit & x != 0) {
   23252: 15 c1        	beqz	a0, 0x23276 <math.ceilPowerOfTwo__anon_6902+0x9c>
   23254: 93 05 00 02  	li	a1, 32
;     return @as(PromotedType, 1) << @intCast(ShiftType, @typeInfo(T).Int.bits - @clz(value - 1));
   23258: 33 85 a5 40  	sub	a0, a1, a0
   2325c: 85 45        	li	a1, 1
;     return @as(PromotedType, 1) << @intCast(ShiftType, @typeInfo(T).Int.bits - @clz(value - 1));
   2325e: 33 95 a5 00  	sll	a0, a1, a0
;     return @intCast(T, x);
   23262: 08 c0        	sw	a0, 0(s0)
   23264: 23 12 04 00  	sh	zero, 4(s0)
   23268: a2 60        	ld	ra, 8(sp)
   2326a: 02 64        	ld	s0, 0(sp)
   2326c: 41 01        	addi	sp, sp, 16
   2326e: 82 80        	ret
   23270: 13 05 00 02  	li	a0, 32
;     if (overflowBit & x != 0) {
   23274: 65 f1        	bnez	a0, 0x23254 <math.ceilPowerOfTwo__anon_6902+0x7a>
;         return error.Overflow;
   23276: 2e 85        	mv	a0, a1
   23278: 97 10 00 00  	auipc	ra, 1
   2327c: e7 80 00 98  	jalr	-1664(ra)
   23280: 13 05 00 03  	li	a0, 48
   23284: 48 c0        	sw	a0, 4(s0)
   23286: 23 20 04 00  	sw	zero, 0(s0)
   2328a: a2 60        	ld	ra, 8(sp)
   2328c: 02 64        	ld	s0, 0(sp)
   2328e: 41 01        	addi	sp, sp, 16
   23290: 82 80        	ret
;     if (!ok) unreachable; // assertion failure
   23292: 37 25 01 00  	lui	a0, 18
   23296: 13 05 b5 a7  	addi	a0, a0, -1413
   2329a: e1 45        	li	a1, 24
   2329c: 97 00 00 00  	auipc	ra, 0
   232a0: e7 80 e0 0d  	jalr	222(ra)

00000000000232a4 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate>:
;         fn deallocate(self: *Self, allocator: Allocator) void {
   232a4: 39 71        	addi	sp, sp, -64
;             if (self.metadata == null) return;
   232a6: 06 fc        	sd	ra, 56(sp)
   232a8: 22 f8        	sd	s0, 48(sp)
   232aa: 26 f4        	sd	s1, 40(sp)
   232ac: 4a f0        	sd	s2, 32(sp)
   232ae: 4e ec        	sd	s3, 24(sp)
   232b0: 52 e8        	sd	s4, 16(sp)
   232b2: 56 e4        	sd	s5, 8(sp)
   232b4: 14 61        	ld	a3, 0(a0)
   232b6: bd ca        	beqz	a3, 0x2332c <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0x88>
   232b8: aa 89        	mv	s3, a0
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   232ba: 13 f5 76 00  	andi	a0, a3, 7
   232be: 51 e9        	bnez	a0, 0x23352 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0xae>
;             const meta_size = @sizeOf(Header) + cap * @sizeOf(Metadata);
   232c0: 03 a6 86 ff  	lw	a2, -8(a3)
   232c4: 1b 05 86 01  	addiw	a0, a2, 24
   232c8: 63 6b c5 06  	bltu	a0, a2, 0x2333e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0x9a>
;             const keys_end = keys_start + cap * @sizeOf(K);
   232cc: 02 16        	slli	a2, a2, 32
   232ce: 75 82        	srli	a2, a2, 29
   232d0: 13 57 06 02  	srli	a4, a2, 32
   232d4: 2d e7        	bnez	a4, 0x2333e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0x9a>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   232d6: a1 16        	addi	a3, a3, -24
;             const slice = @intToPtr([*]align(max_align) u8, @ptrToInt(self.header()))[0..total_size];
   232d8: 13 f7 76 00  	andi	a4, a3, 7
   232dc: 3d eb        	bnez	a4, 0x23352 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0xae>
   232de: 06 89        	mv	s2, ra
   232e0: 81 44        	li	s1, 0
;             const keys_start = std.mem.alignForward(meta_size, key_align);
   232e2: 02 15        	slli	a0, a0, 32
   232e4: 01 91        	srli	a0, a0, 32
;     return alignBackwardGeneric(T, addr + (alignment - 1), alignment);
   232e6: 1d 05        	addi	a0, a0, 7
;     return addr & ~(alignment - 1);
   232e8: 61 99        	andi	a0, a0, -8
;             const vals_end = vals_start + cap * @sizeOf(V);
   232ea: 02 16        	slli	a2, a2, 32
   232ec: 7d 82        	srli	a2, a2, 31
   232ee: 32 95        	add	a0, a0, a2
   232f0: 21 44        	li	s0, 8
;     if (slice.len == 0 and comptime meta.sentinel(Slice) == null) {
   232f2: 19 c1        	beqz	a0, 0x232f8 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0x54>
   232f4: 36 84        	mv	s0, a3
   232f6: aa 84        	mv	s1, a0
;     if (bytes_len == 0) return;
   232f8: 95 c4        	beqz	s1, 0x23324 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0x80>
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   232fa: 35 c4        	beqz	s0, 0x23366 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).deallocate+0xc2>
   232fc: 03 ba 05 00  	ld	s4, 0(a1)
   23300: 83 ba 85 00  	ld	s5, 8(a1)
;     @memset(non_const_ptr, undefined, bytes_len);
   23304: 93 05 a0 0a  	li	a1, 170
   23308: 22 85        	mv	a0, s0
   2330a: 26 86        	mv	a2, s1
   2330c: 97 10 00 00  	auipc	ra, 1
   23310: e7 80 e0 f8  	jalr	-114(ra)
;     return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);
   23314: 83 b7 0a 01  	ld	a5, 16(s5)
   23318: 8d 46        	li	a3, 3
   2331a: 52 85        	mv	a0, s4
   2331c: a2 85        	mv	a1, s0
   2331e: 26 86        	mv	a2, s1
   23320: 4a 87        	mv	a4, s2
   23322: 82 97        	jalr	a5
;             self.metadata = null;
   23324: 23 b0 09 00  	sd	zero, 0(s3)
;             self.available = 0;
   23328: 23 a6 09 00  	sw	zero, 12(s3)
   2332c: e2 70        	ld	ra, 56(sp)
   2332e: 42 74        	ld	s0, 48(sp)
   23330: a2 74        	ld	s1, 40(sp)
   23332: 02 79        	ld	s2, 32(sp)
   23334: e2 69        	ld	s3, 24(sp)
   23336: 42 6a        	ld	s4, 16(sp)
   23338: a2 6a        	ld	s5, 8(sp)
   2333a: 21 61        	addi	sp, sp, 64
   2333c: 82 80        	ret
   2333e: 37 15 01 00  	lui	a0, 17
   23342: 13 05 95 5d  	addi	a0, a0, 1497
   23346: c1 45        	li	a1, 16
   23348: 81 46        	li	a3, 0
   2334a: 97 00 00 00  	auipc	ra, 0
   2334e: e7 80 00 03  	jalr	48(ra)
   23352: 37 15 01 00  	lui	a0, 17
   23356: 13 05 75 63  	addi	a0, a0, 1591
   2335a: cd 45        	li	a1, 19
   2335c: 81 46        	li	a3, 0
   2335e: 97 00 00 00  	auipc	ra, 0
   23362: e7 80 c0 01  	jalr	28(ra)
;     const non_const_ptr = @intToPtr([*]u8, @ptrToInt(bytes.ptr));
   23366: 37 25 01 00  	lui	a0, 18
   2336a: 13 05 a5 86  	addi	a0, a0, -1942
   2336e: f9 45        	li	a1, 30
   23370: 81 46        	li	a3, 0
   23372: 97 00 00 00  	auipc	ra, 0
   23376: e7 80 80 00  	jalr	8(ra)

000000000002337a <builtin.default_panic>:
; pub fn default_panic(msg: []const u8, error_return_trace: ?*StackTrace, ret_addr: ?usize) noreturn {
   2337a: 41 11        	addi	sp, sp, -16
   2337c: 13 f7 f6 0f  	andi	a4, a3, 255
   23380: ae 86        	mv	a3, a1
   23382: aa 85        	mv	a1, a0
;             const first_trace_addr = ret_addr orelse @returnAddress();
   23384: 11 e3        	bnez	a4, 0x23388 <builtin.default_panic+0xe>
   23386: 06 86        	mv	a2, ra
;             std.debug.panicImpl(error_return_trace, first_trace_addr, msg);
   23388: 32 e0        	sd	a2, 0(sp)
   2338a: 05 45        	li	a0, 1
   2338c: 23 04 a1 00  	sb	a0, 8(sp)
   23390: 0a 85        	mv	a0, sp
   23392: 36 86        	mv	a2, a3
   23394: 97 00 00 00  	auipc	ra, 0
   23398: e7 80 80 00  	jalr	8(ra)

000000000002339c <debug.panicImpl>:
; pub fn panicImpl(trace: ?*const std.builtin.StackTrace, first_trace_addr: ?usize, msg: []const u8) noreturn {
   2339c: 13 01 01 d0  	addi	sp, sp, -768
   233a0: 23 3c 11 2e  	sd	ra, 760(sp)
   233a4: 23 38 81 2e  	sd	s0, 752(sp)
   233a8: 23 34 91 2e  	sd	s1, 744(sp)
   233ac: 23 30 21 2f  	sd	s2, 736(sp)
   233b0: 23 3c 31 2d  	sd	s3, 728(sp)
   233b4: 23 38 41 2d  	sd	s4, 720(sp)
   233b8: 23 34 51 2d  	sd	s5, 712(sp)
   233bc: 23 30 61 2d  	sd	s6, 704(sp)
   233c0: 23 3c 71 2b  	sd	s7, 696(sp)
   233c4: 23 38 81 2b  	sd	s8, 688(sp)
   233c8: 00 06        	addi	s0, sp, 768
   233ca: b2 89        	mv	s3, a2
   233cc: 2e 8a        	mv	s4, a1
   233ce: 2a 89        	mv	s2, a0
   233d0: 13 05 04 d0  	addi	a0, s0, -768
   233d4: 23 34 a4 e0  	sd	a0, -504(s0)
   233d8: 13 05 00 02  	li	a0, 32
   233dc: 23 38 a4 e0  	sd	a0, -496(s0)
   233e0: 23 30 04 e0  	sd	zero, -512(s0)
   233e4: 93 05 84 e2  	addi	a1, s0, -472
   233e8: 23 38 b4 f2  	sd	a1, -208(s0)
   233ec: 23 3c a4 f2  	sd	a0, -200(s0)
   233f0: 23 34 04 f2  	sd	zero, -216(s0)
;             .handler = new.handler.handler,
   233f4: 23 38 04 f8  	sd	zero, -112(s0)
   233f8: 37 07 00 04  	lui	a4, 16384
;             .flags = new.flags | SA.RESTORER,
   233fc: 23 3c e4 f8  	sd	a4, -104(s0)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   23400: 37 35 02 00  	lui	a0, 35
   23404: 93 07 c5 08  	addi	a5, a0, 140
   23408: 23 30 f4 fa  	sd	a5, -96(s0)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   2340c: 23 34 04 fa  	sd	zero, -88(s0)
;     return asm volatile ("ecall"
   23410: 93 08 60 08  	li	a7, 134
   23414: 2d 45        	li	a0, 11
   23416: 93 05 04 f9  	addi	a1, s0, -112
   2341a: a1 46        	li	a3, 8
   2341c: 7d 76        	lui	a2, 1048575
   2341e: 9b 04 16 00  	addiw	s1, a2, 1
   23422: 01 46        	li	a2, 0
   23424: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23428: 63 74 95 08  	bgeu	a0, s1, 0x234b0 <debug.panicImpl+0x114>
;             .handler = new.handler.handler,
   2342c: 23 38 04 f8  	sd	zero, -112(s0)
;             .flags = new.flags | SA.RESTORER,
   23430: 23 3c e4 f8  	sd	a4, -104(s0)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   23434: 23 30 f4 fa  	sd	a5, -96(s0)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   23438: 23 34 04 fa  	sd	zero, -88(s0)
;     return asm volatile ("ecall"
   2343c: 93 08 60 08  	li	a7, 134
   23440: 11 45        	li	a0, 4
   23442: 93 05 04 f9  	addi	a1, s0, -112
   23446: a1 46        	li	a3, 8
   23448: 01 46        	li	a2, 0
   2344a: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   2344e: 63 71 95 06  	bgeu	a0, s1, 0x234b0 <debug.panicImpl+0x114>
;             .handler = new.handler.handler,
   23452: 23 38 04 f8  	sd	zero, -112(s0)
   23456: 37 07 00 04  	lui	a4, 16384
;             .flags = new.flags | SA.RESTORER,
   2345a: 23 3c e4 f8  	sd	a4, -104(s0)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   2345e: 37 35 02 00  	lui	a0, 35
   23462: 93 07 c5 08  	addi	a5, a0, 140
   23466: 23 30 f4 fa  	sd	a5, -96(s0)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   2346a: 23 34 04 fa  	sd	zero, -88(s0)
;     return asm volatile ("ecall"
   2346e: 93 08 60 08  	li	a7, 134
   23472: 1d 45        	li	a0, 7
   23474: 93 05 04 f9  	addi	a1, s0, -112
   23478: a1 46        	li	a3, 8
   2347a: 7d 76        	lui	a2, 1048575
   2347c: 9b 04 16 00  	addiw	s1, a2, 1
   23480: 01 46        	li	a2, 0
   23482: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23486: 63 75 95 02  	bgeu	a0, s1, 0x234b0 <debug.panicImpl+0x114>
;             .handler = new.handler.handler,
   2348a: 23 38 04 f8  	sd	zero, -112(s0)
;             .flags = new.flags | SA.RESTORER,
   2348e: 23 3c e4 f8  	sd	a4, -104(s0)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   23492: 23 30 f4 fa  	sd	a5, -96(s0)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   23496: 23 34 04 fa  	sd	zero, -88(s0)
;     return asm volatile ("ecall"
   2349a: 93 08 60 08  	li	a7, 134
   2349e: 21 45        	li	a0, 8
   234a0: 93 05 04 f9  	addi	a1, s0, -112
   234a4: a1 46        	li	a3, 8
   234a6: 01 46        	li	a2, 0
   234a8: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   234ac: 63 69 95 02  	bltu	a0, s1, 0x234de <debug.panicImpl+0x142>
   234b0: 3b 05 a0 40  	negw	a0, a0
   234b4: 42 15        	slli	a0, a0, 48
   234b6: 41 91        	srli	a0, a0, 48
   234b8: d9 45        	li	a1, 22
   234ba: 63 06 b5 00  	beq	a0, a1, 0x234c6 <debug.panicImpl+0x12a>
   234be: 93 05 60 02  	li	a1, 38
   234c2: 63 17 b5 70  	bne	a0, a1, 0x23bd0 <debug.panicImpl+0x834>
   234c6: 13 05 84 f2  	addi	a0, s0, -216
   234ca: 97 00 00 00  	auipc	ra, 0
   234ce: e7 80 e0 72  	jalr	1838(ra)
   234d2: 13 05 84 f2  	addi	a0, s0, -216
   234d6: 97 00 00 00  	auipc	ra, 0
   234da: e7 80 20 72  	jalr	1826(ra)
;     nosuspend switch (panic_stage) {
   234de: 37 05 00 00  	lui	a0, 0
   234e2: 33 05 45 00  	add	a0, a0, tp
   234e6: 83 35 05 00  	ld	a1, 0(a0)
   234ea: 63 94 05 42  	bnez	a1, 0x23912 <debug.panicImpl+0x576>
   234ee: 85 45        	li	a1, 1
;             panic_stage = 1;
   234f0: 23 30 b5 00  	sd	a1, 0(a0)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   234f4: 37 55 02 00  	lui	a0, 37
   234f8: 13 05 85 45  	addi	a0, a0, 1112
   234fc: 13 76 35 00  	andi	a2, a0, 3
   23500: 1b 16 36 00  	slliw	a2, a2, 3
   23504: 93 06 f0 0f  	li	a3, 255
   23508: bb 96 c6 00  	sllw	a3, a3, a2
   2350c: 3b 96 c5 00  	sllw	a2, a1, a2
   23510: 02 16        	slli	a2, a2, 32
   23512: 01 92        	srli	a2, a2, 32
   23514: 71 99        	andi	a0, a0, -4
   23516: 2f 27 05 16  	lr.w.aqrl	a4, (a0)
   2351a: b3 07 c7 00  	add	a5, a4, a2
   2351e: b9 8f        	xor	a5, a5, a4
   23520: f5 8f        	and	a5, a5, a3
   23522: b9 8f        	xor	a5, a5, a4
   23524: af 27 f5 1e  	sc.w.aqrl	a5, a5, (a0)
   23528: fd f7        	bnez	a5, 0x23516 <debug.panicImpl+0x17a>
;                 false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),
   2352a: 37 55 02 00  	lui	a0, 37
   2352e: 13 05 c5 45  	addi	a0, a0, 1116
   23532: 2f 26 05 14  	lr.w.aq	a2, (a0)
   23536: 01 e6        	bnez	a2, 0x2353e <debug.panicImpl+0x1a2>
   23538: af 26 b5 18  	sc.w	a3, a1, (a0)
   2353c: fd fa        	bnez	a3, 0x23532 <debug.panicImpl+0x196>
;         return @field(self.state, casFn)(unlocked, locked, .Acquire, .Monotonic) == null;
   2353e: 09 c6        	beqz	a2, 0x23548 <debug.panicImpl+0x1ac>
;             self.lockSlow();
   23540: 97 10 00 00  	auipc	ra, 1
   23544: e7 80 80 a6  	jalr	-1432(ra)
;         return tls_thread_id orelse {
   23548: 37 05 00 00  	lui	a0, 0
   2354c: b3 05 45 00  	add	a1, a0, tp
   23550: 03 c5 c5 00  	lbu	a0, 12(a1)
   23554: 09 46        	li	a2, 2
;                 const stderr = io.getStdErr().writer();
   23556: 23 2c c4 e0  	sw	a2, -488(s0)
;         return tls_thread_id orelse {
   2355a: 01 c9        	beqz	a0, 0x2356a <debug.panicImpl+0x1ce>
   2355c: 37 05 00 00  	lui	a0, 0
   23560: 33 05 45 00  	add	a0, a0, tp
   23564: 83 2a 85 00  	lw	s5, 8(a0)
   23568: 39 a8        	j	0x23586 <debug.panicImpl+0x1ea>
;     return asm volatile ("ecall"
   2356a: 93 08 20 0b  	li	a7, 178
   2356e: 73 00 00 00  	ecall	
   23572: aa 8a        	mv	s5, a0
;             tls_thread_id = tid;
   23574: 37 05 00 00  	lui	a0, 0
   23578: 33 05 45 00  	add	a0, a0, tp
   2357c: 23 24 55 01  	sw	s5, 8(a0)
   23580: 05 45        	li	a0, 1
   23582: 23 86 a5 00  	sb	a0, 12(a1)
   23586: 81 44        	li	s1, 0
   23588: 21 4b        	li	s6, 8
   2358a: 37 25 01 00  	lui	a0, 18
   2358e: 93 0b a5 ce  	addi	s7, a0, -790
   23592: 1d 4c        	li	s8, 7
;                 index += try self.write(bytes[index..]);
   23594: 63 fd 64 3d  	bgeu	s1, s6, 0x2396e <debug.panicImpl+0x5d2>
   23598: b3 86 9b 00  	add	a3, s7, s1
   2359c: 33 07 9c 40  	sub	a4, s8, s1
;             return writeFn(self.context, bytes);
   235a0: 13 05 84 e2  	addi	a0, s0, -472
   235a4: 93 05 04 e0  	addi	a1, s0, -512
   235a8: 09 46        	li	a2, 2
   235aa: 97 10 ff ff  	auipc	ra, 1048561
   235ae: e7 80 20 8b  	jalr	-1870(ra)
   235b2: 03 55 04 e3  	lhu	a0, -464(s0)
   235b6: 63 12 05 32  	bnez	a0, 0x238da <debug.panicImpl+0x53e>
   235ba: 03 35 84 e2  	ld	a0, -472(s0)
;                 index += try self.write(bytes[index..]);
   235be: 26 95        	add	a0, a0, s1
   235c0: 63 62 95 3c  	bltu	a0, s1, 0x23984 <debug.panicImpl+0x5e8>
   235c4: aa 84        	mv	s1, a0
;             while (index != bytes.len) {
   235c6: e3 17 85 fd  	bne	a0, s8, 0x23594 <debug.panicImpl+0x1f8>
   235ca: 37 55 02 00  	lui	a0, 37
   235ce: 03 35 85 2e  	ld	a0, 744(a0)
   235d2: 93 05 a0 fa  	li	a1, -86
;     var buf: [1 + math.max(value_info.bits, 1)]u8 = undefined;
   235d6: 23 04 b4 e4  	sb	a1, -440(s0)
   235da: 23 30 a4 e4  	sd	a0, -448(s0)
   235de: 23 3c a4 e2  	sd	a0, -456(s0)
   235e2: 23 38 a4 e2  	sd	a0, -464(s0)
   235e6: 23 34 a4 e2  	sd	a0, -472(s0)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   235ea: 9b 85 0a 00  	sext.w	a1, s5
   235ee: 93 07 40 06  	li	a5, 100
   235f2: 93 06 10 02  	li	a3, 33
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   235f6: 63 e9 f5 12  	bltu	a1, a5, 0x23728 <debug.panicImpl+0x38c>
   235fa: 37 85 eb 51  	lui	a0, 335544
   235fe: 1b 07 f5 51  	addiw	a4, a0, 1311
   23602: 13 16 07 02  	slli	a2, a4, 32
   23606: 13 98 0a 02  	slli	a6, s5, 32
   2360a: 33 36 c8 02  	mulhu	a2, a6, a2
   2360e: 15 92        	srli	a2, a2, 37
   23610: bb 06 f6 02  	mulw	a3, a2, a5
   23614: bb 86 da 40  	subw	a3, s5, a3
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   23618: 86 16        	slli	a3, a3, 33
   2361a: 81 92        	srli	a3, a3, 32
   2361c: b7 27 01 00  	lui	a5, 18
   23620: 93 87 27 c0  	addi	a5, a5, -1022
   23624: be 96        	add	a3, a3, a5
;     return ("0001020304050607080910111213141516171819" ++
   23626: 83 84 16 00  	lb	s1, 1(a3)
   2362a: 83 c6 06 00  	lbu	a3, 0(a3)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   2362e: 23 04 94 e4  	sb	s1, -440(s0)
   23632: a3 03 d4 e4  	sb	a3, -441(s0)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   23636: 9b d4 4a 00  	srliw	s1, s5, 4
   2363a: 13 05 10 27  	li	a0, 625
   2363e: fd 46        	li	a3, 31
   23640: 63 e3 a4 0e  	bltu	s1, a0, 0x23726 <debug.panicImpl+0x38a>
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   23644: 33 05 e6 02  	mul	a0, a2, a4
   23648: 15 91        	srli	a0, a0, 37
   2364a: 13 07 40 06  	li	a4, 100
   2364e: 3b 05 e5 02  	mulw	a0, a0, a4
   23652: 3b 05 a6 40  	subw	a0, a2, a0
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   23656: 06 15        	slli	a0, a0, 33
   23658: 01 91        	srli	a0, a0, 32
   2365a: 3e 95        	add	a0, a0, a5
;     return ("0001020304050607080910111213141516171819" ++
   2365c: 03 06 15 00  	lb	a2, 1(a0)
   23660: 03 45 05 00  	lbu	a0, 0(a0)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   23664: 23 03 c4 e4  	sb	a2, -442(s0)
   23668: a3 02 a4 e4  	sb	a0, -443(s0)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   2366c: 37 15 b7 d1  	lui	a0, 858993
   23670: 1b 05 95 75  	addiw	a0, a0, 1881
   23674: 02 15        	slli	a0, a0, 32
   23676: 33 35 a8 02  	mulhu	a0, a6, a0
   2367a: 13 56 d5 02  	srli	a2, a0, 45
   2367e: 37 45 0f 00  	lui	a0, 244
   23682: 1b 05 05 24  	addiw	a0, a0, 576
   23686: f5 46        	li	a3, 29
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   23688: 63 ef a5 08  	bltu	a1, a0, 0x23726 <debug.panicImpl+0x38a>
   2368c: 37 85 eb 51  	lui	a0, 335544
   23690: 1b 05 f5 51  	addiw	a0, a0, 1311
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   23694: 33 05 a6 02  	mul	a0, a2, a0
   23698: 15 91        	srli	a0, a0, 37
   2369a: 3b 05 e5 02  	mulw	a0, a0, a4
   2369e: 3b 05 a6 40  	subw	a0, a2, a0
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   236a2: 06 15        	slli	a0, a0, 33
   236a4: 01 91        	srli	a0, a0, 32
   236a6: 37 26 01 00  	lui	a2, 18
   236aa: 13 07 26 c0  	addi	a4, a2, -1022
   236ae: 3a 95        	add	a0, a0, a4
;     return ("0001020304050607080910111213141516171819" ++
   236b0: 03 06 15 00  	lb	a2, 1(a0)
   236b4: 03 45 05 00  	lbu	a0, 0(a0)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   236b8: 23 02 c4 e4  	sb	a2, -444(s0)
   236bc: a3 01 a4 e4  	sb	a0, -445(s0)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   236c0: 37 e5 1b 43  	lui	a0, 274878
   236c4: 1b 05 35 e8  	addiw	a0, a0, -381
   236c8: 02 15        	slli	a0, a0, 32
   236ca: 33 35 a8 02  	mulhu	a0, a6, a0
   236ce: 13 56 25 03  	srli	a2, a0, 50
   236d2: 37 e5 f5 05  	lui	a0, 24414
   236d6: 1b 05 05 10  	addiw	a0, a0, 256
   236da: ed 46        	li	a3, 27
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   236dc: 63 e5 a5 04  	bltu	a1, a0, 0x23726 <debug.panicImpl+0x38a>
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   236e0: 13 55 26 00  	srli	a0, a2, 2
   236e4: 85 65        	lui	a1, 1
   236e6: 9b 85 b5 47  	addiw	a1, a1, 1147
   236ea: 33 05 b5 02  	mul	a0, a0, a1
   236ee: 45 81        	srli	a0, a0, 17
   236f0: 93 05 40 06  	li	a1, 100
   236f4: 3b 05 b5 02  	mulw	a0, a0, a1
   236f8: 3b 05 a6 40  	subw	a0, a2, a0
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   236fc: 46 15        	slli	a0, a0, 49
   236fe: 41 91        	srli	a0, a0, 48
   23700: 3a 95        	add	a0, a0, a4
;     return ("0001020304050607080910111213141516171819" ++
   23702: 83 05 15 00  	lb	a1, 1(a0)
   23706: 03 45 05 00  	lbu	a0, 0(a0)
;             buf[index..][0..2].* = digits2(@intCast(usize, a % 100));
   2370a: 23 01 b4 e4  	sb	a1, -446(s0)
   2370e: a3 00 a4 e4  	sb	a0, -447(s0)
;         while (a >= 100) : (a = @divTrunc(a, 100)) {
   23712: 37 45 e6 55  	lui	a0, 351844
   23716: 1b 05 95 b8  	addiw	a0, a0, -1143
   2371a: 02 15        	slli	a0, a0, 32
   2371c: 33 35 a8 02  	mulhu	a0, a6, a0
   23720: 13 56 95 03  	srli	a2, a0, 57
   23724: e5 46        	li	a3, 25
   23726: b2 8a        	mv	s5, a2
;         if (a < 10) {
   23728: 1b 85 0a 00  	sext.w	a0, s5
   2372c: a5 45        	li	a1, 9
   2372e: 63 e2 a5 02  	bltu	a1, a0, 0x23752 <debug.panicImpl+0x3b6>
;             index -= 1;
   23732: 13 85 f6 ff  	addi	a0, a3, -1
   23736: 63 e7 a6 24  	bltu	a3, a0, 0x23984 <debug.panicImpl+0x5e8>
   2373a: 93 05 10 02  	li	a1, 33
;             buf[index] = '0' + @intCast(u8, a);
   2373e: 63 73 b5 4a  	bgeu	a0, a1, 0x23be4 <debug.panicImpl+0x848>
   23742: 9b 85 0a 03  	addiw	a1, s5, 48
   23746: 13 06 84 e2  	addi	a2, s0, -472
   2374a: 2a 96        	add	a2, a2, a0
   2374c: 23 00 b6 00  	sb	a1, 0(a2)
   23750: 25 a8        	j	0x23788 <debug.panicImpl+0x3ec>
;             index -= 2;
   23752: 13 85 e6 ff  	addi	a0, a3, -2
   23756: 63 e7 a6 22  	bltu	a3, a0, 0x23984 <debug.panicImpl+0x5e8>
   2375a: 93 05 20 02  	li	a1, 34
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   2375e: 63 78 b5 20  	bgeu	a0, a1, 0x2396e <debug.panicImpl+0x5d2>
;         "8081828384858687888990919293949596979899")[value * 2 ..][0..2].*;
   23762: 93 95 0a 02  	slli	a1, s5, 32
   23766: fd 81        	srli	a1, a1, 31
   23768: 37 26 01 00  	lui	a2, 18
   2376c: 13 06 26 c0  	addi	a2, a2, -1022
   23770: b2 95        	add	a1, a1, a2
;     return ("0001020304050607080910111213141516171819" ++
   23772: 03 86 15 00  	lb	a2, 1(a1)
   23776: 83 c5 05 00  	lbu	a1, 0(a1)
   2377a: 93 06 84 e2  	addi	a3, s0, -472
;             buf[index..][0..2].* = digits2(@intCast(usize, a));
   2377e: aa 96        	add	a3, a3, a0
   23780: a3 80 c6 00  	sb	a2, 1(a3)
   23784: 23 80 b6 00  	sb	a1, 0(a3)
   23788: 93 05 84 e2  	addi	a1, s0, -472
;     return formatBuf(buf[index..], options, writer);
   2378c: aa 95        	add	a1, a1, a0
   2378e: 13 06 10 02  	li	a2, 33
   23792: 09 8e        	sub	a2, a2, a0
   23794: 37 15 01 00  	lui	a0, 17
   23798: 93 06 85 11  	addi	a3, a0, 280
   2379c: 13 05 04 e0  	addi	a0, s0, -512
   237a0: 13 07 84 e1  	addi	a4, s0, -488
   237a4: 97 e0 ff ff  	auipc	ra, 1048574
   237a8: e7 80 c0 58  	jalr	1420(ra)
   237ac: 42 15        	slli	a0, a0, 48
   237ae: 41 91        	srli	a0, a0, 48
   237b0: 63 19 05 10  	bnez	a0, 0x238c2 <debug.panicImpl+0x526>
   237b4: 81 44        	li	s1, 0
   237b6: a5 4a        	li	s5, 9
   237b8: 37 25 01 00  	lui	a0, 18
   237bc: 13 0b a5 ce  	addi	s6, a0, -790
   237c0: a1 4b        	li	s7, 8
;                 index += try self.write(bytes[index..]);
   237c2: 63 f6 54 1b  	bgeu	s1, s5, 0x2396e <debug.panicImpl+0x5d2>
   237c6: 33 05 9b 00  	add	a0, s6, s1
   237ca: 93 06 95 00  	addi	a3, a0, 9
   237ce: 33 87 9b 40  	sub	a4, s7, s1
;             return writeFn(self.context, bytes);
   237d2: 13 05 84 e2  	addi	a0, s0, -472
   237d6: 93 05 04 e0  	addi	a1, s0, -512
   237da: 09 46        	li	a2, 2
   237dc: 97 00 ff ff  	auipc	ra, 1048560
   237e0: e7 80 00 68  	jalr	1664(ra)
   237e4: 03 55 04 e3  	lhu	a0, -464(s0)
   237e8: 6d e9        	bnez	a0, 0x238da <debug.panicImpl+0x53e>
   237ea: 03 35 84 e2  	ld	a0, -472(s0)
;                 index += try self.write(bytes[index..]);
   237ee: 26 95        	add	a0, a0, s1
   237f0: 63 6a 95 18  	bltu	a0, s1, 0x23984 <debug.panicImpl+0x5e8>
   237f4: aa 84        	mv	s1, a0
;             while (index != bytes.len) {
   237f6: e3 16 75 fd  	bne	a0, s7, 0x237c2 <debug.panicImpl+0x426>
;                             return formatBuf(value, options, writer);
   237fa: 37 15 01 00  	lui	a0, 17
   237fe: 93 06 85 11  	addi	a3, a0, 280
   23802: 13 05 04 e0  	addi	a0, s0, -512
   23806: 13 07 84 e1  	addi	a4, s0, -488
   2380a: d2 85        	mv	a1, s4
   2380c: 4e 86        	mv	a2, s3
   2380e: 97 e0 ff ff  	auipc	ra, 1048574
   23812: e7 80 20 52  	jalr	1314(ra)
   23816: 42 15        	slli	a0, a0, 48
   23818: 41 91        	srli	a0, a0, 48
   2381a: 71 e5        	bnez	a0, 0x238e6 <debug.panicImpl+0x54a>
   2381c: b7 25 01 00  	lui	a1, 18
   23820: 93 84 55 db  	addi	s1, a1, -587
;             while (index != bytes.len) {
   23824: 15 e1        	bnez	a0, 0x23848 <debug.panicImpl+0x4ac>
;             return writeFn(self.context, bytes);
   23826: 13 05 84 e2  	addi	a0, s0, -472
   2382a: 93 05 04 e0  	addi	a1, s0, -512
   2382e: 09 46        	li	a2, 2
   23830: 05 47        	li	a4, 1
   23832: a6 86        	mv	a3, s1
   23834: 97 00 ff ff  	auipc	ra, 1048560
   23838: e7 80 80 62  	jalr	1576(ra)
   2383c: 03 55 04 e3  	lhu	a0, -464(s0)
   23840: 49 ed        	bnez	a0, 0x238da <debug.panicImpl+0x53e>
   23842: 03 35 84 e2  	ld	a0, -472(s0)
;             while (index != bytes.len) {
   23846: 65 d1        	beqz	a0, 0x23826 <debug.panicImpl+0x48a>
   23848: 85 45        	li	a1, 1
;             while (index != bytes.len) {
   2384a: 63 12 b5 12  	bne	a0, a1, 0x2396e <debug.panicImpl+0x5d2>
   2384e: 13 05 84 e2  	addi	a0, s0, -472
   23852: 23 38 a4 f2  	sd	a0, -208(s0)
   23856: 13 05 00 02  	li	a0, 32
   2385a: 23 3c a4 f2  	sd	a0, -200(s0)
;     if (self_debug_info) |*info| {
   2385e: 37 95 02 00  	lui	a0, 41
   23862: 03 45 05 13  	lbu	a0, 304(a0)
   23866: 89 45        	li	a1, 2
;         return .{ .context = file };
   23868: 23 20 b4 f4  	sw	a1, -192(s0)
;         const stderr = io.getStdErr().writer();
   2386c: 23 24 b4 f4  	sw	a1, -184(s0)
   23870: 23 34 04 f2  	sd	zero, -216(s0)
   23874: 63 15 05 14  	bnez	a0, 0x239be <debug.panicImpl+0x622>
;     if (debug_info_allocator) |a| return a;
   23878: 37 96 02 00  	lui	a2, 41
   2387c: 93 05 86 13  	addi	a1, a2, 312
   23880: 03 c5 05 01  	lbu	a0, 16(a1)
   23884: 63 1a 05 10  	bnez	a0, 0x23998 <debug.panicImpl+0x5fc>
;             return .{
   23888: 37 15 01 00  	lui	a0, 17
   2388c: 83 36 85 00  	ld	a3, 8(a0)
   23890: 13 05 85 00  	addi	a0, a0, 8
   23894: 18 65        	ld	a4, 8(a0)
;         return (State{}).promote(child_allocator);
   23896: 37 95 02 00  	lui	a0, 41
   2389a: 23 38 d5 14  	sd	a3, 336(a0)
   2389e: 13 05 05 15  	addi	a0, a0, 336
   238a2: 23 38 05 00  	sd	zero, 16(a0)
   238a6: 23 3c 05 00  	sd	zero, 24(a0)
   238aa: 18 e5        	sd	a4, 8(a0)
;     debug_info_allocator = allocator;
   238ac: 23 3c a6 12  	sd	a0, 312(a2)
   238b0: 37 16 01 00  	lui	a2, 17
   238b4: 13 06 06 02  	addi	a2, a2, 32
   238b8: 90 e5        	sd	a2, 8(a1)
   238ba: 85 46        	li	a3, 1
   238bc: 23 88 d5 00  	sb	a3, 16(a1)
   238c0: f9 a8        	j	0x2399e <debug.panicImpl+0x602>
;     return formatBuf(buf[index..], options, writer);
   238c2: 13 05 04 e0  	addi	a0, s0, -512
   238c6: 97 00 00 00  	auipc	ra, 0
   238ca: e7 80 20 33  	jalr	818(ra)
;     return formatInt(int_value, radix, case, options, writer);
   238ce: 13 05 04 e0  	addi	a0, s0, -512
   238d2: 97 00 00 00  	auipc	ra, 0
   238d6: e7 80 60 32  	jalr	806(ra)
   238da: 13 05 04 e0  	addi	a0, s0, -512
   238de: 97 00 00 00  	auipc	ra, 0
   238e2: e7 80 a0 31  	jalr	794(ra)
   238e6: 13 05 04 e0  	addi	a0, s0, -512
   238ea: 97 00 00 00  	auipc	ra, 0
   238ee: e7 80 e0 30  	jalr	782(ra)
   238f2: 13 05 04 e0  	addi	a0, s0, -512
   238f6: 97 00 00 00  	auipc	ra, 0
   238fa: e7 80 20 30  	jalr	770(ra)
   238fe: 13 05 04 e0  	addi	a0, s0, -512
   23902: 97 00 00 00  	auipc	ra, 0
   23906: e7 80 60 2f  	jalr	758(ra)
   2390a: 97 00 00 00  	auipc	ra, 0
   2390e: e7 80 40 4e  	jalr	1252(ra)
   23912: 05 45        	li	a0, 1
   23914: 63 92 a5 26  	bne	a1, a0, 0x23b78 <debug.panicImpl+0x7dc>
   23918: 81 44        	li	s1, 0
;             panic_stage = 2;
   2391a: 37 05 00 00  	lui	a0, 0
   2391e: 33 05 45 00  	add	a0, a0, tp
   23922: 89 45        	li	a1, 2
   23924: 23 30 b5 00  	sd	a1, 0(a0)
   23928: 13 09 40 02  	li	s2, 36
   2392c: 37 25 01 00  	lui	a0, 18
   23930: 93 09 75 dd  	addi	s3, a0, -553
   23934: 13 0a 30 02  	li	s4, 35
   23938: 63 fb 24 03  	bgeu	s1, s2, 0x2396e <debug.panicImpl+0x5d2>
;                 index += try self.write(bytes[index..]);
   2393c: b3 86 99 00  	add	a3, s3, s1
   23940: 33 07 9a 40  	sub	a4, s4, s1
;             return writeFn(self.context, bytes);
   23944: 13 05 84 e2  	addi	a0, s0, -472
   23948: 93 05 04 e0  	addi	a1, s0, -512
   2394c: 09 46        	li	a2, 2
   2394e: 97 00 ff ff  	auipc	ra, 1048560
   23952: e7 80 e0 50  	jalr	1294(ra)
   23956: 03 55 04 e3  	lhu	a0, -464(s0)
   2395a: 41 f1        	bnez	a0, 0x238da <debug.panicImpl+0x53e>
   2395c: 03 35 84 e2  	ld	a0, -472(s0)
;                 index += try self.write(bytes[index..]);
   23960: 26 95        	add	a0, a0, s1
   23962: 63 61 95 02  	bltu	a0, s1, 0x23984 <debug.panicImpl+0x5e8>
   23966: aa 84        	mv	s1, a0
   23968: e3 18 45 fd  	bne	a0, s4, 0x23938 <debug.panicImpl+0x59c>
   2396c: 31 a4        	j	0x23b78 <debug.panicImpl+0x7dc>
   2396e: 37 15 01 00  	lui	a0, 17
   23972: 13 05 45 5b  	addi	a0, a0, 1460
   23976: 93 05 40 02  	li	a1, 36
   2397a: 81 46        	li	a3, 0
   2397c: 97 00 00 00  	auipc	ra, 0
   23980: e7 80 e0 9f  	jalr	-1538(ra)
   23984: 37 15 01 00  	lui	a0, 17
   23988: 13 05 95 5d  	addi	a0, a0, 1497
   2398c: c1 45        	li	a1, 16
   2398e: 81 46        	li	a3, 0
   23990: 97 00 00 00  	auipc	ra, 0
   23994: e7 80 a0 9e  	jalr	-1558(ra)
;     if (debug_info_allocator) |a| return a;
   23998: 03 35 86 13  	ld	a0, 312(a2)
   2399c: 90 65        	ld	a2, 8(a1)
;             return .{
   2399e: b7 95 02 00  	lui	a1, 41
   239a2: 93 86 05 10  	addi	a3, a1, 256
   239a6: 23 bc 06 00  	sd	zero, 24(a3)
   239aa: 23 b8 06 00  	sd	zero, 16(a3)
;         self_debug_info = try openSelfDebugInfo(getDebugInfoAllocator());
   239ae: 23 b0 a5 10  	sd	a0, 256(a1)
   239b2: 90 e6        	sd	a2, 8(a3)
   239b4: 88 f2        	sd	a0, 32(a3)
   239b6: 90 f6        	sd	a2, 40(a3)
   239b8: 05 45        	li	a0, 1
   239ba: 23 88 a6 02  	sb	a0, 48(a3)
;         return os.getenv(key) != null;
   239be: 37 25 01 00  	lui	a0, 18
   239c2: 13 05 c5 bd  	addi	a0, a0, -1060
   239c6: bd 45        	li	a1, 15
   239c8: 97 f0 ff ff  	auipc	ra, 1048575
   239cc: e7 80 e0 b1  	jalr	-1250(ra)
;     } else if (process.hasEnvVarConstant("ZIG_DEBUG_COLOR")) {
   239d0: 15 e5        	bnez	a0, 0x239fc <debug.panicImpl+0x660>
;         return os.getenv(key) != null;
   239d2: 37 25 01 00  	lui	a0, 18
   239d6: 13 05 35 bd  	addi	a0, a0, -1069
   239da: a1 45        	li	a1, 8
   239dc: 97 f0 ff ff  	auipc	ra, 1048575
   239e0: e7 80 a0 b0  	jalr	-1270(ra)
;     } else if (process.hasEnvVarConstant("NO_COLOR")) {
   239e4: 1d e1        	bnez	a0, 0x23a0a <debug.panicImpl+0x66e>
   239e6: 09 45        	li	a0, 2
;     } else if (file.supportsAnsiEscapeCodes()) {
   239e8: 23 28 a4 f8  	sw	a0, -112(s0)
   239ec: 13 05 04 f9  	addi	a0, s0, -112
   239f0: 97 e0 ff ff  	auipc	ra, 1048574
   239f4: e7 80 20 a1  	jalr	-1518(ra)
   239f8: 05 89        	andi	a0, a0, 1
   239fa: 01 c9        	beqz	a0, 0x23a0a <debug.panicImpl+0x66e>
   239fc: 37 15 01 00  	lui	a0, 17
   23a00: 03 05 85 01  	lb	a0, 24(a0)
   23a04: a3 07 a4 f4  	sb	a0, -177(s0)
   23a08: 19 a0        	j	0x23a0e <debug.panicImpl+0x672>
   23a0a: a3 07 04 f4  	sb	zero, -177(s0)
;         return StackIterator{
   23a0e: 03 35 89 00  	ld	a0, 8(s2)
   23a12: 23 3c a4 f8  	sd	a0, -104(s0)
   23a16: 03 35 09 00  	ld	a0, 0(s2)
   23a1a: 23 38 a4 f8  	sd	a0, -112(s0)
;     var it = StackIterator.init(start_addr, null);
   23a1e: 23 30 84 fa  	sd	s0, -96(s0)
   23a22: 37 95 02 00  	lui	a0, 41
   23a26: 13 09 05 10  	addi	s2, a0, 256
   23a2a: 0d a0        	j	0x23a4c <debug.panicImpl+0x6b0>
;         try printSourceAtAddress(debug_info, out_stream, address, tty_config);
   23a2c: 13 05 84 f2  	addi	a0, s0, -216
   23a30: 13 06 04 f4  	addi	a2, s0, -192
   23a34: 13 07 f4 f4  	addi	a4, s0, -177
   23a38: ca 85        	mv	a1, s2
   23a3a: 97 90 ff ff  	auipc	ra, 1048569
   23a3e: e7 80 20 ec  	jalr	-318(ra)
   23a42: 93 14 05 03  	slli	s1, a0, 48
   23a46: 13 d5 04 03  	srli	a0, s1, 48
   23a4a: 31 ed        	bnez	a0, 0x23aa6 <debug.panicImpl+0x70a>
;         var address = self.next_internal() orelse return null;
   23a4c: 13 05 04 f5  	addi	a0, s0, -176
   23a50: 93 05 04 f9  	addi	a1, s0, -112
   23a54: 97 e0 ff ff  	auipc	ra, 1048574
   23a58: e7 80 e0 7a  	jalr	1966(ra)
   23a5c: 03 45 84 f5  	lbu	a0, -168(s0)
   23a60: 51 c9        	beqz	a0, 0x23af4 <debug.panicImpl+0x758>
;         if (self.first_address) |first_address| {
   23a62: 83 45 84 f9  	lbu	a1, -104(s0)
;         var address = self.next_internal() orelse return null;
   23a66: 03 35 04 f5  	ld	a0, -176(s0)
;         if (self.first_address) |first_address| {
   23a6a: 8d c9        	beqz	a1, 0x23a9c <debug.panicImpl+0x700>
   23a6c: 83 34 04 f9  	ld	s1, -112(s0)
;             while (address != first_address) {
   23a70: 63 02 95 02  	beq	a0, s1, 0x23a94 <debug.panicImpl+0x6f8>
;                 address = self.next_internal() orelse return null;
   23a74: 13 05 04 f6  	addi	a0, s0, -160
   23a78: 93 05 04 f9  	addi	a1, s0, -112
   23a7c: 97 e0 ff ff  	auipc	ra, 1048574
   23a80: e7 80 60 78  	jalr	1926(ra)
   23a84: 03 45 84 f6  	lbu	a0, -152(s0)
   23a88: 35 c5        	beqz	a0, 0x23af4 <debug.panicImpl+0x758>
   23a8a: 03 35 04 f6  	ld	a0, -160(s0)
;             while (address != first_address) {
   23a8e: e3 13 95 fe  	bne	a0, s1, 0x23a74 <debug.panicImpl+0x6d8>
   23a92: 26 85        	mv	a0, s1
;             self.first_address = null;
   23a94: 23 3c 04 f8  	sd	zero, -104(s0)
   23a98: 23 38 04 f8  	sd	zero, -112(s0)
   23a9c: 81 46        	li	a3, 0
;         const address = if (return_address == 0) return_address else return_address - 1;
   23a9e: 59 d5        	beqz	a0, 0x23a2c <debug.panicImpl+0x690>
   23aa0: 93 06 f5 ff  	addi	a3, a0, -1
   23aa4: 61 b7        	j	0x23a2c <debug.panicImpl+0x690>
;         try printSourceAtAddress(debug_info, out_stream, address, tty_config);
   23aa6: 13 05 84 f2  	addi	a0, s0, -216
   23aaa: 97 00 00 00  	auipc	ra, 0
   23aae: e7 80 e0 14  	jalr	334(ra)
;             stderr.print("Unable to dump stack trace: {s}\n", .{@errorName(err)}) catch return;
   23ab2: 13 d5 04 43  	srai	a0, s1, 48
   23ab6: b7 15 01 00  	lui	a1, 17
   23aba: 93 85 05 14  	addi	a1, a1, 320
   23abe: 12 05        	slli	a0, a0, 4
   23ac0: 2e 95        	add	a0, a0, a1
   23ac2: 0c 61        	ld	a1, 0(a0)
   23ac4: 08 65        	ld	a0, 8(a0)
   23ac6: 23 38 b4 f8  	sd	a1, -112(s0)
   23aca: 23 3c a4 f8  	sd	a0, -104(s0)
;             return std.fmt.format(self, format, args);
   23ace: 13 05 84 f2  	addi	a0, s0, -216
   23ad2: 93 05 84 f4  	addi	a1, s0, -184
   23ad6: 13 06 04 f9  	addi	a2, s0, -112
   23ada: 97 e0 ff ff  	auipc	ra, 1048574
   23ade: e7 80 00 14  	jalr	320(ra)
   23ae2: 42 15        	slli	a0, a0, 48
   23ae4: 41 91        	srli	a0, a0, 48
   23ae6: 19 c5        	beqz	a0, 0x23af4 <debug.panicImpl+0x758>
   23ae8: 13 05 84 f2  	addi	a0, s0, -216
   23aec: 97 00 00 00  	auipc	ra, 0
   23af0: e7 80 c0 10  	jalr	268(ra)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23af4: 37 55 02 00  	lui	a0, 37
   23af8: 13 05 c5 45  	addi	a0, a0, 1116
   23afc: af 25 05 0a  	amoswap.w.rl	a1, zero, (a0)
   23b00: 0d 46        	li	a2, 3
;     if (!ok) unreachable; // assertion failure
   23b02: 63 84 c5 00  	beq	a1, a2, 0x23b0a <debug.panicImpl+0x76e>
   23b06: e9 c5        	beqz	a1, 0x23bd0 <debug.panicImpl+0x834>
   23b08: 35 a0        	j	0x23b34 <debug.panicImpl+0x798>
;     return asm volatile ("ecall"
   23b0a: 93 08 20 06  	li	a7, 98
   23b0e: 93 05 10 08  	li	a1, 129
   23b12: 05 46        	li	a2, 1
   23b14: fd 76        	lui	a3, 1048575
   23b16: 85 26        	addiw	a3, a3, 1
   23b18: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23b1c: 63 6c d5 00  	bltu	a0, a3, 0x23b34 <debug.panicImpl+0x798>
   23b20: 3b 05 a0 40  	negw	a0, a0
   23b24: 42 15        	slli	a0, a0, 48
   23b26: 41 91        	srli	a0, a0, 48
   23b28: b9 45        	li	a1, 14
;         switch (os.linux.getErrno(rc)) {
   23b2a: 63 05 b5 00  	beq	a0, a1, 0x23b34 <debug.panicImpl+0x798>
   23b2e: d9 45        	li	a1, 22
;         switch (os.linux.getErrno(rc)) {
   23b30: 63 10 b5 0a  	bne	a0, a1, 0x23bd0 <debug.panicImpl+0x834>
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23b34: 37 55 02 00  	lui	a0, 37
   23b38: 13 05 85 45  	addi	a0, a0, 1112
   23b3c: 93 75 35 00  	andi	a1, a0, 3
   23b40: 9b 95 35 00  	slliw	a1, a1, 3
   23b44: 13 06 f0 0f  	li	a2, 255
   23b48: 3b 16 b6 00  	sllw	a2, a2, a1
   23b4c: 85 46        	li	a3, 1
   23b4e: 3b 97 b6 00  	sllw	a4, a3, a1
   23b52: 02 17        	slli	a4, a4, 32
   23b54: 01 93        	srli	a4, a4, 32
   23b56: 71 99        	andi	a0, a0, -4
   23b58: af 27 05 16  	lr.w.aqrl	a5, (a0)
   23b5c: b3 84 e7 40  	sub	s1, a5, a4
   23b60: bd 8c        	xor	s1, s1, a5
   23b62: f1 8c        	and	s1, s1, a2
   23b64: bd 8c        	xor	s1, s1, a5
   23b66: af 24 95 1e  	sc.w.aqrl	s1, s1, (a0)
   23b6a: fd f4        	bnez	s1, 0x23b58 <debug.panicImpl+0x7bc>
   23b6c: 3b d5 b7 00  	srlw	a0, a5, a1
   23b70: 13 75 f5 0f  	andi	a0, a0, 255
;                 return self.rmw(.Sub, value, ordering);
   23b74: 63 16 d5 00  	bne	a0, a3, 0x23b80 <debug.panicImpl+0x7e4>
;     os.abort();
   23b78: 97 00 00 00  	auipc	ra, 0
   23b7c: e7 80 60 27  	jalr	630(ra)
;                 var futex = std.atomic.Atomic(u32).init(0);
   23b80: 23 20 04 e2  	sw	zero, -480(s0)
   23b84: 7d 75        	lui	a0, 1048575
   23b86: 1b 07 15 00  	addiw	a4, a0, 1
   23b8a: b5 47        	li	a5, 13
   23b8c: 91 44        	li	s1, 4
   23b8e: 2d 48        	li	a6, 11
   23b90: d9 42        	li	t0, 22
   23b92: 93 08 20 06  	li	a7, 98
   23b96: 93 05 00 08  	li	a1, 128
   23b9a: 01 46        	li	a2, 0
   23b9c: 81 46        	li	a3, 0
   23b9e: 19 a0        	j	0x23ba4 <debug.panicImpl+0x808>
;         switch (os.linux.getErrno(rc)) {
   23ba0: 63 13 55 02  	bne	a0, t0, 0x23bc6 <debug.panicImpl+0x82a>
;     return asm volatile ("ecall"
   23ba4: 13 05 04 e2  	addi	a0, s0, -480
   23ba8: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23bac: e3 6c e5 fe  	bltu	a0, a4, 0x23ba4 <debug.panicImpl+0x808>
   23bb0: 3b 05 a0 40  	negw	a0, a0
;         switch (os.linux.getErrno(rc)) {
   23bb4: 42 15        	slli	a0, a0, 48
   23bb6: 41 91        	srli	a0, a0, 48
   23bb8: e3 c4 a7 fe  	blt	a5, a0, 0x23ba0 <debug.panicImpl+0x804>
   23bbc: e3 04 95 fe  	beq	a0, s1, 0x23ba4 <debug.panicImpl+0x808>
   23bc0: e3 02 05 ff  	beq	a0, a6, 0x23ba4 <debug.panicImpl+0x808>
   23bc4: 31 a0        	j	0x23bd0 <debug.panicImpl+0x834>
   23bc6: b9 45        	li	a1, 14
;         switch (os.linux.getErrno(rc)) {
   23bc8: 63 04 b5 00  	beq	a0, a1, 0x23bd0 <debug.panicImpl+0x834>
   23bcc: 93 05 e0 06  	li	a1, 110
   23bd0: 37 25 01 00  	lui	a0, 18
   23bd4: 13 05 b5 a7  	addi	a0, a0, -1413
   23bd8: e1 45        	li	a1, 24
   23bda: 81 46        	li	a3, 0
   23bdc: 97 f0 ff ff  	auipc	ra, 1048575
   23be0: e7 80 e0 79  	jalr	1950(ra)
;             buf[index] = '0' + @intCast(u8, a);
   23be4: 37 15 01 00  	lui	a0, 17
   23be8: 13 05 35 6e  	addi	a0, a0, 1763
   23bec: cd 45        	li	a1, 19
   23bee: 81 46        	li	a3, 0
   23bf0: 97 f0 ff ff  	auipc	ra, 1048575
   23bf4: e7 80 a0 78  	jalr	1930(ra)

0000000000023bf8 <builtin.returnError>:
;     if (st.index < st.instruction_addresses.len)
   23bf8: 0c 61        	ld	a1, 0(a0)
   23bfa: 10 69        	ld	a2, 16(a0)
   23bfc: 63 f8 c5 00  	bgeu	a1, a2, 0x23c0c <builtin.returnError+0x14>
   23c00: 10 65        	ld	a2, 8(a0)
;         st.instruction_addresses[st.index] = addr;
   23c02: 8e 05        	slli	a1, a1, 3
   23c04: b2 95        	add	a1, a1, a2
   23c06: 23 b0 15 00  	sd	ra, 0(a1)
;     st.index += 1;
   23c0a: 0c 61        	ld	a1, 0(a0)
   23c0c: 85 05        	addi	a1, a1, 1
   23c0e: 99 c1        	beqz	a1, 0x23c14 <builtin.returnError+0x1c>
   23c10: 0c e1        	sd	a1, 0(a0)
   23c12: 82 80        	ret
   23c14: 37 15 01 00  	lui	a0, 17
   23c18: 13 05 95 5d  	addi	a0, a0, 1497
   23c1c: c1 45        	li	a1, 16
   23c1e: 81 46        	li	a3, 0
   23c20: 97 f0 ff ff  	auipc	ra, 1048575
   23c24: e7 80 a0 75  	jalr	1882(ra)

0000000000023c28 <log.scoped(.default).err__anon_3065>:
;         ) void {
   23c28: 49 71        	addi	sp, sp, -368
   23c2a: 86 f6        	sd	ra, 360(sp)
   23c2c: a2 f2        	sd	s0, 352(sp)
   23c2e: a6 ee        	sd	s1, 344(sp)
   23c30: ca ea        	sd	s2, 336(sp)
   23c32: ce e6        	sd	s3, 328(sp)
   23c34: d2 e2        	sd	s4, 320(sp)
   23c36: 56 fe        	sd	s5, 312(sp)
   23c38: 2c 00        	addi	a1, sp, 8
   23c3a: 2e ea        	sd	a1, 272(sp)
   23c3c: 93 05 00 02  	li	a1, 32
   23c40: 2e ee        	sd	a1, 280(sp)
   23c42: 02 e6        	sd	zero, 264(sp)
   23c44: 89 45        	li	a1, 2
;     const stderr = std.io.getStdErr().writer();
   23c46: 23 20 b1 12  	sw	a1, 288(sp)
;                 false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),
   23c4a: b7 55 02 00  	lui	a1, 37
   23c4e: 93 85 05 49  	addi	a1, a1, 1168
   23c52: 05 46        	li	a2, 1
;                 false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),
   23c54: af a6 05 14  	lr.w.aq	a3, (a1)
   23c58: 81 e6        	bnez	a3, 0x23c60 <log.scoped(.default).err__anon_3065+0x38>
   23c5a: 2f a7 c5 18  	sc.w	a4, a2, (a1)
   23c5e: 7d fb        	bnez	a4, 0x23c54 <log.scoped(.default).err__anon_3065+0x2c>
   23c60: 2a 89        	mv	s2, a0
;         return @field(self.state, casFn)(unlocked, locked, .Acquire, .Monotonic) == null;
   23c62: 63 9b 06 14  	bnez	a3, 0x23db8 <log.scoped(.default).err__anon_3065+0x190>
   23c66: 01 44        	li	s0, 0
;             try writer.writeAll(fmt[start_index..end_index]);
   23c68: 03 2a 01 12  	lw	s4, 288(sp)
   23c6c: a1 49        	li	s3, 8
   23c6e: 37 25 01 00  	lui	a0, 18
   23c72: 93 04 a5 d8  	addi	s1, a0, -630
   23c76: 9d 4a        	li	s5, 7
;                 index += try self.write(bytes[index..]);
   23c78: 63 76 34 15  	bgeu	s0, s3, 0x23dc4 <log.scoped(.default).err__anon_3065+0x19c>
   23c7c: b3 86 84 00  	add	a3, s1, s0
   23c80: 33 87 8a 40  	sub	a4, s5, s0
;             return writeFn(self.context, bytes);
   23c84: 28 12        	addi	a0, sp, 296
   23c86: 2c 02        	addi	a1, sp, 264
   23c88: 52 86        	mv	a2, s4
   23c8a: 97 00 ff ff  	auipc	ra, 1048560
   23c8e: e7 80 20 1d  	jalr	466(ra)
   23c92: 03 55 01 13  	lhu	a0, 304(sp)
   23c96: 61 e1        	bnez	a0, 0x23d56 <log.scoped(.default).err__anon_3065+0x12e>
   23c98: 32 75        	ld	a0, 296(sp)
;                 index += try self.write(bytes[index..]);
   23c9a: 22 95        	add	a0, a0, s0
   23c9c: 63 6f 85 12  	bltu	a0, s0, 0x23dda <log.scoped(.default).err__anon_3065+0x1b2>
   23ca0: 2a 84        	mv	s0, a0
;             while (index != bytes.len) {
   23ca2: e3 1b 55 fd  	bne	a0, s5, 0x23c78 <log.scoped(.default).err__anon_3065+0x50>
;         try formatType(
   23ca6: 83 35 09 00  	ld	a1, 0(s2)
   23caa: 03 36 89 00  	ld	a2, 8(s2)
;                             return formatBuf(value, options, writer);
   23cae: 37 15 01 00  	lui	a0, 17
   23cb2: 93 06 85 11  	addi	a3, a0, 280
   23cb6: 28 02        	addi	a0, sp, 264
   23cb8: 18 12        	addi	a4, sp, 288
   23cba: 97 e0 ff ff  	auipc	ra, 1048574
   23cbe: e7 80 60 07  	jalr	118(ra)
   23cc2: 42 15        	slli	a0, a0, 48
   23cc4: 41 91        	srli	a0, a0, 48
   23cc6: 49 ed        	bnez	a0, 0x23d60 <log.scoped(.default).err__anon_3065+0x138>
   23cc8: 01 44        	li	s0, 0
   23cca: 09 49        	li	s2, 2
   23ccc: 37 25 01 00  	lui	a0, 18
   23cd0: 93 04 a5 d8  	addi	s1, a0, -630
   23cd4: 85 49        	li	s3, 1
;                 index += try self.write(bytes[index..]);
   23cd6: 63 77 24 0f  	bgeu	s0, s2, 0x23dc4 <log.scoped(.default).err__anon_3065+0x19c>
   23cda: 33 85 84 00  	add	a0, s1, s0
   23cde: 93 06 a5 00  	addi	a3, a0, 10
   23ce2: 33 87 89 40  	sub	a4, s3, s0
;             return writeFn(self.context, bytes);
   23ce6: 28 12        	addi	a0, sp, 296
   23ce8: 2c 02        	addi	a1, sp, 264
   23cea: 52 86        	mv	a2, s4
   23cec: 97 00 ff ff  	auipc	ra, 1048560
   23cf0: e7 80 00 17  	jalr	368(ra)
   23cf4: 03 55 01 13  	lhu	a0, 304(sp)
   23cf8: 39 ed        	bnez	a0, 0x23d56 <log.scoped(.default).err__anon_3065+0x12e>
   23cfa: 32 75        	ld	a0, 296(sp)
;                 index += try self.write(bytes[index..]);
   23cfc: 2a 94        	add	s0, s0, a0
;             while (index != bytes.len) {
   23cfe: e3 1c 34 fd  	bne	s0, s3, 0x23cd6 <log.scoped(.default).err__anon_3065+0xae>
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23d02: 37 55 02 00  	lui	a0, 37
   23d06: 13 05 05 49  	addi	a0, a0, 1168
   23d0a: af 25 05 0a  	amoswap.w.rl	a1, zero, (a0)
   23d0e: 0d 46        	li	a2, 3
   23d10: 63 8d c5 00  	beq	a1, a2, 0x23d2a <log.scoped(.default).err__anon_3065+0x102>
   23d14: c9 e9        	bnez	a1, 0x23da6 <log.scoped(.default).err__anon_3065+0x17e>
   23d16: 37 25 01 00  	lui	a0, 18
   23d1a: 13 05 b5 a7  	addi	a0, a0, -1413
   23d1e: e1 45        	li	a1, 24
   23d20: 81 46        	li	a3, 0
   23d22: 97 f0 ff ff  	auipc	ra, 1048575
   23d26: e7 80 80 65  	jalr	1624(ra)
;     return asm volatile ("ecall"
   23d2a: 93 08 20 06  	li	a7, 98
   23d2e: 93 05 10 08  	li	a1, 129
   23d32: 05 46        	li	a2, 1
   23d34: fd 76        	lui	a3, 1048575
   23d36: 85 26        	addiw	a3, a3, 1
   23d38: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23d3c: 63 65 d5 06  	bltu	a0, a3, 0x23da6 <log.scoped(.default).err__anon_3065+0x17e>
   23d40: 3b 05 a0 40  	negw	a0, a0
   23d44: 42 15        	slli	a0, a0, 48
   23d46: 41 91        	srli	a0, a0, 48
   23d48: b9 45        	li	a1, 14
   23d4a: 63 0e b5 04  	beq	a0, a1, 0x23da6 <log.scoped(.default).err__anon_3065+0x17e>
   23d4e: d9 45        	li	a1, 22
   23d50: 63 0b b5 04  	beq	a0, a1, 0x23da6 <log.scoped(.default).err__anon_3065+0x17e>
   23d54: c9 b7        	j	0x23d16 <log.scoped(.default).err__anon_3065+0xee>
   23d56: 28 02        	addi	a0, sp, 264
   23d58: 97 00 00 00  	auipc	ra, 0
   23d5c: e7 80 00 ea  	jalr	-352(ra)
   23d60: 28 02        	addi	a0, sp, 264
   23d62: 97 00 00 00  	auipc	ra, 0
   23d66: e7 80 60 e9  	jalr	-362(ra)
   23d6a: 28 02        	addi	a0, sp, 264
   23d6c: 97 00 00 00  	auipc	ra, 0
   23d70: e7 80 c0 e8  	jalr	-372(ra)
;             return std.fmt.format(self, format, args);
   23d74: 28 02        	addi	a0, sp, 264
   23d76: 97 00 00 00  	auipc	ra, 0
   23d7a: e7 80 20 e8  	jalr	-382(ra)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23d7e: 37 55 02 00  	lui	a0, 37
   23d82: 13 05 05 49  	addi	a0, a0, 1168
   23d86: af 25 05 0a  	amoswap.w.rl	a1, zero, (a0)
   23d8a: 0d 46        	li	a2, 3
;     if (!ok) unreachable; // assertion failure
   23d8c: e3 94 c5 f8  	bne	a1, a2, 0x23d14 <log.scoped(.default).err__anon_3065+0xec>
;     return asm volatile ("ecall"
   23d90: 93 08 20 06  	li	a7, 98
   23d94: 93 05 10 08  	li	a1, 129
   23d98: 05 46        	li	a2, 1
   23d9a: fd 76        	lui	a3, 1048575
   23d9c: 85 26        	addiw	a3, a3, 1
   23d9e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23da2: e3 7f d5 f8  	bgeu	a0, a3, 0x23d40 <log.scoped(.default).err__anon_3065+0x118>
;             log(.err, scope, format, args);
   23da6: b6 70        	ld	ra, 360(sp)
   23da8: 16 74        	ld	s0, 352(sp)
   23daa: f6 64        	ld	s1, 344(sp)
   23dac: 56 69        	ld	s2, 336(sp)
   23dae: b6 69        	ld	s3, 328(sp)
   23db0: 16 6a        	ld	s4, 320(sp)
   23db2: f2 7a        	ld	s5, 312(sp)
   23db4: 75 61        	addi	sp, sp, 368
   23db6: 82 80        	ret
;             self.lockSlow();
   23db8: 2e 85        	mv	a0, a1
   23dba: 97 00 00 00  	auipc	ra, 0
   23dbe: e7 80 e0 1e  	jalr	494(ra)
   23dc2: 55 b5        	j	0x23c66 <log.scoped(.default).err__anon_3065+0x3e>
   23dc4: 37 15 01 00  	lui	a0, 17
   23dc8: 13 05 45 5b  	addi	a0, a0, 1460
   23dcc: 93 05 40 02  	li	a1, 36
   23dd0: 81 46        	li	a3, 0
   23dd2: 97 f0 ff ff  	auipc	ra, 1048575
   23dd6: e7 80 80 5a  	jalr	1448(ra)
;                 index += try self.write(bytes[index..]);
   23dda: 37 15 01 00  	lui	a0, 17
   23dde: 13 05 95 5d  	addi	a0, a0, 1497
   23de2: c1 45        	li	a1, 16
   23de4: 81 46        	li	a3, 0
   23de6: 97 f0 ff ff  	auipc	ra, 1048575
   23dea: e7 80 40 59  	jalr	1428(ra)

0000000000023dee <os.abort>:
; pub fn abort() noreturn {
   23dee: 29 71        	addi	sp, sp, -320
   23df0: 06 fe        	sd	ra, 312(sp)
   23df2: 0a 85        	mv	a0, sp
   23df4: 2a e6        	sd	a0, 264(sp)
   23df6: 13 05 00 02  	li	a0, 32
   23dfa: 2a ea        	sd	a0, 272(sp)
   23dfc: 02 e2        	sd	zero, 256(sp)
;         raise(SIG.ABRT) catch {};
   23dfe: 08 02        	addi	a0, sp, 256
   23e00: 99 45        	li	a1, 6
   23e02: 97 d0 ff ff  	auipc	ra, 1048573
   23e06: e7 80 00 0a  	jalr	160(ra)
   23e0a: 42 15        	slli	a0, a0, 48
   23e0c: 41 91        	srli	a0, a0, 48
   23e0e: 11 c1        	beqz	a0, 0x23e12 <os.abort+0x24>
   23e10: 02 e2        	sd	zero, 256(sp)
;     return asm volatile ("ecall"
   23e12: 37 15 01 00  	lui	a0, 17
   23e16: 93 05 05 de  	addi	a1, a0, -544
   23e1a: 93 08 70 08  	li	a7, 135
   23e1e: a1 46        	li	a3, 8
   23e20: 7d 77        	lui	a4, 1048575
   23e22: 01 45        	li	a0, 0
   23e24: 01 46        	li	a2, 0
   23e26: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23e2a: 63 6b a7 0c  	bltu	a4, a0, 0x23f00 <os.abort+0x112>
   23e2e: 37 55 02 00  	lui	a0, 37
   23e32: 13 06 45 49  	addi	a2, a0, 1172
   23e36: 13 75 36 00  	andi	a0, a2, 3
   23e3a: 9b 15 35 00  	slliw	a1, a0, 3
   23e3e: 13 05 f0 0f  	li	a0, 255
   23e42: 3b 15 b5 00  	sllw	a0, a0, a1
   23e46: 85 46        	li	a3, 1
   23e48: bb 95 b6 00  	sllw	a1, a3, a1
   23e4c: 82 15        	slli	a1, a1, 32
   23e4e: 81 91        	srli	a1, a1, 32
   23e50: 71 9a        	andi	a2, a2, -4
;             while (@cmpxchgWeak(bool, &global.abort_entered, false, true, .SeqCst, .SeqCst)) |_| {}
   23e52: af 26 06 16  	lr.w.aqrl	a3, (a2)
   23e56: 33 f7 a6 00  	and	a4, a3, a0
   23e5a: 01 eb        	bnez	a4, 0x23e6a <os.abort+0x7c>
   23e5c: 33 c7 b6 00  	xor	a4, a3, a1
   23e60: 69 8f        	and	a4, a4, a0
   23e62: 35 8f        	xor	a4, a4, a3
   23e64: 2f 27 e6 1e  	sc.w.aqrl	a4, a4, (a2)
   23e68: 6d f7        	bnez	a4, 0x23e52 <os.abort+0x64>
   23e6a: e9 8e        	and	a3, a3, a0
   23e6c: 81 26        	sext.w	a3, a3
   23e6e: f5 f2        	bnez	a3, 0x23e52 <os.abort+0x64>
;             .handler = new.handler.handler,
   23e70: 02 ee        	sd	zero, 280(sp)
   23e72: 37 05 00 04  	lui	a0, 16384
;             .flags = new.flags | SA.RESTORER,
   23e76: 2a f2        	sd	a0, 288(sp)
;             .restorer = @ptrCast(k_sigaction_funcs.restorer, restorer_fn),
   23e78: 37 35 02 00  	lui	a0, 35
   23e7c: 13 05 c5 08  	addi	a0, a0, 140
   23e80: 2a f6        	sd	a0, 296(sp)
;         @memcpy(@ptrCast([*]u8, &ksa.mask), @ptrCast([*]const u8, &new.mask), mask_size);
   23e82: 02 fa        	sd	zero, 304(sp)
;     return asm volatile ("ecall"
   23e84: 93 08 60 08  	li	a7, 134
   23e88: 19 45        	li	a0, 6
   23e8a: 2c 0a        	addi	a1, sp, 280
   23e8c: a1 46        	li	a3, 8
   23e8e: 7d 76        	lui	a2, 1048575
   23e90: 1b 07 16 00  	addiw	a4, a2, 1
   23e94: 01 46        	li	a2, 0
   23e96: 73 00 00 00  	ecall	
   23e9a: 63 6c e5 02  	bltu	a0, a4, 0x23ed2 <os.abort+0xe4>
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23e9e: 3b 05 a0 40  	negw	a0, a0
   23ea2: 42 15        	slli	a0, a0, 48
   23ea4: 41 91        	srli	a0, a0, 48
   23ea6: d9 45        	li	a1, 22
   23ea8: 63 06 b5 00  	beq	a0, a1, 0x23eb4 <os.abort+0xc6>
   23eac: 93 05 60 02  	li	a1, 38
   23eb0: 63 10 b5 06  	bne	a0, a1, 0x23f10 <os.abort+0x122>
;         .INVAL, .NOSYS => return error.OperationNotSupported,
   23eb4: 08 02        	addi	a0, sp, 256
   23eb6: 97 00 00 00  	auipc	ra, 0
   23eba: e7 80 20 d4  	jalr	-702(ra)
;             error.OperationNotSupported => unreachable,
   23ebe: 37 15 01 00  	lui	a0, 17
   23ec2: 13 05 25 71  	addi	a0, a0, 1810
   23ec6: dd 45        	li	a1, 23
   23ec8: 81 46        	li	a3, 0
   23eca: 97 f0 ff ff  	auipc	ra, 1048575
   23ece: e7 80 00 4b  	jalr	1200(ra)
;     return asm volatile ("ecall"
   23ed2: 93 08 20 0b  	li	a7, 178
   23ed6: 73 00 00 00  	ecall	
;     return syscall2(.tkill, @bitCast(usize, @as(isize, tid)), @bitCast(usize, @as(isize, sig)));
   23eda: 01 25        	sext.w	a0, a0
;     return asm volatile ("ecall"
   23edc: 93 08 20 08  	li	a7, 130
   23ee0: 99 45        	li	a1, 6
   23ee2: 73 00 00 00  	ecall	
;     return asm volatile ("ecall"
   23ee6: 37 15 01 00  	lui	a0, 17
   23eea: 93 05 05 e6  	addi	a1, a0, -416
   23eee: 93 08 70 08  	li	a7, 135
   23ef2: 05 45        	li	a0, 1
   23ef4: a1 46        	li	a3, 8
   23ef6: 01 46        	li	a2, 0
   23ef8: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23efc: 63 64 e5 02  	bltu	a0, a4, 0x23f24 <os.abort+0x136>
   23f00: 3b 05 a0 40  	negw	a0, a0
   23f04: 42 15        	slli	a0, a0, 48
   23f06: 41 91        	srli	a0, a0, 48
   23f08: b9 45        	li	a1, 14
   23f0a: 63 03 b5 00  	beq	a0, a1, 0x23f10 <os.abort+0x122>
   23f0e: d9 45        	li	a1, 22
   23f10: 37 25 01 00  	lui	a0, 18
   23f14: 13 05 b5 a7  	addi	a0, a0, -1413
   23f18: e1 45        	li	a1, 24
   23f1a: 81 46        	li	a3, 0
   23f1c: 97 f0 ff ff  	auipc	ra, 1048575
   23f20: e7 80 e0 45  	jalr	1118(ra)
;         @intToPtr(*allowzero volatile u8, 0).* = 0;
   23f24: 23 00 00 00  	sb	zero, 0(zero)
;         raise(SIG.KILL) catch {};
   23f28: 08 02        	addi	a0, sp, 256
   23f2a: a5 45        	li	a1, 9
   23f2c: 97 d0 ff ff  	auipc	ra, 1048573
   23f30: e7 80 60 f7  	jalr	-138(ra)
   23f34: 42 15        	slli	a0, a0, 48
   23f36: 41 91        	srli	a0, a0, 48
   23f38: 11 c1        	beqz	a0, 0x23f3c <os.abort+0x14e>
   23f3a: 02 e2        	sd	zero, 256(sp)
;         exit(127); // Pid 1 might not be signalled in some containers.
   23f3c: 13 05 f0 07  	li	a0, 127
   23f40: 97 00 ff ff  	auipc	ra, 1048560
   23f44: e7 80 60 db  	jalr	-586(ra)

0000000000023f48 <Thread.Futex.wait>:
;     return syscall4(.futex, @ptrToInt(uaddr), futex_op, @bitCast(u32, val), @ptrToInt(timeout));
   23f48: 82 15        	slli	a1, a1, 32
   23f4a: 13 d6 05 02  	srli	a2, a1, 32
;     return asm volatile ("ecall"
   23f4e: 93 08 20 06  	li	a7, 98
   23f52: 93 05 00 08  	li	a1, 128
   23f56: fd 76        	lui	a3, 1048575
   23f58: 1b 87 16 00  	addiw	a4, a3, 1
   23f5c: 81 46        	li	a3, 0
   23f5e: 73 00 00 00  	ecall	
;     const int = if (signed_r > -4096 and signed_r < 0) -signed_r else 0;
   23f62: 63 63 e5 02  	bltu	a0, a4, 0x23f88 <Thread.Futex.wait+0x40>
   23f66: 3b 05 a0 40  	negw	a0, a0
;         switch (os.linux.getErrno(rc)) {
   23f6a: 42 15        	slli	a0, a0, 48
   23f6c: 41 91        	srli	a0, a0, 48
   23f6e: b5 45        	li	a1, 13
   23f70: 63 c9 a5 00  	blt	a1, a0, 0x23f82 <Thread.Futex.wait+0x3a>
   23f74: 91 45        	li	a1, 4
;         switch (os.linux.getErrno(rc)) {
   23f76: 63 09 b5 00  	beq	a0, a1, 0x23f88 <Thread.Futex.wait+0x40>
   23f7a: ad 45        	li	a1, 11
;         switch (os.linux.getErrno(rc)) {
   23f7c: 63 06 b5 00  	beq	a0, a1, 0x23f88 <Thread.Futex.wait+0x40>
   23f80: 11 a8        	j	0x23f94 <Thread.Futex.wait+0x4c>
   23f82: d9 45        	li	a1, 22
;         switch (os.linux.getErrno(rc)) {
   23f84: 63 13 b5 00  	bne	a0, a1, 0x23f8a <Thread.Futex.wait+0x42>
;     Impl.wait(ptr, expect, null) catch |err| switch (err) {
   23f88: 82 80        	ret
   23f8a: b9 45        	li	a1, 14
;         switch (os.linux.getErrno(rc)) {
   23f8c: 63 04 b5 00  	beq	a0, a1, 0x23f94 <Thread.Futex.wait+0x4c>
   23f90: 93 05 e0 06  	li	a1, 110
   23f94: 37 25 01 00  	lui	a0, 18
   23f98: 13 05 b5 a7  	addi	a0, a0, -1413
   23f9c: e1 45        	li	a1, 24
   23f9e: 81 46        	li	a3, 0
   23fa0: 97 f0 ff ff  	auipc	ra, 1048575
   23fa4: e7 80 a0 3d  	jalr	986(ra)

0000000000023fa8 <Thread.Mutex.FutexImpl.lockSlow>:
;     fn lockSlow(self: *@This()) void {
   23fa8: 01 11        	addi	sp, sp, -32
;             pub inline fn fetchXor(self: *Self, value: T, comptime ordering: Ordering) T {
   23faa: 06 ec        	sd	ra, 24(sp)
   23fac: 22 e8        	sd	s0, 16(sp)
   23fae: 26 e4        	sd	s1, 8(sp)
   23fb0: 2a 84        	mv	s0, a0
;                 else => @atomicLoad(T, &self.value, ordering),
   23fb2: 08 41        	lw	a0, 0(a0)
   23fb4: 8d 44        	li	s1, 3
;             return switch (ordering) {
   23fb6: 63 04 95 02  	beq	a0, s1, 0x23fde <Thread.Mutex.FutexImpl.lockSlow+0x36>
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23fba: 2f 25 94 0c  	amoswap.w.aq	a0, s1, (s0)
;             return self.rmw(.Xchg, value, ordering);
   23fbe: 19 c9        	beqz	a0, 0x23fd4 <Thread.Mutex.FutexImpl.lockSlow+0x2c>
   23fc0: 8d 44        	li	s1, 3
;             Futex.wait(&self.state, contended);
   23fc2: 8d 45        	li	a1, 3
   23fc4: 22 85        	mv	a0, s0
   23fc6: 97 00 00 00  	auipc	ra, 0
   23fca: e7 80 20 f8  	jalr	-126(ra)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23fce: 2f 25 94 0c  	amoswap.w.aq	a0, s1, (s0)
;             return self.rmw(.Xchg, value, ordering);
   23fd2: 65 f9        	bnez	a0, 0x23fc2 <Thread.Mutex.FutexImpl.lockSlow+0x1a>
;             Futex.wait(&self.state, contended);
   23fd4: e2 60        	ld	ra, 24(sp)
   23fd6: 42 64        	ld	s0, 16(sp)
   23fd8: a2 64        	ld	s1, 8(sp)
   23fda: 05 61        	addi	sp, sp, 32
   23fdc: 82 80        	ret
;             Futex.wait(&self.state, contended);
   23fde: 8d 45        	li	a1, 3
   23fe0: 22 85        	mv	a0, s0
   23fe2: 97 00 00 00  	auipc	ra, 0
   23fe6: e7 80 60 f6  	jalr	-154(ra)
;             return @atomicRmw(T, &self.value, op, value, ordering);
   23fea: 2f 25 94 0c  	amoswap.w.aq	a0, s1, (s0)
;             return self.rmw(.Xchg, value, ordering);
   23fee: 69 f9        	bnez	a0, 0x23fc0 <Thread.Mutex.FutexImpl.lockSlow+0x18>
   23ff0: d5 b7        	j	0x23fd4 <Thread.Mutex.FutexImpl.lockSlow+0x2c>

0000000000023ff2 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow>:
;         fn grow(self: *Self, allocator: Allocator, new_capacity: Size, ctx: Context) Allocator.Error!void {
   23ff2: 59 71        	addi	sp, sp, -112
   23ff4: 86 f4        	sd	ra, 104(sp)
   23ff6: a2 f0        	sd	s0, 96(sp)
   23ff8: a6 ec        	sd	s1, 88(sp)
   23ffa: ca e8        	sd	s2, 80(sp)
   23ffc: ce e4        	sd	s3, 72(sp)
   23ffe: d2 e0        	sd	s4, 64(sp)
   24000: 56 fc        	sd	s5, 56(sp)
   24002: 5a f8        	sd	s6, 48(sp)
   24004: 5e f4        	sd	s7, 40(sp)
   24006: 62 f0        	sd	s8, 32(sp)
   24008: 9b 8a 06 00  	sext.w	s5, a3
   2400c: a1 46        	li	a3, 8
   2400e: b2 89        	mv	s3, a2
   24010: 2e 8a        	mv	s4, a1
   24012: 2a 89        	mv	s2, a0
   24014: 63 e3 56 01  	bltu	a3, s5, 0x2401a <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x28>
   24018: a1 4a        	li	s5, 8
;             if (self.metadata == null) return 0;
   2401a: 03 35 0a 00  	ld	a0, 0(s4)
   2401e: 09 c9        	beqz	a0, 0x24030 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x3e>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   24020: 93 75 75 00  	andi	a1, a0, 7
   24024: 63 96 05 1e  	bnez	a1, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
;             return self.header().capacity;
   24028: 03 25 85 ff  	lw	a0, -8(a0)
;     if (!ok) unreachable; // assertion failure
   2402c: 63 70 55 23  	bgeu	a0, s5, 0x2424c <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x25a>
;     return (v & (v - 1)) == 0;
   24030: 1b 85 fa ff  	addiw	a0, s5, -1
   24034: 33 f5 aa 00  	and	a0, s5, a0
;     if (!ok) unreachable; // assertion failure
   24038: 63 1a 05 20  	bnez	a0, 0x2424c <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x25a>
;             var map = Self{};
   2403c: 02 e4        	sd	zero, 8(sp)
;             const meta_size = @sizeOf(Header) + new_capacity * @sizeOf(Metadata);
   2403e: 9b 85 8a 01  	addiw	a1, s5, 24
;             var map = Self{};
   24042: 02 e0        	sd	zero, 0(sp)
;             const meta_size = @sizeOf(Header) + new_capacity * @sizeOf(Metadata);
   24044: 63 e0 55 1f  	bltu	a1, s5, 0x24224 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x232>
;             const keys_end = keys_start + new_capacity * @sizeOf(K);
   24048: 13 9b 0a 02  	slli	s6, s5, 32
   2404c: 13 55 db 01  	srli	a0, s6, 29
   24050: 13 56 05 02  	srli	a2, a0, 32
   24054: 63 18 06 1c  	bnez	a2, 0x24224 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x232>
   24058: 82 15        	slli	a1, a1, 32
   2405a: 81 91        	srli	a1, a1, 32
   2405c: 9d 05        	addi	a1, a1, 7
;             const slice = try allocator.alignedAlloc(u8, max_align, total_size);
   2405e: 03 b6 89 00  	ld	a2, 8(s3)
   24062: 93 fb 85 ff  	andi	s7, a1, -8
;             const keys_end = keys_start + new_capacity * @sizeOf(K);
   24066: 93 15 05 02  	slli	a1, a0, 32
;             const slice = try allocator.alignedAlloc(u8, max_align, total_size);
   2406a: 03 b5 09 00  	ld	a0, 0(s3)
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   2406e: 18 62        	ld	a4, 0(a2)
;             const keys_end = keys_start + new_capacity * @sizeOf(K);
   24070: 81 91        	srli	a1, a1, 32
   24072: 33 8c bb 00  	add	s8, s7, a1
;             const vals_end = vals_start + new_capacity * @sizeOf(V);
   24076: b3 04 bc 00  	add	s1, s8, a1
;     return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);
   2407a: 0d 46        	li	a2, 3
   2407c: a6 85        	mv	a1, s1
   2407e: 86 86        	mv	a3, ra
   24080: 02 97        	jalr	a4
   24082: 63 05 05 14  	beqz	a0, 0x241cc <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x1da>
   24086: 2a 84        	mv	s0, a0
;     @memset(byte_ptr, undefined, byte_count);
   24088: 93 05 a0 0a  	li	a1, 170
   2408c: 26 86        	mv	a2, s1
   2408e: 97 00 00 00  	auipc	ra, 0
   24092: e7 80 c0 20  	jalr	524(ra)
;     return mem.bytesAsSlice(T, @alignCast(a, byte_slice));
   24096: 13 75 74 00  	andi	a0, s0, 7
   2409a: 63 1b 05 16  	bnez	a0, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
;             const metadata = ptr + @sizeOf(Header);
   2409e: 13 05 84 01  	addi	a0, s0, 24
   240a2: 63 61 85 18  	bltu	a0, s0, 0x24224 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x232>
;                 hdr.values = @intToPtr([*]V, ptr + vals_start);
   240a6: b3 05 84 01  	add	a1, s0, s8
   240aa: 63 ed 85 16  	bltu	a1, s0, 0x24224 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x232>
   240ae: 63 85 05 18  	beqz	a1, 0x24238 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x246>
   240b2: 13 f6 75 00  	andi	a2, a1, 7
   240b6: 63 1d 06 14  	bnez	a2, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
;                 hdr.keys = @intToPtr([*]K, ptr + keys_start);
   240ba: 33 06 74 01  	add	a2, s0, s7
;                 hdr.values = @intToPtr([*]V, ptr + vals_start);
   240be: 0c e0        	sd	a1, 0(s0)
;                 hdr.keys = @intToPtr([*]K, ptr + keys_start);
   240c0: 63 62 86 16  	bltu	a2, s0, 0x24224 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x232>
   240c4: 63 0a 06 16  	beqz	a2, 0x24238 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x246>
   240c8: 93 75 76 00  	andi	a1, a2, 7
   240cc: 63 92 05 14  	bnez	a1, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
   240d0: 10 e4        	sd	a2, 8(s0)
;             hdr.capacity = new_capacity;
   240d2: 23 28 54 01  	sw	s5, 16(s0)
;             self.metadata = @intToPtr([*]Metadata, metadata);
   240d6: 63 01 05 16  	beqz	a0, 0x24238 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x246>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   240da: 93 75 75 00  	andi	a1, a0, 7
;             self.metadata = @intToPtr([*]Metadata, metadata);
   240de: 2a e0        	sd	a0, 0(sp)
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   240e0: 63 98 05 12  	bnez	a1, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
;             return self.header().capacity;
   240e4: 03 66 85 ff  	lwu	a2, -8(a0)
;             @memset(@ptrCast([*]u8, self.metadata.?), 0, @sizeOf(Metadata) * self.capacity());
   240e8: 97 00 00 00  	auipc	ra, 0
   240ec: e7 80 20 1b  	jalr	434(ra)
;             map.available = @truncate(u32, (new_cap * max_load_percentage) / 100);
   240f0: 15 45        	li	a0, 5
   240f2: b7 55 02 00  	lui	a1, 37
   240f6: 83 b5 85 42  	ld	a1, 1064(a1)
   240fa: 12 15        	slli	a0, a0, 36
   240fc: 33 35 ab 02  	mulhu	a0, s6, a0
   24100: 09 81        	srli	a0, a0, 2
   24102: 33 35 b5 02  	mulhu	a0, a0, a1
   24106: 09 81        	srli	a0, a0, 2
   24108: 2a c6        	sw	a0, 12(sp)
;             if (self.size != 0) {
   2410a: 03 25 8a 00  	lw	a0, 8(s4)
   2410e: 25 c5        	beqz	a0, 0x24176 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x184>
;             if (self.metadata == null) return 0;
   24110: 03 34 0a 00  	ld	s0, 0(s4)
   24114: 63 06 04 14  	beqz	s0, 0x24260 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x26e>
;             return @ptrCast(*Header, @ptrCast([*]Header, @alignCast(@alignOf(Header), self.metadata.?)) - 1);
   24118: 13 75 74 00  	andi	a0, s0, 7
   2411c: 75 e9        	bnez	a0, 0x24210 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x21e>
;             return self.header().capacity;
   2411e: 03 2b 84 ff  	lw	s6, -8(s0)
;                 while (i < old_capacity) : (i += 1) {
   24122: 63 0a 0b 04  	beqz	s6, 0x24176 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x184>
   24126: 03 39 04 ff  	ld	s2, -16(s0)
   2412a: 83 3a 84 fe  	ld	s5, -24(s0)
   2412e: 81 44        	li	s1, 0
   24130: 3d a0        	j	0x2415e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x16c>
;                         map.putAssumeCapacityNoClobberContext(keys_ptr[i], values_ptr[i], ctx);
   24132: 0e 05        	slli	a0, a0, 3
   24134: b3 05 a9 00  	add	a1, s2, a0
   24138: 8c 61        	ld	a1, 0(a1)
   2413a: 56 95        	add	a0, a0, s5
   2413c: 10 61        	ld	a2, 0(a0)
   2413e: 0a 85        	mv	a0, sp
   24140: 97 f0 ff ff  	auipc	ra, 1048575
   24144: e7 80 a0 a5  	jalr	-1446(ra)
;                         if (map.size == self.size)
   24148: 22 45        	lw	a0, 8(sp)
   2414a: 83 25 8a 00  	lw	a1, 8(s4)
   2414e: 2d 8d        	xor	a0, a0, a1
   24150: 33 35 a0 00  	snez	a0, a0
   24154: 85 24        	addiw	s1, s1, 1
   24156: b3 b5 64 01  	sltu	a1, s1, s6
;                         if (map.size == self.size)
   2415a: 6d 8d        	and	a0, a0, a1
   2415c: 09 cd        	beqz	a0, 0x24176 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x184>
;                     if (metadata[i].isUsed()) {
   2415e: 13 95 04 02  	slli	a0, s1, 32
   24162: 01 91        	srli	a0, a0, 32
   24164: b3 05 a4 00  	add	a1, s0, a0
   24168: 83 85 05 00  	lb	a1, 0(a1)
   2416c: e3 c3 05 fc  	bltz	a1, 0x24132 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x140>
;                 while (i < old_capacity) : (i += 1) {
   24170: 85 24        	addiw	s1, s1, 1
   24172: e3 e6 64 ff  	bltu	s1, s6, 0x2415e <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x16c>
;             self.size = 0;
   24176: 23 24 0a 00  	sw	zero, 8(s4)
;     const tmp = a.*;
   2417a: 03 35 8a 00  	ld	a0, 8(s4)
   2417e: 2a ec        	sd	a0, 24(sp)
   24180: 03 35 0a 00  	ld	a0, 0(s4)
;     a.* = b.*;
   24184: a2 65        	ld	a1, 8(sp)
;     const tmp = a.*;
   24186: 2a e8        	sd	a0, 16(sp)
;     a.* = b.*;
   24188: 23 34 ba 00  	sd	a1, 8(s4)
   2418c: 02 65        	ld	a0, 0(sp)
   2418e: 23 30 aa 00  	sd	a0, 0(s4)
;     b.* = tmp;
   24192: 62 65        	ld	a0, 24(sp)
   24194: c2 65        	ld	a1, 16(sp)
   24196: 2a e4        	sd	a0, 8(sp)
   24198: 2e e0        	sd	a1, 0(sp)
;             self.deallocate(allocator);
   2419a: 0a 85        	mv	a0, sp
   2419c: ce 85        	mv	a1, s3
   2419e: 97 f0 ff ff  	auipc	ra, 1048575
   241a2: e7 80 60 10  	jalr	262(ra)
   241a6: 37 55 02 00  	lui	a0, 37
   241aa: 83 35 05 43  	ld	a1, 1072(a0)
   241ae: 01 45        	li	a0, 0
;             self.* = undefined;
   241b0: 2e e4        	sd	a1, 8(sp)
   241b2: 2e e0        	sd	a1, 0(sp)
   241b4: a6 70        	ld	ra, 104(sp)
   241b6: 06 74        	ld	s0, 96(sp)
   241b8: e6 64        	ld	s1, 88(sp)
   241ba: 46 69        	ld	s2, 80(sp)
   241bc: a6 69        	ld	s3, 72(sp)
   241be: 06 6a        	ld	s4, 64(sp)
   241c0: e2 7a        	ld	s5, 56(sp)
   241c2: 42 7b        	ld	s6, 48(sp)
   241c4: a2 7b        	ld	s7, 40(sp)
   241c6: 02 7c        	ld	s8, 32(sp)
   241c8: 65 61        	addi	sp, sp, 112
   241ca: 82 80        	ret
;     const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;
   241cc: 4a 85        	mv	a0, s2
   241ce: 97 00 00 00  	auipc	ra, 0
   241d2: e7 80 a0 a2  	jalr	-1494(ra)
;     return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());
   241d6: 4a 85        	mv	a0, s2
   241d8: 97 00 00 00  	auipc	ra, 0
   241dc: e7 80 00 a2  	jalr	-1504(ra)
;             const slice = try allocator.alignedAlloc(u8, max_align, total_size);
   241e0: 4a 85        	mv	a0, s2
   241e2: 97 00 00 00  	auipc	ra, 0
   241e6: e7 80 60 a1  	jalr	-1514(ra)
;             self.deallocate(allocator);
   241ea: 0a 85        	mv	a0, sp
   241ec: ce 85        	mv	a1, s3
   241ee: 97 f0 ff ff  	auipc	ra, 1048575
   241f2: e7 80 60 0b  	jalr	182(ra)
   241f6: 37 55 02 00  	lui	a0, 37
   241fa: 03 35 05 43  	ld	a0, 1072(a0)
;             self.* = undefined;
   241fe: 2a e4        	sd	a0, 8(sp)
   24200: 2a e0        	sd	a0, 0(sp)
;             try map.allocate(allocator, new_cap);
   24202: 4a 85        	mv	a0, s2
   24204: 97 00 00 00  	auipc	ra, 0
   24208: e7 80 40 9f  	jalr	-1548(ra)
   2420c: 45 45        	li	a0, 17
   2420e: 5d b7        	j	0x241b4 <hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_3950,hash_map.AutoContext(usize),80).grow+0x1c2>
   24210: 37 15 01 00  	lui	a0, 17
   24214: 13 05 75 63  	addi	a0, a0, 1591
   24218: cd 45        	li	a1, 19
   2421a: 81 46        	li	a3, 0
   2421c: 97 f0 ff ff  	auipc	ra, 1048575
   24220: e7 80 e0 15  	jalr	350(ra)
   24224: 37 15 01 00  	lui	a0, 17
   24228: 13 05 95 5d  	addi	a0, a0, 1497
   2422c: c1 45        	li	a1, 16
   2422e: 81 46        	li	a3, 0
   24230: 97 f0 ff ff  	auipc	ra, 1048575
   24234: e7 80 a0 14  	jalr	330(ra)
   24238: 37 25 01 00  	lui	a0, 18
   2423c: 13 05 a5 86  	addi	a0, a0, -1942
   24240: f9 45        	li	a1, 30
   24242: 81 46        	li	a3, 0
   24244: 97 f0 ff ff  	auipc	ra, 1048575
   24248: e7 80 60 13  	jalr	310(ra)
   2424c: 37 25 01 00  	lui	a0, 18
   24250: 13 05 b5 a7  	addi	a0, a0, -1413
   24254: e1 45        	li	a1, 24
   24256: 81 46        	li	a3, 0
   24258: 97 f0 ff ff  	auipc	ra, 1048575
   2425c: e7 80 20 12  	jalr	290(ra)
;                 var metadata = self.metadata.?;
   24260: 37 25 01 00  	lui	a0, 18
   24264: 13 05 25 9b  	addi	a0, a0, -1614
   24268: e5 45        	li	a1, 25
   2426a: 81 46        	li	a3, 0
   2426c: 97 f0 ff ff  	auipc	ra, 1048575
   24270: e7 80 e0 10  	jalr	270(ra)

0000000000024274 <memcpy>:
   24274: 15 c2        	beqz	a2, 0x24298 <memcpy+0x24>
   24276: 83 86 05 00  	lb	a3, 0(a1)
   2427a: 7d 16        	addi	a2, a2, -1
   2427c: 23 00 d5 00  	sb	a3, 0(a0)
   24280: 01 ce        	beqz	a2, 0x24298 <memcpy+0x24>
   24282: 93 06 15 00  	addi	a3, a0, 1
   24286: 85 05        	addi	a1, a1, 1
   24288: 03 87 05 00  	lb	a4, 0(a1)
   2428c: 23 80 e6 00  	sb	a4, 0(a3)
   24290: 7d 16        	addi	a2, a2, -1
   24292: 85 06        	addi	a3, a3, 1
   24294: 85 05        	addi	a1, a1, 1
   24296: 6d fa        	bnez	a2, 0x24288 <memcpy+0x14>
   24298: 82 80        	ret

000000000002429a <memset>:
   2429a: 19 c6        	beqz	a2, 0x242a8 <memset+0xe>
   2429c: aa 86        	mv	a3, a0
   2429e: 23 80 b6 00  	sb	a1, 0(a3)
   242a2: 7d 16        	addi	a2, a2, -1
   242a4: 85 06        	addi	a3, a3, 1
   242a6: 65 fe        	bnez	a2, 0x2429e <memset+0x4>
   242a8: 82 80        	ret

00000000000242aa <memmove>:
   242aa: 63 7d b5 00  	bgeu	a0, a1, 0x242c4 <memmove+0x1a>
   242ae: 15 ca        	beqz	a2, 0x242e2 <memmove+0x38>
   242b0: aa 86        	mv	a3, a0
   242b2: 03 87 05 00  	lb	a4, 0(a1)
   242b6: 23 80 e6 00  	sb	a4, 0(a3)
   242ba: 7d 16        	addi	a2, a2, -1
   242bc: 85 05        	addi	a1, a1, 1
   242be: 85 06        	addi	a3, a3, 1
   242c0: 6d fa        	bnez	a2, 0x242b2 <memmove+0x8>
   242c2: 05 a0        	j	0x242e2 <memmove+0x38>
   242c4: 19 ce        	beqz	a2, 0x242e2 <memmove+0x38>
   242c6: 93 06 f5 ff  	addi	a3, a0, -1
   242ca: fd 15        	addi	a1, a1, -1
   242cc: 33 87 c5 00  	add	a4, a1, a2
   242d0: 03 07 07 00  	lb	a4, 0(a4)
   242d4: 93 07 f6 ff  	addi	a5, a2, -1
   242d8: 36 96        	add	a2, a2, a3
   242da: 23 00 e6 00  	sb	a4, 0(a2)
   242de: 3e 86        	mv	a2, a5
   242e0: f5 f7        	bnez	a5, 0x242cc <memmove+0x22>
   242e2: 82 80        	ret
